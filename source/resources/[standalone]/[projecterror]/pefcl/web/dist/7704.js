"use strict";(self.webpackChunkweb=self.webpackChunkweb||[]).push([[7704],{7704:function(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__){eval('// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  AnimatePresence: function() { return /* reexport */ AnimatePresence; },\n  AnimateSharedLayout: function() { return /* reexport */ AnimateSharedLayout; },\n  AnimationType: function() { return /* reexport */ AnimationType; },\n  DeprecatedLayoutGroupContext: function() { return /* reexport */ DeprecatedLayoutGroupContext; },\n  DragControls: function() { return /* reexport */ DragControls; },\n  FlatTree: function() { return /* reexport */ FlatTree; },\n  LayoutGroup: function() { return /* reexport */ LayoutGroup; },\n  LayoutGroupContext: function() { return /* reexport */ LayoutGroupContext; },\n  LazyMotion: function() { return /* reexport */ LazyMotion; },\n  MotionConfig: function() { return /* reexport */ MotionConfig; },\n  MotionConfigContext: function() { return /* reexport */ MotionConfigContext; },\n  MotionContext: function() { return /* reexport */ MotionContext; },\n  MotionValue: function() { return /* reexport */ MotionValue; },\n  PresenceContext: function() { return /* reexport */ PresenceContext; },\n  Reorder: function() { return /* reexport */ Reorder; },\n  SwitchLayoutGroupContext: function() { return /* reexport */ SwitchLayoutGroupContext; },\n  addPointerEvent: function() { return /* reexport */ addPointerEvent; },\n  addScaleCorrector: function() { return /* reexport */ addScaleCorrector; },\n  animate: function() { return /* reexport */ animate_animate; },\n  animateVisualElement: function() { return /* reexport */ animateVisualElement; },\n  animationControls: function() { return /* reexport */ animationControls; },\n  animations: function() { return /* reexport */ animations; },\n  calcLength: function() { return /* reexport */ calcLength; },\n  checkTargetForNewValues: function() { return /* reexport */ checkTargetForNewValues; },\n  createBox: function() { return /* reexport */ createBox; },\n  createDomMotionComponent: function() { return /* reexport */ createDomMotionComponent; },\n  createMotionComponent: function() { return /* reexport */ createMotionComponent; },\n  domAnimation: function() { return /* reexport */ domAnimation; },\n  domMax: function() { return /* reexport */ domMax; },\n  filterProps: function() { return /* reexport */ filterProps; },\n  isBrowser: function() { return /* reexport */ isBrowser; },\n  isDragActive: function() { return /* reexport */ isDragActive; },\n  isMotionValue: function() { return /* reexport */ isMotionValue; },\n  isValidMotionProp: function() { return /* reexport */ isValidMotionProp; },\n  m: function() { return /* reexport */ m; },\n  makeUseVisualState: function() { return /* reexport */ makeUseVisualState; },\n  motion: function() { return /* reexport */ motion; },\n  motionValue: function() { return /* reexport */ motionValue; },\n  resolveMotionValue: function() { return /* reexport */ resolveMotionValue; },\n  transform: function() { return /* reexport */ transform; },\n  useAnimation: function() { return /* reexport */ useAnimation; },\n  useAnimationControls: function() { return /* reexport */ useAnimationControls; },\n  useAnimationFrame: function() { return /* reexport */ useAnimationFrame; },\n  useCycle: function() { return /* reexport */ useCycle; },\n  useDeprecatedAnimatedState: function() { return /* reexport */ useAnimatedState; },\n  useDeprecatedInvertedScale: function() { return /* reexport */ useInvertedScale; },\n  useDomEvent: function() { return /* reexport */ useDomEvent; },\n  useDragControls: function() { return /* reexport */ useDragControls; },\n  useElementScroll: function() { return /* reexport */ useElementScroll; },\n  useForceUpdate: function() { return /* reexport */ useForceUpdate; },\n  useInView: function() { return /* reexport */ useInView; },\n  useInstantLayoutTransition: function() { return /* reexport */ useInstantLayoutTransition; },\n  useInstantTransition: function() { return /* reexport */ useInstantTransition; },\n  useIsPresent: function() { return /* reexport */ useIsPresent; },\n  useIsomorphicLayoutEffect: function() { return /* reexport */ useIsomorphicLayoutEffect; },\n  useMotionTemplate: function() { return /* reexport */ useMotionTemplate; },\n  useMotionValue: function() { return /* reexport */ useMotionValue; },\n  usePresence: function() { return /* reexport */ usePresence; },\n  useReducedMotion: function() { return /* reexport */ useReducedMotion; },\n  useReducedMotionConfig: function() { return /* reexport */ useReducedMotionConfig; },\n  useResetProjection: function() { return /* reexport */ useResetProjection; },\n  useScroll: function() { return /* reexport */ useScroll; },\n  useSpring: function() { return /* reexport */ useSpring; },\n  useTime: function() { return /* reexport */ useTime; },\n  useTransform: function() { return /* reexport */ useTransform; },\n  useUnmountEffect: function() { return /* reexport */ useUnmountEffect; },\n  useVelocity: function() { return /* reexport */ useVelocity; },\n  useViewportScroll: function() { return /* reexport */ useViewportScroll; },\n  useVisualElementContext: function() { return /* reexport */ useVisualElementContext; },\n  visualElement: function() { return /* reexport */ visualElement; },\n  wrapHandler: function() { return /* reexport */ wrapHandler; }\n});\n\n;// CONCATENATED MODULE: ./node_modules/tslib/tslib.es6.mjs\n/******************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\n/* global Reflect, Promise, SuppressedError, Symbol */\n\nvar extendStatics = function(d, b) {\n  extendStatics = Object.setPrototypeOf ||\n      ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n      function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n  return extendStatics(d, b);\n};\n\nfunction __extends(d, b) {\n  if (typeof b !== "function" && b !== null)\n      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");\n  extendStatics(d, b);\n  function __() { this.constructor = d; }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nvar __assign = function() {\n  __assign = Object.assign || function __assign(t) {\n      for (var s, i = 1, n = arguments.length; i < n; i++) {\n          s = arguments[i];\n          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n      return t;\n  }\n  return __assign.apply(this, arguments);\n}\n\nfunction __rest(s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n      t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === "function")\n      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n              t[p[i]] = s[p[i]];\n      }\n  return t;\n}\n\nfunction __decorate(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);\n  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n}\n\nfunction __param(paramIndex, decorator) {\n  return function (target, key) { decorator(target, key, paramIndex); }\n}\n\nfunction __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\n  function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }\n  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";\n  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;\n  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\n  var _, done = false;\n  for (var i = decorators.length - 1; i >= 0; i--) {\n      var context = {};\n      for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];\n      for (var p in contextIn.access) context.access[p] = contextIn.access[p];\n      context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };\n      var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\n      if (kind === "accessor") {\n          if (result === void 0) continue;\n          if (result === null || typeof result !== "object") throw new TypeError("Object expected");\n          if (_ = accept(result.get)) descriptor.get = _;\n          if (_ = accept(result.set)) descriptor.set = _;\n          if (_ = accept(result.init)) initializers.unshift(_);\n      }\n      else if (_ = accept(result)) {\n          if (kind === "field") initializers.unshift(_);\n          else descriptor[key] = _;\n      }\n  }\n  if (target) Object.defineProperty(target, contextIn.name, descriptor);\n  done = true;\n};\n\nfunction __runInitializers(thisArg, initializers, value) {\n  var useValue = arguments.length > 2;\n  for (var i = 0; i < initializers.length; i++) {\n      value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\n  }\n  return useValue ? value : void 0;\n};\n\nfunction __propKey(x) {\n  return typeof x === "symbol" ? x : "".concat(x);\n};\n\nfunction __setFunctionName(f, name, prefix) {\n  if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";\n  return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });\n};\n\nfunction __metadata(metadataKey, metadataValue) {\n  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);\n}\n\nfunction __awaiter(thisArg, _arguments, P, generator) {\n  function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n  return new (P || (P = Promise))(function (resolve, reject) {\n      function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n      function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\n      function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n      step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\n\nfunction __generator(thisArg, body) {\n  var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;\n  function verb(n) { return function (v) { return step([n, v]); }; }\n  function step(op) {\n      if (f) throw new TypeError("Generator is already executing.");\n      while (g && (g = 0, op[0] && (_ = 0)), _) try {\n          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n          if (y = 0, t) op = [op[0] & 2, t.value];\n          switch (op[0]) {\n              case 0: case 1: t = op; break;\n              case 4: _.label++; return { value: op[1], done: false };\n              case 5: _.label++; y = op[1]; op = [0]; continue;\n              case 7: op = _.ops.pop(); _.trys.pop(); continue;\n              default:\n                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                  if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                  if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                  if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                  if (t[2]) _.ops.pop();\n                  _.trys.pop(); continue;\n          }\n          op = body.call(thisArg, _);\n      } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n      if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n  }\n}\n\nvar __createBinding = Object.create ? (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n  }\n  Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nfunction __exportStar(m, o) {\n  for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\n}\n\nfunction __values(o) {\n  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === "number") return {\n      next: function () {\n          if (o && i >= o.length) o = void 0;\n          return { value: o && o[i++], done: !o };\n      }\n  };\n  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");\n}\n\nfunction __read(o, n) {\n  var m = typeof Symbol === "function" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o), r, ar = [], e;\n  try {\n      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  }\n  catch (error) { e = { error: error }; }\n  finally {\n      try {\n          if (r && !r.done && (m = i["return"])) m.call(i);\n      }\n      finally { if (e) throw e.error; }\n  }\n  return ar;\n}\n\n/** @deprecated */\nfunction __spread() {\n  for (var ar = [], i = 0; i < arguments.length; i++)\n      ar = ar.concat(__read(arguments[i]));\n  return ar;\n}\n\n/** @deprecated */\nfunction __spreadArrays() {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n  for (var r = Array(s), k = 0, i = 0; i < il; i++)\n      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n          r[k] = a[j];\n  return r;\n}\n\nfunction __spreadArray(to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n      if (ar || !(i in from)) {\n          if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n          ar[i] = from[i];\n      }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n}\n\nfunction __await(v) {\n  return this instanceof __await ? (this.v = v, this) : new __await(v);\n}\n\nfunction __asyncGenerator(thisArg, _arguments, generator) {\n  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");\n  var g = generator.apply(thisArg, _arguments || []), i, q = [];\n  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;\n  function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\n  function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n  function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n  function fulfill(value) { resume("next", value); }\n  function reject(value) { resume("throw", value); }\n  function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n}\n\nfunction __asyncDelegator(o) {\n  var i, p;\n  return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;\n  function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\n}\n\nfunction __asyncValues(o) {\n  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");\n  var m = o[Symbol.asyncIterator], i;\n  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);\n  function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n  function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n}\n\nfunction __makeTemplateObject(cooked, raw) {\n  if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }\n  return cooked;\n};\n\nvar __setModuleDefault = Object.create ? (function(o, v) {\n  Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n  o["default"] = v;\n};\n\nfunction __importStar(mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n}\n\nfunction __importDefault(mod) {\n  return (mod && mod.__esModule) ? mod : { default: mod };\n}\n\nfunction __classPrivateFieldGet(receiver, state, kind, f) {\n  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");\n  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");\n  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);\n}\n\nfunction __classPrivateFieldSet(receiver, state, value, kind, f) {\n  if (kind === "m") throw new TypeError("Private method is not writable");\n  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");\n  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");\n  return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n}\n\nfunction __classPrivateFieldIn(state, receiver) {\n  if (receiver === null || (typeof receiver !== "object" && typeof receiver !== "function")) throw new TypeError("Cannot use \'in\' operator on non-object");\n  return typeof state === "function" ? receiver === state : state.has(receiver);\n}\n\nfunction __addDisposableResource(env, value, async) {\n  if (value !== null && value !== void 0) {\n    if (typeof value !== "object") throw new TypeError("Object expected.");\n    var dispose;\n    if (async) {\n        if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");\n        dispose = value[Symbol.asyncDispose];\n    }\n    if (dispose === void 0) {\n        if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");\n        dispose = value[Symbol.dispose];\n    }\n    if (typeof dispose !== "function") throw new TypeError("Object not disposable.");\n    env.stack.push({ value: value, dispose: dispose, async: async });\n  }\n  else if (async) {\n    env.stack.push({ async: true });\n  }\n  return value;\n}\n\nvar _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {\n  var e = new Error(message);\n  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;\n};\n\nfunction __disposeResources(env) {\n  function fail(e) {\n    env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;\n    env.hasError = true;\n  }\n  function next() {\n    while (env.stack.length) {\n      var rec = env.stack.pop();\n      try {\n        var result = rec.dispose && rec.dispose.call(rec.value);\n        if (rec.async) return Promise.resolve(result).then(next, function(e) { fail(e); return next(); });\n      }\n      catch (e) {\n          fail(e);\n      }\n    }\n    if (env.hasError) throw env.error;\n  }\n  return next();\n}\n\n/* harmony default export */ var tslib_es6 = ({\n  __extends,\n  __assign,\n  __rest,\n  __decorate,\n  __param,\n  __metadata,\n  __awaiter,\n  __generator,\n  __createBinding,\n  __exportStar,\n  __values,\n  __read,\n  __spread,\n  __spreadArrays,\n  __spreadArray,\n  __await,\n  __asyncGenerator,\n  __asyncDelegator,\n  __asyncValues,\n  __makeTemplateObject,\n  __importStar,\n  __importDefault,\n  __classPrivateFieldGet,\n  __classPrivateFieldSet,\n  __classPrivateFieldIn,\n  __addDisposableResource,\n  __disposeResources,\n});\n\n// EXTERNAL MODULE: consume shared module (default) react@^17.0.2 (singleton) (fallback: ./node_modules/react/index.js)\nvar index_js_ = __webpack_require__(2950);\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/utils/process.mjs\n/**\n * Browser-safe usage of process\n */\nvar defaultEnvironment = "production";\nvar env =  false\n    ? 0\n    : "production" || 0;\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/motion/features/definitions.mjs\nvar createDefinition = function (propNames) { return ({\n    isEnabled: function (props) { return propNames.some(function (name) { return !!props[name]; }); },\n}); };\nvar featureDefinitions = {\n    measureLayout: createDefinition(["layout", "layoutId", "drag"]),\n    animation: createDefinition([\n        "animate",\n        "exit",\n        "variants",\n        "whileHover",\n        "whileTap",\n        "whileFocus",\n        "whileDrag",\n        "whileInView",\n    ]),\n    exit: createDefinition(["exit"]),\n    drag: createDefinition(["drag", "dragControls"]),\n    focus: createDefinition(["whileFocus"]),\n    hover: createDefinition(["whileHover", "onHoverStart", "onHoverEnd"]),\n    tap: createDefinition(["whileTap", "onTap", "onTapStart", "onTapCancel"]),\n    pan: createDefinition([\n        "onPan",\n        "onPanStart",\n        "onPanSessionStart",\n        "onPanEnd",\n    ]),\n    inView: createDefinition([\n        "whileInView",\n        "onViewportEnter",\n        "onViewportLeave",\n    ]),\n};\nfunction loadFeatures(features) {\n    for (var key in features) {\n        if (features[key] === null)\n            continue;\n        if (key === "projectionNodeConstructor") {\n            featureDefinitions.projectionNodeConstructor = features[key];\n        }\n        else {\n            featureDefinitions[key].Component = features[key];\n        }\n    }\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/hey-listen/dist/hey-listen.es.js\nvar warning = function () { };\r\nvar invariant = function () { };\r\nif (false) {}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/context/LazyContext.mjs\n\n\nvar LazyContext = (0,index_js_.createContext)({ strict: false });\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/motion/features/use-features.mjs\n\n\n\n\n\n\n\n\nvar featureNames = Object.keys(featureDefinitions);\nvar numFeatures = featureNames.length;\n/**\n * Load features via renderless components based on the provided MotionProps.\n */\nfunction useFeatures(props, visualElement, preloadedFeatures) {\n    var features = [];\n    var lazyContext = (0,index_js_.useContext)(LazyContext);\n    if (!visualElement)\n        return null;\n    /**\n     * If we\'re in development mode, check to make sure we\'re not rendering a motion component\n     * as a child of LazyMotion, as this will break the file-size benefits of using it.\n     */\n    if (env !== "production" && preloadedFeatures && lazyContext.strict) {\n        invariant(false, "You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.");\n    }\n    for (var i = 0; i < numFeatures; i++) {\n        var name_1 = featureNames[i];\n        var _a = featureDefinitions[name_1], isEnabled = _a.isEnabled, Component = _a.Component;\n        /**\n         * It might be possible in the future to use this moment to\n         * dynamically request functionality. In initial tests this\n         * was producing a lot of duplication amongst bundles.\n         */\n        if (isEnabled(props) && Component) {\n            features.push(index_js_.createElement(Component, __assign({ key: name_1 }, props, { visualElement: visualElement })));\n        }\n    }\n    return features;\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/context/MotionConfigContext.mjs\n\n\n/**\n * @public\n */\nvar MotionConfigContext = (0,index_js_.createContext)({\n    transformPagePoint: function (p) { return p; },\n    isStatic: false,\n    reducedMotion: "never",\n});\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/context/MotionContext/index.mjs\n\n\nvar MotionContext = (0,index_js_.createContext)({});\nfunction useVisualElementContext() {\n    return (0,index_js_.useContext)(MotionContext).visualElement;\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/context/PresenceContext.mjs\n\n\n/**\n * @public\n */\nvar PresenceContext = (0,index_js_.createContext)(null);\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/utils/is-browser.mjs\nvar isBrowser = typeof document !== "undefined";\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/utils/use-isomorphic-effect.mjs\n\n\n\nvar useIsomorphicLayoutEffect = isBrowser ? index_js_.useLayoutEffect : index_js_.useEffect;\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/utils/use-reduced-motion.mjs\n\n\n\n\n\n// Does this device prefer reduced motion? Returns `null` server-side.\nvar prefersReducedMotion = { current: null };\nvar hasDetected = false;\nfunction initPrefersReducedMotion() {\n    hasDetected = true;\n    if (!isBrowser)\n        return;\n    if (window.matchMedia) {\n        var motionMediaQuery_1 = window.matchMedia("(prefers-reduced-motion)");\n        var setReducedMotionPreferences = function () {\n            return (prefersReducedMotion.current = motionMediaQuery_1.matches);\n        };\n        motionMediaQuery_1.addListener(setReducedMotionPreferences);\n        setReducedMotionPreferences();\n    }\n    else {\n        prefersReducedMotion.current = false;\n    }\n}\n/**\n * A hook that returns `true` if we should be using reduced motion based on the current device\'s Reduced Motion setting.\n *\n * This can be used to implement changes to your UI based on Reduced Motion. For instance, replacing motion-sickness inducing\n * `x`/`y` animations with `opacity`, disabling the autoplay of background videos, or turning off parallax motion.\n *\n * It will actively respond to changes and re-render your components with the latest setting.\n *\n * ```jsx\n * export function Sidebar({ isOpen }) {\n *   const shouldReduceMotion = useReducedMotion()\n *   const closedX = shouldReduceMotion ? 0 : "-100%"\n *\n *   return (\n *     <motion.div animate={{\n *       opacity: isOpen ? 1 : 0,\n *       x: isOpen ? 0 : closedX\n *     }} />\n *   )\n * }\n * ```\n *\n * @return boolean\n *\n * @public\n */\nfunction useReducedMotion() {\n    /**\n     * Lazy initialisation of prefersReducedMotion\n     */\n    !hasDetected && initPrefersReducedMotion();\n    var _a = __read((0,index_js_.useState)(prefersReducedMotion.current), 1), shouldReduceMotion = _a[0];\n    /**\n     * TODO See if people miss automatically updating shouldReduceMotion setting\n     */\n    return shouldReduceMotion;\n}\nfunction useReducedMotionConfig() {\n    var reducedMotionPreference = useReducedMotion();\n    var reducedMotion = (0,index_js_.useContext)(MotionConfigContext).reducedMotion;\n    if (reducedMotion === "never") {\n        return false;\n    }\n    else if (reducedMotion === "always") {\n        return true;\n    }\n    else {\n        return reducedMotionPreference;\n    }\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/motion/utils/use-visual-element.mjs\n\n\n\n\n\n\n\nfunction useVisualElement(Component, visualState, props, createVisualElement) {\n    var lazyContext = (0,index_js_.useContext)(LazyContext);\n    var parent = useVisualElementContext();\n    var presenceContext = (0,index_js_.useContext)(PresenceContext);\n    var shouldReduceMotion = useReducedMotionConfig();\n    var visualElementRef = (0,index_js_.useRef)(undefined);\n    /**\n     * If we haven\'t preloaded a renderer, check to see if we have one lazy-loaded\n     */\n    if (!createVisualElement)\n        createVisualElement = lazyContext.renderer;\n    if (!visualElementRef.current && createVisualElement) {\n        visualElementRef.current = createVisualElement(Component, {\n            visualState: visualState,\n            parent: parent,\n            props: props,\n            presenceId: presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.id,\n            blockInitialAnimation: (presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.initial) === false,\n            shouldReduceMotion: shouldReduceMotion,\n        });\n    }\n    var visualElement = visualElementRef.current;\n    useIsomorphicLayoutEffect(function () {\n        visualElement === null || visualElement === void 0 ? void 0 : visualElement.syncRender();\n    });\n    (0,index_js_.useEffect)(function () {\n        var _a;\n        (_a = visualElement === null || visualElement === void 0 ? void 0 : visualElement.animationState) === null || _a === void 0 ? void 0 : _a.animateChanges();\n    });\n    useIsomorphicLayoutEffect(function () { return function () { return visualElement === null || visualElement === void 0 ? void 0 : visualElement.notifyUnmount(); }; }, []);\n    return visualElement;\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/utils/is-ref-object.mjs\nfunction isRefObject(ref) {\n    return (typeof ref === "object" &&\n        Object.prototype.hasOwnProperty.call(ref, "current"));\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/motion/utils/use-motion-ref.mjs\n\n\n\n/**\n * Creates a ref function that, when called, hydrates the provided\n * external ref and VisualElement.\n */\nfunction useMotionRef(visualState, visualElement, externalRef) {\n    return (0,index_js_.useCallback)(function (instance) {\n        var _a;\n        instance && ((_a = visualState.mount) === null || _a === void 0 ? void 0 : _a.call(visualState, instance));\n        if (visualElement) {\n            instance\n                ? visualElement.mount(instance)\n                : visualElement.unmount();\n        }\n        if (externalRef) {\n            if (typeof externalRef === "function") {\n                externalRef(instance);\n            }\n            else if (isRefObject(externalRef)) {\n                externalRef.current = instance;\n            }\n        }\n    }, \n    /**\n     * Only pass a new ref callback to React if we\'ve received a visual element\n     * factory. Otherwise we\'ll be mounting/remounting every time externalRef\n     * or other dependencies change.\n     */\n    [visualElement]);\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/render/utils/variants.mjs\n/**\n * Decides if the supplied variable is an array of variant labels\n */\nfunction isVariantLabels(v) {\n    return Array.isArray(v);\n}\n/**\n * Decides if the supplied variable is variant label\n */\nfunction isVariantLabel(v) {\n    return typeof v === "string" || isVariantLabels(v);\n}\n/**\n * Creates an object containing the latest state of every MotionValue on a VisualElement\n */\nfunction getCurrent(visualElement) {\n    var current = {};\n    visualElement.forEachValue(function (value, key) { return (current[key] = value.get()); });\n    return current;\n}\n/**\n * Creates an object containing the latest velocity of every MotionValue on a VisualElement\n */\nfunction getVelocity(visualElement) {\n    var velocity = {};\n    visualElement.forEachValue(function (value, key) { return (velocity[key] = value.getVelocity()); });\n    return velocity;\n}\nfunction resolveVariantFromProps(props, definition, custom, currentValues, currentVelocity) {\n    var _a;\n    if (currentValues === void 0) { currentValues = {}; }\n    if (currentVelocity === void 0) { currentVelocity = {}; }\n    /**\n     * If the variant definition is a function, resolve.\n     */\n    if (typeof definition === "function") {\n        definition = definition(custom !== null && custom !== void 0 ? custom : props.custom, currentValues, currentVelocity);\n    }\n    /**\n     * If the variant definition is a variant label, or\n     * the function returned a variant label, resolve.\n     */\n    if (typeof definition === "string") {\n        definition = (_a = props.variants) === null || _a === void 0 ? void 0 : _a[definition];\n    }\n    /**\n     * At this point we\'ve resolved both functions and variant labels,\n     * but the resolved variant label might itself have been a function.\n     * If so, resolve. This can only have returned a valid target object.\n     */\n    if (typeof definition === "function") {\n        definition = definition(custom !== null && custom !== void 0 ? custom : props.custom, currentValues, currentVelocity);\n    }\n    return definition;\n}\nfunction resolveVariant(visualElement, definition, custom) {\n    var props = visualElement.getProps();\n    return resolveVariantFromProps(props, definition, custom !== null && custom !== void 0 ? custom : props.custom, getCurrent(visualElement), getVelocity(visualElement));\n}\nfunction checkIfControllingVariants(props) {\n    var _a;\n    return (typeof ((_a = props.animate) === null || _a === void 0 ? void 0 : _a.start) === "function" ||\n        isVariantLabel(props.initial) ||\n        isVariantLabel(props.animate) ||\n        isVariantLabel(props.whileHover) ||\n        isVariantLabel(props.whileDrag) ||\n        isVariantLabel(props.whileTap) ||\n        isVariantLabel(props.whileFocus) ||\n        isVariantLabel(props.exit));\n}\nfunction checkIfVariantNode(props) {\n    return Boolean(checkIfControllingVariants(props) || props.variants);\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/context/MotionContext/utils.mjs\n\n\nfunction getCurrentTreeVariants(props, context) {\n    if (checkIfControllingVariants(props)) {\n        var initial = props.initial, animate = props.animate;\n        return {\n            initial: initial === false || isVariantLabel(initial)\n                ? initial\n                : undefined,\n            animate: isVariantLabel(animate) ? animate : undefined,\n        };\n    }\n    return props.inherit !== false ? context : {};\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/context/MotionContext/create.mjs\n\n\n\n\nfunction useCreateMotionContext(props) {\n    var _a = getCurrentTreeVariants(props, (0,index_js_.useContext)(MotionContext)), initial = _a.initial, animate = _a.animate;\n    return (0,index_js_.useMemo)(function () { return ({ initial: initial, animate: animate }); }, [variantLabelsAsDependency(initial), variantLabelsAsDependency(animate)]);\n}\nfunction variantLabelsAsDependency(prop) {\n    return Array.isArray(prop) ? prop.join(" ") : prop;\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/utils/use-constant.mjs\n\n\n/**\n * Creates a constant value over the lifecycle of a component.\n *\n * Even if `useMemo` is provided an empty array as its final argument, it doesn\'t offer\n * a guarantee that it won\'t re-run for performance reasons later on. By using `useConstant`\n * you can ensure that initialisers don\'t execute twice or more.\n */\nfunction useConstant(init) {\n    var ref = (0,index_js_.useRef)(null);\n    if (ref.current === null) {\n        ref.current = init();\n    }\n    return ref.current;\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/projection/node/state.mjs\n/**\n * This should only ever be modified on the client otherwise it\'ll\n * persist through server requests. If we need instanced states we\n * could lazy-init via root.\n */\nvar globalProjectionState = {\n    /**\n     * Global flag as to whether the tree has animated since the last time\n     * we resized the window\n     */\n    hasAnimatedSinceResize: true,\n    /**\n     * We set this to true once, on the first update. Any nodes added to the tree beyond that\n     * update will be given a `data-projection-id` attribute.\n     */\n    hasEverUpdated: false,\n};\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/projection/node/id.mjs\n\n\n\nvar id = 1;\nfunction useProjectionId() {\n    return useConstant(function () {\n        if (globalProjectionState.hasEverUpdated) {\n            return id++;\n        }\n    });\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/context/LayoutGroupContext.mjs\n\n\nvar LayoutGroupContext = (0,index_js_.createContext)({});\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/context/SwitchLayoutGroupContext.mjs\n\n\n/**\n * Internal, exported only for usage in Framer\n */\nvar SwitchLayoutGroupContext = (0,index_js_.createContext)({});\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/motion/features/use-projection.mjs\n\n\n\n\nfunction useProjection(projectionId, _a, visualElement, ProjectionNodeConstructor) {\n    var _b;\n    var layoutId = _a.layoutId, layout = _a.layout, drag = _a.drag, dragConstraints = _a.dragConstraints, layoutScroll = _a.layoutScroll;\n    var initialPromotionConfig = (0,index_js_.useContext)(SwitchLayoutGroupContext);\n    if (!ProjectionNodeConstructor ||\n        !visualElement ||\n        (visualElement === null || visualElement === void 0 ? void 0 : visualElement.projection)) {\n        return;\n    }\n    visualElement.projection = new ProjectionNodeConstructor(projectionId, visualElement.getLatestValues(), (_b = visualElement.parent) === null || _b === void 0 ? void 0 : _b.projection);\n    visualElement.projection.setOptions({\n        layoutId: layoutId,\n        layout: layout,\n        alwaysMeasureLayout: Boolean(drag) || (dragConstraints && isRefObject(dragConstraints)),\n        visualElement: visualElement,\n        scheduleRender: function () { return visualElement.scheduleRender(); },\n        /**\n         * TODO: Update options in an effect. This could be tricky as it\'ll be too late\n         * to update by the time layout animations run.\n         * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,\n         * ensuring it gets called if there\'s no potential layout animations.\n         *\n         */\n        animationType: typeof layout === "string" ? layout : "both",\n        initialPromotionConfig: initialPromotionConfig,\n        layoutScroll: layoutScroll,\n    });\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/motion/utils/VisualElementHandler.mjs\n\n\n\nvar VisualElementHandler = /** @class */ (function (_super) {\n    __extends(VisualElementHandler, _super);\n    function VisualElementHandler() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * Update visual element props as soon as we know this update is going to be commited.\n     */\n    VisualElementHandler.prototype.getSnapshotBeforeUpdate = function () {\n        this.updateProps();\n        return null;\n    };\n    VisualElementHandler.prototype.componentDidUpdate = function () { };\n    VisualElementHandler.prototype.updateProps = function () {\n        var _a = this.props, visualElement = _a.visualElement, props = _a.props;\n        if (visualElement)\n            visualElement.setProps(props);\n    };\n    VisualElementHandler.prototype.render = function () {\n        return this.props.children;\n    };\n    return VisualElementHandler;\n}(index_js_.Component));\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/motion/index.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Create a `motion` component.\n *\n * This function accepts a Component argument, which can be either a string (ie "div"\n * for `motion.div`), or an actual React component.\n *\n * Alongside this is a config option which provides a way of rendering the provided\n * component "offline", or outside the React render cycle.\n */\nfunction createMotionComponent(_a) {\n    var preloadedFeatures = _a.preloadedFeatures, createVisualElement = _a.createVisualElement, projectionNodeConstructor = _a.projectionNodeConstructor, useRender = _a.useRender, useVisualState = _a.useVisualState, Component = _a.Component;\n    preloadedFeatures && loadFeatures(preloadedFeatures);\n    function MotionComponent(props, externalRef) {\n        var layoutId = useLayoutId(props);\n        props = __assign(__assign({}, props), { layoutId: layoutId });\n        /**\n         * If we\'re rendering in a static environment, we only visually update the component\n         * as a result of a React-rerender rather than interactions or animations. This\n         * means we don\'t need to load additional memory structures like VisualElement,\n         * or any gesture/animation features.\n         */\n        var config = (0,index_js_.useContext)(MotionConfigContext);\n        var features = null;\n        var context = useCreateMotionContext(props);\n        /**\n         * Create a unique projection ID for this component. If a new component is added\n         * during a layout animation we\'ll use this to query the DOM and hydrate its ref early, allowing\n         * us to measure it as soon as any layout effect flushes pending layout animations.\n         *\n         * Performance note: It\'d be better not to have to search the DOM for these elements.\n         * For newly-entering components it could be enough to only correct treeScale, in which\n         * case we could mount in a scale-correction mode. This wouldn\'t be enough for\n         * shared element transitions however. Perhaps for those we could revert to a root node\n         * that gets forceRendered and layout animations are triggered on its layout effect.\n         */\n        var projectionId = config.isStatic ? undefined : useProjectionId();\n        /**\n         *\n         */\n        var visualState = useVisualState(props, config.isStatic);\n        if (!config.isStatic && isBrowser) {\n            /**\n             * Create a VisualElement for this component. A VisualElement provides a common\n             * interface to renderer-specific APIs (ie DOM/Three.js etc) as well as\n             * providing a way of rendering to these APIs outside of the React render loop\n             * for more performant animations and interactions\n             */\n            context.visualElement = useVisualElement(Component, visualState, __assign(__assign({}, config), props), createVisualElement);\n            useProjection(projectionId, props, context.visualElement, projectionNodeConstructor ||\n                featureDefinitions.projectionNodeConstructor);\n            /**\n             * Load Motion gesture and animation features. These are rendered as renderless\n             * components so each feature can optionally make use of React lifecycle methods.\n             */\n            features = useFeatures(props, context.visualElement, preloadedFeatures);\n        }\n        /**\n         * The mount order and hierarchy is specific to ensure our element ref\n         * is hydrated by the time features fire their effects.\n         */\n        return (index_js_.createElement(VisualElementHandler, { visualElement: context.visualElement, props: __assign(__assign({}, config), props) },\n            features,\n            index_js_.createElement(MotionContext.Provider, { value: context }, useRender(Component, props, projectionId, useMotionRef(visualState, context.visualElement, externalRef), visualState, config.isStatic, context.visualElement))));\n    }\n    return (0,index_js_.forwardRef)(MotionComponent);\n}\nfunction useLayoutId(_a) {\n    var _b;\n    var layoutId = _a.layoutId;\n    var layoutGroupId = (_b = (0,index_js_.useContext)(LayoutGroupContext)) === null || _b === void 0 ? void 0 : _b.id;\n    return layoutGroupId && layoutId !== undefined\n        ? layoutGroupId + "-" + layoutId\n        : layoutId;\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/render/dom/motion-proxy.mjs\n\n\n/**\n * Convert any React component into a `motion` component. The provided component\n * **must** use `React.forwardRef` to the underlying DOM component you want to animate.\n *\n * ```jsx\n * const Component = React.forwardRef((props, ref) => {\n *   return <div ref={ref} />\n * })\n *\n * const MotionComponent = motion(Component)\n * ```\n *\n * @public\n */\nfunction createMotionProxy(createConfig) {\n    function custom(Component, customMotionComponentConfig) {\n        if (customMotionComponentConfig === void 0) { customMotionComponentConfig = {}; }\n        return createMotionComponent(createConfig(Component, customMotionComponentConfig));\n    }\n    if (typeof Proxy === "undefined") {\n        return custom;\n    }\n    /**\n     * A cache of generated `motion` components, e.g `motion.div`, `motion.input` etc.\n     * Rather than generating them anew every render.\n     */\n    var componentCache = new Map();\n    return new Proxy(custom, {\n        /**\n         * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.\n         * The prop name is passed through as `key` and we can use that to generate a `motion`\n         * DOM component with that name.\n         */\n        get: function (_target, key) {\n            /**\n             * If this element doesn\'t exist in the component cache, create it and cache.\n             */\n            if (!componentCache.has(key)) {\n                componentCache.set(key, custom(key));\n            }\n            return componentCache.get(key);\n        },\n    });\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/render/svg/lowercase-elements.mjs\n/**\n * We keep these listed seperately as we use the lowercase tag names as part\n * of the runtime bundle to detect SVG components\n */\nvar lowercaseSVGElements = [\n    "animate",\n    "circle",\n    "defs",\n    "desc",\n    "ellipse",\n    "g",\n    "image",\n    "line",\n    "filter",\n    "marker",\n    "mask",\n    "metadata",\n    "path",\n    "pattern",\n    "polygon",\n    "polyline",\n    "rect",\n    "stop",\n    "svg",\n    "switch",\n    "symbol",\n    "text",\n    "tspan",\n    "use",\n    "view",\n];\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/render/dom/utils/is-svg-component.mjs\n\n\nfunction isSVGComponent(Component) {\n    if (\n    /**\n     * If it\'s not a string, it\'s a custom React component. Currently we only support\n     * HTML custom React components.\n     */\n    typeof Component !== "string" ||\n        /**\n         * If it contains a dash, the element is a custom HTML webcomponent.\n         */\n        Component.includes("-")) {\n        return false;\n    }\n    else if (\n    /**\n     * If it\'s in our list of lowercase SVG tags, it\'s an SVG component\n     */\n    lowercaseSVGElements.indexOf(Component) > -1 ||\n        /**\n         * If it contains a capital letter, it\'s an SVG component\n         */\n        /[A-Z]/.test(Component)) {\n        return true;\n    }\n    return false;\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/projection/styles/scale-correction.mjs\nvar scaleCorrectors = {};\nfunction addScaleCorrector(correctors) {\n    Object.assign(scaleCorrectors, correctors);\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/render/html/utils/transform.mjs\n/**\n * A list of all transformable axes. We\'ll use this list to generated a version\n * of each axes for each transform.\n */\nvar transformAxes = ["", "X", "Y", "Z"];\n/**\n * An ordered array of each transformable value. By default, transform values\n * will be sorted to this order.\n */\nvar order = ["translate", "scale", "rotate", "skew"];\n/**\n * Generate a list of every possible transform key.\n */\nvar transformProps = ["transformPerspective", "x", "y", "z"];\norder.forEach(function (operationKey) {\n    return transformAxes.forEach(function (axesKey) {\n        return transformProps.push(operationKey + axesKey);\n    });\n});\n/**\n * A function to use with Array.sort to sort transform keys by their default order.\n */\nfunction sortTransformProps(a, b) {\n    return transformProps.indexOf(a) - transformProps.indexOf(b);\n}\n/**\n * A quick lookup for transform props.\n */\nvar transformPropSet = new Set(transformProps);\nfunction isTransformProp(key) {\n    return transformPropSet.has(key);\n}\n/**\n * A quick lookup for transform origin props\n */\nvar transformOriginProps = new Set(["originX", "originY", "originZ"]);\nfunction isTransformOriginProp(key) {\n    return transformOriginProps.has(key);\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/motion/utils/is-forced-motion-value.mjs\n\n\n\nfunction isForcedMotionValue(key, _a) {\n    var layout = _a.layout, layoutId = _a.layoutId;\n    return (isTransformProp(key) ||\n        isTransformOriginProp(key) ||\n        ((layout || layoutId !== undefined) &&\n            (!!scaleCorrectors[key] || key === "opacity")));\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/value/utils/is-motion-value.mjs\nvar isMotionValue = function (value) {\n    return Boolean(value !== null && typeof value === "object" && value.getVelocity);\n};\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/render/html/utils/build-transform.mjs\n\n\nvar translateAlias = {\n    x: "translateX",\n    y: "translateY",\n    z: "translateZ",\n    transformPerspective: "perspective",\n};\n/**\n * Build a CSS transform style from individual x/y/scale etc properties.\n *\n * This outputs with a default order of transforms/scales/rotations, this can be customised by\n * providing a transformTemplate function.\n */\nfunction buildTransform(_a, _b, transformIsDefault, transformTemplate) {\n    var transform = _a.transform, transformKeys = _a.transformKeys;\n    var _c = _b.enableHardwareAcceleration, enableHardwareAcceleration = _c === void 0 ? true : _c, _d = _b.allowTransformNone, allowTransformNone = _d === void 0 ? true : _d;\n    // The transform string we\'re going to build into.\n    var transformString = "";\n    // Transform keys into their default order - this will determine the output order.\n    transformKeys.sort(sortTransformProps);\n    // Track whether the defined transform has a defined z so we don\'t add a\n    // second to enable hardware acceleration\n    var transformHasZ = false;\n    // Loop over each transform and build them into transformString\n    var numTransformKeys = transformKeys.length;\n    for (var i = 0; i < numTransformKeys; i++) {\n        var key = transformKeys[i];\n        transformString += "".concat(translateAlias[key] || key, "(").concat(transform[key], ") ");\n        if (key === "z")\n            transformHasZ = true;\n    }\n    if (!transformHasZ && enableHardwareAcceleration) {\n        transformString += "translateZ(0)";\n    }\n    else {\n        transformString = transformString.trim();\n    }\n    // If we have a custom `transform` template, pass our transform values and\n    // generated transformString to that before returning\n    if (transformTemplate) {\n        transformString = transformTemplate(transform, transformIsDefault ? "" : transformString);\n    }\n    else if (allowTransformNone && transformIsDefault) {\n        transformString = "none";\n    }\n    return transformString;\n}\n/**\n * Build a transformOrigin style. Uses the same defaults as the browser for\n * undefined origins.\n */\nfunction buildTransformOrigin(_a) {\n    var _b = _a.originX, originX = _b === void 0 ? "50%" : _b, _c = _a.originY, originY = _c === void 0 ? "50%" : _c, _d = _a.originZ, originZ = _d === void 0 ? 0 : _d;\n    return "".concat(originX, " ").concat(originY, " ").concat(originZ);\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/render/dom/utils/is-css-variable.mjs\n/**\n * Returns true if the provided key is a CSS variable\n */\nfunction isCSSVariable(key) {\n    return key.startsWith("--");\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/render/dom/value-types/get-as-type.mjs\n/**\n * Provided a value and a ValueType, returns the value as that value type.\n */\nvar getValueAsType = function (value, type) {\n    return type && typeof value === "number"\n        ? type.transform(value)\n        : value;\n};\n\n\n\n;// CONCATENATED MODULE: ./node_modules/style-value-types/dist/es/utils.mjs\nconst clamp = (min, max) => (v) => Math.max(Math.min(v, max), min);\nconst sanitize = (v) => (v % 1 ? Number(v.toFixed(5)) : v);\nconst floatRegex = /(-)?([\\d]*\\.?[\\d])+/g;\nconst colorRegex = /(#[0-9a-f]{6}|#[0-9a-f]{3}|#(?:[0-9a-f]{2}){2,4}|(rgb|hsl)a?\\((-?[\\d\\.]+%?[,\\s]+){2,3}\\s*\\/*\\s*[\\d\\.]+%?\\))/gi;\nconst singleColorRegex = /^(#[0-9a-f]{3}|#(?:[0-9a-f]{2}){2,4}|(rgb|hsl)a?\\((-?[\\d\\.]+%?[,\\s]+){2,3}\\s*\\/*\\s*[\\d\\.]+%?\\))$/i;\nfunction isString(v) {\n    return typeof v === \'string\';\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/style-value-types/dist/es/numbers/units.mjs\n\n\nconst createUnitType = (unit) => ({\n    test: (v) => isString(v) && v.endsWith(unit) && v.split(\' \').length === 1,\n    parse: parseFloat,\n    transform: (v) => `${v}${unit}`,\n});\nconst degrees = createUnitType(\'deg\');\nconst percent = createUnitType(\'%\');\nconst px = createUnitType(\'px\');\nconst vh = createUnitType(\'vh\');\nconst vw = createUnitType(\'vw\');\nconst progressPercentage = Object.assign(Object.assign({}, percent), { parse: (v) => percent.parse(v) / 100, transform: (v) => percent.transform(v * 100) });\n\n\n\n;// CONCATENATED MODULE: ./node_modules/style-value-types/dist/es/numbers/index.mjs\n\n\nconst number = {\n    test: (v) => typeof v === \'number\',\n    parse: parseFloat,\n    transform: (v) => v,\n};\nconst alpha = Object.assign(Object.assign({}, number), { transform: clamp(0, 1) });\nconst scale = Object.assign(Object.assign({}, number), { default: 1 });\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/render/dom/value-types/type-int.mjs\n\n\n\nvar type_int_int = __assign(__assign({}, number), { transform: Math.round });\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/render/dom/value-types/number.mjs\n\n\n\nvar numberValueTypes = {\n    // Border props\n    borderWidth: px,\n    borderTopWidth: px,\n    borderRightWidth: px,\n    borderBottomWidth: px,\n    borderLeftWidth: px,\n    borderRadius: px,\n    radius: px,\n    borderTopLeftRadius: px,\n    borderTopRightRadius: px,\n    borderBottomRightRadius: px,\n    borderBottomLeftRadius: px,\n    // Positioning props\n    width: px,\n    maxWidth: px,\n    height: px,\n    maxHeight: px,\n    size: px,\n    top: px,\n    right: px,\n    bottom: px,\n    left: px,\n    // Spacing props\n    padding: px,\n    paddingTop: px,\n    paddingRight: px,\n    paddingBottom: px,\n    paddingLeft: px,\n    margin: px,\n    marginTop: px,\n    marginRight: px,\n    marginBottom: px,\n    marginLeft: px,\n    // Transform props\n    rotate: degrees,\n    rotateX: degrees,\n    rotateY: degrees,\n    rotateZ: degrees,\n    scale: scale,\n    scaleX: scale,\n    scaleY: scale,\n    scaleZ: scale,\n    skew: degrees,\n    skewX: degrees,\n    skewY: degrees,\n    distance: px,\n    translateX: px,\n    translateY: px,\n    translateZ: px,\n    x: px,\n    y: px,\n    z: px,\n    perspective: px,\n    transformPerspective: px,\n    opacity: alpha,\n    originX: progressPercentage,\n    originY: progressPercentage,\n    originZ: px,\n    // Misc\n    zIndex: type_int_int,\n    // SVG\n    fillOpacity: alpha,\n    strokeOpacity: alpha,\n    numOctaves: type_int_int,\n};\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/render/html/utils/build-styles.mjs\n\n\n\n\n\n\nfunction buildHTMLStyles(state, latestValues, options, transformTemplate) {\n    var _a;\n    var style = state.style, vars = state.vars, transform = state.transform, transformKeys = state.transformKeys, transformOrigin = state.transformOrigin;\n    // Empty the transformKeys array. As we\'re throwing out refs to its items\n    // this might not be as cheap as suspected. Maybe using the array as a buffer\n    // with a manual incrementation would be better.\n    transformKeys.length = 0;\n    // Track whether we encounter any transform or transformOrigin values.\n    var hasTransform = false;\n    var hasTransformOrigin = false;\n    // Does the calculated transform essentially equal "none"?\n    var transformIsNone = true;\n    /**\n     * Loop over all our latest animated values and decide whether to handle them\n     * as a style or CSS variable.\n     *\n     * Transforms and transform origins are kept seperately for further processing.\n     */\n    for (var key in latestValues) {\n        var value = latestValues[key];\n        /**\n         * If this is a CSS variable we don\'t do any further processing.\n         */\n        if (isCSSVariable(key)) {\n            vars[key] = value;\n            continue;\n        }\n        // Convert the value to its default value type, ie 0 -> "0px"\n        var valueType = numberValueTypes[key];\n        var valueAsType = getValueAsType(value, valueType);\n        if (isTransformProp(key)) {\n            // If this is a transform, flag to enable further transform processing\n            hasTransform = true;\n            transform[key] = valueAsType;\n            transformKeys.push(key);\n            // If we already know we have a non-default transform, early return\n            if (!transformIsNone)\n                continue;\n            // Otherwise check to see if this is a default transform\n            if (value !== ((_a = valueType.default) !== null && _a !== void 0 ? _a : 0))\n                transformIsNone = false;\n        }\n        else if (isTransformOriginProp(key)) {\n            transformOrigin[key] = valueAsType;\n            // If this is a transform origin, flag and enable further transform-origin processing\n            hasTransformOrigin = true;\n        }\n        else {\n            style[key] = valueAsType;\n        }\n    }\n    if (hasTransform) {\n        style.transform = buildTransform(state, options, transformIsNone, transformTemplate);\n    }\n    else if (transformTemplate) {\n        style.transform = transformTemplate({}, "");\n    }\n    else if (!latestValues.transform && style.transform) {\n        style.transform = "none";\n    }\n    if (hasTransformOrigin) {\n        style.transformOrigin = buildTransformOrigin(transformOrigin);\n    }\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/render/html/utils/create-render-state.mjs\nvar createHtmlRenderState = function () { return ({\n    style: {},\n    transform: {},\n    transformKeys: [],\n    transformOrigin: {},\n    vars: {},\n}); };\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/render/html/use-props.mjs\n\n\n\n\n\n\n\nfunction copyRawValuesOnly(target, source, props) {\n    for (var key in source) {\n        if (!isMotionValue(source[key]) && !isForcedMotionValue(key, props)) {\n            target[key] = source[key];\n        }\n    }\n}\nfunction useInitialMotionValues(_a, visualState, isStatic) {\n    var transformTemplate = _a.transformTemplate;\n    return (0,index_js_.useMemo)(function () {\n        var state = createHtmlRenderState();\n        buildHTMLStyles(state, visualState, { enableHardwareAcceleration: !isStatic }, transformTemplate);\n        var vars = state.vars, style = state.style;\n        return __assign(__assign({}, vars), style);\n    }, [visualState]);\n}\nfunction useStyle(props, visualState, isStatic) {\n    var styleProp = props.style || {};\n    var style = {};\n    /**\n     * Copy non-Motion Values straight into style\n     */\n    copyRawValuesOnly(style, styleProp, props);\n    Object.assign(style, useInitialMotionValues(props, visualState, isStatic));\n    if (props.transformValues) {\n        style = props.transformValues(style);\n    }\n    return style;\n}\nfunction useHTMLProps(props, visualState, isStatic) {\n    // The `any` isn\'t ideal but it is the type of createElement props argument\n    var htmlProps = {};\n    var style = useStyle(props, visualState, isStatic);\n    if (Boolean(props.drag) && props.dragListener !== false) {\n        // Disable the ghost element when a user drags\n        htmlProps.draggable = false;\n        // Disable text selection\n        style.userSelect =\n            style.WebkitUserSelect =\n                style.WebkitTouchCallout =\n                    "none";\n        // Disable scrolling on the draggable direction\n        style.touchAction =\n            props.drag === true\n                ? "none"\n                : "pan-".concat(props.drag === "x" ? "y" : "x");\n    }\n    htmlProps.style = style;\n    return htmlProps;\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/motion/utils/valid-prop.mjs\n/**\n * A list of all valid MotionProps.\n *\n * @privateRemarks\n * This doesn\'t throw if a `MotionProp` name is missing - it should.\n */\nvar validMotionProps = new Set([\n    "initial",\n    "animate",\n    "exit",\n    "style",\n    "variants",\n    "transition",\n    "transformTemplate",\n    "transformValues",\n    "custom",\n    "inherit",\n    "layout",\n    "layoutId",\n    "layoutDependency",\n    "onLayoutAnimationStart",\n    "onLayoutAnimationComplete",\n    "onLayoutMeasure",\n    "onBeforeLayoutMeasure",\n    "onAnimationStart",\n    "onAnimationComplete",\n    "onUpdate",\n    "onDragStart",\n    "onDrag",\n    "onDragEnd",\n    "onMeasureDragConstraints",\n    "onDirectionLock",\n    "onDragTransitionEnd",\n    "drag",\n    "dragControls",\n    "dragListener",\n    "dragConstraints",\n    "dragDirectionLock",\n    "dragSnapToOrigin",\n    "_dragX",\n    "_dragY",\n    "dragElastic",\n    "dragMomentum",\n    "dragPropagation",\n    "dragTransition",\n    "whileDrag",\n    "onPan",\n    "onPanStart",\n    "onPanEnd",\n    "onPanSessionStart",\n    "onTap",\n    "onTapStart",\n    "onTapCancel",\n    "onHoverStart",\n    "onHoverEnd",\n    "whileFocus",\n    "whileTap",\n    "whileHover",\n    "whileInView",\n    "onViewportEnter",\n    "onViewportLeave",\n    "viewport",\n    "layoutScroll",\n]);\n/**\n * Check whether a prop name is a valid `MotionProp` key.\n *\n * @param key - Name of the property to check\n * @returns `true` is key is a valid `MotionProp`.\n *\n * @public\n */\nfunction isValidMotionProp(key) {\n    return validMotionProps.has(key);\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/render/dom/utils/filter-props.mjs\n\n\nvar shouldForward = function (key) { return !isValidMotionProp(key); };\nfunction loadExternalIsValidProp(isValidProp) {\n    if (!isValidProp)\n        return;\n    // Explicitly filter our events\n    shouldForward = function (key) {\n        return key.startsWith("on") ? !isValidMotionProp(key) : isValidProp(key);\n    };\n}\n/**\n * Emotion and Styled Components both allow users to pass through arbitrary props to their components\n * to dynamically generate CSS. They both use the `@emotion/is-prop-valid` package to determine which\n * of these should be passed to the underlying DOM node.\n *\n * However, when styling a Motion component `styled(motion.div)`, both packages pass through *all* props\n * as it\'s seen as an arbitrary component rather than a DOM node. Motion only allows arbitrary props\n * passed through the `custom` prop so it doesn\'t *need* the payload or computational overhead of\n * `@emotion/is-prop-valid`, however to fix this problem we need to use it.\n *\n * By making it an optionalDependency we can offer this functionality only in the situations where it\'s\n * actually required.\n */\ntry {\n    /**\n     * We attempt to import this package but require won\'t be defined in esm environments, in that case\n     * isPropValid will have to be provided via `MotionContext`. In a 6.0.0 this should probably be removed\n     * in favour of explicit injection.\n     */\n    loadExternalIsValidProp(require("@emotion/is-prop-valid").default);\n}\ncatch (_a) {\n    // We don\'t need to actually do anything here - the fallback is the existing `isPropValid`.\n}\nfunction filterProps(props, isDom, forwardMotionProps) {\n    var filteredProps = {};\n    for (var key in props) {\n        if (shouldForward(key) ||\n            (forwardMotionProps === true && isValidMotionProp(key)) ||\n            (!isDom && !isValidMotionProp(key)) ||\n            // If trying to use native HTML drag events, forward drag listeners\n            (props["draggable"] && key.startsWith("onDrag"))) {\n            filteredProps[key] = props[key];\n        }\n    }\n    return filteredProps;\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/render/svg/utils/transform-origin.mjs\n\n\nfunction calcOrigin(origin, offset, size) {\n    return typeof origin === "string"\n        ? origin\n        : px.transform(offset + size * origin);\n}\n/**\n * The SVG transform origin defaults are different to CSS and is less intuitive,\n * so we use the measured dimensions of the SVG to reconcile these.\n */\nfunction calcSVGTransformOrigin(dimensions, originX, originY) {\n    var pxOriginX = calcOrigin(originX, dimensions.x, dimensions.width);\n    var pxOriginY = calcOrigin(originY, dimensions.y, dimensions.height);\n    return "".concat(pxOriginX, " ").concat(pxOriginY);\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/render/svg/utils/path.mjs\n\n\nvar dashKeys = {\n    offset: "stroke-dashoffset",\n    array: "stroke-dasharray",\n};\nvar camelKeys = {\n    offset: "strokeDashoffset",\n    array: "strokeDasharray",\n};\n/**\n * Build SVG path properties. Uses the path\'s measured length to convert\n * our custom pathLength, pathSpacing and pathOffset into stroke-dashoffset\n * and stroke-dasharray attributes.\n *\n * This function is mutative to reduce per-frame GC.\n */\nfunction buildSVGPath(attrs, length, spacing, offset, useDashCase) {\n    if (spacing === void 0) { spacing = 1; }\n    if (offset === void 0) { offset = 0; }\n    if (useDashCase === void 0) { useDashCase = true; }\n    // Normalise path length by setting SVG attribute pathLength to 1\n    attrs.pathLength = 1;\n    // We use dash case when setting attributes directly to the DOM node and camel case\n    // when defining props on a React component.\n    var keys = useDashCase ? dashKeys : camelKeys;\n    // Build the dash offset\n    attrs[keys.offset] = px.transform(-offset);\n    // Build the dash array\n    var pathLength = px.transform(length);\n    var pathSpacing = px.transform(spacing);\n    attrs[keys.array] = "".concat(pathLength, " ").concat(pathSpacing);\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/render/svg/utils/build-attrs.mjs\n\n\n\n\n\n/**\n * Build SVG visual attrbutes, like cx and style.transform\n */\nfunction buildSVGAttrs(state, _a, options, transformTemplate) {\n    var attrX = _a.attrX, attrY = _a.attrY, originX = _a.originX, originY = _a.originY, pathLength = _a.pathLength, _b = _a.pathSpacing, pathSpacing = _b === void 0 ? 1 : _b, _c = _a.pathOffset, pathOffset = _c === void 0 ? 0 : _c, \n    // This is object creation, which we try to avoid per-frame.\n    latest = __rest(_a, ["attrX", "attrY", "originX", "originY", "pathLength", "pathSpacing", "pathOffset"]);\n    buildHTMLStyles(state, latest, options, transformTemplate);\n    state.attrs = state.style;\n    state.style = {};\n    var attrs = state.attrs, style = state.style, dimensions = state.dimensions;\n    /**\n     * However, we apply transforms as CSS transforms. So if we detect a transform we take it from attrs\n     * and copy it into style.\n     */\n    if (attrs.transform) {\n        if (dimensions)\n            style.transform = attrs.transform;\n        delete attrs.transform;\n    }\n    // Parse transformOrigin\n    if (dimensions &&\n        (originX !== undefined || originY !== undefined || style.transform)) {\n        style.transformOrigin = calcSVGTransformOrigin(dimensions, originX !== undefined ? originX : 0.5, originY !== undefined ? originY : 0.5);\n    }\n    // Treat x/y not as shortcuts but as actual attributes\n    if (attrX !== undefined)\n        attrs.x = attrX;\n    if (attrY !== undefined)\n        attrs.y = attrY;\n    // Build SVG path if one has been defined\n    if (pathLength !== undefined) {\n        buildSVGPath(attrs, pathLength, pathSpacing, pathOffset, false);\n    }\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/render/svg/utils/create-render-state.mjs\n\n\n\nvar createSvgRenderState = function () { return (__assign(__assign({}, createHtmlRenderState()), { attrs: {} })); };\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/render/svg/use-props.mjs\n\n\n\n\n\n\nfunction useSVGProps(props, visualState) {\n    var visualProps = (0,index_js_.useMemo)(function () {\n        var state = createSvgRenderState();\n        buildSVGAttrs(state, visualState, { enableHardwareAcceleration: false }, props.transformTemplate);\n        return __assign(__assign({}, state.attrs), { style: __assign({}, state.style) });\n    }, [visualState]);\n    if (props.style) {\n        var rawStyles = {};\n        copyRawValuesOnly(rawStyles, props.style, props);\n        visualProps.style = __assign(__assign({}, rawStyles), visualProps.style);\n    }\n    return visualProps;\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/render/dom/use-render.mjs\n\n\n\n\n\n\n\nfunction createUseRender(forwardMotionProps) {\n    if (forwardMotionProps === void 0) { forwardMotionProps = false; }\n    var useRender = function (Component, props, projectionId, ref, _a, isStatic) {\n        var latestValues = _a.latestValues;\n        var useVisualProps = isSVGComponent(Component)\n            ? useSVGProps\n            : useHTMLProps;\n        var visualProps = useVisualProps(props, latestValues, isStatic);\n        var filteredProps = filterProps(props, typeof Component === "string", forwardMotionProps);\n        var elementProps = __assign(__assign(__assign({}, filteredProps), visualProps), { ref: ref });\n        if (projectionId) {\n            elementProps["data-projection-id"] = projectionId;\n        }\n        return (0,index_js_.createElement)(Component, elementProps);\n    };\n    return useRender;\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/render/dom/utils/camel-to-dash.mjs\nvar CAMEL_CASE_PATTERN = /([a-z])([A-Z])/g;\nvar REPLACE_TEMPLATE = "$1-$2";\n/**\n * Convert camelCase to dash-case properties.\n */\nvar camelToDash = function (str) {\n    return str.replace(CAMEL_CASE_PATTERN, REPLACE_TEMPLATE).toLowerCase();\n};\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/render/html/utils/render.mjs\nfunction renderHTML(element, _a, styleProp, projection) {\n    var style = _a.style, vars = _a.vars;\n    Object.assign(element.style, style, projection && projection.getProjectionStyles(styleProp));\n    // Loop over any CSS variables and assign those.\n    for (var key in vars) {\n        element.style.setProperty(key, vars[key]);\n    }\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/render/svg/utils/camel-case-attrs.mjs\n/**\n * A set of attribute names that are always read/written as camel case.\n */\nvar camelCaseAttributes = new Set([\n    "baseFrequency",\n    "diffuseConstant",\n    "kernelMatrix",\n    "kernelUnitLength",\n    "keySplines",\n    "keyTimes",\n    "limitingConeAngle",\n    "markerHeight",\n    "markerWidth",\n    "numOctaves",\n    "targetX",\n    "targetY",\n    "surfaceScale",\n    "specularConstant",\n    "specularExponent",\n    "stdDeviation",\n    "tableValues",\n    "viewBox",\n    "gradientTransform",\n    "pathLength",\n]);\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/render/svg/utils/render.mjs\n\n\n\n\nfunction renderSVG(element, renderState, _styleProp, projection) {\n    renderHTML(element, renderState, undefined, projection);\n    for (var key in renderState.attrs) {\n        element.setAttribute(!camelCaseAttributes.has(key) ? camelToDash(key) : key, renderState.attrs[key]);\n    }\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/render/html/utils/scrape-motion-values.mjs\n\n\n\nfunction scrapeMotionValuesFromProps(props) {\n    var style = props.style;\n    var newValues = {};\n    for (var key in style) {\n        if (isMotionValue(style[key]) || isForcedMotionValue(key, props)) {\n            newValues[key] = style[key];\n        }\n    }\n    return newValues;\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/render/svg/utils/scrape-motion-values.mjs\n\n\n\nfunction scrape_motion_values_scrapeMotionValuesFromProps(props) {\n    var newValues = scrapeMotionValuesFromProps(props);\n    for (var key in props) {\n        if (isMotionValue(props[key])) {\n            var targetKey = key === "x" || key === "y" ? "attr" + key.toUpperCase() : key;\n            newValues[targetKey] = props[key];\n        }\n    }\n    return newValues;\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/animation/utils/is-animation-controls.mjs\nfunction isAnimationControls(v) {\n    return typeof v === "object" && typeof v.start === "function";\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/animation/utils/is-keyframes-target.mjs\nvar isKeyframesTarget = function (v) {\n    return Array.isArray(v);\n};\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/utils/resolve-value.mjs\n\n\nvar isCustomValue = function (v) {\n    return Boolean(v && typeof v === "object" && v.mix && v.toValue);\n};\nvar resolveFinalValueInKeyframes = function (v) {\n    // TODO maybe throw if v.length - 1 is placeholder token?\n    return isKeyframesTarget(v) ? v[v.length - 1] || 0 : v;\n};\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/value/utils/resolve-motion-value.mjs\n\n\n\n/**\n * If the provided value is a MotionValue, this returns the actual value, otherwise just the value itself\n *\n * TODO: Remove and move to library\n */\nfunction resolveMotionValue(value) {\n    var unwrappedValue = isMotionValue(value) ? value.get() : value;\n    return isCustomValue(unwrappedValue)\n        ? unwrappedValue.toValue()\n        : unwrappedValue;\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/motion/utils/use-visual-state.mjs\n\n\n\n\n\n\n\n\n\nfunction makeState(_a, props, context, presenceContext) {\n    var scrapeMotionValuesFromProps = _a.scrapeMotionValuesFromProps, createRenderState = _a.createRenderState, onMount = _a.onMount;\n    var state = {\n        latestValues: makeLatestValues(props, context, presenceContext, scrapeMotionValuesFromProps),\n        renderState: createRenderState(),\n    };\n    if (onMount) {\n        state.mount = function (instance) { return onMount(props, instance, state); };\n    }\n    return state;\n}\nvar makeUseVisualState = function (config) {\n    return function (props, isStatic) {\n        var context = (0,index_js_.useContext)(MotionContext);\n        var presenceContext = (0,index_js_.useContext)(PresenceContext);\n        return isStatic\n            ? makeState(config, props, context, presenceContext)\n            : useConstant(function () {\n                return makeState(config, props, context, presenceContext);\n            });\n    };\n};\nfunction makeLatestValues(props, context, presenceContext, scrapeMotionValues) {\n    var values = {};\n    var blockInitialAnimation = (presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.initial) === false;\n    var motionValues = scrapeMotionValues(props);\n    for (var key in motionValues) {\n        values[key] = resolveMotionValue(motionValues[key]);\n    }\n    var initial = props.initial, animate = props.animate;\n    var isControllingVariants = checkIfControllingVariants(props);\n    var isVariantNode = checkIfVariantNode(props);\n    if (context &&\n        isVariantNode &&\n        !isControllingVariants &&\n        props.inherit !== false) {\n        initial !== null && initial !== void 0 ? initial : (initial = context.initial);\n        animate !== null && animate !== void 0 ? animate : (animate = context.animate);\n    }\n    var initialAnimationIsBlocked = blockInitialAnimation || initial === false;\n    var variantToSet = initialAnimationIsBlocked ? animate : initial;\n    if (variantToSet &&\n        typeof variantToSet !== "boolean" &&\n        !isAnimationControls(variantToSet)) {\n        var list = Array.isArray(variantToSet) ? variantToSet : [variantToSet];\n        list.forEach(function (definition) {\n            var resolved = resolveVariantFromProps(props, definition);\n            if (!resolved)\n                return;\n            var transitionEnd = resolved.transitionEnd; resolved.transition; var target = __rest(resolved, ["transitionEnd", "transition"]);\n            for (var key in target) {\n                var valueTarget = target[key];\n                if (Array.isArray(valueTarget)) {\n                    /**\n                     * Take final keyframe if the initial animation is blocked because\n                     * we want to initialise at the end of that blocked animation.\n                     */\n                    var index = initialAnimationIsBlocked\n                        ? valueTarget.length - 1\n                        : 0;\n                    valueTarget = valueTarget[index];\n                }\n                if (valueTarget !== null) {\n                    values[key] = valueTarget;\n                }\n            }\n            for (var key in transitionEnd)\n                values[key] = transitionEnd[key];\n        });\n    }\n    return values;\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/render/svg/config-motion.mjs\n\n\n\n\n\n\nvar svgMotionConfig = {\n    useVisualState: makeUseVisualState({\n        scrapeMotionValuesFromProps: scrape_motion_values_scrapeMotionValuesFromProps,\n        createRenderState: createSvgRenderState,\n        onMount: function (props, instance, _a) {\n            var renderState = _a.renderState, latestValues = _a.latestValues;\n            try {\n                renderState.dimensions =\n                    typeof instance.getBBox ===\n                        "function"\n                        ? instance.getBBox()\n                        : instance.getBoundingClientRect();\n            }\n            catch (e) {\n                // Most likely trying to measure an unrendered element under Firefox\n                renderState.dimensions = {\n                    x: 0,\n                    y: 0,\n                    width: 0,\n                    height: 0,\n                };\n            }\n            buildSVGAttrs(renderState, latestValues, { enableHardwareAcceleration: false }, props.transformTemplate);\n            renderSVG(instance, renderState);\n        },\n    }),\n};\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/render/html/config-motion.mjs\n\n\n\n\nvar htmlMotionConfig = {\n    useVisualState: makeUseVisualState({\n        scrapeMotionValuesFromProps: scrapeMotionValuesFromProps,\n        createRenderState: createHtmlRenderState,\n    }),\n};\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/render/dom/utils/create-config.mjs\n\n\n\n\n\n\nfunction createDomMotionConfig(Component, _a, preloadedFeatures, createVisualElement, projectionNodeConstructor) {\n    var _b = _a.forwardMotionProps, forwardMotionProps = _b === void 0 ? false : _b;\n    var baseConfig = isSVGComponent(Component)\n        ? svgMotionConfig\n        : htmlMotionConfig;\n    return __assign(__assign({}, baseConfig), { preloadedFeatures: preloadedFeatures, useRender: createUseRender(forwardMotionProps), createVisualElement: createVisualElement, projectionNodeConstructor: projectionNodeConstructor, Component: Component });\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/render/utils/types.mjs\nvar AnimationType;\n(function (AnimationType) {\n    AnimationType["Animate"] = "animate";\n    AnimationType["Hover"] = "whileHover";\n    AnimationType["Tap"] = "whileTap";\n    AnimationType["Drag"] = "whileDrag";\n    AnimationType["Focus"] = "whileFocus";\n    AnimationType["InView"] = "whileInView";\n    AnimationType["Exit"] = "exit";\n})(AnimationType || (AnimationType = {}));\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/events/use-dom-event.mjs\n\n\nfunction addDomEvent(target, eventName, handler, options) {\n    if (options === void 0) { options = { passive: true }; }\n    target.addEventListener(eventName, handler, options);\n    return function () { return target.removeEventListener(eventName, handler); };\n}\n/**\n * Attaches an event listener directly to the provided DOM element.\n *\n * Bypassing React\'s event system can be desirable, for instance when attaching non-passive\n * event handlers.\n *\n * ```jsx\n * const ref = useRef(null)\n *\n * useDomEvent(ref, \'wheel\', onWheel, { passive: false })\n *\n * return <div ref={ref} />\n * ```\n *\n * @param ref - React.RefObject that\'s been provided to the element you want to bind the listener to.\n * @param eventName - Name of the event you want listen for.\n * @param handler - Function to fire when receiving the event.\n * @param options - Options to pass to `Event.addEventListener`.\n *\n * @public\n */\nfunction useDomEvent(ref, eventName, handler, options) {\n    (0,index_js_.useEffect)(function () {\n        var element = ref.current;\n        if (handler && element) {\n            return addDomEvent(element, eventName, handler, options);\n        }\n    }, [ref, eventName, handler, options]);\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/gestures/use-focus-gesture.mjs\n\n\n\n/**\n *\n * @param props\n * @param ref\n * @internal\n */\nfunction useFocusGesture(_a) {\n    var whileFocus = _a.whileFocus, visualElement = _a.visualElement;\n    var onFocus = function () {\n        var _a;\n        (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(AnimationType.Focus, true);\n    };\n    var onBlur = function () {\n        var _a;\n        (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(AnimationType.Focus, false);\n    };\n    useDomEvent(visualElement, "focus", whileFocus ? onFocus : undefined);\n    useDomEvent(visualElement, "blur", whileFocus ? onBlur : undefined);\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/gestures/utils/event-type.mjs\nfunction isMouseEvent(event) {\n    // PointerEvent inherits from MouseEvent so we can\'t use a straight instanceof check.\n    if (typeof PointerEvent !== "undefined" && event instanceof PointerEvent) {\n        return !!(event.pointerType === "mouse");\n    }\n    return event instanceof MouseEvent;\n}\nfunction isTouchEvent(event) {\n    var hasTouches = !!event.touches;\n    return hasTouches;\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/events/event-info.mjs\n\n\n/**\n * Filters out events not attached to the primary pointer (currently left mouse button)\n * @param eventHandler\n */\nfunction filterPrimaryPointer(eventHandler) {\n    return function (event) {\n        var isMouseEvent = event instanceof MouseEvent;\n        var isPrimaryPointer = !isMouseEvent ||\n            (isMouseEvent && event.button === 0);\n        if (isPrimaryPointer) {\n            eventHandler(event);\n        }\n    };\n}\nvar defaultPagePoint = { pageX: 0, pageY: 0 };\nfunction pointFromTouch(e, pointType) {\n    if (pointType === void 0) { pointType = "page"; }\n    var primaryTouch = e.touches[0] || e.changedTouches[0];\n    var point = primaryTouch || defaultPagePoint;\n    return {\n        x: point[pointType + "X"],\n        y: point[pointType + "Y"],\n    };\n}\nfunction pointFromMouse(point, pointType) {\n    if (pointType === void 0) { pointType = "page"; }\n    return {\n        x: point[pointType + "X"],\n        y: point[pointType + "Y"],\n    };\n}\nfunction extractEventInfo(event, pointType) {\n    if (pointType === void 0) { pointType = "page"; }\n    return {\n        point: isTouchEvent(event)\n            ? pointFromTouch(event, pointType)\n            : pointFromMouse(event, pointType),\n    };\n}\nvar wrapHandler = function (handler, shouldFilterPrimaryPointer) {\n    if (shouldFilterPrimaryPointer === void 0) { shouldFilterPrimaryPointer = false; }\n    var listener = function (event) {\n        return handler(event, extractEventInfo(event));\n    };\n    return shouldFilterPrimaryPointer\n        ? filterPrimaryPointer(listener)\n        : listener;\n};\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/events/utils.mjs\n\n\n// We check for event support via functions in case they\'ve been mocked by a testing suite.\nvar supportsPointerEvents = function () {\n    return isBrowser && window.onpointerdown === null;\n};\nvar supportsTouchEvents = function () {\n    return isBrowser && window.ontouchstart === null;\n};\nvar supportsMouseEvents = function () {\n    return isBrowser && window.onmousedown === null;\n};\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/events/use-pointer-event.mjs\n\n\n\n\nvar mouseEventNames = {\n    pointerdown: "mousedown",\n    pointermove: "mousemove",\n    pointerup: "mouseup",\n    pointercancel: "mousecancel",\n    pointerover: "mouseover",\n    pointerout: "mouseout",\n    pointerenter: "mouseenter",\n    pointerleave: "mouseleave",\n};\nvar touchEventNames = {\n    pointerdown: "touchstart",\n    pointermove: "touchmove",\n    pointerup: "touchend",\n    pointercancel: "touchcancel",\n};\nfunction getPointerEventName(name) {\n    if (supportsPointerEvents()) {\n        return name;\n    }\n    else if (supportsTouchEvents()) {\n        return touchEventNames[name];\n    }\n    else if (supportsMouseEvents()) {\n        return mouseEventNames[name];\n    }\n    return name;\n}\nfunction addPointerEvent(target, eventName, handler, options) {\n    return addDomEvent(target, getPointerEventName(eventName), wrapHandler(handler, eventName === "pointerdown"), options);\n}\nfunction usePointerEvent(ref, eventName, handler, options) {\n    return useDomEvent(ref, getPointerEventName(eventName), handler && wrapHandler(handler, eventName === "pointerdown"), options);\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/gestures/drag/utils/lock.mjs\nfunction createLock(name) {\n    var lock = null;\n    return function () {\n        var openLock = function () {\n            lock = null;\n        };\n        if (lock === null) {\n            lock = name;\n            return openLock;\n        }\n        return false;\n    };\n}\nvar globalHorizontalLock = createLock("dragHorizontal");\nvar globalVerticalLock = createLock("dragVertical");\nfunction getGlobalLock(drag) {\n    var lock = false;\n    if (drag === "y") {\n        lock = globalVerticalLock();\n    }\n    else if (drag === "x") {\n        lock = globalHorizontalLock();\n    }\n    else {\n        var openHorizontal_1 = globalHorizontalLock();\n        var openVertical_1 = globalVerticalLock();\n        if (openHorizontal_1 && openVertical_1) {\n            lock = function () {\n                openHorizontal_1();\n                openVertical_1();\n            };\n        }\n        else {\n            // Release the locks because we don\'t use them\n            if (openHorizontal_1)\n                openHorizontal_1();\n            if (openVertical_1)\n                openVertical_1();\n        }\n    }\n    return lock;\n}\nfunction isDragActive() {\n    // Check the gesture lock - if we get it, it means no drag gesture is active\n    // and we can safely fire the tap gesture.\n    var openGestureLock = getGlobalLock(true);\n    if (!openGestureLock)\n        return true;\n    openGestureLock();\n    return false;\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/gestures/use-hover-gesture.mjs\n\n\n\n\n\nfunction createHoverEvent(visualElement, isActive, callback) {\n    return function (event, info) {\n        var _a;\n        if (!isMouseEvent(event) || isDragActive())\n            return;\n        /**\n         * Ensure we trigger animations before firing event callback\n         */\n        (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(AnimationType.Hover, isActive);\n        callback === null || callback === void 0 ? void 0 : callback(event, info);\n    };\n}\nfunction useHoverGesture(_a) {\n    var onHoverStart = _a.onHoverStart, onHoverEnd = _a.onHoverEnd, whileHover = _a.whileHover, visualElement = _a.visualElement;\n    usePointerEvent(visualElement, "pointerenter", onHoverStart || whileHover\n        ? createHoverEvent(visualElement, true, onHoverStart)\n        : undefined, { passive: !onHoverStart });\n    usePointerEvent(visualElement, "pointerleave", onHoverEnd || whileHover\n        ? createHoverEvent(visualElement, false, onHoverEnd)\n        : undefined, { passive: !onHoverEnd });\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/gestures/utils/is-node-or-child.mjs\n/**\n * Recursively traverse up the tree to check whether the provided child node\n * is the parent or a descendant of it.\n *\n * @param parent - Element to find\n * @param child - Element to test against parent\n */\nvar isNodeOrChild = function (parent, child) {\n    if (!child) {\n        return false;\n    }\n    else if (parent === child) {\n        return true;\n    }\n    else {\n        return isNodeOrChild(parent, child.parentElement);\n    }\n};\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/utils/use-unmount-effect.mjs\n\n\nfunction useUnmountEffect(callback) {\n    return (0,index_js_.useEffect)(function () { return function () { return callback(); }; }, []);\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/popmotion/dist/es/utils/pipe.mjs\nconst combineFunctions = (a, b) => (v) => b(a(v));\nconst pipe = (...transformers) => transformers.reduce(combineFunctions);\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/gestures/use-tap-gesture.mjs\n\n\n\n\n\n\n\n\n/**\n * @param handlers -\n * @internal\n */\nfunction useTapGesture(_a) {\n    var onTap = _a.onTap, onTapStart = _a.onTapStart, onTapCancel = _a.onTapCancel, whileTap = _a.whileTap, visualElement = _a.visualElement;\n    var hasPressListeners = onTap || onTapStart || onTapCancel || whileTap;\n    var isPressing = (0,index_js_.useRef)(false);\n    var cancelPointerEndListeners = (0,index_js_.useRef)(null);\n    /**\n     * Only set listener to passive if there are no external listeners.\n     */\n    var eventOptions = {\n        passive: !(onTapStart || onTap || onTapCancel || onPointerDown),\n    };\n    function removePointerEndListener() {\n        var _a;\n        (_a = cancelPointerEndListeners.current) === null || _a === void 0 ? void 0 : _a.call(cancelPointerEndListeners);\n        cancelPointerEndListeners.current = null;\n    }\n    function checkPointerEnd() {\n        var _a;\n        removePointerEndListener();\n        isPressing.current = false;\n        (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(AnimationType.Tap, false);\n        return !isDragActive();\n    }\n    function onPointerUp(event, info) {\n        if (!checkPointerEnd())\n            return;\n        /**\n         * We only count this as a tap gesture if the event.target is the same\n         * as, or a child of, this component\'s element\n         */\n        !isNodeOrChild(visualElement.getInstance(), event.target)\n            ? onTapCancel === null || onTapCancel === void 0 ? void 0 : onTapCancel(event, info)\n            : onTap === null || onTap === void 0 ? void 0 : onTap(event, info);\n    }\n    function onPointerCancel(event, info) {\n        if (!checkPointerEnd())\n            return;\n        onTapCancel === null || onTapCancel === void 0 ? void 0 : onTapCancel(event, info);\n    }\n    function onPointerDown(event, info) {\n        var _a;\n        removePointerEndListener();\n        if (isPressing.current)\n            return;\n        isPressing.current = true;\n        cancelPointerEndListeners.current = pipe(addPointerEvent(window, "pointerup", onPointerUp, eventOptions), addPointerEvent(window, "pointercancel", onPointerCancel, eventOptions));\n        /**\n         * Ensure we trigger animations before firing event callback\n         */\n        (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(AnimationType.Tap, true);\n        onTapStart === null || onTapStart === void 0 ? void 0 : onTapStart(event, info);\n    }\n    usePointerEvent(visualElement, "pointerdown", hasPressListeners ? onPointerDown : undefined, eventOptions);\n    useUnmountEffect(removePointerEndListener);\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/utils/warn-once.mjs\nvar warned = new Set();\nfunction warnOnce(condition, message, element) {\n    if (condition || warned.has(message))\n        return;\n    console.warn(message);\n    if (element)\n        console.warn(element);\n    warned.add(message);\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/motion/features/viewport/observers.mjs\n\n\n/**\n * Map an IntersectionHandler callback to an element. We only ever make one handler for one\n * element, so even though these handlers might all be triggered by different\n * observers, we can keep them in the same map.\n */\nvar observerCallbacks = new WeakMap();\n/**\n * Multiple observers can be created for multiple element/document roots. Each with\n * different settings. So here we store dictionaries of observers to each root,\n * using serialised settings (threshold/margin) as lookup keys.\n */\nvar observers = new WeakMap();\nvar fireObserverCallback = function (entry) {\n    var _a;\n    (_a = observerCallbacks.get(entry.target)) === null || _a === void 0 ? void 0 : _a(entry);\n};\nvar fireAllObserverCallbacks = function (entries) {\n    entries.forEach(fireObserverCallback);\n};\nfunction initIntersectionObserver(_a) {\n    var root = _a.root, options = __rest(_a, ["root"]);\n    var lookupRoot = root || document;\n    /**\n     * If we don\'t have an observer lookup map for this root, create one.\n     */\n    if (!observers.has(lookupRoot)) {\n        observers.set(lookupRoot, {});\n    }\n    var rootObservers = observers.get(lookupRoot);\n    var key = JSON.stringify(options);\n    /**\n     * If we don\'t have an observer for this combination of root and settings,\n     * create one.\n     */\n    if (!rootObservers[key]) {\n        rootObservers[key] = new IntersectionObserver(fireAllObserverCallbacks, __assign({ root: root }, options));\n    }\n    return rootObservers[key];\n}\nfunction observeIntersection(element, options, callback) {\n    var rootInteresectionObserver = initIntersectionObserver(options);\n    observerCallbacks.set(element, callback);\n    rootInteresectionObserver.observe(element);\n    return function () {\n        observerCallbacks.delete(element);\n        rootInteresectionObserver.unobserve(element);\n    };\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/motion/features/viewport/use-viewport.mjs\n\n\n\n\n\n\nfunction useViewport(_a) {\n    var visualElement = _a.visualElement, whileInView = _a.whileInView, onViewportEnter = _a.onViewportEnter, onViewportLeave = _a.onViewportLeave, _b = _a.viewport, viewport = _b === void 0 ? {} : _b;\n    var state = (0,index_js_.useRef)({\n        hasEnteredView: false,\n        isInView: false,\n    });\n    var shouldObserve = Boolean(whileInView || onViewportEnter || onViewportLeave);\n    if (viewport.once && state.current.hasEnteredView)\n        shouldObserve = false;\n    var useObserver = typeof IntersectionObserver === "undefined"\n        ? useMissingIntersectionObserver\n        : useIntersectionObserver;\n    useObserver(shouldObserve, state.current, visualElement, viewport);\n}\nvar thresholdNames = {\n    some: 0,\n    all: 1,\n};\nfunction useIntersectionObserver(shouldObserve, state, visualElement, _a) {\n    var root = _a.root, rootMargin = _a.margin, _b = _a.amount, amount = _b === void 0 ? "some" : _b, once = _a.once;\n    (0,index_js_.useEffect)(function () {\n        if (!shouldObserve)\n            return;\n        var options = {\n            root: root === null || root === void 0 ? void 0 : root.current,\n            rootMargin: rootMargin,\n            threshold: typeof amount === "number" ? amount : thresholdNames[amount],\n        };\n        var intersectionCallback = function (entry) {\n            var _a;\n            var isIntersecting = entry.isIntersecting;\n            /**\n             * If there\'s been no change in the viewport state, early return.\n             */\n            if (state.isInView === isIntersecting)\n                return;\n            state.isInView = isIntersecting;\n            /**\n             * Handle hasEnteredView. If this is only meant to run once, and\n             * element isn\'t visible, early return. Otherwise set hasEnteredView to true.\n             */\n            if (once && !isIntersecting && state.hasEnteredView) {\n                return;\n            }\n            else if (isIntersecting) {\n                state.hasEnteredView = true;\n            }\n            (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(AnimationType.InView, isIntersecting);\n            /**\n             * Use the latest committed props rather than the ones in scope\n             * when this observer is created\n             */\n            var props = visualElement.getProps();\n            var callback = isIntersecting\n                ? props.onViewportEnter\n                : props.onViewportLeave;\n            callback === null || callback === void 0 ? void 0 : callback(entry);\n        };\n        return observeIntersection(visualElement.getInstance(), options, intersectionCallback);\n    }, [shouldObserve, root, rootMargin, amount]);\n}\n/**\n * If IntersectionObserver is missing, we activate inView and fire onViewportEnter\n * on mount. This way, the page will be in the state the author expects users\n * to see it in for everyone.\n */\nfunction useMissingIntersectionObserver(shouldObserve, state, visualElement, _a) {\n    var _b = _a.fallback, fallback = _b === void 0 ? true : _b;\n    (0,index_js_.useEffect)(function () {\n        if (!shouldObserve || !fallback)\n            return;\n        if (env !== "production") {\n            warnOnce(false, "IntersectionObserver not available on this device. whileInView animations will trigger on mount.");\n        }\n        /**\n         * Fire this in an rAF because, at this point, the animation state\n         * won\'t have flushed for the first time and there\'s certain logic in\n         * there that behaves differently on the initial animation.\n         *\n         * This hook should be quite rarely called so setting this in an rAF\n         * is preferred to changing the behaviour of the animation state.\n         */\n        requestAnimationFrame(function () {\n            var _a;\n            state.hasEnteredView = true;\n            var onViewportEnter = visualElement.getProps().onViewportEnter;\n            onViewportEnter === null || onViewportEnter === void 0 ? void 0 : onViewportEnter(null);\n            (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(AnimationType.InView, true);\n        });\n    }, [shouldObserve]);\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/motion/utils/make-renderless-component.mjs\nvar makeRenderlessComponent = function (hook) { return function (props) {\n    hook(props);\n    return null;\n}; };\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/motion/features/gestures.mjs\n\n\n\n\n\n\nvar gestureAnimations = {\n    inView: makeRenderlessComponent(useViewport),\n    tap: makeRenderlessComponent(useTapGesture),\n    focus: makeRenderlessComponent(useFocusGesture),\n    hover: makeRenderlessComponent(useHoverGesture),\n};\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/utils/use-id.mjs\n\n\nvar counter = 0;\nvar incrementId = function () { return counter++; };\nvar useId = function () { return useConstant(incrementId); };\n/**\n * Ideally we\'d use the following code to support React 18 optionally.\n * But this fairly fails in Webpack (otherwise treeshaking wouldn\'t work at all).\n * Need to come up with a different way of figuring this out.\n */\n// export const useId = (React as any).useId\n//     ? (React as any).useId\n//     : () => useConstant(incrementId)\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/components/AnimatePresence/use-presence.mjs\n\n\n\n\n/**\n * When a component is the child of `AnimatePresence`, it can use `usePresence`\n * to access information about whether it\'s still present in the React tree.\n *\n * ```jsx\n * import { usePresence } from "framer-motion"\n *\n * export const Component = () => {\n *   const [isPresent, safeToRemove] = usePresence()\n *\n *   useEffect(() => {\n *     !isPresent && setTimeout(safeToRemove, 1000)\n *   }, [isPresent])\n *\n *   return <div />\n * }\n * ```\n *\n * If `isPresent` is `false`, it means that a component has been removed the tree, but\n * `AnimatePresence` won\'t really remove it until `safeToRemove` has been called.\n *\n * @public\n */\nfunction usePresence() {\n    var context = (0,index_js_.useContext)(PresenceContext);\n    if (context === null)\n        return [true, null];\n    var isPresent = context.isPresent, onExitComplete = context.onExitComplete, register = context.register;\n    // It\'s safe to call the following hooks conditionally (after an early return) because the context will always\n    // either be null or non-null for the lifespan of the component.\n    // Replace with useId when released in React\n    var id = useId();\n    (0,index_js_.useEffect)(function () { return register(id); }, []);\n    var safeToRemove = function () { return onExitComplete === null || onExitComplete === void 0 ? void 0 : onExitComplete(id); };\n    return !isPresent && onExitComplete ? [false, safeToRemove] : [true];\n}\n/**\n * Similar to `usePresence`, except `useIsPresent` simply returns whether or not the component is present.\n * There is no `safeToRemove` function.\n *\n * ```jsx\n * import { useIsPresent } from "framer-motion"\n *\n * export const Component = () => {\n *   const isPresent = useIsPresent()\n *\n *   useEffect(() => {\n *     !isPresent && console.log("I\'ve been removed!")\n *   }, [isPresent])\n *\n *   return <div />\n * }\n * ```\n *\n * @public\n */\nfunction useIsPresent() {\n    return isPresent((0,index_js_.useContext)(PresenceContext));\n}\nfunction isPresent(context) {\n    return context === null ? true : context.isPresent;\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/utils/shallow-compare.mjs\nfunction shallowCompare(next, prev) {\n    if (!Array.isArray(prev))\n        return false;\n    var prevLength = prev.length;\n    if (prevLength !== next.length)\n        return false;\n    for (var i = 0; i < prevLength; i++) {\n        if (prev[i] !== next[i])\n            return false;\n    }\n    return true;\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/popmotion/dist/es/utils/clamp.mjs\nconst clamp_clamp = (min, max, v) => Math.min(Math.max(v, min), max);\n\n\n\n;// CONCATENATED MODULE: ./node_modules/popmotion/dist/es/animations/utils/find-spring.mjs\n\n\n\nconst safeMin = 0.001;\nconst minDuration = 0.01;\nconst maxDuration = 10.0;\nconst minDamping = 0.05;\nconst maxDamping = 1;\nfunction findSpring({ duration = 800, bounce = 0.25, velocity = 0, mass = 1, }) {\n    let envelope;\n    let derivative;\n    warning(duration <= maxDuration * 1000, "Spring duration must be 10 seconds or less");\n    let dampingRatio = 1 - bounce;\n    dampingRatio = clamp_clamp(minDamping, maxDamping, dampingRatio);\n    duration = clamp_clamp(minDuration, maxDuration, duration / 1000);\n    if (dampingRatio < 1) {\n        envelope = (undampedFreq) => {\n            const exponentialDecay = undampedFreq * dampingRatio;\n            const delta = exponentialDecay * duration;\n            const a = exponentialDecay - velocity;\n            const b = calcAngularFreq(undampedFreq, dampingRatio);\n            const c = Math.exp(-delta);\n            return safeMin - (a / b) * c;\n        };\n        derivative = (undampedFreq) => {\n            const exponentialDecay = undampedFreq * dampingRatio;\n            const delta = exponentialDecay * duration;\n            const d = delta * velocity + velocity;\n            const e = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq, 2) * duration;\n            const f = Math.exp(-delta);\n            const g = calcAngularFreq(Math.pow(undampedFreq, 2), dampingRatio);\n            const factor = -envelope(undampedFreq) + safeMin > 0 ? -1 : 1;\n            return (factor * ((d - e) * f)) / g;\n        };\n    }\n    else {\n        envelope = (undampedFreq) => {\n            const a = Math.exp(-undampedFreq * duration);\n            const b = (undampedFreq - velocity) * duration + 1;\n            return -safeMin + a * b;\n        };\n        derivative = (undampedFreq) => {\n            const a = Math.exp(-undampedFreq * duration);\n            const b = (velocity - undampedFreq) * (duration * duration);\n            return a * b;\n        };\n    }\n    const initialGuess = 5 / duration;\n    const undampedFreq = approximateRoot(envelope, derivative, initialGuess);\n    duration = duration * 1000;\n    if (isNaN(undampedFreq)) {\n        return {\n            stiffness: 100,\n            damping: 10,\n            duration,\n        };\n    }\n    else {\n        const stiffness = Math.pow(undampedFreq, 2) * mass;\n        return {\n            stiffness,\n            damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),\n            duration,\n        };\n    }\n}\nconst rootIterations = 12;\nfunction approximateRoot(envelope, derivative, initialGuess) {\n    let result = initialGuess;\n    for (let i = 1; i < rootIterations; i++) {\n        result = result - envelope(result) / derivative(result);\n    }\n    return result;\n}\nfunction calcAngularFreq(undampedFreq, dampingRatio) {\n    return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/popmotion/dist/es/animations/generators/spring.mjs\n\n\n\nconst durationKeys = ["duration", "bounce"];\nconst physicsKeys = ["stiffness", "damping", "mass"];\nfunction isSpringType(options, keys) {\n    return keys.some((key) => options[key] !== undefined);\n}\nfunction getSpringOptions(options) {\n    let springOptions = Object.assign({ velocity: 0.0, stiffness: 100, damping: 10, mass: 1.0, isResolvedFromDuration: false }, options);\n    if (!isSpringType(options, physicsKeys) &&\n        isSpringType(options, durationKeys)) {\n        const derived = findSpring(options);\n        springOptions = Object.assign(Object.assign(Object.assign({}, springOptions), derived), { velocity: 0.0, mass: 1.0 });\n        springOptions.isResolvedFromDuration = true;\n    }\n    return springOptions;\n}\nfunction spring(_a) {\n    var { from = 0.0, to = 1.0, restSpeed = 2, restDelta } = _a, options = __rest(_a, ["from", "to", "restSpeed", "restDelta"]);\n    const state = { done: false, value: from };\n    let { stiffness, damping, mass, velocity, duration, isResolvedFromDuration, } = getSpringOptions(options);\n    let resolveSpring = zero;\n    let resolveVelocity = zero;\n    function createSpring() {\n        const initialVelocity = velocity ? -(velocity / 1000) : 0.0;\n        const initialDelta = to - from;\n        const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));\n        const undampedAngularFreq = Math.sqrt(stiffness / mass) / 1000;\n        if (restDelta === undefined) {\n            restDelta = Math.min(Math.abs(to - from) / 100, 0.4);\n        }\n        if (dampingRatio < 1) {\n            const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);\n            resolveSpring = (t) => {\n                const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n                return (to -\n                    envelope *\n                        (((initialVelocity +\n                            dampingRatio * undampedAngularFreq * initialDelta) /\n                            angularFreq) *\n                            Math.sin(angularFreq * t) +\n                            initialDelta * Math.cos(angularFreq * t)));\n            };\n            resolveVelocity = (t) => {\n                const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n                return (dampingRatio *\n                    undampedAngularFreq *\n                    envelope *\n                    ((Math.sin(angularFreq * t) *\n                        (initialVelocity +\n                            dampingRatio *\n                                undampedAngularFreq *\n                                initialDelta)) /\n                        angularFreq +\n                        initialDelta * Math.cos(angularFreq * t)) -\n                    envelope *\n                        (Math.cos(angularFreq * t) *\n                            (initialVelocity +\n                                dampingRatio *\n                                    undampedAngularFreq *\n                                    initialDelta) -\n                            angularFreq *\n                                initialDelta *\n                                Math.sin(angularFreq * t)));\n            };\n        }\n        else if (dampingRatio === 1) {\n            resolveSpring = (t) => to -\n                Math.exp(-undampedAngularFreq * t) *\n                    (initialDelta +\n                        (initialVelocity + undampedAngularFreq * initialDelta) *\n                            t);\n        }\n        else {\n            const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);\n            resolveSpring = (t) => {\n                const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n                const freqForT = Math.min(dampedAngularFreq * t, 300);\n                return (to -\n                    (envelope *\n                        ((initialVelocity +\n                            dampingRatio * undampedAngularFreq * initialDelta) *\n                            Math.sinh(freqForT) +\n                            dampedAngularFreq *\n                                initialDelta *\n                                Math.cosh(freqForT))) /\n                        dampedAngularFreq);\n            };\n        }\n    }\n    createSpring();\n    return {\n        next: (t) => {\n            const current = resolveSpring(t);\n            if (!isResolvedFromDuration) {\n                const currentVelocity = resolveVelocity(t) * 1000;\n                const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;\n                const isBelowDisplacementThreshold = Math.abs(to - current) <= restDelta;\n                state.done =\n                    isBelowVelocityThreshold && isBelowDisplacementThreshold;\n            }\n            else {\n                state.done = t >= duration;\n            }\n            state.value = state.done ? to : current;\n            return state;\n        },\n        flipTarget: () => {\n            velocity = -velocity;\n            [from, to] = [to, from];\n            createSpring();\n        },\n    };\n}\nspring.needsInterpolation = (a, b) => typeof a === "string" || typeof b === "string";\nconst zero = (_t) => 0;\n\n\n\n;// CONCATENATED MODULE: ./node_modules/popmotion/dist/es/utils/progress.mjs\nconst progress = (from, to, value) => {\n    const toFromDifference = to - from;\n    return toFromDifference === 0 ? 1 : (value - from) / toFromDifference;\n};\n\n\n\n;// CONCATENATED MODULE: ./node_modules/popmotion/dist/es/utils/mix.mjs\nconst mix = (from, to, progress) => -progress * from + progress * to + from;\n\n\n\n;// CONCATENATED MODULE: ./node_modules/style-value-types/dist/es/color/utils.mjs\n\n\nconst isColorString = (type, testProp) => (v) => {\n    return Boolean((isString(v) && singleColorRegex.test(v) && v.startsWith(type)) ||\n        (testProp && Object.prototype.hasOwnProperty.call(v, testProp)));\n};\nconst splitColor = (aName, bName, cName) => (v) => {\n    if (!isString(v))\n        return v;\n    const [a, b, c, alpha] = v.match(floatRegex);\n    return {\n        [aName]: parseFloat(a),\n        [bName]: parseFloat(b),\n        [cName]: parseFloat(c),\n        alpha: alpha !== undefined ? parseFloat(alpha) : 1,\n    };\n};\n\n\n\n;// CONCATENATED MODULE: ./node_modules/style-value-types/dist/es/color/rgba.mjs\n\n\n\n\nconst clampRgbUnit = clamp(0, 255);\nconst rgbUnit = Object.assign(Object.assign({}, number), { transform: (v) => Math.round(clampRgbUnit(v)) });\nconst rgba = {\n    test: isColorString(\'rgb\', \'red\'),\n    parse: splitColor(\'red\', \'green\', \'blue\'),\n    transform: ({ red, green, blue, alpha: alpha$1 = 1 }) => \'rgba(\' +\n        rgbUnit.transform(red) +\n        \', \' +\n        rgbUnit.transform(green) +\n        \', \' +\n        rgbUnit.transform(blue) +\n        \', \' +\n        sanitize(alpha.transform(alpha$1)) +\n        \')\',\n};\n\n\n\n;// CONCATENATED MODULE: ./node_modules/style-value-types/dist/es/color/hex.mjs\n\n\n\nfunction parseHex(v) {\n    let r = \'\';\n    let g = \'\';\n    let b = \'\';\n    let a = \'\';\n    if (v.length > 5) {\n        r = v.substr(1, 2);\n        g = v.substr(3, 2);\n        b = v.substr(5, 2);\n        a = v.substr(7, 2);\n    }\n    else {\n        r = v.substr(1, 1);\n        g = v.substr(2, 1);\n        b = v.substr(3, 1);\n        a = v.substr(4, 1);\n        r += r;\n        g += g;\n        b += b;\n        a += a;\n    }\n    return {\n        red: parseInt(r, 16),\n        green: parseInt(g, 16),\n        blue: parseInt(b, 16),\n        alpha: a ? parseInt(a, 16) / 255 : 1,\n    };\n}\nconst hex = {\n    test: isColorString(\'#\'),\n    parse: parseHex,\n    transform: rgba.transform,\n};\n\n\n\n;// CONCATENATED MODULE: ./node_modules/style-value-types/dist/es/color/hsla.mjs\n\n\n\n\n\nconst hsla = {\n    test: isColorString(\'hsl\', \'hue\'),\n    parse: splitColor(\'hue\', \'saturation\', \'lightness\'),\n    transform: ({ hue, saturation, lightness, alpha: alpha$1 = 1 }) => {\n        return (\'hsla(\' +\n            Math.round(hue) +\n            \', \' +\n            percent.transform(sanitize(saturation)) +\n            \', \' +\n            percent.transform(sanitize(lightness)) +\n            \', \' +\n            sanitize(alpha.transform(alpha$1)) +\n            \')\');\n    },\n};\n\n\n\n;// CONCATENATED MODULE: ./node_modules/popmotion/dist/es/utils/hsla-to-rgba.mjs\nfunction hueToRgb(p, q, t) {\n    if (t < 0)\n        t += 1;\n    if (t > 1)\n        t -= 1;\n    if (t < 1 / 6)\n        return p + (q - p) * 6 * t;\n    if (t < 1 / 2)\n        return q;\n    if (t < 2 / 3)\n        return p + (q - p) * (2 / 3 - t) * 6;\n    return p;\n}\nfunction hslaToRgba({ hue, saturation, lightness, alpha }) {\n    hue /= 360;\n    saturation /= 100;\n    lightness /= 100;\n    let red = 0;\n    let green = 0;\n    let blue = 0;\n    if (!saturation) {\n        red = green = blue = lightness;\n    }\n    else {\n        const q = lightness < 0.5\n            ? lightness * (1 + saturation)\n            : lightness + saturation - lightness * saturation;\n        const p = 2 * lightness - q;\n        red = hueToRgb(p, q, hue + 1 / 3);\n        green = hueToRgb(p, q, hue);\n        blue = hueToRgb(p, q, hue - 1 / 3);\n    }\n    return {\n        red: Math.round(red * 255),\n        green: Math.round(green * 255),\n        blue: Math.round(blue * 255),\n        alpha,\n    };\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/popmotion/dist/es/utils/mix-color.mjs\n\n\n\n\n\nconst mixLinearColor = (from, to, v) => {\n    const fromExpo = from * from;\n    const toExpo = to * to;\n    return Math.sqrt(Math.max(0, v * (toExpo - fromExpo) + fromExpo));\n};\nconst colorTypes = [hex, rgba, hsla];\nconst getColorType = (v) => colorTypes.find((type) => type.test(v));\nconst notAnimatable = (color) => `\'${color}\' is not an animatable color. Use the equivalent color code instead.`;\nconst mixColor = (from, to) => {\n    let fromColorType = getColorType(from);\n    let toColorType = getColorType(to);\n    invariant(!!fromColorType, notAnimatable(from));\n    invariant(!!toColorType, notAnimatable(to));\n    let fromColor = fromColorType.parse(from);\n    let toColor = toColorType.parse(to);\n    if (fromColorType === hsla) {\n        fromColor = hslaToRgba(fromColor);\n        fromColorType = rgba;\n    }\n    if (toColorType === hsla) {\n        toColor = hslaToRgba(toColor);\n        toColorType = rgba;\n    }\n    const blended = Object.assign({}, fromColor);\n    return (v) => {\n        for (const key in blended) {\n            if (key !== "alpha") {\n                blended[key] = mixLinearColor(fromColor[key], toColor[key], v);\n            }\n        }\n        blended.alpha = mix(fromColor.alpha, toColor.alpha, v);\n        return fromColorType.transform(blended);\n    };\n};\n\n\n\n;// CONCATENATED MODULE: ./node_modules/style-value-types/dist/es/color/index.mjs\n\n\n\n\n\nconst color = {\n    test: (v) => rgba.test(v) || hex.test(v) || hsla.test(v),\n    parse: (v) => {\n        if (rgba.test(v)) {\n            return rgba.parse(v);\n        }\n        else if (hsla.test(v)) {\n            return hsla.parse(v);\n        }\n        else {\n            return hex.parse(v);\n        }\n    },\n    transform: (v) => {\n        return isString(v)\n            ? v\n            : v.hasOwnProperty(\'red\')\n                ? rgba.transform(v)\n                : hsla.transform(v);\n    },\n};\n\n\n\n;// CONCATENATED MODULE: ./node_modules/style-value-types/dist/es/complex/index.mjs\n\n\n\n\nconst colorToken = \'${c}\';\nconst numberToken = \'${n}\';\nfunction test(v) {\n    var _a, _b, _c, _d;\n    return (isNaN(v) &&\n        isString(v) &&\n        ((_b = (_a = v.match(floatRegex)) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0) + ((_d = (_c = v.match(colorRegex)) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 0) > 0);\n}\nfunction analyse(v) {\n    if (typeof v === \'number\')\n        v = `${v}`;\n    const values = [];\n    let numColors = 0;\n    const colors = v.match(colorRegex);\n    if (colors) {\n        numColors = colors.length;\n        v = v.replace(colorRegex, colorToken);\n        values.push(...colors.map(color.parse));\n    }\n    const numbers = v.match(floatRegex);\n    if (numbers) {\n        v = v.replace(floatRegex, numberToken);\n        values.push(...numbers.map(number.parse));\n    }\n    return { values, numColors, tokenised: v };\n}\nfunction parse(v) {\n    return analyse(v).values;\n}\nfunction createTransformer(v) {\n    const { values, numColors, tokenised } = analyse(v);\n    const numValues = values.length;\n    return (v) => {\n        let output = tokenised;\n        for (let i = 0; i < numValues; i++) {\n            output = output.replace(i < numColors ? colorToken : numberToken, i < numColors ? color.transform(v[i]) : sanitize(v[i]));\n        }\n        return output;\n    };\n}\nconst convertNumbersToZero = (v) => typeof v === \'number\' ? 0 : v;\nfunction getAnimatableNone(v) {\n    const parsed = parse(v);\n    const transformer = createTransformer(v);\n    return transformer(parsed.map(convertNumbersToZero));\n}\nconst complex = { test, parse, createTransformer, getAnimatableNone };\n\n\n\n;// CONCATENATED MODULE: ./node_modules/popmotion/dist/es/utils/inc.mjs\nconst zeroPoint = {\n    x: 0,\n    y: 0,\n    z: 0\n};\nconst isNum = (v) => typeof v === \'number\';\n\n\n\n;// CONCATENATED MODULE: ./node_modules/popmotion/dist/es/utils/mix-complex.mjs\n\n\n\n\n\n\n\nfunction getMixer(origin, target) {\n    if (isNum(origin)) {\n        return (v) => mix(origin, target, v);\n    }\n    else if (color.test(origin)) {\n        return mixColor(origin, target);\n    }\n    else {\n        return mixComplex(origin, target);\n    }\n}\nconst mixArray = (from, to) => {\n    const output = [...from];\n    const numValues = output.length;\n    const blendValue = from.map((fromThis, i) => getMixer(fromThis, to[i]));\n    return (v) => {\n        for (let i = 0; i < numValues; i++) {\n            output[i] = blendValue[i](v);\n        }\n        return output;\n    };\n};\nconst mixObject = (origin, target) => {\n    const output = Object.assign(Object.assign({}, origin), target);\n    const blendValue = {};\n    for (const key in output) {\n        if (origin[key] !== undefined && target[key] !== undefined) {\n            blendValue[key] = getMixer(origin[key], target[key]);\n        }\n    }\n    return (v) => {\n        for (const key in blendValue) {\n            output[key] = blendValue[key](v);\n        }\n        return output;\n    };\n};\nfunction mix_complex_analyse(value) {\n    const parsed = complex.parse(value);\n    const numValues = parsed.length;\n    let numNumbers = 0;\n    let numRGB = 0;\n    let numHSL = 0;\n    for (let i = 0; i < numValues; i++) {\n        if (numNumbers || typeof parsed[i] === "number") {\n            numNumbers++;\n        }\n        else {\n            if (parsed[i].hue !== undefined) {\n                numHSL++;\n            }\n            else {\n                numRGB++;\n            }\n        }\n    }\n    return { parsed, numNumbers, numRGB, numHSL };\n}\nconst mixComplex = (origin, target) => {\n    const template = complex.createTransformer(target);\n    const originStats = mix_complex_analyse(origin);\n    const targetStats = mix_complex_analyse(target);\n    const canInterpolate = originStats.numHSL === targetStats.numHSL &&\n        originStats.numRGB === targetStats.numRGB &&\n        originStats.numNumbers >= targetStats.numNumbers;\n    if (canInterpolate) {\n        return pipe(mixArray(originStats.parsed, targetStats.parsed), template);\n    }\n    else {\n        warning(true, `Complex values \'${origin}\' and \'${target}\' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`);\n        return (p) => `${p > 0 ? target : origin}`;\n    }\n};\n\n\n\n;// CONCATENATED MODULE: ./node_modules/popmotion/dist/es/utils/interpolate.mjs\n\n\n\n\n\n\n\n\n\nconst mixNumber = (from, to) => (p) => mix(from, to, p);\nfunction detectMixerFactory(v) {\n    if (typeof v === \'number\') {\n        return mixNumber;\n    }\n    else if (typeof v === \'string\') {\n        if (color.test(v)) {\n            return mixColor;\n        }\n        else {\n            return mixComplex;\n        }\n    }\n    else if (Array.isArray(v)) {\n        return mixArray;\n    }\n    else if (typeof v === \'object\') {\n        return mixObject;\n    }\n}\nfunction createMixers(output, ease, customMixer) {\n    const mixers = [];\n    const mixerFactory = customMixer || detectMixerFactory(output[0]);\n    const numMixers = output.length - 1;\n    for (let i = 0; i < numMixers; i++) {\n        let mixer = mixerFactory(output[i], output[i + 1]);\n        if (ease) {\n            const easingFunction = Array.isArray(ease) ? ease[i] : ease;\n            mixer = pipe(easingFunction, mixer);\n        }\n        mixers.push(mixer);\n    }\n    return mixers;\n}\nfunction fastInterpolate([from, to], [mixer]) {\n    return (v) => mixer(progress(from, to, v));\n}\nfunction slowInterpolate(input, mixers) {\n    const inputLength = input.length;\n    const lastInputIndex = inputLength - 1;\n    return (v) => {\n        let mixerIndex = 0;\n        let foundMixerIndex = false;\n        if (v <= input[0]) {\n            foundMixerIndex = true;\n        }\n        else if (v >= input[lastInputIndex]) {\n            mixerIndex = lastInputIndex - 1;\n            foundMixerIndex = true;\n        }\n        if (!foundMixerIndex) {\n            let i = 1;\n            for (; i < inputLength; i++) {\n                if (input[i] > v || i === lastInputIndex) {\n                    break;\n                }\n            }\n            mixerIndex = i - 1;\n        }\n        const progressInRange = progress(input[mixerIndex], input[mixerIndex + 1], v);\n        return mixers[mixerIndex](progressInRange);\n    };\n}\nfunction interpolate(input, output, { clamp: isClamp = true, ease, mixer } = {}) {\n    const inputLength = input.length;\n    invariant(inputLength === output.length, \'Both input and output ranges must be the same length\');\n    invariant(!ease || !Array.isArray(ease) || ease.length === inputLength - 1, \'Array of easing functions must be of length `input.length - 1`, as it applies to the transitions **between** the defined values.\');\n    if (input[0] > input[inputLength - 1]) {\n        input = [].concat(input);\n        output = [].concat(output);\n        input.reverse();\n        output.reverse();\n    }\n    const mixers = createMixers(output, ease, mixer);\n    const interpolator = inputLength === 2\n        ? fastInterpolate(input, mixers)\n        : slowInterpolate(input, mixers);\n    return isClamp\n        ? (v) => interpolator(clamp_clamp(input[0], input[inputLength - 1], v))\n        : interpolator;\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/popmotion/dist/es/easing/utils.mjs\nconst reverseEasing = easing => p => 1 - easing(1 - p);\nconst mirrorEasing = easing => p => p <= 0.5 ? easing(2 * p) / 2 : (2 - easing(2 * (1 - p))) / 2;\nconst createExpoIn = (power) => p => Math.pow(p, power);\nconst createBackIn = (power) => p => p * p * ((power + 1) * p - power);\nconst createAnticipate = (power) => {\n    const backEasing = createBackIn(power);\n    return p => (p *= 2) < 1\n        ? 0.5 * backEasing(p)\n        : 0.5 * (2 - Math.pow(2, -10 * (p - 1)));\n};\n\n\n\n;// CONCATENATED MODULE: ./node_modules/popmotion/dist/es/easing/index.mjs\n\n\nconst DEFAULT_OVERSHOOT_STRENGTH = 1.525;\nconst BOUNCE_FIRST_THRESHOLD = 4.0 / 11.0;\nconst BOUNCE_SECOND_THRESHOLD = 8.0 / 11.0;\nconst BOUNCE_THIRD_THRESHOLD = 9.0 / 10.0;\nconst linear = p => p;\nconst easeIn = createExpoIn(2);\nconst easeOut = reverseEasing(easeIn);\nconst easeInOut = mirrorEasing(easeIn);\nconst circIn = p => 1 - Math.sin(Math.acos(p));\nconst circOut = reverseEasing(circIn);\nconst circInOut = mirrorEasing(circOut);\nconst backIn = createBackIn(DEFAULT_OVERSHOOT_STRENGTH);\nconst backOut = reverseEasing(backIn);\nconst backInOut = mirrorEasing(backIn);\nconst anticipate = createAnticipate(DEFAULT_OVERSHOOT_STRENGTH);\nconst ca = 4356.0 / 361.0;\nconst cb = 35442.0 / 1805.0;\nconst cc = 16061.0 / 1805.0;\nconst bounceOut = (p) => {\n    if (p === 1 || p === 0)\n        return p;\n    const p2 = p * p;\n    return p < BOUNCE_FIRST_THRESHOLD\n        ? 7.5625 * p2\n        : p < BOUNCE_SECOND_THRESHOLD\n            ? 9.075 * p2 - 9.9 * p + 3.4\n            : p < BOUNCE_THIRD_THRESHOLD\n                ? ca * p2 - cb * p + cc\n                : 10.8 * p * p - 20.52 * p + 10.72;\n};\nconst bounceIn = reverseEasing(bounceOut);\nconst bounceInOut = (p) => p < 0.5\n    ? 0.5 * (1.0 - bounceOut(1.0 - p * 2.0))\n    : 0.5 * bounceOut(p * 2.0 - 1.0) + 0.5;\n\n\n\n;// CONCATENATED MODULE: ./node_modules/popmotion/dist/es/animations/generators/keyframes.mjs\n\n\n\nfunction defaultEasing(values, easing) {\n    return values.map(() => easing || easeInOut).splice(0, values.length - 1);\n}\nfunction defaultOffset(values) {\n    const numValues = values.length;\n    return values.map((_value, i) => i !== 0 ? i / (numValues - 1) : 0);\n}\nfunction convertOffsetToTimes(offset, duration) {\n    return offset.map((o) => o * duration);\n}\nfunction keyframes({ from = 0, to = 1, ease, offset, duration = 300, }) {\n    const state = { done: false, value: from };\n    const values = Array.isArray(to) ? to : [from, to];\n    const times = convertOffsetToTimes(offset && offset.length === values.length\n        ? offset\n        : defaultOffset(values), duration);\n    function createInterpolator() {\n        return interpolate(times, values, {\n            ease: Array.isArray(ease) ? ease : defaultEasing(values, ease),\n        });\n    }\n    let interpolator = createInterpolator();\n    return {\n        next: (t) => {\n            state.value = interpolator(t);\n            state.done = t >= duration;\n            return state;\n        },\n        flipTarget: () => {\n            values.reverse();\n            interpolator = createInterpolator();\n        },\n    };\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/popmotion/dist/es/animations/generators/decay.mjs\nfunction decay({ velocity = 0, from = 0, power = 0.8, timeConstant = 350, restDelta = 0.5, modifyTarget, }) {\n    const state = { done: false, value: from };\n    let amplitude = power * velocity;\n    const ideal = from + amplitude;\n    const target = modifyTarget === undefined ? ideal : modifyTarget(ideal);\n    if (target !== ideal)\n        amplitude = target - from;\n    return {\n        next: (t) => {\n            const delta = -amplitude * Math.exp(-t / timeConstant);\n            state.done = !(delta > restDelta || delta < -restDelta);\n            state.value = state.done ? target : target + delta;\n            return state;\n        },\n        flipTarget: () => { },\n    };\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/popmotion/dist/es/animations/utils/detect-animation-from-options.mjs\n\n\n\n\nconst types = { keyframes: keyframes, spring: spring, decay: decay };\nfunction detectAnimationFromOptions(config) {\n    if (Array.isArray(config.to)) {\n        return keyframes;\n    }\n    else if (types[config.type]) {\n        return types[config.type];\n    }\n    const keys = new Set(Object.keys(config));\n    if (keys.has("ease") ||\n        (keys.has("duration") && !keys.has("dampingRatio"))) {\n        return keyframes;\n    }\n    else if (keys.has("dampingRatio") ||\n        keys.has("stiffness") ||\n        keys.has("mass") ||\n        keys.has("damping") ||\n        keys.has("restSpeed") ||\n        keys.has("restDelta")) {\n        return spring;\n    }\n    return keyframes;\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framesync/dist/es/on-next-frame.mjs\nconst defaultTimestep = (1 / 60) * 1000;\nconst getCurrentTime = typeof performance !== "undefined"\n    ? () => performance.now()\n    : () => Date.now();\nconst onNextFrame = typeof window !== "undefined"\n    ? (callback) => window.requestAnimationFrame(callback)\n    : (callback) => setTimeout(() => callback(getCurrentTime()), defaultTimestep);\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framesync/dist/es/create-render-step.mjs\nfunction createRenderStep(runNextFrame) {\n    let toRun = [];\n    let toRunNextFrame = [];\n    let numToRun = 0;\n    let isProcessing = false;\n    let flushNextFrame = false;\n    const toKeepAlive = new WeakSet();\n    const step = {\n        schedule: (callback, keepAlive = false, immediate = false) => {\n            const addToCurrentFrame = immediate && isProcessing;\n            const buffer = addToCurrentFrame ? toRun : toRunNextFrame;\n            if (keepAlive)\n                toKeepAlive.add(callback);\n            if (buffer.indexOf(callback) === -1) {\n                buffer.push(callback);\n                if (addToCurrentFrame && isProcessing)\n                    numToRun = toRun.length;\n            }\n            return callback;\n        },\n        cancel: (callback) => {\n            const index = toRunNextFrame.indexOf(callback);\n            if (index !== -1)\n                toRunNextFrame.splice(index, 1);\n            toKeepAlive.delete(callback);\n        },\n        process: (frameData) => {\n            if (isProcessing) {\n                flushNextFrame = true;\n                return;\n            }\n            isProcessing = true;\n            [toRun, toRunNextFrame] = [toRunNextFrame, toRun];\n            toRunNextFrame.length = 0;\n            numToRun = toRun.length;\n            if (numToRun) {\n                for (let i = 0; i < numToRun; i++) {\n                    const callback = toRun[i];\n                    callback(frameData);\n                    if (toKeepAlive.has(callback)) {\n                        step.schedule(callback);\n                        runNextFrame();\n                    }\n                }\n            }\n            isProcessing = false;\n            if (flushNextFrame) {\n                flushNextFrame = false;\n                step.process(frameData);\n            }\n        },\n    };\n    return step;\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framesync/dist/es/index.mjs\n\n\n\nconst maxElapsed = 40;\nlet useDefaultElapsed = true;\nlet runNextFrame = false;\nlet isProcessing = false;\nconst es_frame = {\n    delta: 0,\n    timestamp: 0,\n};\nconst stepsOrder = [\n    "read",\n    "update",\n    "preRender",\n    "render",\n    "postRender",\n];\nconst steps = stepsOrder.reduce((acc, key) => {\n    acc[key] = createRenderStep(() => (runNextFrame = true));\n    return acc;\n}, {});\nconst sync = stepsOrder.reduce((acc, key) => {\n    const step = steps[key];\n    acc[key] = (process, keepAlive = false, immediate = false) => {\n        if (!runNextFrame)\n            startLoop();\n        return step.schedule(process, keepAlive, immediate);\n    };\n    return acc;\n}, {});\nconst cancelSync = stepsOrder.reduce((acc, key) => {\n    acc[key] = steps[key].cancel;\n    return acc;\n}, {});\nconst flushSync = stepsOrder.reduce((acc, key) => {\n    acc[key] = () => steps[key].process(es_frame);\n    return acc;\n}, {});\nconst processStep = (stepId) => steps[stepId].process(es_frame);\nconst processFrame = (timestamp) => {\n    runNextFrame = false;\n    es_frame.delta = useDefaultElapsed\n        ? defaultTimestep\n        : Math.max(Math.min(timestamp - es_frame.timestamp, maxElapsed), 1);\n    es_frame.timestamp = timestamp;\n    isProcessing = true;\n    stepsOrder.forEach(processStep);\n    isProcessing = false;\n    if (runNextFrame) {\n        useDefaultElapsed = false;\n        onNextFrame(processFrame);\n    }\n};\nconst startLoop = () => {\n    runNextFrame = true;\n    useDefaultElapsed = true;\n    if (!isProcessing)\n        onNextFrame(processFrame);\n};\nconst getFrameData = () => es_frame;\n\n/* harmony default export */ var es = (sync);\n\n\n;// CONCATENATED MODULE: ./node_modules/popmotion/dist/es/animations/utils/elapsed.mjs\nfunction loopElapsed(elapsed, duration, delay = 0) {\n    return elapsed - duration - delay;\n}\nfunction reverseElapsed(elapsed, duration, delay = 0, isForwardPlayback = true) {\n    return isForwardPlayback\n        ? loopElapsed(duration + -elapsed, duration, delay)\n        : duration - (elapsed - duration) + delay;\n}\nfunction hasRepeatDelayElapsed(elapsed, duration, delay, isForwardPlayback) {\n    return isForwardPlayback ? elapsed >= duration + delay : elapsed <= -delay;\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/popmotion/dist/es/animations/index.mjs\n\n\n\n\n\n\nconst framesync = (update) => {\n    const passTimestamp = ({ delta }) => update(delta);\n    return {\n        start: () => es.update(passTimestamp, true),\n        stop: () => cancelSync.update(passTimestamp),\n    };\n};\nfunction animate(_a) {\n    var _b, _c;\n    var { from, autoplay = true, driver = framesync, elapsed = 0, repeat: repeatMax = 0, repeatType = "loop", repeatDelay = 0, onPlay, onStop, onComplete, onRepeat, onUpdate } = _a, options = __rest(_a, ["from", "autoplay", "driver", "elapsed", "repeat", "repeatType", "repeatDelay", "onPlay", "onStop", "onComplete", "onRepeat", "onUpdate"]);\n    let { to } = options;\n    let driverControls;\n    let repeatCount = 0;\n    let computedDuration = options.duration;\n    let latest;\n    let isComplete = false;\n    let isForwardPlayback = true;\n    let interpolateFromNumber;\n    const animator = detectAnimationFromOptions(options);\n    if ((_c = (_b = animator).needsInterpolation) === null || _c === void 0 ? void 0 : _c.call(_b, from, to)) {\n        interpolateFromNumber = interpolate([0, 100], [from, to], {\n            clamp: false,\n        });\n        from = 0;\n        to = 100;\n    }\n    const animation = animator(Object.assign(Object.assign({}, options), { from, to }));\n    function repeat() {\n        repeatCount++;\n        if (repeatType === "reverse") {\n            isForwardPlayback = repeatCount % 2 === 0;\n            elapsed = reverseElapsed(elapsed, computedDuration, repeatDelay, isForwardPlayback);\n        }\n        else {\n            elapsed = loopElapsed(elapsed, computedDuration, repeatDelay);\n            if (repeatType === "mirror")\n                animation.flipTarget();\n        }\n        isComplete = false;\n        onRepeat && onRepeat();\n    }\n    function complete() {\n        driverControls.stop();\n        onComplete && onComplete();\n    }\n    function update(delta) {\n        if (!isForwardPlayback)\n            delta = -delta;\n        elapsed += delta;\n        if (!isComplete) {\n            const state = animation.next(Math.max(0, elapsed));\n            latest = state.value;\n            if (interpolateFromNumber)\n                latest = interpolateFromNumber(latest);\n            isComplete = isForwardPlayback ? state.done : elapsed <= 0;\n        }\n        onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate(latest);\n        if (isComplete) {\n            if (repeatCount === 0)\n                computedDuration !== null && computedDuration !== void 0 ? computedDuration : (computedDuration = elapsed);\n            if (repeatCount < repeatMax) {\n                hasRepeatDelayElapsed(elapsed, computedDuration, repeatDelay, isForwardPlayback) && repeat();\n            }\n            else {\n                complete();\n            }\n        }\n    }\n    function play() {\n        onPlay === null || onPlay === void 0 ? void 0 : onPlay();\n        driverControls = driver(update);\n        driverControls.start();\n    }\n    autoplay && play();\n    return {\n        stop: () => {\n            onStop === null || onStop === void 0 ? void 0 : onStop();\n            driverControls.stop();\n        },\n    };\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/popmotion/dist/es/utils/velocity-per-second.mjs\nfunction velocityPerSecond(velocity, frameDuration) {\n    return frameDuration ? velocity * (1000 / frameDuration) : 0;\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/popmotion/dist/es/animations/inertia.mjs\n\n\n\n\nfunction inertia({ from = 0, velocity = 0, min, max, power = 0.8, timeConstant = 750, bounceStiffness = 500, bounceDamping = 10, restDelta = 1, modifyTarget, driver, onUpdate, onComplete, onStop, }) {\n    let currentAnimation;\n    function isOutOfBounds(v) {\n        return (min !== undefined && v < min) || (max !== undefined && v > max);\n    }\n    function boundaryNearest(v) {\n        if (min === undefined)\n            return max;\n        if (max === undefined)\n            return min;\n        return Math.abs(min - v) < Math.abs(max - v) ? min : max;\n    }\n    function startAnimation(options) {\n        currentAnimation === null || currentAnimation === void 0 ? void 0 : currentAnimation.stop();\n        currentAnimation = animate(Object.assign(Object.assign({}, options), { driver, onUpdate: (v) => {\n                var _a;\n                onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate(v);\n                (_a = options.onUpdate) === null || _a === void 0 ? void 0 : _a.call(options, v);\n            }, onComplete,\n            onStop }));\n    }\n    function startSpring(options) {\n        startAnimation(Object.assign({ type: "spring", stiffness: bounceStiffness, damping: bounceDamping, restDelta }, options));\n    }\n    if (isOutOfBounds(from)) {\n        startSpring({ from, velocity, to: boundaryNearest(from) });\n    }\n    else {\n        let target = power * velocity + from;\n        if (typeof modifyTarget !== "undefined")\n            target = modifyTarget(target);\n        const boundary = boundaryNearest(target);\n        const heading = boundary === min ? -1 : 1;\n        let prev;\n        let current;\n        const checkBoundary = (v) => {\n            prev = current;\n            current = v;\n            velocity = velocityPerSecond(v - prev, getFrameData().delta);\n            if ((heading === 1 && v > boundary) ||\n                (heading === -1 && v < boundary)) {\n                startSpring({ from: v, to: boundary, velocity });\n            }\n        };\n        startAnimation({\n            type: "decay",\n            from,\n            velocity,\n            timeConstant,\n            power,\n            restDelta,\n            modifyTarget,\n            onUpdate: isOutOfBounds(target) ? checkBoundary : undefined,\n        });\n    }\n    return {\n        stop: () => currentAnimation === null || currentAnimation === void 0 ? void 0 : currentAnimation.stop(),\n    };\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/utils/time-conversion.mjs\n/**\n * Converts seconds to milliseconds\n *\n * @param seconds - Time in seconds.\n * @return milliseconds - Converted time in milliseconds.\n */\nvar secondsToMilliseconds = function (seconds) { return seconds * 1000; };\n\n\n\n;// CONCATENATED MODULE: ./node_modules/popmotion/dist/es/easing/cubic-bezier.mjs\n\n\nconst a = (a1, a2) => 1.0 - 3.0 * a2 + 3.0 * a1;\nconst b = (a1, a2) => 3.0 * a2 - 6.0 * a1;\nconst c = (a1) => 3.0 * a1;\nconst calcBezier = (t, a1, a2) => ((a(a1, a2) * t + b(a1, a2)) * t + c(a1)) * t;\nconst getSlope = (t, a1, a2) => 3.0 * a(a1, a2) * t * t + 2.0 * b(a1, a2) * t + c(a1);\nconst subdivisionPrecision = 0.0000001;\nconst subdivisionMaxIterations = 10;\nfunction binarySubdivide(aX, aA, aB, mX1, mX2) {\n    let currentX;\n    let currentT;\n    let i = 0;\n    do {\n        currentT = aA + (aB - aA) / 2.0;\n        currentX = calcBezier(currentT, mX1, mX2) - aX;\n        if (currentX > 0.0) {\n            aB = currentT;\n        }\n        else {\n            aA = currentT;\n        }\n    } while (Math.abs(currentX) > subdivisionPrecision &&\n        ++i < subdivisionMaxIterations);\n    return currentT;\n}\nconst newtonIterations = 8;\nconst newtonMinSlope = 0.001;\nfunction newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {\n    for (let i = 0; i < newtonIterations; ++i) {\n        const currentSlope = getSlope(aGuessT, mX1, mX2);\n        if (currentSlope === 0.0) {\n            return aGuessT;\n        }\n        const currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n        aGuessT -= currentX / currentSlope;\n    }\n    return aGuessT;\n}\nconst kSplineTableSize = 11;\nconst kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);\nfunction cubicBezier(mX1, mY1, mX2, mY2) {\n    if (mX1 === mY1 && mX2 === mY2)\n        return linear;\n    const sampleValues = new Float32Array(kSplineTableSize);\n    for (let i = 0; i < kSplineTableSize; ++i) {\n        sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);\n    }\n    function getTForX(aX) {\n        let intervalStart = 0.0;\n        let currentSample = 1;\n        const lastSample = kSplineTableSize - 1;\n        for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {\n            intervalStart += kSampleStepSize;\n        }\n        --currentSample;\n        const dist = (aX - sampleValues[currentSample]) /\n            (sampleValues[currentSample + 1] - sampleValues[currentSample]);\n        const guessForT = intervalStart + dist * kSampleStepSize;\n        const initialSlope = getSlope(guessForT, mX1, mX2);\n        if (initialSlope >= newtonMinSlope) {\n            return newtonRaphsonIterate(aX, guessForT, mX1, mX2);\n        }\n        else if (initialSlope === 0.0) {\n            return guessForT;\n        }\n        else {\n            return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);\n        }\n    }\n    return (t) => t === 0 || t === 1 ? t : calcBezier(getTForX(t), mY1, mY2);\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/animation/utils/easing.mjs\n\n\n\n\nvar easingLookup = {\n    linear: linear,\n    easeIn: easeIn,\n    easeInOut: easeInOut,\n    easeOut: easeOut,\n    circIn: circIn,\n    circInOut: circInOut,\n    circOut: circOut,\n    backIn: backIn,\n    backInOut: backInOut,\n    backOut: backOut,\n    anticipate: anticipate,\n    bounceIn: bounceIn,\n    bounceInOut: bounceInOut,\n    bounceOut: bounceOut,\n};\nvar easingDefinitionToFunction = function (definition) {\n    if (Array.isArray(definition)) {\n        // If cubic bezier definition, create bezier curve\n        invariant(definition.length === 4, "Cubic bezier arrays must contain four numerical values.");\n        var _a = __read(definition, 4), x1 = _a[0], y1 = _a[1], x2 = _a[2], y2 = _a[3];\n        return cubicBezier(x1, y1, x2, y2);\n    }\n    else if (typeof definition === "string") {\n        // Else lookup from table\n        invariant(easingLookup[definition] !== undefined, "Invalid easing type \'".concat(definition, "\'"));\n        return easingLookup[definition];\n    }\n    return definition;\n};\nvar isEasingArray = function (ease) {\n    return Array.isArray(ease) && typeof ease[0] !== "number";\n};\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/animation/utils/is-animatable.mjs\n\n\n/**\n * Check if a value is animatable. Examples:\n *\n * : 100, "100px", "#fff"\n * : "block", "url(2.jpg)"\n * @param value\n *\n * @internal\n */\nvar isAnimatable = function (key, value) {\n    // If the list of keys tat might be non-animatable grows, replace with Set\n    if (key === "zIndex")\n        return false;\n    // If it\'s a number or a keyframes array, we can animate it. We might at some point\n    // need to do a deep isAnimatable check of keyframes, or let Popmotion handle this,\n    // but for now lets leave it like this for performance reasons\n    if (typeof value === "number" || Array.isArray(value))\n        return true;\n    if (typeof value === "string" && // It\'s animatable if we have a string\n        complex.test(value) && // And it contains numbers and/or colors\n        !value.startsWith("url(") // Unless it starts with "url("\n    ) {\n        return true;\n    }\n    return false;\n};\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/animation/utils/default-transitions.mjs\n\n\n\nvar underDampedSpring = function () { return ({\n    type: "spring",\n    stiffness: 500,\n    damping: 25,\n    restSpeed: 10,\n}); };\nvar criticallyDampedSpring = function (to) { return ({\n    type: "spring",\n    stiffness: 550,\n    damping: to === 0 ? 2 * Math.sqrt(550) : 30,\n    restSpeed: 10,\n}); };\nvar linearTween = function () { return ({\n    type: "keyframes",\n    ease: "linear",\n    duration: 0.3,\n}); };\nvar default_transitions_keyframes = function (values) { return ({\n    type: "keyframes",\n    duration: 0.8,\n    values: values,\n}); };\nvar defaultTransitions = {\n    x: underDampedSpring,\n    y: underDampedSpring,\n    z: underDampedSpring,\n    rotate: underDampedSpring,\n    rotateX: underDampedSpring,\n    rotateY: underDampedSpring,\n    rotateZ: underDampedSpring,\n    scaleX: criticallyDampedSpring,\n    scaleY: criticallyDampedSpring,\n    scale: criticallyDampedSpring,\n    opacity: linearTween,\n    backgroundColor: linearTween,\n    color: linearTween,\n    default: criticallyDampedSpring,\n};\nvar getDefaultTransition = function (valueKey, to) {\n    var transitionFactory;\n    if (isKeyframesTarget(to)) {\n        transitionFactory = default_transitions_keyframes;\n    }\n    else {\n        transitionFactory =\n            defaultTransitions[valueKey] || defaultTransitions.default;\n    }\n    return __assign({ to: to }, transitionFactory(to));\n};\n\n\n\n;// CONCATENATED MODULE: ./node_modules/style-value-types/dist/es/complex/filter.mjs\n\n\n\nconst maxDefaults = new Set([\'brightness\', \'contrast\', \'saturate\', \'opacity\']);\nfunction applyDefaultFilter(v) {\n    let [name, value] = v.slice(0, -1).split(\'(\');\n    if (name === \'drop-shadow\')\n        return v;\n    const [number] = value.match(floatRegex) || [];\n    if (!number)\n        return v;\n    const unit = value.replace(number, \'\');\n    let defaultValue = maxDefaults.has(name) ? 1 : 0;\n    if (number !== value)\n        defaultValue *= 100;\n    return name + \'(\' + defaultValue + unit + \')\';\n}\nconst functionRegex = /([a-z-]*)\\(.*?\\)/g;\nconst filter = Object.assign(Object.assign({}, complex), { getAnimatableNone: (v) => {\n        const functions = v.match(functionRegex);\n        return functions ? functions.map(applyDefaultFilter).join(\' \') : v;\n    } });\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/render/dom/value-types/defaults.mjs\n\n\n\n\n/**\n * A map of default value types for common values\n */\nvar defaultValueTypes = __assign(__assign({}, numberValueTypes), { \n    // Color props\n    color: color, backgroundColor: color, outlineColor: color, fill: color, stroke: color, \n    // Border props\n    borderColor: color, borderTopColor: color, borderRightColor: color, borderBottomColor: color, borderLeftColor: color, filter: filter, WebkitFilter: filter });\n/**\n * Gets the default ValueType for the provided value key\n */\nvar getDefaultValueType = function (key) { return defaultValueTypes[key]; };\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/render/dom/value-types/animatable-none.mjs\n\n\n\nfunction animatable_none_getAnimatableNone(key, value) {\n    var _a;\n    var defaultValueType = getDefaultValueType(key);\n    if (defaultValueType !== filter)\n        defaultValueType = complex;\n    // If value is not recognised as animatable, ie "none", create an animatable version origin based on the target\n    return (_a = defaultValueType.getAnimatableNone) === null || _a === void 0 ? void 0 : _a.call(defaultValueType, value);\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/utils/use-instant-transition-state.mjs\nvar instantAnimationState = {\n    current: false,\n};\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/animation/utils/transitions.mjs\n\n\n\n\n\n\n\n\n\n\n\n/**\n * Decide whether a transition is defined on a given Transition.\n * This filters out orchestration options and returns true\n * if any options are left.\n */\nfunction isTransitionDefined(_a) {\n    _a.when; _a.delay; _a.delayChildren; _a.staggerChildren; _a.staggerDirection; _a.repeat; _a.repeatType; _a.repeatDelay; _a.from; var transition = __rest(_a, ["when", "delay", "delayChildren", "staggerChildren", "staggerDirection", "repeat", "repeatType", "repeatDelay", "from"]);\n    return !!Object.keys(transition).length;\n}\nvar legacyRepeatWarning = false;\n/**\n * Convert Framer Motion\'s Transition type into Popmotion-compatible options.\n */\nfunction convertTransitionToAnimationOptions(_a) {\n    var ease = _a.ease, times = _a.times, yoyo = _a.yoyo, flip = _a.flip, loop = _a.loop, transition = __rest(_a, ["ease", "times", "yoyo", "flip", "loop"]);\n    var options = __assign({}, transition);\n    if (times)\n        options["offset"] = times;\n    /**\n     * Convert any existing durations from seconds to milliseconds\n     */\n    if (transition.duration)\n        options["duration"] = secondsToMilliseconds(transition.duration);\n    if (transition.repeatDelay)\n        options.repeatDelay = secondsToMilliseconds(transition.repeatDelay);\n    /**\n     * Map easing names to Popmotion\'s easing functions\n     */\n    if (ease) {\n        options["ease"] = isEasingArray(ease)\n            ? ease.map(easingDefinitionToFunction)\n            : easingDefinitionToFunction(ease);\n    }\n    /**\n     * Support legacy transition API\n     */\n    if (transition.type === "tween")\n        options.type = "keyframes";\n    /**\n     * TODO: These options are officially removed from the API.\n     */\n    if (yoyo || loop || flip) {\n        warning(!legacyRepeatWarning, "yoyo, loop and flip have been removed from the API. Replace with repeat and repeatType options.");\n        legacyRepeatWarning = true;\n        if (yoyo) {\n            options.repeatType = "reverse";\n        }\n        else if (loop) {\n            options.repeatType = "loop";\n        }\n        else if (flip) {\n            options.repeatType = "mirror";\n        }\n        options.repeat = loop || yoyo || flip || transition.repeat;\n    }\n    /**\n     * TODO: Popmotion 9 has the ability to automatically detect whether to use\n     * a keyframes or spring animation, but does so by detecting velocity and other spring options.\n     * It\'d be good to introduce a similar thing here.\n     */\n    if (transition.type !== "spring")\n        options.type = "keyframes";\n    return options;\n}\n/**\n * Get the delay for a value by checking Transition with decreasing specificity.\n */\nfunction getDelayFromTransition(transition, key) {\n    var _a, _b;\n    var valueTransition = getValueTransition(transition, key) || {};\n    return (_b = (_a = valueTransition.delay) !== null && _a !== void 0 ? _a : transition.delay) !== null && _b !== void 0 ? _b : 0;\n}\nfunction hydrateKeyframes(options) {\n    if (Array.isArray(options.to) && options.to[0] === null) {\n        options.to = __spreadArray([], __read(options.to), false);\n        options.to[0] = options.from;\n    }\n    return options;\n}\nfunction getPopmotionAnimationOptions(transition, options, key) {\n    var _a;\n    if (Array.isArray(options.to)) {\n        (_a = transition.duration) !== null && _a !== void 0 ? _a : (transition.duration = 0.8);\n    }\n    hydrateKeyframes(options);\n    /**\n     * Get a default transition if none is determined to be defined.\n     */\n    if (!isTransitionDefined(transition)) {\n        transition = __assign(__assign({}, transition), getDefaultTransition(key, options.to));\n    }\n    return __assign(__assign({}, options), convertTransitionToAnimationOptions(transition));\n}\n/**\n *\n */\nfunction getAnimation(key, value, target, transition, onComplete) {\n    var _a;\n    var valueTransition = getValueTransition(transition, key);\n    var origin = (_a = valueTransition.from) !== null && _a !== void 0 ? _a : value.get();\n    var isTargetAnimatable = isAnimatable(key, target);\n    if (origin === "none" && isTargetAnimatable && typeof target === "string") {\n        /**\n         * If we\'re trying to animate from "none", try and get an animatable version\n         * of the target. This could be improved to work both ways.\n         */\n        origin = animatable_none_getAnimatableNone(key, target);\n    }\n    else if (isZero(origin) && typeof target === "string") {\n        origin = getZeroUnit(target);\n    }\n    else if (!Array.isArray(target) &&\n        isZero(target) &&\n        typeof origin === "string") {\n        target = getZeroUnit(origin);\n    }\n    var isOriginAnimatable = isAnimatable(key, origin);\n    warning(isOriginAnimatable === isTargetAnimatable, "You are trying to animate ".concat(key, " from \\"").concat(origin, "\\" to \\"").concat(target, "\\". ").concat(origin, " is not an animatable value - to enable this animation set ").concat(origin, " to a value animatable to ").concat(target, " via the `style` property."));\n    function start() {\n        var options = {\n            from: origin,\n            to: target,\n            velocity: value.getVelocity(),\n            onComplete: onComplete,\n            onUpdate: function (v) { return value.set(v); },\n        };\n        return valueTransition.type === "inertia" ||\n            valueTransition.type === "decay"\n            ? inertia(__assign(__assign({}, options), valueTransition))\n            : animate(__assign(__assign({}, getPopmotionAnimationOptions(valueTransition, options, key)), { onUpdate: function (v) {\n                    var _a;\n                    options.onUpdate(v);\n                    (_a = valueTransition.onUpdate) === null || _a === void 0 ? void 0 : _a.call(valueTransition, v);\n                }, onComplete: function () {\n                    var _a;\n                    options.onComplete();\n                    (_a = valueTransition.onComplete) === null || _a === void 0 ? void 0 : _a.call(valueTransition);\n                } }));\n    }\n    function set() {\n        var _a, _b;\n        var finalTarget = resolveFinalValueInKeyframes(target);\n        value.set(finalTarget);\n        onComplete();\n        (_a = valueTransition === null || valueTransition === void 0 ? void 0 : valueTransition.onUpdate) === null || _a === void 0 ? void 0 : _a.call(valueTransition, finalTarget);\n        (_b = valueTransition === null || valueTransition === void 0 ? void 0 : valueTransition.onComplete) === null || _b === void 0 ? void 0 : _b.call(valueTransition);\n        return { stop: function () { } };\n    }\n    return !isOriginAnimatable ||\n        !isTargetAnimatable ||\n        valueTransition.type === false\n        ? set\n        : start;\n}\nfunction isZero(value) {\n    return (value === 0 ||\n        (typeof value === "string" &&\n            parseFloat(value) === 0 &&\n            value.indexOf(" ") === -1));\n}\nfunction getZeroUnit(potentialUnitType) {\n    return typeof potentialUnitType === "number"\n        ? 0\n        : animatable_none_getAnimatableNone("", potentialUnitType);\n}\nfunction getValueTransition(transition, key) {\n    return transition[key] || transition["default"] || transition;\n}\n/**\n * Start animation on a MotionValue. This function is an interface between\n * Framer Motion and Popmotion\n */\nfunction startAnimation(key, value, target, transition) {\n    if (transition === void 0) { transition = {}; }\n    if (instantAnimationState.current) {\n        transition = { type: false };\n    }\n    return value.start(function (onComplete) {\n        var delayTimer;\n        var controls;\n        var animation = getAnimation(key, value, target, transition, onComplete);\n        var delay = getDelayFromTransition(transition, key);\n        var start = function () { return (controls = animation()); };\n        if (delay) {\n            delayTimer = window.setTimeout(start, secondsToMilliseconds(delay));\n        }\n        else {\n            start();\n        }\n        return function () {\n            clearTimeout(delayTimer);\n            controls === null || controls === void 0 ? void 0 : controls.stop();\n        };\n    });\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/utils/is-numerical-string.mjs\n/**\n * Check if value is a numerical string, ie a string that is purely a number eg "100" or "-100.1"\n */\nvar isNumericalString = function (v) { return /^\\-?\\d*\\.?\\d+$/.test(v); };\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/utils/is-zero-value-string.mjs\n/**\n * Check if the value is a zero value string like "0px" or "0%"\n */\nvar isZeroValueString = function (v) { return /^0[^.\\s]+$/.test(v); };\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/utils/array.mjs\n\n\nfunction addUniqueItem(arr, item) {\n    arr.indexOf(item) === -1 && arr.push(item);\n}\nfunction removeItem(arr, item) {\n    var index = arr.indexOf(item);\n    index > -1 && arr.splice(index, 1);\n}\n// Adapted from array-move\nfunction moveItem(_a, fromIndex, toIndex) {\n    var _b = __read(_a), arr = _b.slice(0);\n    var startIndex = fromIndex < 0 ? arr.length + fromIndex : fromIndex;\n    if (startIndex >= 0 && startIndex < arr.length) {\n        var endIndex = toIndex < 0 ? arr.length + toIndex : toIndex;\n        var _c = __read(arr.splice(fromIndex, 1), 1), item = _c[0];\n        arr.splice(endIndex, 0, item);\n    }\n    return arr;\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/utils/subscription-manager.mjs\n\n\nvar SubscriptionManager = /** @class */ (function () {\n    function SubscriptionManager() {\n        this.subscriptions = [];\n    }\n    SubscriptionManager.prototype.add = function (handler) {\n        var _this = this;\n        addUniqueItem(this.subscriptions, handler);\n        return function () { return removeItem(_this.subscriptions, handler); };\n    };\n    SubscriptionManager.prototype.notify = function (a, b, c) {\n        var numSubscriptions = this.subscriptions.length;\n        if (!numSubscriptions)\n            return;\n        if (numSubscriptions === 1) {\n            /**\n             * If there\'s only a single handler we can just call it without invoking a loop.\n             */\n            this.subscriptions[0](a, b, c);\n        }\n        else {\n            for (var i = 0; i < numSubscriptions; i++) {\n                /**\n                 * Check whether the handler exists before firing as it\'s possible\n                 * the subscriptions were modified during this loop running.\n                 */\n                var handler = this.subscriptions[i];\n                handler && handler(a, b, c);\n            }\n        }\n    };\n    SubscriptionManager.prototype.getSize = function () {\n        return this.subscriptions.length;\n    };\n    SubscriptionManager.prototype.clear = function () {\n        this.subscriptions.length = 0;\n    };\n    return SubscriptionManager;\n}());\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/value/index.mjs\n\n\n\n\nvar isFloat = function (value) {\n    return !isNaN(parseFloat(value));\n};\n/**\n * `MotionValue` is used to track the state and velocity of motion values.\n *\n * @public\n */\nvar MotionValue = /** @class */ (function () {\n    /**\n     * @param init - The initiating value\n     * @param config - Optional configuration options\n     *\n     * -  `transformer`: A function to transform incoming values with.\n     *\n     * @internal\n     */\n    function MotionValue(init) {\n        var _this = this;\n        /**\n         * This will be replaced by the build step with the latest version number.\n         * When MotionValues are provided to motion components, warn if versions are mixed.\n         */\n        this.version = "6.5.1";\n        /**\n         * Duration, in milliseconds, since last updating frame.\n         *\n         * @internal\n         */\n        this.timeDelta = 0;\n        /**\n         * Timestamp of the last time this `MotionValue` was updated.\n         *\n         * @internal\n         */\n        this.lastUpdated = 0;\n        /**\n         * Functions to notify when the `MotionValue` updates.\n         *\n         * @internal\n         */\n        this.updateSubscribers = new SubscriptionManager();\n        /**\n         * Functions to notify when the velocity updates.\n         *\n         * @internal\n         */\n        this.velocityUpdateSubscribers = new SubscriptionManager();\n        /**\n         * Functions to notify when the `MotionValue` updates and `render` is set to `true`.\n         *\n         * @internal\n         */\n        this.renderSubscribers = new SubscriptionManager();\n        /**\n         * Tracks whether this value can output a velocity. Currently this is only true\n         * if the value is numerical, but we might be able to widen the scope here and support\n         * other value types.\n         *\n         * @internal\n         */\n        this.canTrackVelocity = false;\n        this.updateAndNotify = function (v, render) {\n            if (render === void 0) { render = true; }\n            _this.prev = _this.current;\n            _this.current = v;\n            // Update timestamp\n            var _a = getFrameData(), delta = _a.delta, timestamp = _a.timestamp;\n            if (_this.lastUpdated !== timestamp) {\n                _this.timeDelta = delta;\n                _this.lastUpdated = timestamp;\n                es.postRender(_this.scheduleVelocityCheck);\n            }\n            // Update update subscribers\n            if (_this.prev !== _this.current) {\n                _this.updateSubscribers.notify(_this.current);\n            }\n            // Update velocity subscribers\n            if (_this.velocityUpdateSubscribers.getSize()) {\n                _this.velocityUpdateSubscribers.notify(_this.getVelocity());\n            }\n            // Update render subscribers\n            if (render) {\n                _this.renderSubscribers.notify(_this.current);\n            }\n        };\n        /**\n         * Schedule a velocity check for the next frame.\n         *\n         * This is an instanced and bound function to prevent generating a new\n         * function once per frame.\n         *\n         * @internal\n         */\n        this.scheduleVelocityCheck = function () { return es.postRender(_this.velocityCheck); };\n        /**\n         * Updates `prev` with `current` if the value hasn\'t been updated this frame.\n         * This ensures velocity calculations return `0`.\n         *\n         * This is an instanced and bound function to prevent generating a new\n         * function once per frame.\n         *\n         * @internal\n         */\n        this.velocityCheck = function (_a) {\n            var timestamp = _a.timestamp;\n            if (timestamp !== _this.lastUpdated) {\n                _this.prev = _this.current;\n                _this.velocityUpdateSubscribers.notify(_this.getVelocity());\n            }\n        };\n        this.hasAnimated = false;\n        this.prev = this.current = init;\n        this.canTrackVelocity = isFloat(this.current);\n    }\n    /**\n     * Adds a function that will be notified when the `MotionValue` is updated.\n     *\n     * It returns a function that, when called, will cancel the subscription.\n     *\n     * When calling `onChange` inside a React component, it should be wrapped with the\n     * `useEffect` hook. As it returns an unsubscribe function, this should be returned\n     * from the `useEffect` function to ensure you don\'t add duplicate subscribers..\n     *\n     * ```jsx\n     * export const MyComponent = () => {\n     *   const x = useMotionValue(0)\n     *   const y = useMotionValue(0)\n     *   const opacity = useMotionValue(1)\n     *\n     *   useEffect(() => {\n     *     function updateOpacity() {\n     *       const maxXY = Math.max(x.get(), y.get())\n     *       const newOpacity = transform(maxXY, [0, 100], [1, 0])\n     *       opacity.set(newOpacity)\n     *     }\n     *\n     *     const unsubscribeX = x.onChange(updateOpacity)\n     *     const unsubscribeY = y.onChange(updateOpacity)\n     *\n     *     return () => {\n     *       unsubscribeX()\n     *       unsubscribeY()\n     *     }\n     *   }, [])\n     *\n     *   return <motion.div style={{ x }} />\n     * }\n     * ```\n     *\n     * @privateRemarks\n     *\n     * We could look into a `useOnChange` hook if the above lifecycle management proves confusing.\n     *\n     * ```jsx\n     * useOnChange(x, () => {})\n     * ```\n     *\n     * @param subscriber - A function that receives the latest value.\n     * @returns A function that, when called, will cancel this subscription.\n     *\n     * @public\n     */\n    MotionValue.prototype.onChange = function (subscription) {\n        return this.updateSubscribers.add(subscription);\n    };\n    MotionValue.prototype.clearListeners = function () {\n        this.updateSubscribers.clear();\n    };\n    /**\n     * Adds a function that will be notified when the `MotionValue` requests a render.\n     *\n     * @param subscriber - A function that\'s provided the latest value.\n     * @returns A function that, when called, will cancel this subscription.\n     *\n     * @internal\n     */\n    MotionValue.prototype.onRenderRequest = function (subscription) {\n        // Render immediately\n        subscription(this.get());\n        return this.renderSubscribers.add(subscription);\n    };\n    /**\n     * Attaches a passive effect to the `MotionValue`.\n     *\n     * @internal\n     */\n    MotionValue.prototype.attach = function (passiveEffect) {\n        this.passiveEffect = passiveEffect;\n    };\n    /**\n     * Sets the state of the `MotionValue`.\n     *\n     * @remarks\n     *\n     * ```jsx\n     * const x = useMotionValue(0)\n     * x.set(10)\n     * ```\n     *\n     * @param latest - Latest value to set.\n     * @param render - Whether to notify render subscribers. Defaults to `true`\n     *\n     * @public\n     */\n    MotionValue.prototype.set = function (v, render) {\n        if (render === void 0) { render = true; }\n        if (!render || !this.passiveEffect) {\n            this.updateAndNotify(v, render);\n        }\n        else {\n            this.passiveEffect(v, this.updateAndNotify);\n        }\n    };\n    /**\n     * Returns the latest state of `MotionValue`\n     *\n     * @returns - The latest state of `MotionValue`\n     *\n     * @public\n     */\n    MotionValue.prototype.get = function () {\n        return this.current;\n    };\n    /**\n     * @public\n     */\n    MotionValue.prototype.getPrevious = function () {\n        return this.prev;\n    };\n    /**\n     * Returns the latest velocity of `MotionValue`\n     *\n     * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.\n     *\n     * @public\n     */\n    MotionValue.prototype.getVelocity = function () {\n        // This could be isFloat(this.prev) && isFloat(this.current), but that would be wasteful\n        return this.canTrackVelocity\n            ? // These casts could be avoided if parseFloat would be typed better\n                velocityPerSecond(parseFloat(this.current) -\n                    parseFloat(this.prev), this.timeDelta)\n            : 0;\n    };\n    /**\n     * Registers a new animation to control this `MotionValue`. Only one\n     * animation can drive a `MotionValue` at one time.\n     *\n     * ```jsx\n     * value.start()\n     * ```\n     *\n     * @param animation - A function that starts the provided animation\n     *\n     * @internal\n     */\n    MotionValue.prototype.start = function (animation) {\n        var _this = this;\n        this.stop();\n        return new Promise(function (resolve) {\n            _this.hasAnimated = true;\n            _this.stopAnimation = animation(resolve);\n        }).then(function () { return _this.clearAnimation(); });\n    };\n    /**\n     * Stop the currently active animation.\n     *\n     * @public\n     */\n    MotionValue.prototype.stop = function () {\n        if (this.stopAnimation)\n            this.stopAnimation();\n        this.clearAnimation();\n    };\n    /**\n     * Returns `true` if this value is currently animating.\n     *\n     * @public\n     */\n    MotionValue.prototype.isAnimating = function () {\n        return !!this.stopAnimation;\n    };\n    MotionValue.prototype.clearAnimation = function () {\n        this.stopAnimation = null;\n    };\n    /**\n     * Destroy and clean up subscribers to this `MotionValue`.\n     *\n     * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically\n     * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you\'ve manually\n     * created a `MotionValue` via the `motionValue` function.\n     *\n     * @public\n     */\n    MotionValue.prototype.destroy = function () {\n        this.updateSubscribers.clear();\n        this.renderSubscribers.clear();\n        this.stop();\n    };\n    return MotionValue;\n}());\nfunction motionValue(init) {\n    return new MotionValue(init);\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/render/dom/value-types/test.mjs\n/**\n * Tests a provided value against a ValueType\n */\nvar testValueType = function (v) { return function (type) { return type.test(v); }; };\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/render/dom/value-types/type-auto.mjs\n/**\n * ValueType for "auto"\n */\nvar auto = {\n    test: function (v) { return v === "auto"; },\n    parse: function (v) { return v; },\n};\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/render/dom/value-types/dimensions.mjs\n\n\n\n\n/**\n * A list of value types commonly used for dimensions\n */\nvar dimensionValueTypes = [number, px, percent, degrees, vw, vh, auto];\n/**\n * Tests a dimensional value against the list of dimension ValueTypes\n */\nvar findDimensionValueType = function (v) {\n    return dimensionValueTypes.find(testValueType(v));\n};\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/render/dom/value-types/find.mjs\n\n\n\n\n\n/**\n * A list of all ValueTypes\n */\nvar valueTypes = __spreadArray(__spreadArray([], __read(dimensionValueTypes), false), [color, complex], false);\n/**\n * Tests a value against the list of ValueTypes\n */\nvar findValueType = function (v) { return valueTypes.find(testValueType(v)); };\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/render/utils/setters.mjs\n\n\n\n\n\n\n\n\n\n\n/**\n * Set VisualElement\'s MotionValue, creating a new MotionValue for it if\n * it doesn\'t exist.\n */\nfunction setMotionValue(visualElement, key, value) {\n    if (visualElement.hasValue(key)) {\n        visualElement.getValue(key).set(value);\n    }\n    else {\n        visualElement.addValue(key, motionValue(value));\n    }\n}\nfunction setTarget(visualElement, definition) {\n    var resolved = resolveVariant(visualElement, definition);\n    var _a = resolved ? visualElement.makeTargetAnimatable(resolved, false) : {}, _b = _a.transitionEnd, transitionEnd = _b === void 0 ? {} : _b; _a.transition; var target = __rest(_a, ["transitionEnd", "transition"]);\n    target = __assign(__assign({}, target), transitionEnd);\n    for (var key in target) {\n        var value = resolveFinalValueInKeyframes(target[key]);\n        setMotionValue(visualElement, key, value);\n    }\n}\nfunction setVariants(visualElement, variantLabels) {\n    var reversedLabels = __spreadArray([], __read(variantLabels), false).reverse();\n    reversedLabels.forEach(function (key) {\n        var _a;\n        var variant = visualElement.getVariant(key);\n        variant && setTarget(visualElement, variant);\n        (_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.forEach(function (child) {\n            setVariants(child, variantLabels);\n        });\n    });\n}\nfunction setValues(visualElement, definition) {\n    if (Array.isArray(definition)) {\n        return setVariants(visualElement, definition);\n    }\n    else if (typeof definition === "string") {\n        return setVariants(visualElement, [definition]);\n    }\n    else {\n        setTarget(visualElement, definition);\n    }\n}\nfunction checkTargetForNewValues(visualElement, target, origin) {\n    var _a, _b, _c;\n    var _d;\n    var newValueKeys = Object.keys(target).filter(function (key) { return !visualElement.hasValue(key); });\n    var numNewValues = newValueKeys.length;\n    if (!numNewValues)\n        return;\n    for (var i = 0; i < numNewValues; i++) {\n        var key = newValueKeys[i];\n        var targetValue = target[key];\n        var value = null;\n        /**\n         * If the target is a series of keyframes, we can use the first value\n         * in the array. If this first value is null, we\'ll still need to read from the DOM.\n         */\n        if (Array.isArray(targetValue)) {\n            value = targetValue[0];\n        }\n        /**\n         * If the target isn\'t keyframes, or the first keyframe was null, we need to\n         * first check if an origin value was explicitly defined in the transition as "from",\n         * if not read the value from the DOM. As an absolute fallback, take the defined target value.\n         */\n        if (value === null) {\n            value = (_b = (_a = origin[key]) !== null && _a !== void 0 ? _a : visualElement.readValue(key)) !== null && _b !== void 0 ? _b : target[key];\n        }\n        /**\n         * If value is still undefined or null, ignore it. Preferably this would throw,\n         * but this was causing issues in Framer.\n         */\n        if (value === undefined || value === null)\n            continue;\n        if (typeof value === "string" &&\n            (isNumericalString(value) || isZeroValueString(value))) {\n            // If this is a number read as a string, ie "0" or "200", convert it to a number\n            value = parseFloat(value);\n        }\n        else if (!findValueType(value) && complex.test(targetValue)) {\n            value = animatable_none_getAnimatableNone(key, targetValue);\n        }\n        visualElement.addValue(key, motionValue(value));\n        (_c = (_d = origin)[key]) !== null && _c !== void 0 ? _c : (_d[key] = value);\n        visualElement.setBaseTarget(key, value);\n    }\n}\nfunction getOriginFromTransition(key, transition) {\n    if (!transition)\n        return;\n    var valueTransition = transition[key] || transition["default"] || transition;\n    return valueTransition.from;\n}\nfunction getOrigin(target, transition, visualElement) {\n    var _a, _b;\n    var origin = {};\n    for (var key in target) {\n        origin[key] =\n            (_a = getOriginFromTransition(key, transition)) !== null && _a !== void 0 ? _a : (_b = visualElement.getValue(key)) === null || _b === void 0 ? void 0 : _b.get();\n    }\n    return origin;\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/render/utils/animation.mjs\n\n\n\n\n\n\nfunction animateVisualElement(visualElement, definition, options) {\n    if (options === void 0) { options = {}; }\n    visualElement.notifyAnimationStart(definition);\n    var animation;\n    if (Array.isArray(definition)) {\n        var animations = definition.map(function (variant) {\n            return animateVariant(visualElement, variant, options);\n        });\n        animation = Promise.all(animations);\n    }\n    else if (typeof definition === "string") {\n        animation = animateVariant(visualElement, definition, options);\n    }\n    else {\n        var resolvedDefinition = typeof definition === "function"\n            ? resolveVariant(visualElement, definition, options.custom)\n            : definition;\n        animation = animateTarget(visualElement, resolvedDefinition, options);\n    }\n    return animation.then(function () {\n        return visualElement.notifyAnimationComplete(definition);\n    });\n}\nfunction animateVariant(visualElement, variant, options) {\n    var _a;\n    if (options === void 0) { options = {}; }\n    var resolved = resolveVariant(visualElement, variant, options.custom);\n    var _b = (resolved || {}).transition, transition = _b === void 0 ? visualElement.getDefaultTransition() || {} : _b;\n    if (options.transitionOverride) {\n        transition = options.transitionOverride;\n    }\n    /**\n     * If we have a variant, create a callback that runs it as an animation.\n     * Otherwise, we resolve a Promise immediately for a composable no-op.\n     */\n    var getAnimation = resolved\n        ? function () { return animateTarget(visualElement, resolved, options); }\n        : function () { return Promise.resolve(); };\n    /**\n     * If we have children, create a callback that runs all their animations.\n     * Otherwise, we resolve a Promise immediately for a composable no-op.\n     */\n    var getChildAnimations = ((_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.size)\n        ? function (forwardDelay) {\n            if (forwardDelay === void 0) { forwardDelay = 0; }\n            var _a = transition.delayChildren, delayChildren = _a === void 0 ? 0 : _a, staggerChildren = transition.staggerChildren, staggerDirection = transition.staggerDirection;\n            return animateChildren(visualElement, variant, delayChildren + forwardDelay, staggerChildren, staggerDirection, options);\n        }\n        : function () { return Promise.resolve(); };\n    /**\n     * If the transition explicitly defines a "when" option, we need to resolve either\n     * this animation or all children animations before playing the other.\n     */\n    var when = transition.when;\n    if (when) {\n        var _c = __read(when === "beforeChildren"\n            ? [getAnimation, getChildAnimations]\n            : [getChildAnimations, getAnimation], 2), first = _c[0], last = _c[1];\n        return first().then(last);\n    }\n    else {\n        return Promise.all([getAnimation(), getChildAnimations(options.delay)]);\n    }\n}\n/**\n * @internal\n */\nfunction animateTarget(visualElement, definition, _a) {\n    var _b;\n    var _c = _a === void 0 ? {} : _a, _d = _c.delay, delay = _d === void 0 ? 0 : _d, transitionOverride = _c.transitionOverride, type = _c.type;\n    var _e = visualElement.makeTargetAnimatable(definition), _f = _e.transition, transition = _f === void 0 ? visualElement.getDefaultTransition() : _f, transitionEnd = _e.transitionEnd, target = __rest(_e, ["transition", "transitionEnd"]);\n    if (transitionOverride)\n        transition = transitionOverride;\n    var animations = [];\n    var animationTypeState = type && ((_b = visualElement.animationState) === null || _b === void 0 ? void 0 : _b.getState()[type]);\n    for (var key in target) {\n        var value = visualElement.getValue(key);\n        var valueTarget = target[key];\n        if (!value ||\n            valueTarget === undefined ||\n            (animationTypeState &&\n                shouldBlockAnimation(animationTypeState, key))) {\n            continue;\n        }\n        var valueTransition = __assign({ delay: delay }, transition);\n        /**\n         * Make animation instant if this is a transform prop and we should reduce motion.\n         */\n        if (visualElement.shouldReduceMotion && isTransformProp(key)) {\n            valueTransition = __assign(__assign({}, valueTransition), { type: false, delay: 0 });\n        }\n        var animation = startAnimation(key, value, valueTarget, valueTransition);\n        animations.push(animation);\n    }\n    return Promise.all(animations).then(function () {\n        transitionEnd && setTarget(visualElement, transitionEnd);\n    });\n}\nfunction animateChildren(visualElement, variant, delayChildren, staggerChildren, staggerDirection, options) {\n    if (delayChildren === void 0) { delayChildren = 0; }\n    if (staggerChildren === void 0) { staggerChildren = 0; }\n    if (staggerDirection === void 0) { staggerDirection = 1; }\n    var animations = [];\n    var maxStaggerDuration = (visualElement.variantChildren.size - 1) * staggerChildren;\n    var generateStaggerDuration = staggerDirection === 1\n        ? function (i) {\n            if (i === void 0) { i = 0; }\n            return i * staggerChildren;\n        }\n        : function (i) {\n            if (i === void 0) { i = 0; }\n            return maxStaggerDuration - i * staggerChildren;\n        };\n    Array.from(visualElement.variantChildren)\n        .sort(sortByTreeOrder)\n        .forEach(function (child, i) {\n        animations.push(animateVariant(child, variant, __assign(__assign({}, options), { delay: delayChildren + generateStaggerDuration(i) })).then(function () { return child.notifyAnimationComplete(variant); }));\n    });\n    return Promise.all(animations);\n}\nfunction stopAnimation(visualElement) {\n    visualElement.forEachValue(function (value) { return value.stop(); });\n}\nfunction sortByTreeOrder(a, b) {\n    return a.sortNodePosition(b);\n}\n/**\n * Decide whether we should block this animation. Previously, we achieved this\n * just by checking whether the key was listed in protectedKeys, but this\n * posed problems if an animation was triggered by afterChildren and protectedKeys\n * had been set to true in the meantime.\n */\nfunction shouldBlockAnimation(_a, key) {\n    var protectedKeys = _a.protectedKeys, needsAnimating = _a.needsAnimating;\n    var shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true;\n    needsAnimating[key] = false;\n    return shouldBlock;\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/render/utils/animation-state.mjs\n\n\n\n\n\n\n\n\nvar variantPriorityOrder = [\n    AnimationType.Animate,\n    AnimationType.InView,\n    AnimationType.Focus,\n    AnimationType.Hover,\n    AnimationType.Tap,\n    AnimationType.Drag,\n    AnimationType.Exit,\n];\nvar reversePriorityOrder = __spreadArray([], __read(variantPriorityOrder), false).reverse();\nvar numAnimationTypes = variantPriorityOrder.length;\nfunction animateList(visualElement) {\n    return function (animations) {\n        return Promise.all(animations.map(function (_a) {\n            var animation = _a.animation, options = _a.options;\n            return animateVisualElement(visualElement, animation, options);\n        }));\n    };\n}\nfunction createAnimationState(visualElement) {\n    var animate = animateList(visualElement);\n    var state = createState();\n    var allAnimatedKeys = {};\n    var isInitialRender = true;\n    /**\n     * This function will be used to reduce the animation definitions for\n     * each active animation type into an object of resolved values for it.\n     */\n    var buildResolvedTypeValues = function (acc, definition) {\n        var resolved = resolveVariant(visualElement, definition);\n        if (resolved) {\n            resolved.transition; var transitionEnd = resolved.transitionEnd, target = __rest(resolved, ["transition", "transitionEnd"]);\n            acc = __assign(__assign(__assign({}, acc), target), transitionEnd);\n        }\n        return acc;\n    };\n    function isAnimated(key) {\n        return allAnimatedKeys[key] !== undefined;\n    }\n    /**\n     * This just allows us to inject mocked animation functions\n     * @internal\n     */\n    function setAnimateFunction(makeAnimator) {\n        animate = makeAnimator(visualElement);\n    }\n    /**\n     * When we receive new props, we need to:\n     * 1. Create a list of protected keys for each type. This is a directory of\n     *    value keys that are currently being "handled" by types of a higher priority\n     *    so that whenever an animation is played of a given type, these values are\n     *    protected from being animated.\n     * 2. Determine if an animation type needs animating.\n     * 3. Determine if any values have been removed from a type and figure out\n     *    what to animate those to.\n     */\n    function animateChanges(options, changedActiveType) {\n        var _a;\n        var props = visualElement.getProps();\n        var context = visualElement.getVariantContext(true) || {};\n        /**\n         * A list of animations that we\'ll build into as we iterate through the animation\n         * types. This will get executed at the end of the function.\n         */\n        var animations = [];\n        /**\n         * Keep track of which values have been removed. Then, as we hit lower priority\n         * animation types, we can check if they contain removed values and animate to that.\n         */\n        var removedKeys = new Set();\n        /**\n         * A dictionary of all encountered keys. This is an object to let us build into and\n         * copy it without iteration. Each time we hit an animation type we set its protected\n         * keys - the keys its not allowed to animate - to the latest version of this object.\n         */\n        var encounteredKeys = {};\n        /**\n         * If a variant has been removed at a given index, and this component is controlling\n         * variant animations, we want to ensure lower-priority variants are forced to animate.\n         */\n        var removedVariantIndex = Infinity;\n        var _loop_1 = function (i) {\n            var type = reversePriorityOrder[i];\n            var typeState = state[type];\n            var prop = (_a = props[type]) !== null && _a !== void 0 ? _a : context[type];\n            var propIsVariant = isVariantLabel(prop);\n            /**\n             * If this type has *just* changed isActive status, set activeDelta\n             * to that status. Otherwise set to null.\n             */\n            var activeDelta = type === changedActiveType ? typeState.isActive : null;\n            if (activeDelta === false)\n                removedVariantIndex = i;\n            /**\n             * If this prop is an inherited variant, rather than been set directly on the\n             * component itself, we want to make sure we allow the parent to trigger animations.\n             *\n             * TODO: Can probably change this to a !isControllingVariants check\n             */\n            var isInherited = prop === context[type] && prop !== props[type] && propIsVariant;\n            /**\n             *\n             */\n            if (isInherited &&\n                isInitialRender &&\n                visualElement.manuallyAnimateOnMount) {\n                isInherited = false;\n            }\n            /**\n             * Set all encountered keys so far as the protected keys for this type. This will\n             * be any key that has been animated or otherwise handled by active, higher-priortiy types.\n             */\n            typeState.protectedKeys = __assign({}, encounteredKeys);\n            // Check if we can skip analysing this prop early\n            if (\n            // If it isn\'t active and hasn\'t *just* been set as inactive\n            (!typeState.isActive && activeDelta === null) ||\n                // If we didn\'t and don\'t have any defined prop for this animation type\n                (!prop && !typeState.prevProp) ||\n                // Or if the prop doesn\'t define an animation\n                isAnimationControls(prop) ||\n                typeof prop === "boolean") {\n                return "continue";\n            }\n            /**\n             * As we go look through the values defined on this type, if we detect\n             * a changed value or a value that was removed in a higher priority, we set\n             * this to true and add this prop to the animation list.\n             */\n            var variantDidChange = checkVariantsDidChange(typeState.prevProp, prop);\n            var shouldAnimateType = variantDidChange ||\n                // If we\'re making this variant active, we want to always make it active\n                (type === changedActiveType &&\n                    typeState.isActive &&\n                    !isInherited &&\n                    propIsVariant) ||\n                // If we removed a higher-priority variant (i is in reverse order)\n                (i > removedVariantIndex && propIsVariant);\n            /**\n             * As animations can be set as variant lists, variants or target objects, we\n             * coerce everything to an array if it isn\'t one already\n             */\n            var definitionList = Array.isArray(prop) ? prop : [prop];\n            /**\n             * Build an object of all the resolved values. We\'ll use this in the subsequent\n             * animateChanges calls to determine whether a value has changed.\n             */\n            var resolvedValues = definitionList.reduce(buildResolvedTypeValues, {});\n            if (activeDelta === false)\n                resolvedValues = {};\n            /**\n             * Now we need to loop through all the keys in the prev prop and this prop,\n             * and decide:\n             * 1. If the value has changed, and needs animating\n             * 2. If it has been removed, and needs adding to the removedKeys set\n             * 3. If it has been removed in a higher priority type and needs animating\n             * 4. If it hasn\'t been removed in a higher priority but hasn\'t changed, and\n             *    needs adding to the type\'s protectedKeys list.\n             */\n            var _b = typeState.prevResolvedValues, prevResolvedValues = _b === void 0 ? {} : _b;\n            var allKeys = __assign(__assign({}, prevResolvedValues), resolvedValues);\n            var markToAnimate = function (key) {\n                shouldAnimateType = true;\n                removedKeys.delete(key);\n                typeState.needsAnimating[key] = true;\n            };\n            for (var key in allKeys) {\n                var next = resolvedValues[key];\n                var prev = prevResolvedValues[key];\n                // If we\'ve already handled this we can just skip ahead\n                if (encounteredKeys.hasOwnProperty(key))\n                    continue;\n                /**\n                 * If the value has changed, we probably want to animate it.\n                 */\n                if (next !== prev) {\n                    /**\n                     * If both values are keyframes, we need to shallow compare them to\n                     * detect whether any value has changed. If it has, we animate it.\n                     */\n                    if (isKeyframesTarget(next) && isKeyframesTarget(prev)) {\n                        if (!shallowCompare(next, prev) || variantDidChange) {\n                            markToAnimate(key);\n                        }\n                        else {\n                            /**\n                             * If it hasn\'t changed, we want to ensure it doesn\'t animate by\n                             * adding it to the list of protected keys.\n                             */\n                            typeState.protectedKeys[key] = true;\n                        }\n                    }\n                    else if (next !== undefined) {\n                        // If next is defined and doesn\'t equal prev, it needs animating\n                        markToAnimate(key);\n                    }\n                    else {\n                        // If it\'s undefined, it\'s been removed.\n                        removedKeys.add(key);\n                    }\n                }\n                else if (next !== undefined && removedKeys.has(key)) {\n                    /**\n                     * If next hasn\'t changed and it isn\'t undefined, we want to check if it\'s\n                     * been removed by a higher priority\n                     */\n                    markToAnimate(key);\n                }\n                else {\n                    /**\n                     * If it hasn\'t changed, we add it to the list of protected values\n                     * to ensure it doesn\'t get animated.\n                     */\n                    typeState.protectedKeys[key] = true;\n                }\n            }\n            /**\n             * Update the typeState so next time animateChanges is called we can compare the\n             * latest prop and resolvedValues to these.\n             */\n            typeState.prevProp = prop;\n            typeState.prevResolvedValues = resolvedValues;\n            /**\n             *\n             */\n            if (typeState.isActive) {\n                encounteredKeys = __assign(__assign({}, encounteredKeys), resolvedValues);\n            }\n            if (isInitialRender && visualElement.blockInitialAnimation) {\n                shouldAnimateType = false;\n            }\n            /**\n             * If this is an inherited prop we want to hard-block animations\n             * TODO: Test as this should probably still handle animations triggered\n             * by removed values?\n             */\n            if (shouldAnimateType && !isInherited) {\n                animations.push.apply(animations, __spreadArray([], __read(definitionList.map(function (animation) { return ({\n                    animation: animation,\n                    options: __assign({ type: type }, options),\n                }); })), false));\n            }\n        };\n        /**\n         * Iterate through all animation types in reverse priority order. For each, we want to\n         * detect which values it\'s handling and whether or not they\'ve changed (and therefore\n         * need to be animated). If any values have been removed, we want to detect those in\n         * lower priority props and flag for animation.\n         */\n        for (var i = 0; i < numAnimationTypes; i++) {\n            _loop_1(i);\n        }\n        allAnimatedKeys = __assign({}, encounteredKeys);\n        /**\n         * If there are some removed value that haven\'t been dealt with,\n         * we need to create a new animation that falls back either to the value\n         * defined in the style prop, or the last read value.\n         */\n        if (removedKeys.size) {\n            var fallbackAnimation_1 = {};\n            removedKeys.forEach(function (key) {\n                var fallbackTarget = visualElement.getBaseTarget(key);\n                if (fallbackTarget !== undefined) {\n                    fallbackAnimation_1[key] = fallbackTarget;\n                }\n            });\n            animations.push({ animation: fallbackAnimation_1 });\n        }\n        var shouldAnimate = Boolean(animations.length);\n        if (isInitialRender &&\n            props.initial === false &&\n            !visualElement.manuallyAnimateOnMount) {\n            shouldAnimate = false;\n        }\n        isInitialRender = false;\n        return shouldAnimate ? animate(animations) : Promise.resolve();\n    }\n    /**\n     * Change whether a certain animation type is active.\n     */\n    function setActive(type, isActive, options) {\n        var _a;\n        // If the active state hasn\'t changed, we can safely do nothing here\n        if (state[type].isActive === isActive)\n            return Promise.resolve();\n        // Propagate active change to children\n        (_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.forEach(function (child) { var _a; return (_a = child.animationState) === null || _a === void 0 ? void 0 : _a.setActive(type, isActive); });\n        state[type].isActive = isActive;\n        var animations = animateChanges(options, type);\n        for (var key in state) {\n            state[key].protectedKeys = {};\n        }\n        return animations;\n    }\n    return {\n        isAnimated: isAnimated,\n        animateChanges: animateChanges,\n        setActive: setActive,\n        setAnimateFunction: setAnimateFunction,\n        getState: function () { return state; },\n    };\n}\nfunction checkVariantsDidChange(prev, next) {\n    if (typeof next === "string") {\n        return next !== prev;\n    }\n    else if (isVariantLabels(next)) {\n        return !shallowCompare(next, prev);\n    }\n    return false;\n}\nfunction createTypeState(isActive) {\n    if (isActive === void 0) { isActive = false; }\n    return {\n        isActive: isActive,\n        protectedKeys: {},\n        needsAnimating: {},\n        prevResolvedValues: {},\n    };\n}\nfunction createState() {\n    var _a;\n    return _a = {},\n        _a[AnimationType.Animate] = createTypeState(true),\n        _a[AnimationType.InView] = createTypeState(),\n        _a[AnimationType.Hover] = createTypeState(),\n        _a[AnimationType.Tap] = createTypeState(),\n        _a[AnimationType.Drag] = createTypeState(),\n        _a[AnimationType.Focus] = createTypeState(),\n        _a[AnimationType.Exit] = createTypeState(),\n        _a;\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/motion/features/animations.mjs\n\n\n\n\n\n\n\n\n\nvar animations = {\n    animation: makeRenderlessComponent(function (_a) {\n        var visualElement = _a.visualElement, animate = _a.animate;\n        /**\n         * We dynamically generate the AnimationState manager as it contains a reference\n         * to the underlying animation library. We only want to load that if we load this,\n         * so people can optionally code split it out using the `m` component.\n         */\n        visualElement.animationState || (visualElement.animationState = createAnimationState(visualElement));\n        /**\n         * Subscribe any provided AnimationControls to the component\'s VisualElement\n         */\n        if (isAnimationControls(animate)) {\n            (0,index_js_.useEffect)(function () { return animate.subscribe(visualElement); }, [animate]);\n        }\n    }),\n    exit: makeRenderlessComponent(function (props) {\n        var custom = props.custom, visualElement = props.visualElement;\n        var _a = __read(usePresence(), 2), isPresent = _a[0], safeToRemove = _a[1];\n        var presenceContext = (0,index_js_.useContext)(PresenceContext);\n        (0,index_js_.useEffect)(function () {\n            var _a, _b;\n            visualElement.isPresent = isPresent;\n            var animation = (_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(AnimationType.Exit, !isPresent, { custom: (_b = presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.custom) !== null && _b !== void 0 ? _b : custom });\n            !isPresent && (animation === null || animation === void 0 ? void 0 : animation.then(safeToRemove));\n        }, [isPresent]);\n    }),\n};\n\n\n\n;// CONCATENATED MODULE: ./node_modules/popmotion/dist/es/utils/is-point.mjs\nconst isPoint = (point) => point.hasOwnProperty(\'x\') && point.hasOwnProperty(\'y\');\n\n\n\n;// CONCATENATED MODULE: ./node_modules/popmotion/dist/es/utils/is-point-3d.mjs\n\n\nconst isPoint3D = (point) => isPoint(point) && point.hasOwnProperty(\'z\');\n\n\n\n;// CONCATENATED MODULE: ./node_modules/popmotion/dist/es/utils/distance.mjs\n\n\n\n\nconst distance1D = (a, b) => Math.abs(a - b);\nfunction distance(a, b) {\n    if (isNum(a) && isNum(b)) {\n        return distance1D(a, b);\n    }\n    else if (isPoint(a) && isPoint(b)) {\n        const xDelta = distance1D(a.x, b.x);\n        const yDelta = distance1D(a.y, b.y);\n        const zDelta = isPoint3D(a) && isPoint3D(b) ? distance1D(a.z, b.z) : 0;\n        return Math.sqrt(Math.pow(xDelta, 2) + Math.pow(yDelta, 2) + Math.pow(zDelta, 2));\n    }\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/gestures/PanSession.mjs\n\n\n\n\n\n\n\n\n/**\n * @internal\n */\nvar PanSession = /** @class */ (function () {\n    function PanSession(event, handlers, _a) {\n        var _this = this;\n        var _b = _a === void 0 ? {} : _a, transformPagePoint = _b.transformPagePoint;\n        /**\n         * @internal\n         */\n        this.startEvent = null;\n        /**\n         * @internal\n         */\n        this.lastMoveEvent = null;\n        /**\n         * @internal\n         */\n        this.lastMoveEventInfo = null;\n        /**\n         * @internal\n         */\n        this.handlers = {};\n        this.updatePoint = function () {\n            if (!(_this.lastMoveEvent && _this.lastMoveEventInfo))\n                return;\n            var info = getPanInfo(_this.lastMoveEventInfo, _this.history);\n            var isPanStarted = _this.startEvent !== null;\n            // Only start panning if the offset is larger than 3 pixels. If we make it\n            // any larger than this we\'ll want to reset the pointer history\n            // on the first update to avoid visual snapping to the cursoe.\n            var isDistancePastThreshold = distance(info.offset, { x: 0, y: 0 }) >= 3;\n            if (!isPanStarted && !isDistancePastThreshold)\n                return;\n            var point = info.point;\n            var timestamp = getFrameData().timestamp;\n            _this.history.push(__assign(__assign({}, point), { timestamp: timestamp }));\n            var _a = _this.handlers, onStart = _a.onStart, onMove = _a.onMove;\n            if (!isPanStarted) {\n                onStart && onStart(_this.lastMoveEvent, info);\n                _this.startEvent = _this.lastMoveEvent;\n            }\n            onMove && onMove(_this.lastMoveEvent, info);\n        };\n        this.handlePointerMove = function (event, info) {\n            _this.lastMoveEvent = event;\n            _this.lastMoveEventInfo = transformPoint(info, _this.transformPagePoint);\n            // Because Safari doesn\'t trigger mouseup events when it\'s above a `<select>`\n            if (isMouseEvent(event) && event.buttons === 0) {\n                _this.handlePointerUp(event, info);\n                return;\n            }\n            // Throttle mouse move event to once per frame\n            es.update(_this.updatePoint, true);\n        };\n        this.handlePointerUp = function (event, info) {\n            _this.end();\n            var _a = _this.handlers, onEnd = _a.onEnd, onSessionEnd = _a.onSessionEnd;\n            var panInfo = getPanInfo(transformPoint(info, _this.transformPagePoint), _this.history);\n            if (_this.startEvent && onEnd) {\n                onEnd(event, panInfo);\n            }\n            onSessionEnd && onSessionEnd(event, panInfo);\n        };\n        // If we have more than one touch, don\'t start detecting this gesture\n        if (isTouchEvent(event) && event.touches.length > 1)\n            return;\n        this.handlers = handlers;\n        this.transformPagePoint = transformPagePoint;\n        var info = extractEventInfo(event);\n        var initialInfo = transformPoint(info, this.transformPagePoint);\n        var point = initialInfo.point;\n        var timestamp = getFrameData().timestamp;\n        this.history = [__assign(__assign({}, point), { timestamp: timestamp })];\n        var onSessionStart = handlers.onSessionStart;\n        onSessionStart &&\n            onSessionStart(event, getPanInfo(initialInfo, this.history));\n        this.removeListeners = pipe(addPointerEvent(window, "pointermove", this.handlePointerMove), addPointerEvent(window, "pointerup", this.handlePointerUp), addPointerEvent(window, "pointercancel", this.handlePointerUp));\n    }\n    PanSession.prototype.updateHandlers = function (handlers) {\n        this.handlers = handlers;\n    };\n    PanSession.prototype.end = function () {\n        this.removeListeners && this.removeListeners();\n        cancelSync.update(this.updatePoint);\n    };\n    return PanSession;\n}());\nfunction transformPoint(info, transformPagePoint) {\n    return transformPagePoint ? { point: transformPagePoint(info.point) } : info;\n}\nfunction subtractPoint(a, b) {\n    return { x: a.x - b.x, y: a.y - b.y };\n}\nfunction getPanInfo(_a, history) {\n    var point = _a.point;\n    return {\n        point: point,\n        delta: subtractPoint(point, lastDevicePoint(history)),\n        offset: subtractPoint(point, startDevicePoint(history)),\n        velocity: PanSession_getVelocity(history, 0.1),\n    };\n}\nfunction startDevicePoint(history) {\n    return history[0];\n}\nfunction lastDevicePoint(history) {\n    return history[history.length - 1];\n}\nfunction PanSession_getVelocity(history, timeDelta) {\n    if (history.length < 2) {\n        return { x: 0, y: 0 };\n    }\n    var i = history.length - 1;\n    var timestampedPoint = null;\n    var lastPoint = lastDevicePoint(history);\n    while (i >= 0) {\n        timestampedPoint = history[i];\n        if (lastPoint.timestamp - timestampedPoint.timestamp >\n            secondsToMilliseconds(timeDelta)) {\n            break;\n        }\n        i--;\n    }\n    if (!timestampedPoint) {\n        return { x: 0, y: 0 };\n    }\n    var time = (lastPoint.timestamp - timestampedPoint.timestamp) / 1000;\n    if (time === 0) {\n        return { x: 0, y: 0 };\n    }\n    var currentVelocity = {\n        x: (lastPoint.x - timestampedPoint.x) / time,\n        y: (lastPoint.y - timestampedPoint.y) / time,\n    };\n    if (currentVelocity.x === Infinity) {\n        currentVelocity.x = 0;\n    }\n    if (currentVelocity.y === Infinity) {\n        currentVelocity.y = 0;\n    }\n    return currentVelocity;\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/projection/geometry/delta-calc.mjs\n\n\nfunction calcLength(axis) {\n    return axis.max - axis.min;\n}\nfunction isNear(value, target, maxDistance) {\n    if (target === void 0) { target = 0; }\n    if (maxDistance === void 0) { maxDistance = 0.01; }\n    return distance(value, target) < maxDistance;\n}\nfunction calcAxisDelta(delta, source, target, origin) {\n    if (origin === void 0) { origin = 0.5; }\n    delta.origin = origin;\n    delta.originPoint = mix(source.min, source.max, delta.origin);\n    delta.scale = calcLength(target) / calcLength(source);\n    if (isNear(delta.scale, 1, 0.0001) || isNaN(delta.scale))\n        delta.scale = 1;\n    delta.translate =\n        mix(target.min, target.max, delta.origin) - delta.originPoint;\n    if (isNear(delta.translate) || isNaN(delta.translate))\n        delta.translate = 0;\n}\nfunction calcBoxDelta(delta, source, target, origin) {\n    calcAxisDelta(delta.x, source.x, target.x, origin === null || origin === void 0 ? void 0 : origin.originX);\n    calcAxisDelta(delta.y, source.y, target.y, origin === null || origin === void 0 ? void 0 : origin.originY);\n}\nfunction calcRelativeAxis(target, relative, parent) {\n    target.min = parent.min + relative.min;\n    target.max = target.min + calcLength(relative);\n}\nfunction calcRelativeBox(target, relative, parent) {\n    calcRelativeAxis(target.x, relative.x, parent.x);\n    calcRelativeAxis(target.y, relative.y, parent.y);\n}\nfunction calcRelativeAxisPosition(target, layout, parent) {\n    target.min = layout.min - parent.min;\n    target.max = target.min + calcLength(layout);\n}\nfunction calcRelativePosition(target, layout, parent) {\n    calcRelativeAxisPosition(target.x, layout.x, parent.x);\n    calcRelativeAxisPosition(target.y, layout.y, parent.y);\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/gestures/drag/utils/constraints.mjs\n\n\n\n\n/**\n * Apply constraints to a point. These constraints are both physical along an\n * axis, and an elastic factor that determines how much to constrain the point\n * by if it does lie outside the defined parameters.\n */\nfunction applyConstraints(point, _a, elastic) {\n    var min = _a.min, max = _a.max;\n    if (min !== undefined && point < min) {\n        // If we have a min point defined, and this is outside of that, constrain\n        point = elastic ? mix(min, point, elastic.min) : Math.max(point, min);\n    }\n    else if (max !== undefined && point > max) {\n        // If we have a max point defined, and this is outside of that, constrain\n        point = elastic ? mix(max, point, elastic.max) : Math.min(point, max);\n    }\n    return point;\n}\n/**\n * Calculate constraints in terms of the viewport when defined relatively to the\n * measured axis. This is measured from the nearest edge, so a max constraint of 200\n * on an axis with a max value of 300 would return a constraint of 500 - axis length\n */\nfunction calcRelativeAxisConstraints(axis, min, max) {\n    return {\n        min: min !== undefined ? axis.min + min : undefined,\n        max: max !== undefined\n            ? axis.max + max - (axis.max - axis.min)\n            : undefined,\n    };\n}\n/**\n * Calculate constraints in terms of the viewport when\n * defined relatively to the measured bounding box.\n */\nfunction calcRelativeConstraints(layoutBox, _a) {\n    var top = _a.top, left = _a.left, bottom = _a.bottom, right = _a.right;\n    return {\n        x: calcRelativeAxisConstraints(layoutBox.x, left, right),\n        y: calcRelativeAxisConstraints(layoutBox.y, top, bottom),\n    };\n}\n/**\n * Calculate viewport constraints when defined as another viewport-relative axis\n */\nfunction calcViewportAxisConstraints(layoutAxis, constraintsAxis) {\n    var _a;\n    var min = constraintsAxis.min - layoutAxis.min;\n    var max = constraintsAxis.max - layoutAxis.max;\n    // If the constraints axis is actually smaller than the layout axis then we can\n    // flip the constraints\n    if (constraintsAxis.max - constraintsAxis.min <\n        layoutAxis.max - layoutAxis.min) {\n        _a = __read([max, min], 2), min = _a[0], max = _a[1];\n    }\n    return { min: min, max: max };\n}\n/**\n * Calculate viewport constraints when defined as another viewport-relative box\n */\nfunction calcViewportConstraints(layoutBox, constraintsBox) {\n    return {\n        x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),\n        y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y),\n    };\n}\n/**\n * Calculate a transform origin relative to the source axis, between 0-1, that results\n * in an asthetically pleasing scale/transform needed to project from source to target.\n */\nfunction constraints_calcOrigin(source, target) {\n    var origin = 0.5;\n    var sourceLength = calcLength(source);\n    var targetLength = calcLength(target);\n    if (targetLength > sourceLength) {\n        origin = progress(target.min, target.max - sourceLength, source.min);\n    }\n    else if (sourceLength > targetLength) {\n        origin = progress(source.min, source.max - targetLength, target.min);\n    }\n    return clamp_clamp(0, 1, origin);\n}\n/**\n * Rebase the calculated viewport constraints relative to the layout.min point.\n */\nfunction rebaseAxisConstraints(layout, constraints) {\n    var relativeConstraints = {};\n    if (constraints.min !== undefined) {\n        relativeConstraints.min = constraints.min - layout.min;\n    }\n    if (constraints.max !== undefined) {\n        relativeConstraints.max = constraints.max - layout.min;\n    }\n    return relativeConstraints;\n}\nvar defaultElastic = 0.35;\n/**\n * Accepts a dragElastic prop and returns resolved elastic values for each axis.\n */\nfunction resolveDragElastic(dragElastic) {\n    if (dragElastic === void 0) { dragElastic = defaultElastic; }\n    if (dragElastic === false) {\n        dragElastic = 0;\n    }\n    else if (dragElastic === true) {\n        dragElastic = defaultElastic;\n    }\n    return {\n        x: resolveAxisElastic(dragElastic, "left", "right"),\n        y: resolveAxisElastic(dragElastic, "top", "bottom"),\n    };\n}\nfunction resolveAxisElastic(dragElastic, minLabel, maxLabel) {\n    return {\n        min: resolvePointElastic(dragElastic, minLabel),\n        max: resolvePointElastic(dragElastic, maxLabel),\n    };\n}\nfunction resolvePointElastic(dragElastic, label) {\n    var _a;\n    return typeof dragElastic === "number"\n        ? dragElastic\n        : (_a = dragElastic[label]) !== null && _a !== void 0 ? _a : 0;\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/projection/geometry/models.mjs\nvar createAxisDelta = function () { return ({\n    translate: 0,\n    scale: 1,\n    origin: 0,\n    originPoint: 0,\n}); };\nvar createDelta = function () { return ({\n    x: createAxisDelta(),\n    y: createAxisDelta(),\n}); };\nvar createAxis = function () { return ({ min: 0, max: 0 }); };\nvar createBox = function () { return ({\n    x: createAxis(),\n    y: createAxis(),\n}); };\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/projection/utils/each-axis.mjs\nfunction eachAxis(callback) {\n    return [callback("x"), callback("y")];\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/projection/geometry/conversion.mjs\n/**\n * Bounding boxes tend to be defined as top, left, right, bottom. For various operations\n * it\'s easier to consider each axis individually. This function returns a bounding box\n * as a map of single-axis min/max values.\n */\nfunction convertBoundingBoxToBox(_a) {\n    var top = _a.top, left = _a.left, right = _a.right, bottom = _a.bottom;\n    return {\n        x: { min: left, max: right },\n        y: { min: top, max: bottom },\n    };\n}\nfunction convertBoxToBoundingBox(_a) {\n    var x = _a.x, y = _a.y;\n    return { top: y.min, right: x.max, bottom: y.max, left: x.min };\n}\n/**\n * Applies a TransformPoint function to a bounding box. TransformPoint is usually a function\n * provided by Framer to allow measured points to be corrected for device scaling. This is used\n * when measuring DOM elements and DOM event points.\n */\nfunction transformBoxPoints(point, transformPoint) {\n    if (!transformPoint)\n        return point;\n    var topLeft = transformPoint({ x: point.left, y: point.top });\n    var bottomRight = transformPoint({ x: point.right, y: point.bottom });\n    return {\n        top: topLeft.y,\n        left: topLeft.x,\n        bottom: bottomRight.y,\n        right: bottomRight.x,\n    };\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/projection/utils/has-transform.mjs\nfunction isIdentityScale(scale) {\n    return scale === undefined || scale === 1;\n}\nfunction hasScale(_a) {\n    var scale = _a.scale, scaleX = _a.scaleX, scaleY = _a.scaleY;\n    return (!isIdentityScale(scale) ||\n        !isIdentityScale(scaleX) ||\n        !isIdentityScale(scaleY));\n}\nfunction hasTransform(values) {\n    return (hasScale(values) ||\n        hasTranslate(values.x) ||\n        hasTranslate(values.y) ||\n        values.z ||\n        values.rotate ||\n        values.rotateX ||\n        values.rotateY);\n}\nfunction hasTranslate(value) {\n    return value && value !== "0%";\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/projection/geometry/delta-apply.mjs\n\n\n\n\n/**\n * Scales a point based on a factor and an originPoint\n */\nfunction scalePoint(point, scale, originPoint) {\n    var distanceFromOrigin = point - originPoint;\n    var scaled = scale * distanceFromOrigin;\n    return originPoint + scaled;\n}\n/**\n * Applies a translate/scale delta to a point\n */\nfunction applyPointDelta(point, translate, scale, originPoint, boxScale) {\n    if (boxScale !== undefined) {\n        point = scalePoint(point, boxScale, originPoint);\n    }\n    return scalePoint(point, scale, originPoint) + translate;\n}\n/**\n * Applies a translate/scale delta to an axis\n */\nfunction applyAxisDelta(axis, translate, scale, originPoint, boxScale) {\n    if (translate === void 0) { translate = 0; }\n    if (scale === void 0) { scale = 1; }\n    axis.min = applyPointDelta(axis.min, translate, scale, originPoint, boxScale);\n    axis.max = applyPointDelta(axis.max, translate, scale, originPoint, boxScale);\n}\n/**\n * Applies a translate/scale delta to a box\n */\nfunction applyBoxDelta(box, _a) {\n    var x = _a.x, y = _a.y;\n    applyAxisDelta(box.x, x.translate, x.scale, x.originPoint);\n    applyAxisDelta(box.y, y.translate, y.scale, y.originPoint);\n}\n/**\n * Apply a tree of deltas to a box. We do this to calculate the effect of all the transforms\n * in a tree upon our box before then calculating how to project it into our desired viewport-relative box\n *\n * This is the final nested loop within updateLayoutDelta for future refactoring\n */\nfunction applyTreeDeltas(box, treeScale, treePath, isSharedTransition) {\n    var _a, _b;\n    if (isSharedTransition === void 0) { isSharedTransition = false; }\n    var treeLength = treePath.length;\n    if (!treeLength)\n        return;\n    // Reset the treeScale\n    treeScale.x = treeScale.y = 1;\n    var node;\n    var delta;\n    for (var i = 0; i < treeLength; i++) {\n        node = treePath[i];\n        delta = node.projectionDelta;\n        if (((_b = (_a = node.instance) === null || _a === void 0 ? void 0 : _a.style) === null || _b === void 0 ? void 0 : _b.display) === "contents")\n            continue;\n        if (isSharedTransition &&\n            node.options.layoutScroll &&\n            node.scroll &&\n            node !== node.root) {\n            transformBox(box, { x: -node.scroll.x, y: -node.scroll.y });\n        }\n        if (delta) {\n            // Incoporate each ancestor\'s scale into a culmulative treeScale for this component\n            treeScale.x *= delta.x.scale;\n            treeScale.y *= delta.y.scale;\n            // Apply each ancestor\'s calculated delta into this component\'s recorded layout box\n            applyBoxDelta(box, delta);\n        }\n        if (isSharedTransition && hasTransform(node.latestValues)) {\n            transformBox(box, node.latestValues);\n        }\n    }\n}\nfunction translateAxis(axis, distance) {\n    axis.min = axis.min + distance;\n    axis.max = axis.max + distance;\n}\n/**\n * Apply a transform to an axis from the latest resolved motion values.\n * This function basically acts as a bridge between a flat motion value map\n * and applyAxisDelta\n */\nfunction transformAxis(axis, transforms, _a) {\n    var _b = __read(_a, 3), key = _b[0], scaleKey = _b[1], originKey = _b[2];\n    var axisOrigin = transforms[originKey] !== undefined ? transforms[originKey] : 0.5;\n    var originPoint = mix(axis.min, axis.max, axisOrigin);\n    // Apply the axis delta to the final axis\n    applyAxisDelta(axis, transforms[key], transforms[scaleKey], originPoint, transforms.scale);\n}\n/**\n * The names of the motion values we want to apply as translation, scale and origin.\n */\nvar xKeys = ["x", "scaleX", "originX"];\nvar yKeys = ["y", "scaleY", "originY"];\n/**\n * Apply a transform to a box from the latest resolved motion values.\n */\nfunction transformBox(box, transform) {\n    transformAxis(box.x, transform, xKeys);\n    transformAxis(box.y, transform, yKeys);\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/projection/utils/measure.mjs\n\n\n\nfunction measureViewportBox(instance, transformPoint) {\n    return convertBoundingBoxToBox(transformBoxPoints(instance.getBoundingClientRect(), transformPoint));\n}\nfunction measurePageBox(element, rootProjectionNode, transformPagePoint) {\n    var viewportBox = measureViewportBox(element, transformPagePoint);\n    var scroll = rootProjectionNode.scroll;\n    if (scroll) {\n        translateAxis(viewportBox.x, scroll.x);\n        translateAxis(viewportBox.y, scroll.y);\n    }\n    return viewportBox;\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/gestures/drag/VisualElementDragControls.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar elementDragControls = new WeakMap();\n/**\n *\n */\n// let latestPointerEvent: AnyPointerEvent\nvar VisualElementDragControls = /** @class */ (function () {\n    function VisualElementDragControls(visualElement) {\n        // This is a reference to the global drag gesture lock, ensuring only one component\n        // can "capture" the drag of one or both axes.\n        // TODO: Look into moving this into pansession?\n        this.openGlobalLock = null;\n        this.isDragging = false;\n        this.currentDirection = null;\n        this.originPoint = { x: 0, y: 0 };\n        /**\n         * The permitted boundaries of travel, in pixels.\n         */\n        this.constraints = false;\n        this.hasMutatedConstraints = false;\n        /**\n         * The per-axis resolved elastic values.\n         */\n        this.elastic = createBox();\n        this.visualElement = visualElement;\n    }\n    VisualElementDragControls.prototype.start = function (originEvent, _a) {\n        var _this = this;\n        var _b = _a === void 0 ? {} : _a, _c = _b.snapToCursor, snapToCursor = _c === void 0 ? false : _c;\n        /**\n         * Don\'t start dragging if this component is exiting\n         */\n        if (this.visualElement.isPresent === false)\n            return;\n        var onSessionStart = function (event) {\n            // Stop any animations on both axis values immediately. This allows the user to throw and catch\n            // the component.\n            _this.stopAnimation();\n            if (snapToCursor) {\n                _this.snapToCursor(extractEventInfo(event, "page").point);\n            }\n        };\n        var onStart = function (event, info) {\n            var _a;\n            // Attempt to grab the global drag gesture lock - maybe make this part of PanSession\n            var _b = _this.getProps(), drag = _b.drag, dragPropagation = _b.dragPropagation, onDragStart = _b.onDragStart;\n            if (drag && !dragPropagation) {\n                if (_this.openGlobalLock)\n                    _this.openGlobalLock();\n                _this.openGlobalLock = getGlobalLock(drag);\n                // If we don \'t have the lock, don\'t start dragging\n                if (!_this.openGlobalLock)\n                    return;\n            }\n            _this.isDragging = true;\n            _this.currentDirection = null;\n            _this.resolveConstraints();\n            if (_this.visualElement.projection) {\n                _this.visualElement.projection.isAnimationBlocked = true;\n                _this.visualElement.projection.target = undefined;\n            }\n            /**\n             * Record gesture origin\n             */\n            eachAxis(function (axis) {\n                var _a, _b;\n                var current = _this.getAxisMotionValue(axis).get() || 0;\n                /**\n                 * If the MotionValue is a percentage value convert to px\n                 */\n                if (percent.test(current)) {\n                    var measuredAxis = (_b = (_a = _this.visualElement.projection) === null || _a === void 0 ? void 0 : _a.layout) === null || _b === void 0 ? void 0 : _b.actual[axis];\n                    if (measuredAxis) {\n                        var length_1 = calcLength(measuredAxis);\n                        current = length_1 * (parseFloat(current) / 100);\n                    }\n                }\n                _this.originPoint[axis] = current;\n            });\n            // Fire onDragStart event\n            onDragStart === null || onDragStart === void 0 ? void 0 : onDragStart(event, info);\n            (_a = _this.visualElement.animationState) === null || _a === void 0 ? void 0 : _a.setActive(AnimationType.Drag, true);\n        };\n        var onMove = function (event, info) {\n            // latestPointerEvent = event\n            var _a = _this.getProps(), dragPropagation = _a.dragPropagation, dragDirectionLock = _a.dragDirectionLock, onDirectionLock = _a.onDirectionLock, onDrag = _a.onDrag;\n            // If we didn\'t successfully receive the gesture lock, early return.\n            if (!dragPropagation && !_this.openGlobalLock)\n                return;\n            var offset = info.offset;\n            // Attempt to detect drag direction if directionLock is true\n            if (dragDirectionLock && _this.currentDirection === null) {\n                _this.currentDirection = getCurrentDirection(offset);\n                // If we\'ve successfully set a direction, notify listener\n                if (_this.currentDirection !== null) {\n                    onDirectionLock === null || onDirectionLock === void 0 ? void 0 : onDirectionLock(_this.currentDirection);\n                }\n                return;\n            }\n            // Update each point with the latest position\n            _this.updateAxis("x", info.point, offset);\n            _this.updateAxis("y", info.point, offset);\n            /**\n             * Ideally we would leave the renderer to fire naturally at the end of\n             * this frame but if the element is about to change layout as the result\n             * of a re-render we want to ensure the browser can read the latest\n             * bounding box to ensure the pointer and element don\'t fall out of sync.\n             */\n            _this.visualElement.syncRender();\n            /**\n             * This must fire after the syncRender call as it might trigger a state\n             * change which itself might trigger a layout update.\n             */\n            onDrag === null || onDrag === void 0 ? void 0 : onDrag(event, info);\n        };\n        var onSessionEnd = function (event, info) {\n            return _this.stop(event, info);\n        };\n        this.panSession = new PanSession(originEvent, {\n            onSessionStart: onSessionStart,\n            onStart: onStart,\n            onMove: onMove,\n            onSessionEnd: onSessionEnd,\n        }, { transformPagePoint: this.visualElement.getTransformPagePoint() });\n    };\n    VisualElementDragControls.prototype.stop = function (event, info) {\n        var isDragging = this.isDragging;\n        this.cancel();\n        if (!isDragging)\n            return;\n        var velocity = info.velocity;\n        this.startAnimation(velocity);\n        var onDragEnd = this.getProps().onDragEnd;\n        onDragEnd === null || onDragEnd === void 0 ? void 0 : onDragEnd(event, info);\n    };\n    VisualElementDragControls.prototype.cancel = function () {\n        var _a, _b;\n        this.isDragging = false;\n        if (this.visualElement.projection) {\n            this.visualElement.projection.isAnimationBlocked = false;\n        }\n        (_a = this.panSession) === null || _a === void 0 ? void 0 : _a.end();\n        this.panSession = undefined;\n        var dragPropagation = this.getProps().dragPropagation;\n        if (!dragPropagation && this.openGlobalLock) {\n            this.openGlobalLock();\n            this.openGlobalLock = null;\n        }\n        (_b = this.visualElement.animationState) === null || _b === void 0 ? void 0 : _b.setActive(AnimationType.Drag, false);\n    };\n    VisualElementDragControls.prototype.updateAxis = function (axis, _point, offset) {\n        var drag = this.getProps().drag;\n        // If we\'re not dragging this axis, do an early return.\n        if (!offset || !shouldDrag(axis, drag, this.currentDirection))\n            return;\n        var axisValue = this.getAxisMotionValue(axis);\n        var next = this.originPoint[axis] + offset[axis];\n        // Apply constraints\n        if (this.constraints && this.constraints[axis]) {\n            next = applyConstraints(next, this.constraints[axis], this.elastic[axis]);\n        }\n        axisValue.set(next);\n    };\n    VisualElementDragControls.prototype.resolveConstraints = function () {\n        var _this = this;\n        var _a = this.getProps(), dragConstraints = _a.dragConstraints, dragElastic = _a.dragElastic;\n        var layout = (this.visualElement.projection || {}).layout;\n        var prevConstraints = this.constraints;\n        if (dragConstraints && isRefObject(dragConstraints)) {\n            if (!this.constraints) {\n                this.constraints = this.resolveRefConstraints();\n            }\n        }\n        else {\n            if (dragConstraints && layout) {\n                this.constraints = calcRelativeConstraints(layout.actual, dragConstraints);\n            }\n            else {\n                this.constraints = false;\n            }\n        }\n        this.elastic = resolveDragElastic(dragElastic);\n        /**\n         * If we\'re outputting to external MotionValues, we want to rebase the measured constraints\n         * from viewport-relative to component-relative.\n         */\n        if (prevConstraints !== this.constraints &&\n            layout &&\n            this.constraints &&\n            !this.hasMutatedConstraints) {\n            eachAxis(function (axis) {\n                if (_this.getAxisMotionValue(axis)) {\n                    _this.constraints[axis] = rebaseAxisConstraints(layout.actual[axis], _this.constraints[axis]);\n                }\n            });\n        }\n    };\n    VisualElementDragControls.prototype.resolveRefConstraints = function () {\n        var _a = this.getProps(), constraints = _a.dragConstraints, onMeasureDragConstraints = _a.onMeasureDragConstraints;\n        if (!constraints || !isRefObject(constraints))\n            return false;\n        var constraintsElement = constraints.current;\n        invariant(constraintsElement !== null, "If `dragConstraints` is set as a React ref, that ref must be passed to another component\'s `ref` prop.");\n        var projection = this.visualElement.projection;\n        // TODO\n        if (!projection || !projection.layout)\n            return false;\n        var constraintsBox = measurePageBox(constraintsElement, projection.root, this.visualElement.getTransformPagePoint());\n        var measuredConstraints = calcViewportConstraints(projection.layout.actual, constraintsBox);\n        /**\n         * If there\'s an onMeasureDragConstraints listener we call it and\n         * if different constraints are returned, set constraints to that\n         */\n        if (onMeasureDragConstraints) {\n            var userConstraints = onMeasureDragConstraints(convertBoxToBoundingBox(measuredConstraints));\n            this.hasMutatedConstraints = !!userConstraints;\n            if (userConstraints) {\n                measuredConstraints = convertBoundingBoxToBox(userConstraints);\n            }\n        }\n        return measuredConstraints;\n    };\n    VisualElementDragControls.prototype.startAnimation = function (velocity) {\n        var _this = this;\n        var _a = this.getProps(), drag = _a.drag, dragMomentum = _a.dragMomentum, dragElastic = _a.dragElastic, dragTransition = _a.dragTransition, dragSnapToOrigin = _a.dragSnapToOrigin, onDragTransitionEnd = _a.onDragTransitionEnd;\n        var constraints = this.constraints || {};\n        var momentumAnimations = eachAxis(function (axis) {\n            var _a;\n            if (!shouldDrag(axis, drag, _this.currentDirection)) {\n                return;\n            }\n            var transition = (_a = constraints === null || constraints === void 0 ? void 0 : constraints[axis]) !== null && _a !== void 0 ? _a : {};\n            if (dragSnapToOrigin)\n                transition = { min: 0, max: 0 };\n            /**\n             * Overdamp the boundary spring if `dragElastic` is disabled. There\'s still a frame\n             * of spring animations so we should look into adding a disable spring option to `inertia`.\n             * We could do something here where we affect the `bounceStiffness` and `bounceDamping`\n             * using the value of `dragElastic`.\n             */\n            var bounceStiffness = dragElastic ? 200 : 1000000;\n            var bounceDamping = dragElastic ? 40 : 10000000;\n            var inertia = __assign(__assign({ type: "inertia", velocity: dragMomentum ? velocity[axis] : 0, bounceStiffness: bounceStiffness, bounceDamping: bounceDamping, timeConstant: 750, restDelta: 1, restSpeed: 10 }, dragTransition), transition);\n            // If we\'re not animating on an externally-provided `MotionValue` we can use the\n            // component\'s animation controls which will handle interactions with whileHover (etc),\n            // otherwise we just have to animate the `MotionValue` itself.\n            return _this.startAxisValueAnimation(axis, inertia);\n        });\n        // Run all animations and then resolve the new drag constraints.\n        return Promise.all(momentumAnimations).then(onDragTransitionEnd);\n    };\n    VisualElementDragControls.prototype.startAxisValueAnimation = function (axis, transition) {\n        var axisValue = this.getAxisMotionValue(axis);\n        return startAnimation(axis, axisValue, 0, transition);\n    };\n    VisualElementDragControls.prototype.stopAnimation = function () {\n        var _this = this;\n        eachAxis(function (axis) { return _this.getAxisMotionValue(axis).stop(); });\n    };\n    /**\n     * Drag works differently depending on which props are provided.\n     *\n     * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.\n     * - Otherwise, we apply the delta to the x/y motion values.\n     */\n    VisualElementDragControls.prototype.getAxisMotionValue = function (axis) {\n        var _a, _b;\n        var dragKey = "_drag" + axis.toUpperCase();\n        var externalMotionValue = this.visualElement.getProps()[dragKey];\n        return externalMotionValue\n            ? externalMotionValue\n            : this.visualElement.getValue(axis, (_b = (_a = this.visualElement.getProps().initial) === null || _a === void 0 ? void 0 : _a[axis]) !== null && _b !== void 0 ? _b : 0);\n    };\n    VisualElementDragControls.prototype.snapToCursor = function (point) {\n        var _this = this;\n        eachAxis(function (axis) {\n            var drag = _this.getProps().drag;\n            // If we\'re not dragging this axis, do an early return.\n            if (!shouldDrag(axis, drag, _this.currentDirection))\n                return;\n            var projection = _this.visualElement.projection;\n            var axisValue = _this.getAxisMotionValue(axis);\n            if (projection && projection.layout) {\n                var _a = projection.layout.actual[axis], min = _a.min, max = _a.max;\n                axisValue.set(point[axis] - mix(min, max, 0.5));\n            }\n        });\n    };\n    /**\n     * When the viewport resizes we want to check if the measured constraints\n     * have changed and, if so, reposition the element within those new constraints\n     * relative to where it was before the resize.\n     */\n    VisualElementDragControls.prototype.scalePositionWithinConstraints = function () {\n        var _this = this;\n        var _a;\n        var _b = this.getProps(), drag = _b.drag, dragConstraints = _b.dragConstraints;\n        var projection = this.visualElement.projection;\n        if (!isRefObject(dragConstraints) || !projection || !this.constraints)\n            return;\n        /**\n         * Stop current animations as there can be visual glitching if we try to do\n         * this mid-animation\n         */\n        this.stopAnimation();\n        /**\n         * Record the relative position of the dragged element relative to the\n         * constraints box and save as a progress value.\n         */\n        var boxProgress = { x: 0, y: 0 };\n        eachAxis(function (axis) {\n            var axisValue = _this.getAxisMotionValue(axis);\n            if (axisValue) {\n                var latest = axisValue.get();\n                boxProgress[axis] = constraints_calcOrigin({ min: latest, max: latest }, _this.constraints[axis]);\n            }\n        });\n        /**\n         * Update the layout of this element and resolve the latest drag constraints\n         */\n        var transformTemplate = this.visualElement.getProps().transformTemplate;\n        this.visualElement.getInstance().style.transform = transformTemplate\n            ? transformTemplate({}, "")\n            : "none";\n        (_a = projection.root) === null || _a === void 0 ? void 0 : _a.updateScroll();\n        projection.updateLayout();\n        this.resolveConstraints();\n        /**\n         * For each axis, calculate the current progress of the layout axis\n         * within the new constraints.\n         */\n        eachAxis(function (axis) {\n            if (!shouldDrag(axis, drag, null))\n                return;\n            /**\n             * Calculate a new transform based on the previous box progress\n             */\n            var axisValue = _this.getAxisMotionValue(axis);\n            var _a = _this.constraints[axis], min = _a.min, max = _a.max;\n            axisValue.set(mix(min, max, boxProgress[axis]));\n        });\n    };\n    VisualElementDragControls.prototype.addListeners = function () {\n        var _this = this;\n        var _a;\n        elementDragControls.set(this.visualElement, this);\n        var element = this.visualElement.getInstance();\n        /**\n         * Attach a pointerdown event listener on this DOM element to initiate drag tracking.\n         */\n        var stopPointerListener = addPointerEvent(element, "pointerdown", function (event) {\n            var _a = _this.getProps(), drag = _a.drag, _b = _a.dragListener, dragListener = _b === void 0 ? true : _b;\n            drag && dragListener && _this.start(event);\n        });\n        var measureDragConstraints = function () {\n            var dragConstraints = _this.getProps().dragConstraints;\n            if (isRefObject(dragConstraints)) {\n                _this.constraints = _this.resolveRefConstraints();\n            }\n        };\n        var projection = this.visualElement.projection;\n        var stopMeasureLayoutListener = projection.addEventListener("measure", measureDragConstraints);\n        if (projection && !projection.layout) {\n            (_a = projection.root) === null || _a === void 0 ? void 0 : _a.updateScroll();\n            projection.updateLayout();\n        }\n        measureDragConstraints();\n        /**\n         * Attach a window resize listener to scale the draggable target within its defined\n         * constraints as the window resizes.\n         */\n        var stopResizeListener = addDomEvent(window, "resize", function () {\n            return _this.scalePositionWithinConstraints();\n        });\n        /**\n         * If the element\'s layout changes, calculate the delta and apply that to\n         * the drag gesture\'s origin point.\n         */\n        projection.addEventListener("didUpdate", (function (_a) {\n            var delta = _a.delta, hasLayoutChanged = _a.hasLayoutChanged;\n            if (_this.isDragging && hasLayoutChanged) {\n                eachAxis(function (axis) {\n                    var motionValue = _this.getAxisMotionValue(axis);\n                    if (!motionValue)\n                        return;\n                    _this.originPoint[axis] += delta[axis].translate;\n                    motionValue.set(motionValue.get() + delta[axis].translate);\n                });\n                _this.visualElement.syncRender();\n            }\n        }));\n        return function () {\n            stopResizeListener();\n            stopPointerListener();\n            stopMeasureLayoutListener();\n        };\n    };\n    VisualElementDragControls.prototype.getProps = function () {\n        var props = this.visualElement.getProps();\n        var _a = props.drag, drag = _a === void 0 ? false : _a, _b = props.dragDirectionLock, dragDirectionLock = _b === void 0 ? false : _b, _c = props.dragPropagation, dragPropagation = _c === void 0 ? false : _c, _d = props.dragConstraints, dragConstraints = _d === void 0 ? false : _d, _e = props.dragElastic, dragElastic = _e === void 0 ? defaultElastic : _e, _f = props.dragMomentum, dragMomentum = _f === void 0 ? true : _f;\n        return __assign(__assign({}, props), { drag: drag, dragDirectionLock: dragDirectionLock, dragPropagation: dragPropagation, dragConstraints: dragConstraints, dragElastic: dragElastic, dragMomentum: dragMomentum });\n    };\n    return VisualElementDragControls;\n}());\nfunction shouldDrag(direction, drag, currentDirection) {\n    return ((drag === true || drag === direction) &&\n        (currentDirection === null || currentDirection === direction));\n}\n/**\n * Based on an x/y offset determine the current drag direction. If both axis\' offsets are lower\n * than the provided threshold, return `null`.\n *\n * @param offset - The x/y offset from origin.\n * @param lockThreshold - (Optional) - the minimum absolute offset before we can determine a drag direction.\n */\nfunction getCurrentDirection(offset, lockThreshold) {\n    if (lockThreshold === void 0) { lockThreshold = 10; }\n    var direction = null;\n    if (Math.abs(offset.y) > lockThreshold) {\n        direction = "y";\n    }\n    else if (Math.abs(offset.x) > lockThreshold) {\n        direction = "x";\n    }\n    return direction;\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/gestures/drag/use-drag.mjs\n\n\n\n\n/**\n * A hook that allows an element to be dragged.\n *\n * @internal\n */\nfunction useDrag(props) {\n    var groupDragControls = props.dragControls, visualElement = props.visualElement;\n    var dragControls = useConstant(function () { return new VisualElementDragControls(visualElement); });\n    // If we\'ve been provided a DragControls for manual control over the drag gesture,\n    // subscribe this component to it on mount.\n    (0,index_js_.useEffect)(function () { return groupDragControls && groupDragControls.subscribe(dragControls); }, [dragControls, groupDragControls]);\n    // Apply the event listeners to the element\n    (0,index_js_.useEffect)(function () { return dragControls.addListeners(); }, [dragControls]);\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/gestures/use-pan-gesture.mjs\n\n\n\n\n\n\n/**\n *\n * @param handlers -\n * @param ref -\n *\n * @privateRemarks\n * Currently this sets new pan gesture functions every render. The memo route has been explored\n * in the past but ultimately we\'re still creating new functions every render. An optimisation\n * to explore is creating the pan gestures and loading them into a `ref`.\n *\n * @internal\n */\nfunction usePanGesture(_a) {\n    var onPan = _a.onPan, onPanStart = _a.onPanStart, onPanEnd = _a.onPanEnd, onPanSessionStart = _a.onPanSessionStart, visualElement = _a.visualElement;\n    var hasPanEvents = onPan || onPanStart || onPanEnd || onPanSessionStart;\n    var panSession = (0,index_js_.useRef)(null);\n    var transformPagePoint = (0,index_js_.useContext)(MotionConfigContext).transformPagePoint;\n    var handlers = {\n        onSessionStart: onPanSessionStart,\n        onStart: onPanStart,\n        onMove: onPan,\n        onEnd: function (event, info) {\n            panSession.current = null;\n            onPanEnd && onPanEnd(event, info);\n        },\n    };\n    (0,index_js_.useEffect)(function () {\n        if (panSession.current !== null) {\n            panSession.current.updateHandlers(handlers);\n        }\n    });\n    function onPointerDown(event) {\n        panSession.current = new PanSession(event, handlers, {\n            transformPagePoint: transformPagePoint,\n        });\n    }\n    usePointerEvent(visualElement, "pointerdown", hasPanEvents && onPointerDown);\n    useUnmountEffect(function () { return panSession.current && panSession.current.end(); });\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/motion/features/drag.mjs\n\n\n\n\nvar drag = {\n    pan: makeRenderlessComponent(usePanGesture),\n    drag: makeRenderlessComponent(useDrag),\n};\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/render/utils/lifecycles.mjs\n\n\n\nvar names = [\n    "LayoutMeasure",\n    "BeforeLayoutMeasure",\n    "LayoutUpdate",\n    "ViewportBoxUpdate",\n    "Update",\n    "Render",\n    "AnimationComplete",\n    "LayoutAnimationComplete",\n    "AnimationStart",\n    "LayoutAnimationStart",\n    "SetAxisTarget",\n    "Unmount",\n];\nfunction createLifecycles() {\n    var managers = names.map(function () { return new SubscriptionManager(); });\n    var propSubscriptions = {};\n    var lifecycles = {\n        clearAllListeners: function () { return managers.forEach(function (manager) { return manager.clear(); }); },\n        updatePropListeners: function (props) {\n            names.forEach(function (name) {\n                var _a;\n                var on = "on" + name;\n                var propListener = props[on];\n                // Unsubscribe existing subscription\n                (_a = propSubscriptions[name]) === null || _a === void 0 ? void 0 : _a.call(propSubscriptions);\n                // Add new subscription\n                if (propListener) {\n                    propSubscriptions[name] = lifecycles[on](propListener);\n                }\n            });\n        },\n    };\n    managers.forEach(function (manager, i) {\n        lifecycles["on" + names[i]] = function (handler) { return manager.add(handler); };\n        lifecycles["notify" + names[i]] = function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            return manager.notify.apply(manager, __spreadArray([], __read(args), false));\n        };\n    });\n    return lifecycles;\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/render/utils/motion-values.mjs\n\n\n\n\nfunction updateMotionValuesFromProps(element, next, prev) {\n    var _a;\n    for (var key in next) {\n        var nextValue = next[key];\n        var prevValue = prev[key];\n        if (isMotionValue(nextValue)) {\n            /**\n             * If this is a motion value found in props or style, we want to add it\n             * to our visual element\'s motion value map.\n             */\n            element.addValue(key, nextValue);\n            /**\n             * Check the version of the incoming motion value with this version\n             * and warn against mismatches.\n             */\n            if (false) {}\n        }\n        else if (isMotionValue(prevValue)) {\n            /**\n             * If we\'re swapping to a new motion value, create a new motion value\n             * from that\n             */\n            element.addValue(key, motionValue(nextValue));\n        }\n        else if (prevValue !== nextValue) {\n            /**\n             * If this is a flat value that has changed, update the motion value\n             * or create one if it doesn\'t exist. We only want to do this if we\'re\n             * not handling the value with our animation state.\n             */\n            if (element.hasValue(key)) {\n                var existingValue = element.getValue(key);\n                // TODO: Only update values that aren\'t being animated or even looked at\n                !existingValue.hasAnimated && existingValue.set(nextValue);\n            }\n            else {\n                element.addValue(key, motionValue((_a = element.getStaticValue(key)) !== null && _a !== void 0 ? _a : nextValue));\n            }\n        }\n    }\n    // Handle removed values\n    for (var key in prev) {\n        if (next[key] === undefined)\n            element.removeValue(key);\n    }\n    return next;\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/render/index.mjs\n\n\n\n\n\n\n\n\n\nvar visualElement = function (_a) {\n    var _b = _a.treeType, treeType = _b === void 0 ? "" : _b, build = _a.build, getBaseTarget = _a.getBaseTarget, makeTargetAnimatable = _a.makeTargetAnimatable, measureViewportBox = _a.measureViewportBox, renderInstance = _a.render, readValueFromInstance = _a.readValueFromInstance, removeValueFromRenderState = _a.removeValueFromRenderState, sortNodePosition = _a.sortNodePosition, scrapeMotionValuesFromProps = _a.scrapeMotionValuesFromProps;\n    return function (_a, options) {\n        var parent = _a.parent, props = _a.props, presenceId = _a.presenceId, blockInitialAnimation = _a.blockInitialAnimation, visualState = _a.visualState, shouldReduceMotion = _a.shouldReduceMotion;\n        if (options === void 0) { options = {}; }\n        var isMounted = false;\n        var latestValues = visualState.latestValues, renderState = visualState.renderState;\n        /**\n         * The instance of the render-specific node that will be hydrated by the\n         * exposed React ref. So for example, this visual element can host a\n         * HTMLElement, plain object, or Three.js object. The functions provided\n         * in VisualElementConfig allow us to interface with this instance.\n         */\n        var instance;\n        /**\n         * Manages the subscriptions for a visual element\'s lifecycle, for instance\n         * onRender\n         */\n        var lifecycles = createLifecycles();\n        /**\n         * A map of all motion values attached to this visual element. Motion\n         * values are source of truth for any given animated value. A motion\n         * value might be provided externally by the component via props.\n         */\n        var values = new Map();\n        /**\n         * A map of every subscription that binds the provided or generated\n         * motion values onChange listeners to this visual element.\n         */\n        var valueSubscriptions = new Map();\n        /**\n         * A reference to the previously-provided motion values as returned\n         * from scrapeMotionValuesFromProps. We use the keys in here to determine\n         * if any motion values need to be removed after props are updated.\n         */\n        var prevMotionValues = {};\n        /**\n         * When values are removed from all animation props we need to search\n         * for a fallback value to animate to. These values are tracked in baseTarget.\n         */\n        var baseTarget = __assign({}, latestValues);\n        // Internal methods ========================\n        /**\n         * On mount, this will be hydrated with a callback to disconnect\n         * this visual element from its parent on unmount.\n         */\n        var removeFromVariantTree;\n        /**\n         * Render the element with the latest styles outside of the React\n         * render lifecycle\n         */\n        function render() {\n            if (!instance || !isMounted)\n                return;\n            triggerBuild();\n            renderInstance(instance, renderState, props.style, element.projection);\n        }\n        function triggerBuild() {\n            build(element, renderState, latestValues, options, props);\n        }\n        function update() {\n            lifecycles.notifyUpdate(latestValues);\n        }\n        /**\n         *\n         */\n        function bindToMotionValue(key, value) {\n            var removeOnChange = value.onChange(function (latestValue) {\n                latestValues[key] = latestValue;\n                props.onUpdate && es.update(update, false, true);\n            });\n            var removeOnRenderRequest = value.onRenderRequest(element.scheduleRender);\n            valueSubscriptions.set(key, function () {\n                removeOnChange();\n                removeOnRenderRequest();\n            });\n        }\n        /**\n         * Any motion values that are provided to the element when created\n         * aren\'t yet bound to the element, as this would technically be impure.\n         * However, we iterate through the motion values and set them to the\n         * initial values for this component.\n         *\n         * TODO: This is impure and we should look at changing this to run on mount.\n         * Doing so will break some tests but this isn\'t neccessarily a breaking change,\n         * more a reflection of the test.\n         */\n        var initialMotionValues = scrapeMotionValuesFromProps(props);\n        for (var key in initialMotionValues) {\n            var value = initialMotionValues[key];\n            if (latestValues[key] !== undefined && isMotionValue(value)) {\n                value.set(latestValues[key], false);\n            }\n        }\n        /**\n         * Determine what role this visual element should take in the variant tree.\n         */\n        var isControllingVariants = checkIfControllingVariants(props);\n        var isVariantNode = checkIfVariantNode(props);\n        var element = __assign(__assign({ treeType: treeType, \n            /**\n             * This is a mirror of the internal instance prop, which keeps\n             * VisualElement type-compatible with React\'s RefObject.\n             */\n            current: null, \n            /**\n             * The depth of this visual element within the visual element tree.\n             */\n            depth: parent ? parent.depth + 1 : 0, parent: parent, children: new Set(), \n            /**\n             *\n             */\n            presenceId: presenceId, shouldReduceMotion: shouldReduceMotion, \n            /**\n             * If this component is part of the variant tree, it should track\n             * any children that are also part of the tree. This is essentially\n             * a shadow tree to simplify logic around how to stagger over children.\n             */\n            variantChildren: isVariantNode ? new Set() : undefined, \n            /**\n             * Whether this instance is visible. This can be changed imperatively\n             * by the projection tree, is analogous to CSS\'s visibility in that\n             * hidden elements should take up layout, and needs enacting by the configured\n             * render function.\n             */\n            isVisible: undefined, \n            /**\n             * Normally, if a component is controlled by a parent\'s variants, it can\n             * rely on that ancestor to trigger animations further down the tree.\n             * However, if a component is created after its parent is mounted, the parent\n             * won\'t trigger that mount animation so the child needs to.\n             *\n             * TODO: This might be better replaced with a method isParentMounted\n             */\n            manuallyAnimateOnMount: Boolean(parent === null || parent === void 0 ? void 0 : parent.isMounted()), \n            /**\n             * This can be set by AnimatePresence to force components that mount\n             * at the same time as it to mount as if they have initial={false} set.\n             */\n            blockInitialAnimation: blockInitialAnimation, \n            /**\n             * Determine whether this component has mounted yet. This is mostly used\n             * by variant children to determine whether they need to trigger their\n             * own animations on mount.\n             */\n            isMounted: function () { return Boolean(instance); }, mount: function (newInstance) {\n                isMounted = true;\n                instance = element.current = newInstance;\n                if (element.projection) {\n                    element.projection.mount(newInstance);\n                }\n                if (isVariantNode && parent && !isControllingVariants) {\n                    removeFromVariantTree = parent === null || parent === void 0 ? void 0 : parent.addVariantChild(element);\n                }\n                values.forEach(function (value, key) { return bindToMotionValue(key, value); });\n                parent === null || parent === void 0 ? void 0 : parent.children.add(element);\n                element.setProps(props);\n            }, \n            /**\n             *\n             */\n            unmount: function () {\n                var _a;\n                (_a = element.projection) === null || _a === void 0 ? void 0 : _a.unmount();\n                cancelSync.update(update);\n                cancelSync.render(render);\n                valueSubscriptions.forEach(function (remove) { return remove(); });\n                removeFromVariantTree === null || removeFromVariantTree === void 0 ? void 0 : removeFromVariantTree();\n                parent === null || parent === void 0 ? void 0 : parent.children.delete(element);\n                lifecycles.clearAllListeners();\n                instance = undefined;\n                isMounted = false;\n            }, \n            /**\n             * Add a child visual element to our set of children.\n             */\n            addVariantChild: function (child) {\n                var _a;\n                var closestVariantNode = element.getClosestVariantNode();\n                if (closestVariantNode) {\n                    (_a = closestVariantNode.variantChildren) === null || _a === void 0 ? void 0 : _a.add(child);\n                    return function () {\n                        return closestVariantNode.variantChildren.delete(child);\n                    };\n                }\n            }, sortNodePosition: function (other) {\n                /**\n                 * If these nodes aren\'t even of the same type we can\'t compare their depth.\n                 */\n                if (!sortNodePosition || treeType !== other.treeType)\n                    return 0;\n                return sortNodePosition(element.getInstance(), other.getInstance());\n            }, \n            /**\n             * Returns the closest variant node in the tree starting from\n             * this visual element.\n             */\n            getClosestVariantNode: function () {\n                return isVariantNode ? element : parent === null || parent === void 0 ? void 0 : parent.getClosestVariantNode();\n            }, \n            /**\n             * Expose the latest layoutId prop.\n             */\n            getLayoutId: function () { return props.layoutId; }, \n            /**\n             * Returns the current instance.\n             */\n            getInstance: function () { return instance; }, \n            /**\n             * Get/set the latest static values.\n             */\n            getStaticValue: function (key) { return latestValues[key]; }, setStaticValue: function (key, value) { return (latestValues[key] = value); }, \n            /**\n             * Returns the latest motion value state. Currently only used to take\n             * a snapshot of the visual element - perhaps this can return the whole\n             * visual state\n             */\n            getLatestValues: function () { return latestValues; }, \n            /**\n             * Set the visiblity of the visual element. If it\'s changed, schedule\n             * a render to reflect these changes.\n             */\n            setVisibility: function (visibility) {\n                if (element.isVisible === visibility)\n                    return;\n                element.isVisible = visibility;\n                element.scheduleRender();\n            }, \n            /**\n             * Make a target animatable by Popmotion. For instance, if we\'re\n             * trying to animate width from 100px to 100vw we need to measure 100vw\n             * in pixels to determine what we really need to animate to. This is also\n             * pluggable to support Framer\'s custom value types like Color,\n             * and CSS variables.\n             */\n            makeTargetAnimatable: function (target, canMutate) {\n                if (canMutate === void 0) { canMutate = true; }\n                return makeTargetAnimatable(element, target, props, canMutate);\n            }, \n            /**\n             * Measure the current viewport box with or without transforms.\n             * Only measures axis-aligned boxes, rotate and skew must be manually\n             * removed with a re-render to work.\n             */\n            measureViewportBox: function () {\n                return measureViewportBox(instance, props);\n            }, \n            // Motion values ========================\n            /**\n             * Add a motion value and bind it to this visual element.\n             */\n            addValue: function (key, value) {\n                // Remove existing value if it exists\n                if (element.hasValue(key))\n                    element.removeValue(key);\n                values.set(key, value);\n                latestValues[key] = value.get();\n                bindToMotionValue(key, value);\n            }, \n            /**\n             * Remove a motion value and unbind any active subscriptions.\n             */\n            removeValue: function (key) {\n                var _a;\n                values.delete(key);\n                (_a = valueSubscriptions.get(key)) === null || _a === void 0 ? void 0 : _a();\n                valueSubscriptions.delete(key);\n                delete latestValues[key];\n                removeValueFromRenderState(key, renderState);\n            }, \n            /**\n             * Check whether we have a motion value for this key\n             */\n            hasValue: function (key) { return values.has(key); }, \n            /**\n             * Get a motion value for this key. If called with a default\n             * value, we\'ll create one if none exists.\n             */\n            getValue: function (key, defaultValue) {\n                var value = values.get(key);\n                if (value === undefined && defaultValue !== undefined) {\n                    value = motionValue(defaultValue);\n                    element.addValue(key, value);\n                }\n                return value;\n            }, \n            /**\n             * Iterate over our motion values.\n             */\n            forEachValue: function (callback) { return values.forEach(callback); }, \n            /**\n             * If we\'re trying to animate to a previously unencountered value,\n             * we need to check for it in our state and as a last resort read it\n             * directly from the instance (which might have performance implications).\n             */\n            readValue: function (key) {\n                var _a;\n                return (_a = latestValues[key]) !== null && _a !== void 0 ? _a : readValueFromInstance(instance, key, options);\n            }, \n            /**\n             * Set the base target to later animate back to. This is currently\n             * only hydrated on creation and when we first read a value.\n             */\n            setBaseTarget: function (key, value) {\n                baseTarget[key] = value;\n            }, \n            /**\n             * Find the base target for a value thats been removed from all animation\n             * props.\n             */\n            getBaseTarget: function (key) {\n                if (getBaseTarget) {\n                    var target = getBaseTarget(props, key);\n                    if (target !== undefined && !isMotionValue(target))\n                        return target;\n                }\n                return baseTarget[key];\n            } }, lifecycles), { \n            /**\n             * Build the renderer state based on the latest visual state.\n             */\n            build: function () {\n                triggerBuild();\n                return renderState;\n            }, \n            /**\n             * Schedule a render on the next animation frame.\n             */\n            scheduleRender: function () {\n                es.render(render, false, true);\n            }, \n            /**\n             * Synchronously fire render. It\'s prefered that we batch renders but\n             * in many circumstances, like layout measurement, we need to run this\n             * synchronously. However in those instances other measures should be taken\n             * to batch reads/writes.\n             */\n            syncRender: render, \n            /**\n             * Update the provided props. Ensure any newly-added motion values are\n             * added to our map, old ones removed, and listeners updated.\n             */\n            setProps: function (newProps) {\n                if (newProps.transformTemplate || props.transformTemplate) {\n                    element.scheduleRender();\n                }\n                props = newProps;\n                lifecycles.updatePropListeners(newProps);\n                prevMotionValues = updateMotionValuesFromProps(element, scrapeMotionValuesFromProps(props), prevMotionValues);\n            }, getProps: function () { return props; }, \n            // Variants ==============================\n            /**\n             * Returns the variant definition with a given name.\n             */\n            getVariant: function (name) { var _a; return (_a = props.variants) === null || _a === void 0 ? void 0 : _a[name]; }, \n            /**\n             * Returns the defined default transition on this component.\n             */\n            getDefaultTransition: function () { return props.transition; }, getTransformPagePoint: function () {\n                return props.transformPagePoint;\n            }, \n            /**\n             * Used by child variant nodes to get the closest ancestor variant props.\n             */\n            getVariantContext: function (startAtParent) {\n                if (startAtParent === void 0) { startAtParent = false; }\n                if (startAtParent)\n                    return parent === null || parent === void 0 ? void 0 : parent.getVariantContext();\n                if (!isControllingVariants) {\n                    var context_1 = (parent === null || parent === void 0 ? void 0 : parent.getVariantContext()) || {};\n                    if (props.initial !== undefined) {\n                        context_1.initial = props.initial;\n                    }\n                    return context_1;\n                }\n                var context = {};\n                for (var i = 0; i < numVariantProps; i++) {\n                    var name_1 = variantProps[i];\n                    var prop = props[name_1];\n                    if (isVariantLabel(prop) || prop === false) {\n                        context[name_1] = prop;\n                    }\n                }\n                return context;\n            } });\n        return element;\n    };\n};\nvar variantProps = __spreadArray(["initial"], __read(variantPriorityOrder), false);\nvar numVariantProps = variantProps.length;\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/render/dom/utils/css-variables-conversion.mjs\n\n\n\nfunction css_variables_conversion_isCSSVariable(value) {\n    return typeof value === "string" && value.startsWith("var(--");\n}\n/**\n * Parse Framer\'s special CSS variable format into a CSS token and a fallback.\n *\n * ```\n * `var(--foo, #fff)` => [`--foo`, \'#fff\']\n * ```\n *\n * @param current\n */\nvar cssVariableRegex = /var\\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\\)/;\nfunction parseCSSVariable(current) {\n    var match = cssVariableRegex.exec(current);\n    if (!match)\n        return [,];\n    var _a = __read(match, 3), token = _a[1], fallback = _a[2];\n    return [token, fallback];\n}\nvar maxDepth = 4;\nfunction getVariableValue(current, element, depth) {\n    if (depth === void 0) { depth = 1; }\n    invariant(depth <= maxDepth, "Max CSS variable fallback depth detected in property \\"".concat(current, "\\". This may indicate a circular fallback dependency."));\n    var _a = __read(parseCSSVariable(current), 2), token = _a[0], fallback = _a[1];\n    // No CSS variable detected\n    if (!token)\n        return;\n    // Attempt to read this CSS variable off the element\n    var resolved = window.getComputedStyle(element).getPropertyValue(token);\n    if (resolved) {\n        return resolved.trim();\n    }\n    else if (css_variables_conversion_isCSSVariable(fallback)) {\n        // The fallback might itself be a CSS variable, in which case we attempt to resolve it too.\n        return getVariableValue(fallback, element, depth + 1);\n    }\n    else {\n        return fallback;\n    }\n}\n/**\n * Resolve CSS variables from\n *\n * @internal\n */\nfunction resolveCSSVariables(visualElement, _a, transitionEnd) {\n    var _b;\n    var target = __rest(_a, []);\n    var element = visualElement.getInstance();\n    if (!(element instanceof Element))\n        return { target: target, transitionEnd: transitionEnd };\n    // If `transitionEnd` isn\'t `undefined`, clone it. We could clone `target` and `transitionEnd`\n    // only if they change but I think this reads clearer and this isn\'t a performance-critical path.\n    if (transitionEnd) {\n        transitionEnd = __assign({}, transitionEnd);\n    }\n    // Go through existing `MotionValue`s and ensure any existing CSS variables are resolved\n    visualElement.forEachValue(function (value) {\n        var current = value.get();\n        if (!css_variables_conversion_isCSSVariable(current))\n            return;\n        var resolved = getVariableValue(current, element);\n        if (resolved)\n            value.set(resolved);\n    });\n    // Cycle through every target property and resolve CSS variables. Currently\n    // we only read single-var properties like `var(--foo)`, not `calc(var(--foo) + 20px)`\n    for (var key in target) {\n        var current = target[key];\n        if (!css_variables_conversion_isCSSVariable(current))\n            continue;\n        var resolved = getVariableValue(current, element);\n        if (!resolved)\n            continue;\n        // Clone target if it hasn\'t already been\n        target[key] = resolved;\n        // If the user hasn\'t already set this key on `transitionEnd`, set it to the unresolved\n        // CSS variable. This will ensure that after the animation the component will reflect\n        // changes in the value of the CSS variable.\n        if (transitionEnd)\n            (_b = transitionEnd[key]) !== null && _b !== void 0 ? _b : (transitionEnd[key] = current);\n    }\n    return { target: target, transitionEnd: transitionEnd };\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/render/dom/utils/unit-conversion.mjs\n\n\n\n\n\n\n\nvar positionalKeys = new Set([\n    "width",\n    "height",\n    "top",\n    "left",\n    "right",\n    "bottom",\n    "x",\n    "y",\n]);\nvar isPositionalKey = function (key) { return positionalKeys.has(key); };\nvar hasPositionalKey = function (target) {\n    return Object.keys(target).some(isPositionalKey);\n};\nvar setAndResetVelocity = function (value, to) {\n    // Looks odd but setting it twice doesn\'t render, it\'ll just\n    // set both prev and current to the latest value\n    value.set(to, false);\n    value.set(to);\n};\nvar isNumOrPxType = function (v) {\n    return v === number || v === px;\n};\nvar BoundingBoxDimension;\n(function (BoundingBoxDimension) {\n    BoundingBoxDimension["width"] = "width";\n    BoundingBoxDimension["height"] = "height";\n    BoundingBoxDimension["left"] = "left";\n    BoundingBoxDimension["right"] = "right";\n    BoundingBoxDimension["top"] = "top";\n    BoundingBoxDimension["bottom"] = "bottom";\n})(BoundingBoxDimension || (BoundingBoxDimension = {}));\nvar getPosFromMatrix = function (matrix, pos) {\n    return parseFloat(matrix.split(", ")[pos]);\n};\nvar getTranslateFromMatrix = function (pos2, pos3) {\n    return function (_bbox, _a) {\n        var transform = _a.transform;\n        if (transform === "none" || !transform)\n            return 0;\n        var matrix3d = transform.match(/^matrix3d\\((.+)\\)$/);\n        if (matrix3d) {\n            return getPosFromMatrix(matrix3d[1], pos3);\n        }\n        else {\n            var matrix = transform.match(/^matrix\\((.+)\\)$/);\n            if (matrix) {\n                return getPosFromMatrix(matrix[1], pos2);\n            }\n            else {\n                return 0;\n            }\n        }\n    };\n};\nvar transformKeys = new Set(["x", "y", "z"]);\nvar nonTranslationalTransformKeys = transformProps.filter(function (key) { return !transformKeys.has(key); });\nfunction removeNonTranslationalTransform(visualElement) {\n    var removedTransforms = [];\n    nonTranslationalTransformKeys.forEach(function (key) {\n        var value = visualElement.getValue(key);\n        if (value !== undefined) {\n            removedTransforms.push([key, value.get()]);\n            value.set(key.startsWith("scale") ? 1 : 0);\n        }\n    });\n    // Apply changes to element before measurement\n    if (removedTransforms.length)\n        visualElement.syncRender();\n    return removedTransforms;\n}\nvar positionalValues = {\n    // Dimensions\n    width: function (_a, _b) {\n        var x = _a.x;\n        var _c = _b.paddingLeft, paddingLeft = _c === void 0 ? "0" : _c, _d = _b.paddingRight, paddingRight = _d === void 0 ? "0" : _d;\n        return x.max - x.min - parseFloat(paddingLeft) - parseFloat(paddingRight);\n    },\n    height: function (_a, _b) {\n        var y = _a.y;\n        var _c = _b.paddingTop, paddingTop = _c === void 0 ? "0" : _c, _d = _b.paddingBottom, paddingBottom = _d === void 0 ? "0" : _d;\n        return y.max - y.min - parseFloat(paddingTop) - parseFloat(paddingBottom);\n    },\n    top: function (_bbox, _a) {\n        var top = _a.top;\n        return parseFloat(top);\n    },\n    left: function (_bbox, _a) {\n        var left = _a.left;\n        return parseFloat(left);\n    },\n    bottom: function (_a, _b) {\n        var y = _a.y;\n        var top = _b.top;\n        return parseFloat(top) + (y.max - y.min);\n    },\n    right: function (_a, _b) {\n        var x = _a.x;\n        var left = _b.left;\n        return parseFloat(left) + (x.max - x.min);\n    },\n    // Transform\n    x: getTranslateFromMatrix(4, 13),\n    y: getTranslateFromMatrix(5, 14),\n};\nvar convertChangedValueTypes = function (target, visualElement, changedKeys) {\n    var originBbox = visualElement.measureViewportBox();\n    var element = visualElement.getInstance();\n    var elementComputedStyle = getComputedStyle(element);\n    var display = elementComputedStyle.display;\n    var origin = {};\n    // If the element is currently set to display: "none", make it visible before\n    // measuring the target bounding box\n    if (display === "none") {\n        visualElement.setStaticValue("display", target.display || "block");\n    }\n    /**\n     * Record origins before we render and update styles\n     */\n    changedKeys.forEach(function (key) {\n        origin[key] = positionalValues[key](originBbox, elementComputedStyle);\n    });\n    // Apply the latest values (as set in checkAndConvertChangedValueTypes)\n    visualElement.syncRender();\n    var targetBbox = visualElement.measureViewportBox();\n    changedKeys.forEach(function (key) {\n        // Restore styles to their **calculated computed style**, not their actual\n        // originally set style. This allows us to animate between equivalent pixel units.\n        var value = visualElement.getValue(key);\n        setAndResetVelocity(value, origin[key]);\n        target[key] = positionalValues[key](targetBbox, elementComputedStyle);\n    });\n    return target;\n};\nvar checkAndConvertChangedValueTypes = function (visualElement, target, origin, transitionEnd) {\n    if (origin === void 0) { origin = {}; }\n    if (transitionEnd === void 0) { transitionEnd = {}; }\n    target = __assign({}, target);\n    transitionEnd = __assign({}, transitionEnd);\n    var targetPositionalKeys = Object.keys(target).filter(isPositionalKey);\n    // We want to remove any transform values that could affect the element\'s bounding box before\n    // it\'s measured. We\'ll reapply these later.\n    var removedTransformValues = [];\n    var hasAttemptedToRemoveTransformValues = false;\n    var changedValueTypeKeys = [];\n    targetPositionalKeys.forEach(function (key) {\n        var value = visualElement.getValue(key);\n        if (!visualElement.hasValue(key))\n            return;\n        var from = origin[key];\n        var fromType = findDimensionValueType(from);\n        var to = target[key];\n        var toType;\n        // TODO: The current implementation of this basically throws an error\n        // if you try and do value conversion via keyframes. There\'s probably\n        // a way of doing this but the performance implications would need greater scrutiny,\n        // as it\'d be doing multiple resize-remeasure operations.\n        if (isKeyframesTarget(to)) {\n            var numKeyframes = to.length;\n            var fromIndex = to[0] === null ? 1 : 0;\n            from = to[fromIndex];\n            fromType = findDimensionValueType(from);\n            for (var i = fromIndex; i < numKeyframes; i++) {\n                if (!toType) {\n                    toType = findDimensionValueType(to[i]);\n                    invariant(toType === fromType ||\n                        (isNumOrPxType(fromType) && isNumOrPxType(toType)), "Keyframes must be of the same dimension as the current value");\n                }\n                else {\n                    invariant(findDimensionValueType(to[i]) === toType, "All keyframes must be of the same type");\n                }\n            }\n        }\n        else {\n            toType = findDimensionValueType(to);\n        }\n        if (fromType !== toType) {\n            // If they\'re both just number or px, convert them both to numbers rather than\n            // relying on resize/remeasure to convert (which is wasteful in this situation)\n            if (isNumOrPxType(fromType) && isNumOrPxType(toType)) {\n                var current = value.get();\n                if (typeof current === "string") {\n                    value.set(parseFloat(current));\n                }\n                if (typeof to === "string") {\n                    target[key] = parseFloat(to);\n                }\n                else if (Array.isArray(to) && toType === px) {\n                    target[key] = to.map(parseFloat);\n                }\n            }\n            else if ((fromType === null || fromType === void 0 ? void 0 : fromType.transform) &&\n                (toType === null || toType === void 0 ? void 0 : toType.transform) &&\n                (from === 0 || to === 0)) {\n                // If one or the other value is 0, it\'s safe to coerce it to the\n                // type of the other without measurement\n                if (from === 0) {\n                    value.set(toType.transform(from));\n                }\n                else {\n                    target[key] = fromType.transform(to);\n                }\n            }\n            else {\n                // If we\'re going to do value conversion via DOM measurements, we first\n                // need to remove non-positional transform values that could affect the bbox measurements.\n                if (!hasAttemptedToRemoveTransformValues) {\n                    removedTransformValues =\n                        removeNonTranslationalTransform(visualElement);\n                    hasAttemptedToRemoveTransformValues = true;\n                }\n                changedValueTypeKeys.push(key);\n                transitionEnd[key] =\n                    transitionEnd[key] !== undefined\n                        ? transitionEnd[key]\n                        : target[key];\n                setAndResetVelocity(value, to);\n            }\n        }\n    });\n    if (changedValueTypeKeys.length) {\n        var scrollY_1 = changedValueTypeKeys.indexOf("height") >= 0\n            ? window.pageYOffset\n            : null;\n        var convertedTarget = convertChangedValueTypes(target, visualElement, changedValueTypeKeys);\n        // If we removed transform values, reapply them before the next render\n        if (removedTransformValues.length) {\n            removedTransformValues.forEach(function (_a) {\n                var _b = __read(_a, 2), key = _b[0], value = _b[1];\n                visualElement.getValue(key).set(value);\n            });\n        }\n        // Reapply original values\n        visualElement.syncRender();\n        // Restore scroll position\n        if (scrollY_1 !== null)\n            window.scrollTo({ top: scrollY_1 });\n        return { target: convertedTarget, transitionEnd: transitionEnd };\n    }\n    else {\n        return { target: target, transitionEnd: transitionEnd };\n    }\n};\n/**\n * Convert value types for x/y/width/height/top/left/bottom/right\n *\n * Allows animation between `\'auto\'` -> `\'100%\'` or `0` -> `\'calc(50% - 10vw)\'`\n *\n * @internal\n */\nfunction unitConversion(visualElement, target, origin, transitionEnd) {\n    return hasPositionalKey(target)\n        ? checkAndConvertChangedValueTypes(visualElement, target, origin, transitionEnd)\n        : { target: target, transitionEnd: transitionEnd };\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/render/dom/utils/parse-dom-variant.mjs\n\n\n\n/**\n * Parse a DOM variant to make it animatable. This involves resolving CSS variables\n * and ensuring animations like "20%" => "calc(50vw)" are performed in pixels.\n */\nvar parseDomVariant = function (visualElement, target, origin, transitionEnd) {\n    var resolved = resolveCSSVariables(visualElement, target, transitionEnd);\n    target = resolved.target;\n    transitionEnd = resolved.transitionEnd;\n    return unitConversion(visualElement, target, origin, transitionEnd);\n};\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/render/html/visual-element.mjs\n\n\n\n\n\n\n\n\n\n\n\n\nfunction visual_element_getComputedStyle(element) {\n    return window.getComputedStyle(element);\n}\nvar htmlConfig = {\n    treeType: "dom",\n    readValueFromInstance: function (domElement, key) {\n        if (isTransformProp(key)) {\n            var defaultType = getDefaultValueType(key);\n            return defaultType ? defaultType.default || 0 : 0;\n        }\n        else {\n            var computedStyle = visual_element_getComputedStyle(domElement);\n            return ((isCSSVariable(key)\n                ? computedStyle.getPropertyValue(key)\n                : computedStyle[key]) || 0);\n        }\n    },\n    sortNodePosition: function (a, b) {\n        /**\n         * compareDocumentPosition returns a bitmask, by using the bitwise &\n         * we\'re returning true if 2 in that bitmask is set to true. 2 is set\n         * to true if b preceeds a.\n         */\n        return a.compareDocumentPosition(b) & 2 ? 1 : -1;\n    },\n    getBaseTarget: function (props, key) {\n        var _a;\n        return (_a = props.style) === null || _a === void 0 ? void 0 : _a[key];\n    },\n    measureViewportBox: function (element, _a) {\n        var transformPagePoint = _a.transformPagePoint;\n        return measureViewportBox(element, transformPagePoint);\n    },\n    /**\n     * Reset the transform on the current Element. This is called as part\n     * of a batched process across the entire layout tree. To remove this write\n     * cycle it\'d be interesting to see if it\'s possible to "undo" all the current\n     * layout transforms up the tree in the same way this.getBoundingBoxWithoutTransforms\n     * works\n     */\n    resetTransform: function (element, domElement, props) {\n        var transformTemplate = props.transformTemplate;\n        domElement.style.transform = transformTemplate\n            ? transformTemplate({}, "")\n            : "none";\n        // Ensure that whatever happens next, we restore our transform on the next frame\n        element.scheduleRender();\n    },\n    restoreTransform: function (instance, mutableState) {\n        instance.style.transform = mutableState.style.transform;\n    },\n    removeValueFromRenderState: function (key, _a) {\n        var vars = _a.vars, style = _a.style;\n        delete vars[key];\n        delete style[key];\n    },\n    /**\n     * Ensure that HTML and Framer-specific value types like `px`->`%` and `Color`\n     * can be animated by Motion.\n     */\n    makeTargetAnimatable: function (element, _a, _b, isMounted) {\n        var transformValues = _b.transformValues;\n        if (isMounted === void 0) { isMounted = true; }\n        var transition = _a.transition, transitionEnd = _a.transitionEnd, target = __rest(_a, ["transition", "transitionEnd"]);\n        var origin = getOrigin(target, transition || {}, element);\n        /**\n         * If Framer has provided a function to convert `Color` etc value types, convert them\n         */\n        if (transformValues) {\n            if (transitionEnd)\n                transitionEnd = transformValues(transitionEnd);\n            if (target)\n                target = transformValues(target);\n            if (origin)\n                origin = transformValues(origin);\n        }\n        if (isMounted) {\n            checkTargetForNewValues(element, target, origin);\n            var parsed = parseDomVariant(element, target, origin, transitionEnd);\n            transitionEnd = parsed.transitionEnd;\n            target = parsed.target;\n        }\n        return __assign({ transition: transition, transitionEnd: transitionEnd }, target);\n    },\n    scrapeMotionValuesFromProps: scrapeMotionValuesFromProps,\n    build: function (element, renderState, latestValues, options, props) {\n        if (element.isVisible !== undefined) {\n            renderState.style.visibility = element.isVisible\n                ? "visible"\n                : "hidden";\n        }\n        buildHTMLStyles(renderState, latestValues, options, props.transformTemplate);\n    },\n    render: renderHTML,\n};\nvar htmlVisualElement = visualElement(htmlConfig);\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/render/svg/visual-element.mjs\n\n\n\n\n\n\n\n\n\n\n\nvar svgVisualElement = visualElement(__assign(__assign({}, htmlConfig), { getBaseTarget: function (props, key) {\n        return props[key];\n    }, readValueFromInstance: function (domElement, key) {\n        var _a;\n        if (isTransformProp(key)) {\n            return ((_a = getDefaultValueType(key)) === null || _a === void 0 ? void 0 : _a.default) || 0;\n        }\n        key = !camelCaseAttributes.has(key) ? camelToDash(key) : key;\n        return domElement.getAttribute(key);\n    }, scrapeMotionValuesFromProps: scrape_motion_values_scrapeMotionValuesFromProps, build: function (_element, renderState, latestValues, options, props) {\n        buildSVGAttrs(renderState, latestValues, options, props.transformTemplate);\n    }, render: renderSVG }));\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/render/dom/create-visual-element.mjs\n\n\n\n\nvar createDomVisualElement = function (Component, options) {\n    return isSVGComponent(Component)\n        ? svgVisualElement(options, { enableHardwareAcceleration: false })\n        : htmlVisualElement(options, { enableHardwareAcceleration: true });\n};\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/projection/styles/scale-border-radius.mjs\n\n\nfunction pixelsToPercent(pixels, axis) {\n    if (axis.max === axis.min)\n        return 0;\n    return (pixels / (axis.max - axis.min)) * 100;\n}\n/**\n * We always correct borderRadius as a percentage rather than pixels to reduce paints.\n * For example, if you are projecting a box that is 100px wide with a 10px borderRadius\n * into a box that is 200px wide with a 20px borderRadius, that is actually a 10%\n * borderRadius in both states. If we animate between the two in pixels that will trigger\n * a paint each time. If we animate between the two in percentage we\'ll avoid a paint.\n */\nvar correctBorderRadius = {\n    correct: function (latest, node) {\n        if (!node.target)\n            return latest;\n        /**\n         * If latest is a string, if it\'s a percentage we can return immediately as it\'s\n         * going to be stretched appropriately. Otherwise, if it\'s a pixel, convert it to a number.\n         */\n        if (typeof latest === "string") {\n            if (px.test(latest)) {\n                latest = parseFloat(latest);\n            }\n            else {\n                return latest;\n            }\n        }\n        /**\n         * If latest is a number, it\'s a pixel value. We use the current viewportBox to calculate that\n         * pixel value as a percentage of each axis\n         */\n        var x = pixelsToPercent(latest, node.target.x);\n        var y = pixelsToPercent(latest, node.target.y);\n        return "".concat(x, "% ").concat(y, "%");\n    },\n};\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/projection/styles/scale-box-shadow.mjs\n\n\n\n\nvar varToken = "_$css";\nvar correctBoxShadow = {\n    correct: function (latest, _a) {\n        var treeScale = _a.treeScale, projectionDelta = _a.projectionDelta;\n        var original = latest;\n        /**\n         * We need to first strip and store CSS variables from the string.\n         */\n        var containsCSSVariables = latest.includes("var(");\n        var cssVariables = [];\n        if (containsCSSVariables) {\n            latest = latest.replace(cssVariableRegex, function (match) {\n                cssVariables.push(match);\n                return varToken;\n            });\n        }\n        var shadow = complex.parse(latest);\n        // TODO: Doesn\'t support multiple shadows\n        if (shadow.length > 5)\n            return original;\n        var template = complex.createTransformer(latest);\n        var offset = typeof shadow[0] !== "number" ? 1 : 0;\n        // Calculate the overall context scale\n        var xScale = projectionDelta.x.scale * treeScale.x;\n        var yScale = projectionDelta.y.scale * treeScale.y;\n        shadow[0 + offset] /= xScale;\n        shadow[1 + offset] /= yScale;\n        /**\n         * Ideally we\'d correct x and y scales individually, but because blur and\n         * spread apply to both we have to take a scale average and apply that instead.\n         * We could potentially improve the outcome of this by incorporating the ratio between\n         * the two scales.\n         */\n        var averageScale = mix(xScale, yScale, 0.5);\n        // Blur\n        if (typeof shadow[2 + offset] === "number")\n            shadow[2 + offset] /= averageScale;\n        // Spread\n        if (typeof shadow[3 + offset] === "number")\n            shadow[3 + offset] /= averageScale;\n        var output = template(shadow);\n        if (containsCSSVariables) {\n            var i_1 = 0;\n            output = output.replace(varToken, function () {\n                var cssVariable = cssVariables[i_1];\n                i_1++;\n                return cssVariable;\n            });\n        }\n        return output;\n    },\n};\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/motion/features/layout/MeasureLayout.mjs\n\n\n\n\n\n\n\n\n\n\n\nvar MeasureLayoutWithContext = /** @class */ (function (_super) {\n    __extends(MeasureLayoutWithContext, _super);\n    function MeasureLayoutWithContext() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * This only mounts projection nodes for components that\n     * need measuring, we might want to do it for all components\n     * in order to incorporate transforms\n     */\n    MeasureLayoutWithContext.prototype.componentDidMount = function () {\n        var _this = this;\n        var _a = this.props, visualElement = _a.visualElement, layoutGroup = _a.layoutGroup, switchLayoutGroup = _a.switchLayoutGroup, layoutId = _a.layoutId;\n        var projection = visualElement.projection;\n        addScaleCorrector(defaultScaleCorrectors);\n        if (projection) {\n            if (layoutGroup === null || layoutGroup === void 0 ? void 0 : layoutGroup.group)\n                layoutGroup.group.add(projection);\n            if ((switchLayoutGroup === null || switchLayoutGroup === void 0 ? void 0 : switchLayoutGroup.register) && layoutId) {\n                switchLayoutGroup.register(projection);\n            }\n            projection.root.didUpdate();\n            projection.addEventListener("animationComplete", function () {\n                _this.safeToRemove();\n            });\n            projection.setOptions(__assign(__assign({}, projection.options), { onExitComplete: function () { return _this.safeToRemove(); } }));\n        }\n        globalProjectionState.hasEverUpdated = true;\n    };\n    MeasureLayoutWithContext.prototype.getSnapshotBeforeUpdate = function (prevProps) {\n        var _this = this;\n        var _a = this.props, layoutDependency = _a.layoutDependency, visualElement = _a.visualElement, drag = _a.drag, isPresent = _a.isPresent;\n        var projection = visualElement.projection;\n        if (!projection)\n            return null;\n        /**\n         * TODO: We use this data in relegate to determine whether to\n         * promote a previous element. There\'s no guarantee its presence data\n         * will have updated by this point - if a bug like this arises it will\n         * have to be that we markForRelegation and then find a new lead some other way,\n         * perhaps in didUpdate\n         */\n        projection.isPresent = isPresent;\n        if (drag ||\n            prevProps.layoutDependency !== layoutDependency ||\n            layoutDependency === undefined) {\n            projection.willUpdate();\n        }\n        else {\n            this.safeToRemove();\n        }\n        if (prevProps.isPresent !== isPresent) {\n            if (isPresent) {\n                projection.promote();\n            }\n            else if (!projection.relegate()) {\n                /**\n                 * If there\'s another stack member taking over from this one,\n                 * it\'s in charge of the exit animation and therefore should\n                 * be in charge of the safe to remove. Otherwise we call it here.\n                 */\n                es.postRender(function () {\n                    var _a;\n                    if (!((_a = projection.getStack()) === null || _a === void 0 ? void 0 : _a.members.length)) {\n                        _this.safeToRemove();\n                    }\n                });\n            }\n        }\n        return null;\n    };\n    MeasureLayoutWithContext.prototype.componentDidUpdate = function () {\n        var projection = this.props.visualElement.projection;\n        if (projection) {\n            projection.root.didUpdate();\n            if (!projection.currentAnimation && projection.isLead()) {\n                this.safeToRemove();\n            }\n        }\n    };\n    MeasureLayoutWithContext.prototype.componentWillUnmount = function () {\n        var _a = this.props, visualElement = _a.visualElement, layoutGroup = _a.layoutGroup, promoteContext = _a.switchLayoutGroup;\n        var projection = visualElement.projection;\n        if (projection) {\n            projection.scheduleCheckAfterUnmount();\n            if (layoutGroup === null || layoutGroup === void 0 ? void 0 : layoutGroup.group)\n                layoutGroup.group.remove(projection);\n            if (promoteContext === null || promoteContext === void 0 ? void 0 : promoteContext.deregister)\n                promoteContext.deregister(projection);\n        }\n    };\n    MeasureLayoutWithContext.prototype.safeToRemove = function () {\n        var safeToRemove = this.props.safeToRemove;\n        safeToRemove === null || safeToRemove === void 0 ? void 0 : safeToRemove();\n    };\n    MeasureLayoutWithContext.prototype.render = function () {\n        return null;\n    };\n    return MeasureLayoutWithContext;\n}(index_js_.Component));\nfunction MeasureLayout(props) {\n    var _a = __read(usePresence(), 2), isPresent = _a[0], safeToRemove = _a[1];\n    var layoutGroup = (0,index_js_.useContext)(LayoutGroupContext);\n    return (index_js_.createElement(MeasureLayoutWithContext, __assign({}, props, { layoutGroup: layoutGroup, switchLayoutGroup: (0,index_js_.useContext)(SwitchLayoutGroupContext), isPresent: isPresent, safeToRemove: safeToRemove })));\n}\nvar defaultScaleCorrectors = {\n    borderRadius: __assign(__assign({}, correctBorderRadius), { applyTo: [\n            "borderTopLeftRadius",\n            "borderTopRightRadius",\n            "borderBottomLeftRadius",\n            "borderBottomRightRadius",\n        ] }),\n    borderTopLeftRadius: correctBorderRadius,\n    borderTopRightRadius: correctBorderRadius,\n    borderBottomLeftRadius: correctBorderRadius,\n    borderBottomRightRadius: correctBorderRadius,\n    boxShadow: correctBoxShadow,\n};\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/motion/features/layout/index.mjs\n\n\nvar layoutFeatures = {\n    measureLayout: MeasureLayout,\n};\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/animation/animate.mjs\n\n\n\n\n/**\n * Animate a single value or a `MotionValue`.\n *\n * The first argument is either a `MotionValue` to animate, or an initial animation value.\n *\n * The second is either a value to animate to, or an array of keyframes to animate through.\n *\n * The third argument can be either tween or spring options, and optional lifecycle methods: `onUpdate`, `onPlay`, `onComplete`, `onRepeat` and `onStop`.\n *\n * Returns `AnimationPlaybackControls`, currently just a `stop` method.\n *\n * ```javascript\n * const x = useMotionValue(0)\n *\n * useEffect(() => {\n *   const controls = animate(x, 100, {\n *     type: "spring",\n *     stiffness: 2000,\n *     onComplete: v => {}\n *   })\n *\n *   return controls.stop\n * })\n * ```\n *\n * @public\n */\nfunction animate_animate(from, to, transition) {\n    if (transition === void 0) { transition = {}; }\n    var value = isMotionValue(from) ? from : motionValue(from);\n    startAnimation("", value, to, transition);\n    return {\n        stop: function () { return value.stop(); },\n        isAnimating: function () { return value.isAnimating(); },\n    };\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/projection/animation/mix-values.mjs\n\n\n\nvar borders = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"];\nvar numBorders = borders.length;\nvar asNumber = function (value) {\n    return typeof value === "string" ? parseFloat(value) : value;\n};\nvar isPx = function (value) {\n    return typeof value === "number" || px.test(value);\n};\nfunction mixValues(target, follow, lead, progress, shouldCrossfadeOpacity, isOnlyMember) {\n    var _a, _b, _c, _d;\n    if (shouldCrossfadeOpacity) {\n        target.opacity = mix(0, \n        // (follow?.opacity as number) ?? 0,\n        // TODO Reinstate this if only child\n        (_a = lead.opacity) !== null && _a !== void 0 ? _a : 1, easeCrossfadeIn(progress));\n        target.opacityExit = mix((_b = follow.opacity) !== null && _b !== void 0 ? _b : 1, 0, easeCrossfadeOut(progress));\n    }\n    else if (isOnlyMember) {\n        target.opacity = mix((_c = follow.opacity) !== null && _c !== void 0 ? _c : 1, (_d = lead.opacity) !== null && _d !== void 0 ? _d : 1, progress);\n    }\n    /**\n     * Mix border radius\n     */\n    for (var i = 0; i < numBorders; i++) {\n        var borderLabel = "border".concat(borders[i], "Radius");\n        var followRadius = getRadius(follow, borderLabel);\n        var leadRadius = getRadius(lead, borderLabel);\n        if (followRadius === undefined && leadRadius === undefined)\n            continue;\n        followRadius || (followRadius = 0);\n        leadRadius || (leadRadius = 0);\n        var canMix = followRadius === 0 ||\n            leadRadius === 0 ||\n            isPx(followRadius) === isPx(leadRadius);\n        if (canMix) {\n            target[borderLabel] = Math.max(mix(asNumber(followRadius), asNumber(leadRadius), progress), 0);\n            if (percent.test(leadRadius) || percent.test(followRadius)) {\n                target[borderLabel] += "%";\n            }\n        }\n        else {\n            target[borderLabel] = leadRadius;\n        }\n    }\n    /**\n     * Mix rotation\n     */\n    if (follow.rotate || lead.rotate) {\n        target.rotate = mix(follow.rotate || 0, lead.rotate || 0, progress);\n    }\n}\nfunction getRadius(values, radiusName) {\n    var _a;\n    return (_a = values[radiusName]) !== null && _a !== void 0 ? _a : values.borderRadius;\n}\n// /**\n//  * We only want to mix the background color if there\'s a follow element\n//  * that we\'re not crossfading opacity between. For instance with switch\n//  * AnimateSharedLayout animations, this helps the illusion of a continuous\n//  * element being animated but also cuts down on the number of paints triggered\n//  * for elements where opacity is doing that work for us.\n//  */\n// if (\n//     !hasFollowElement &&\n//     latestLeadValues.backgroundColor &&\n//     latestFollowValues.backgroundColor\n// ) {\n//     /**\n//      * This isn\'t ideal performance-wise as mixColor is creating a new function every frame.\n//      * We could probably create a mixer that runs at the start of the animation but\n//      * the idea behind the crossfader is that it runs dynamically between two potentially\n//      * changing targets (ie opacity or borderRadius may be animating independently via variants)\n//      */\n//     leadState.backgroundColor = followState.backgroundColor = mixColor(\n//         latestFollowValues.backgroundColor as string,\n//         latestLeadValues.backgroundColor as string\n//     )(p)\n// }\nvar easeCrossfadeIn = compress(0, 0.5, circOut);\nvar easeCrossfadeOut = compress(0.5, 0.95, linear);\nfunction compress(min, max, easing) {\n    return function (p) {\n        // Could replace ifs with clamp\n        if (p < min)\n            return 0;\n        if (p > max)\n            return 1;\n        return easing(progress(min, max, p));\n    };\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/projection/geometry/copy.mjs\n/**\n * Reset an axis to the provided origin box.\n *\n * This is a mutative operation.\n */\nfunction copyAxisInto(axis, originAxis) {\n    axis.min = originAxis.min;\n    axis.max = originAxis.max;\n}\n/**\n * Reset a box to the provided origin box.\n *\n * This is a mutative operation.\n */\nfunction copyBoxInto(box, originBox) {\n    copyAxisInto(box.x, originBox.x);\n    copyAxisInto(box.y, originBox.y);\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/projection/geometry/delta-remove.mjs\n\n\n\n\n\n/**\n * Remove a delta from a point. This is essentially the steps of applyPointDelta in reverse\n */\nfunction removePointDelta(point, translate, scale, originPoint, boxScale) {\n    point -= translate;\n    point = scalePoint(point, 1 / scale, originPoint);\n    if (boxScale !== undefined) {\n        point = scalePoint(point, 1 / boxScale, originPoint);\n    }\n    return point;\n}\n/**\n * Remove a delta from an axis. This is essentially the steps of applyAxisDelta in reverse\n */\nfunction removeAxisDelta(axis, translate, scale, origin, boxScale, originAxis, sourceAxis) {\n    if (translate === void 0) { translate = 0; }\n    if (scale === void 0) { scale = 1; }\n    if (origin === void 0) { origin = 0.5; }\n    if (originAxis === void 0) { originAxis = axis; }\n    if (sourceAxis === void 0) { sourceAxis = axis; }\n    if (percent.test(translate)) {\n        translate = parseFloat(translate);\n        var relativeProgress = mix(sourceAxis.min, sourceAxis.max, translate / 100);\n        translate = relativeProgress - sourceAxis.min;\n    }\n    if (typeof translate !== "number")\n        return;\n    var originPoint = mix(originAxis.min, originAxis.max, origin);\n    if (axis === originAxis)\n        originPoint -= translate;\n    axis.min = removePointDelta(axis.min, translate, scale, originPoint, boxScale);\n    axis.max = removePointDelta(axis.max, translate, scale, originPoint, boxScale);\n}\n/**\n * Remove a transforms from an axis. This is essentially the steps of applyAxisTransforms in reverse\n * and acts as a bridge between motion values and removeAxisDelta\n */\nfunction removeAxisTransforms(axis, transforms, _a, origin, sourceAxis) {\n    var _b = __read(_a, 3), key = _b[0], scaleKey = _b[1], originKey = _b[2];\n    removeAxisDelta(axis, transforms[key], transforms[scaleKey], transforms[originKey], transforms.scale, origin, sourceAxis);\n}\n/**\n * The names of the motion values we want to apply as translation, scale and origin.\n */\nvar delta_remove_xKeys = ["x", "scaleX", "originX"];\nvar delta_remove_yKeys = ["y", "scaleY", "originY"];\n/**\n * Remove a transforms from an box. This is essentially the steps of applyAxisBox in reverse\n * and acts as a bridge between motion values and removeAxisDelta\n */\nfunction removeBoxTransforms(box, transforms, originBox, sourceBox) {\n    removeAxisTransforms(box.x, transforms, delta_remove_xKeys, originBox === null || originBox === void 0 ? void 0 : originBox.x, sourceBox === null || sourceBox === void 0 ? void 0 : sourceBox.x);\n    removeAxisTransforms(box.y, transforms, delta_remove_yKeys, originBox === null || originBox === void 0 ? void 0 : originBox.y, sourceBox === null || sourceBox === void 0 ? void 0 : sourceBox.y);\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/projection/geometry/utils.mjs\nfunction isAxisDeltaZero(delta) {\n    return delta.translate === 0 && delta.scale === 1;\n}\nfunction isDeltaZero(delta) {\n    return isAxisDeltaZero(delta.x) && isAxisDeltaZero(delta.y);\n}\nfunction boxEquals(a, b) {\n    return (a.x.min === b.x.min &&\n        a.x.max === b.x.max &&\n        a.y.min === b.y.min &&\n        a.y.max === b.y.max);\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/projection/shared/stack.mjs\n\n\nvar NodeStack = /** @class */ (function () {\n    function NodeStack() {\n        this.members = [];\n    }\n    NodeStack.prototype.add = function (node) {\n        addUniqueItem(this.members, node);\n        node.scheduleRender();\n    };\n    NodeStack.prototype.remove = function (node) {\n        removeItem(this.members, node);\n        if (node === this.prevLead) {\n            this.prevLead = undefined;\n        }\n        if (node === this.lead) {\n            var prevLead = this.members[this.members.length - 1];\n            if (prevLead) {\n                this.promote(prevLead);\n            }\n        }\n    };\n    NodeStack.prototype.relegate = function (node) {\n        var indexOfNode = this.members.findIndex(function (member) { return node === member; });\n        if (indexOfNode === 0)\n            return false;\n        /**\n         * Find the next projection node that is present\n         */\n        var prevLead;\n        for (var i = indexOfNode; i >= 0; i--) {\n            var member = this.members[i];\n            if (member.isPresent !== false) {\n                prevLead = member;\n                break;\n            }\n        }\n        if (prevLead) {\n            this.promote(prevLead);\n            return true;\n        }\n        else {\n            return false;\n        }\n    };\n    NodeStack.prototype.promote = function (node, preserveFollowOpacity) {\n        var _a;\n        var prevLead = this.lead;\n        if (node === prevLead)\n            return;\n        this.prevLead = prevLead;\n        this.lead = node;\n        node.show();\n        if (prevLead) {\n            prevLead.instance && prevLead.scheduleRender();\n            node.scheduleRender();\n            node.resumeFrom = prevLead;\n            if (preserveFollowOpacity) {\n                node.resumeFrom.preserveOpacity = true;\n            }\n            if (prevLead.snapshot) {\n                node.snapshot = prevLead.snapshot;\n                node.snapshot.latestValues =\n                    prevLead.animationValues || prevLead.latestValues;\n                node.snapshot.isShared = true;\n            }\n            if ((_a = node.root) === null || _a === void 0 ? void 0 : _a.isUpdating) {\n                node.isLayoutDirty = true;\n            }\n            var crossfade = node.options.crossfade;\n            if (crossfade === false) {\n                prevLead.hide();\n            }\n            /**\n             * TODO:\n             *   - Test border radius when previous node was deleted\n             *   - boxShadow mixing\n             *   - Shared between element A in scrolled container and element B (scroll stays the same or changes)\n             *   - Shared between element A in transformed container and element B (transform stays the same or changes)\n             *   - Shared between element A in scrolled page and element B (scroll stays the same or changes)\n             * ---\n             *   - Crossfade opacity of root nodes\n             *   - layoutId changes after animation\n             *   - layoutId changes mid animation\n             */\n        }\n    };\n    NodeStack.prototype.exitAnimationComplete = function () {\n        this.members.forEach(function (node) {\n            var _a, _b, _c, _d, _e;\n            (_b = (_a = node.options).onExitComplete) === null || _b === void 0 ? void 0 : _b.call(_a);\n            (_e = (_c = node.resumingFrom) === null || _c === void 0 ? void 0 : (_d = _c.options).onExitComplete) === null || _e === void 0 ? void 0 : _e.call(_d);\n        });\n    };\n    NodeStack.prototype.scheduleRender = function () {\n        this.members.forEach(function (node) {\n            node.instance && node.scheduleRender(false);\n        });\n    };\n    /**\n     * Clear any leads that have been removed this render to prevent them from being\n     * used in future animations and to prevent memory leaks\n     */\n    NodeStack.prototype.removeLeadSnapshot = function () {\n        if (this.lead && this.lead.snapshot) {\n            this.lead.snapshot = undefined;\n        }\n    };\n    return NodeStack;\n}());\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/projection/styles/transform.mjs\nvar identityProjection = "translate3d(0px, 0px, 0) scale(1, 1) scale(1, 1)";\nfunction buildProjectionTransform(delta, treeScale, latestTransform) {\n    /**\n     * The translations we use to calculate are always relative to the viewport coordinate space.\n     * But when we apply scales, we also scale the coordinate space of an element and its children.\n     * For instance if we have a treeScale (the culmination of all parent scales) of 0.5 and we need\n     * to move an element 100 pixels, we actually need to move it 200 in within that scaled space.\n     */\n    var xTranslate = delta.x.translate / treeScale.x;\n    var yTranslate = delta.y.translate / treeScale.y;\n    var transform = "translate3d(".concat(xTranslate, "px, ").concat(yTranslate, "px, 0) ");\n    /**\n     * Apply scale correction for the tree transform.\n     * This will apply scale to the screen-orientated axes.\n     */\n    transform += "scale(".concat(1 / treeScale.x, ", ").concat(1 / treeScale.y, ") ");\n    if (latestTransform) {\n        var rotate = latestTransform.rotate, rotateX = latestTransform.rotateX, rotateY = latestTransform.rotateY;\n        if (rotate)\n            transform += "rotate(".concat(rotate, "deg) ");\n        if (rotateX)\n            transform += "rotateX(".concat(rotateX, "deg) ");\n        if (rotateY)\n            transform += "rotateY(".concat(rotateY, "deg) ");\n    }\n    /**\n     * Apply scale to match the size of the element to the size we want it.\n     * This will apply scale to the element-orientated axes.\n     */\n    var elementScaleX = delta.x.scale * treeScale.x;\n    var elementScaleY = delta.y.scale * treeScale.y;\n    transform += "scale(".concat(elementScaleX, ", ").concat(elementScaleY, ")");\n    return transform === identityProjection ? "none" : transform;\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/render/utils/compare-by-depth.mjs\nvar compareByDepth = function (a, b) {\n    return a.depth - b.depth;\n};\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/render/utils/flat-tree.mjs\n\n\n\nvar FlatTree = /** @class */ (function () {\n    function FlatTree() {\n        this.children = [];\n        this.isDirty = false;\n    }\n    FlatTree.prototype.add = function (child) {\n        addUniqueItem(this.children, child);\n        this.isDirty = true;\n    };\n    FlatTree.prototype.remove = function (child) {\n        removeItem(this.children, child);\n        this.isDirty = true;\n    };\n    FlatTree.prototype.forEach = function (callback) {\n        this.isDirty && this.children.sort(compareByDepth);\n        this.isDirty = false;\n        this.children.forEach(callback);\n    };\n    return FlatTree;\n}());\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/projection/node/create-projection-node.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * We use 1000 as the animation target as 0-1000 maps better to pixels than 0-1\n * which has a noticeable difference in spring animations\n */\nvar animationTarget = 1000;\nfunction createProjectionNode(_a) {\n    var attachResizeListener = _a.attachResizeListener, defaultParent = _a.defaultParent, measureScroll = _a.measureScroll, checkIsScrollRoot = _a.checkIsScrollRoot, resetTransform = _a.resetTransform;\n    return /** @class */ (function () {\n        function ProjectionNode(id, latestValues, parent) {\n            var _this = this;\n            if (latestValues === void 0) { latestValues = {}; }\n            if (parent === void 0) { parent = defaultParent === null || defaultParent === void 0 ? void 0 : defaultParent(); }\n            /**\n             * A Set containing all this component\'s children. This is used to iterate\n             * through the children.\n             *\n             * TODO: This could be faster to iterate as a flat array stored on the root node.\n             */\n            this.children = new Set();\n            /**\n             * Options for the node. We use this to configure what kind of layout animations\n             * we should perform (if any).\n             */\n            this.options = {};\n            /**\n             * We use this to detect when its safe to shut down part of a projection tree.\n             * We have to keep projecting children for scale correction and relative projection\n             * until all their parents stop performing layout animations.\n             */\n            this.isTreeAnimating = false;\n            this.isAnimationBlocked = false;\n            /**\n             * Flag to true if we think this layout has been changed. We can\'t always know this,\n             * currently we set it to true every time a component renders, or if it has a layoutDependency\n             * if that has changed between renders. Additionally, components can be grouped by LayoutGroup\n             * and if one node is dirtied, they all are.\n             */\n            this.isLayoutDirty = false;\n            /**\n             * Block layout updates for instant layout transitions throughout the tree.\n             */\n            this.updateManuallyBlocked = false;\n            this.updateBlockedByResize = false;\n            /**\n             * Set to true between the start of the first `willUpdate` call and the end of the `didUpdate`\n             * call.\n             */\n            this.isUpdating = false;\n            /**\n             * If this is an SVG element we currently disable projection transforms\n             */\n            this.isSVG = false;\n            /**\n             * Flag to true (during promotion) if a node doing an instant layout transition needs to reset\n             * its projection styles.\n             */\n            this.needsReset = false;\n            /**\n             * Flags whether this node should have its transform reset prior to measuring.\n             */\n            this.shouldResetTransform = false;\n            /**\n             * An object representing the calculated contextual/accumulated/tree scale.\n             * This will be used to scale calculcated projection transforms, as these are\n             * calculated in screen-space but need to be scaled for elements to actually\n             * make it to their calculated destinations.\n             *\n             * TODO: Lazy-init\n             */\n            this.treeScale = { x: 1, y: 1 };\n            /**\n             *\n             */\n            this.eventHandlers = new Map();\n            // Note: Currently only running on root node\n            this.potentialNodes = new Map();\n            this.checkUpdateFailed = function () {\n                if (_this.isUpdating) {\n                    _this.isUpdating = false;\n                    _this.clearAllSnapshots();\n                }\n            };\n            this.updateProjection = function () {\n                _this.nodes.forEach(resolveTargetDelta);\n                _this.nodes.forEach(calcProjection);\n            };\n            this.hasProjected = false;\n            this.isVisible = true;\n            this.animationProgress = 0;\n            /**\n             * Shared layout\n             */\n            // TODO Only running on root node\n            this.sharedNodes = new Map();\n            this.id = id;\n            this.latestValues = latestValues;\n            this.root = parent ? parent.root || parent : this;\n            this.path = parent ? __spreadArray(__spreadArray([], __read(parent.path), false), [parent], false) : [];\n            this.parent = parent;\n            this.depth = parent ? parent.depth + 1 : 0;\n            id && this.root.registerPotentialNode(id, this);\n            for (var i = 0; i < this.path.length; i++) {\n                this.path[i].shouldResetTransform = true;\n            }\n            if (this.root === this)\n                this.nodes = new FlatTree();\n        }\n        ProjectionNode.prototype.addEventListener = function (name, handler) {\n            if (!this.eventHandlers.has(name)) {\n                this.eventHandlers.set(name, new SubscriptionManager());\n            }\n            return this.eventHandlers.get(name).add(handler);\n        };\n        ProjectionNode.prototype.notifyListeners = function (name) {\n            var args = [];\n            for (var _i = 1; _i < arguments.length; _i++) {\n                args[_i - 1] = arguments[_i];\n            }\n            var subscriptionManager = this.eventHandlers.get(name);\n            subscriptionManager === null || subscriptionManager === void 0 ? void 0 : subscriptionManager.notify.apply(subscriptionManager, __spreadArray([], __read(args), false));\n        };\n        ProjectionNode.prototype.hasListeners = function (name) {\n            return this.eventHandlers.has(name);\n        };\n        ProjectionNode.prototype.registerPotentialNode = function (id, node) {\n            this.potentialNodes.set(id, node);\n        };\n        /**\n         * Lifecycles\n         */\n        ProjectionNode.prototype.mount = function (instance, isLayoutDirty) {\n            var _this = this;\n            var _a;\n            if (isLayoutDirty === void 0) { isLayoutDirty = false; }\n            if (this.instance)\n                return;\n            this.isSVG =\n                instance instanceof SVGElement && instance.tagName !== "svg";\n            this.instance = instance;\n            var _b = this.options, layoutId = _b.layoutId, layout = _b.layout, visualElement = _b.visualElement;\n            if (visualElement && !visualElement.getInstance()) {\n                visualElement.mount(instance);\n            }\n            this.root.nodes.add(this);\n            (_a = this.parent) === null || _a === void 0 ? void 0 : _a.children.add(this);\n            this.id && this.root.potentialNodes.delete(this.id);\n            if (isLayoutDirty && (layout || layoutId)) {\n                this.isLayoutDirty = true;\n            }\n            if (attachResizeListener) {\n                var unblockTimeout_1;\n                var resizeUnblockUpdate_1 = function () {\n                    return (_this.root.updateBlockedByResize = false);\n                };\n                attachResizeListener(instance, function () {\n                    _this.root.updateBlockedByResize = true;\n                    clearTimeout(unblockTimeout_1);\n                    unblockTimeout_1 = window.setTimeout(resizeUnblockUpdate_1, 250);\n                    if (globalProjectionState.hasAnimatedSinceResize) {\n                        globalProjectionState.hasAnimatedSinceResize = false;\n                        _this.nodes.forEach(finishAnimation);\n                    }\n                });\n            }\n            if (layoutId) {\n                this.root.registerSharedNode(layoutId, this);\n            }\n            // Only register the handler if it requires layout animation\n            if (this.options.animate !== false &&\n                visualElement &&\n                (layoutId || layout)) {\n                this.addEventListener("didUpdate", function (_a) {\n                    var _b, _c, _d, _e, _f;\n                    var delta = _a.delta, hasLayoutChanged = _a.hasLayoutChanged, hasRelativeTargetChanged = _a.hasRelativeTargetChanged, newLayout = _a.layout;\n                    if (_this.isTreeAnimationBlocked()) {\n                        _this.target = undefined;\n                        _this.relativeTarget = undefined;\n                        return;\n                    }\n                    // TODO: Check here if an animation exists\n                    var layoutTransition = (_c = (_b = _this.options.transition) !== null && _b !== void 0 ? _b : visualElement.getDefaultTransition()) !== null && _c !== void 0 ? _c : defaultLayoutTransition;\n                    var _g = visualElement.getProps(), onLayoutAnimationStart = _g.onLayoutAnimationStart, onLayoutAnimationComplete = _g.onLayoutAnimationComplete;\n                    /**\n                     * The target layout of the element might stay the same,\n                     * but its position relative to its parent has changed.\n                     */\n                    var targetChanged = !_this.targetLayout ||\n                        !boxEquals(_this.targetLayout, newLayout) ||\n                        hasRelativeTargetChanged;\n                    /**\n                     * If the layout hasn\'t seemed to have changed, it might be that the\n                     * element is visually in the same place in the document but its position\n                     * relative to its parent has indeed changed. So here we check for that.\n                     */\n                    var hasOnlyRelativeTargetChanged = !hasLayoutChanged && hasRelativeTargetChanged;\n                    if (((_d = _this.resumeFrom) === null || _d === void 0 ? void 0 : _d.instance) ||\n                        hasOnlyRelativeTargetChanged ||\n                        (hasLayoutChanged &&\n                            (targetChanged || !_this.currentAnimation))) {\n                        if (_this.resumeFrom) {\n                            _this.resumingFrom = _this.resumeFrom;\n                            _this.resumingFrom.resumingFrom = undefined;\n                        }\n                        _this.setAnimationOrigin(delta, hasOnlyRelativeTargetChanged);\n                        var animationOptions = __assign(__assign({}, getValueTransition(layoutTransition, "layout")), { onPlay: onLayoutAnimationStart, onComplete: onLayoutAnimationComplete });\n                        if (visualElement.shouldReduceMotion) {\n                            animationOptions.delay = 0;\n                            animationOptions.type = false;\n                        }\n                        _this.startAnimation(animationOptions);\n                    }\n                    else {\n                        /**\n                         * If the layout hasn\'t changed and we have an animation that hasn\'t started yet,\n                         * finish it immediately. Otherwise it will be animating from a location\n                         * that was probably never commited to screen and look like a jumpy box.\n                         */\n                        if (!hasLayoutChanged &&\n                            _this.animationProgress === 0) {\n                            _this.finishAnimation();\n                        }\n                        _this.isLead() && ((_f = (_e = _this.options).onExitComplete) === null || _f === void 0 ? void 0 : _f.call(_e));\n                    }\n                    _this.targetLayout = newLayout;\n                });\n            }\n        };\n        ProjectionNode.prototype.unmount = function () {\n            var _a, _b;\n            this.options.layoutId && this.willUpdate();\n            this.root.nodes.remove(this);\n            (_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.remove(this);\n            (_b = this.parent) === null || _b === void 0 ? void 0 : _b.children.delete(this);\n            this.instance = undefined;\n            cancelSync.preRender(this.updateProjection);\n        };\n        // only on the root\n        ProjectionNode.prototype.blockUpdate = function () {\n            this.updateManuallyBlocked = true;\n        };\n        ProjectionNode.prototype.unblockUpdate = function () {\n            this.updateManuallyBlocked = false;\n        };\n        ProjectionNode.prototype.isUpdateBlocked = function () {\n            return this.updateManuallyBlocked || this.updateBlockedByResize;\n        };\n        ProjectionNode.prototype.isTreeAnimationBlocked = function () {\n            var _a;\n            return (this.isAnimationBlocked ||\n                ((_a = this.parent) === null || _a === void 0 ? void 0 : _a.isTreeAnimationBlocked()) ||\n                false);\n        };\n        // Note: currently only running on root node\n        ProjectionNode.prototype.startUpdate = function () {\n            var _a;\n            if (this.isUpdateBlocked())\n                return;\n            this.isUpdating = true;\n            (_a = this.nodes) === null || _a === void 0 ? void 0 : _a.forEach(resetRotation);\n        };\n        ProjectionNode.prototype.willUpdate = function (shouldNotifyListeners) {\n            var _a, _b, _c;\n            if (shouldNotifyListeners === void 0) { shouldNotifyListeners = true; }\n            if (this.root.isUpdateBlocked()) {\n                (_b = (_a = this.options).onExitComplete) === null || _b === void 0 ? void 0 : _b.call(_a);\n                return;\n            }\n            !this.root.isUpdating && this.root.startUpdate();\n            if (this.isLayoutDirty)\n                return;\n            this.isLayoutDirty = true;\n            for (var i = 0; i < this.path.length; i++) {\n                var node = this.path[i];\n                node.shouldResetTransform = true;\n                /**\n                 * TODO: Check we haven\'t updated the scroll\n                 * since the last didUpdate\n                 */\n                node.updateScroll();\n            }\n            var _d = this.options, layoutId = _d.layoutId, layout = _d.layout;\n            if (layoutId === undefined && !layout)\n                return;\n            var transformTemplate = (_c = this.options.visualElement) === null || _c === void 0 ? void 0 : _c.getProps().transformTemplate;\n            this.prevTransformTemplateValue = transformTemplate === null || transformTemplate === void 0 ? void 0 : transformTemplate(this.latestValues, "");\n            this.updateSnapshot();\n            shouldNotifyListeners && this.notifyListeners("willUpdate");\n        };\n        // Note: Currently only running on root node\n        ProjectionNode.prototype.didUpdate = function () {\n            var updateWasBlocked = this.isUpdateBlocked();\n            // When doing an instant transition, we skip the layout update,\n            // but should still clean up the measurements so that the next\n            // snapshot could be taken correctly.\n            if (updateWasBlocked) {\n                this.unblockUpdate();\n                this.clearAllSnapshots();\n                this.nodes.forEach(clearMeasurements);\n                return;\n            }\n            if (!this.isUpdating)\n                return;\n            this.isUpdating = false;\n            /**\n             * Search for and mount newly-added projection elements.\n             *\n             * TODO: Every time a new component is rendered we could search up the tree for\n             * the closest mounted node and query from there rather than document.\n             */\n            if (this.potentialNodes.size) {\n                this.potentialNodes.forEach(mountNodeEarly);\n                this.potentialNodes.clear();\n            }\n            /**\n             * Write\n             */\n            this.nodes.forEach(resetTransformStyle);\n            /**\n             * Read ==================\n             */\n            // Update layout measurements of updated children\n            this.nodes.forEach(updateLayout);\n            /**\n             * Write\n             */\n            // Notify listeners that the layout is updated\n            this.nodes.forEach(notifyLayoutUpdate);\n            this.clearAllSnapshots();\n            // Flush any scheduled updates\n            flushSync.update();\n            flushSync.preRender();\n            flushSync.render();\n        };\n        ProjectionNode.prototype.clearAllSnapshots = function () {\n            this.nodes.forEach(clearSnapshot);\n            this.sharedNodes.forEach(removeLeadSnapshots);\n        };\n        ProjectionNode.prototype.scheduleUpdateProjection = function () {\n            es.preRender(this.updateProjection, false, true);\n        };\n        ProjectionNode.prototype.scheduleCheckAfterUnmount = function () {\n            var _this = this;\n            /**\n             * If the unmounting node is in a layoutGroup and did trigger a willUpdate,\n             * we manually call didUpdate to give a chance to the siblings to animate.\n             * Otherwise, cleanup all snapshots to prevents future nodes from reusing them.\n             */\n            es.postRender(function () {\n                if (_this.isLayoutDirty) {\n                    _this.root.didUpdate();\n                }\n                else {\n                    _this.root.checkUpdateFailed();\n                }\n            });\n        };\n        /**\n         * Update measurements\n         */\n        ProjectionNode.prototype.updateSnapshot = function () {\n            if (this.snapshot || !this.instance)\n                return;\n            var measured = this.measure();\n            var layout = this.removeTransform(this.removeElementScroll(measured));\n            roundBox(layout);\n            this.snapshot = {\n                measured: measured,\n                layout: layout,\n                latestValues: {},\n            };\n        };\n        ProjectionNode.prototype.updateLayout = function () {\n            var _a;\n            if (!this.instance)\n                return;\n            // TODO: Incorporate into a forwarded scroll offset\n            this.updateScroll();\n            if (!(this.options.alwaysMeasureLayout && this.isLead()) &&\n                !this.isLayoutDirty) {\n                return;\n            }\n            /**\n             * When a node is mounted, it simply resumes from the prevLead\'s\n             * snapshot instead of taking a new one, but the ancestors scroll\n             * might have updated while the prevLead is unmounted. We need to\n             * update the scroll again to make sure the layout we measure is\n             * up to date.\n             */\n            if (this.resumeFrom && !this.resumeFrom.instance) {\n                for (var i = 0; i < this.path.length; i++) {\n                    var node = this.path[i];\n                    node.updateScroll();\n                }\n            }\n            var measured = this.measure();\n            roundBox(measured);\n            var prevLayout = this.layout;\n            this.layout = {\n                measured: measured,\n                actual: this.removeElementScroll(measured),\n            };\n            this.layoutCorrected = createBox();\n            this.isLayoutDirty = false;\n            this.projectionDelta = undefined;\n            this.notifyListeners("measure", this.layout.actual);\n            (_a = this.options.visualElement) === null || _a === void 0 ? void 0 : _a.notifyLayoutMeasure(this.layout.actual, prevLayout === null || prevLayout === void 0 ? void 0 : prevLayout.actual);\n        };\n        ProjectionNode.prototype.updateScroll = function () {\n            if (this.options.layoutScroll && this.instance) {\n                this.isScrollRoot = checkIsScrollRoot(this.instance);\n                this.scroll = measureScroll(this.instance);\n            }\n        };\n        ProjectionNode.prototype.resetTransform = function () {\n            var _a;\n            if (!resetTransform)\n                return;\n            var isResetRequested = this.isLayoutDirty || this.shouldResetTransform;\n            var hasProjection = this.projectionDelta && !isDeltaZero(this.projectionDelta);\n            var transformTemplate = (_a = this.options.visualElement) === null || _a === void 0 ? void 0 : _a.getProps().transformTemplate;\n            var transformTemplateValue = transformTemplate === null || transformTemplate === void 0 ? void 0 : transformTemplate(this.latestValues, "");\n            var transformTemplateHasChanged = transformTemplateValue !== this.prevTransformTemplateValue;\n            if (isResetRequested &&\n                (hasProjection ||\n                    hasTransform(this.latestValues) ||\n                    transformTemplateHasChanged)) {\n                resetTransform(this.instance, transformTemplateValue);\n                this.shouldResetTransform = false;\n                this.scheduleRender();\n            }\n        };\n        ProjectionNode.prototype.measure = function () {\n            var visualElement = this.options.visualElement;\n            if (!visualElement)\n                return createBox();\n            var box = visualElement.measureViewportBox();\n            // Remove viewport scroll to give page-relative coordinates\n            var scroll = this.root.scroll;\n            if (scroll) {\n                translateAxis(box.x, scroll.x);\n                translateAxis(box.y, scroll.y);\n            }\n            return box;\n        };\n        ProjectionNode.prototype.removeElementScroll = function (box) {\n            var boxWithoutScroll = createBox();\n            copyBoxInto(boxWithoutScroll, box);\n            /**\n             * Performance TODO: Keep a cumulative scroll offset down the tree\n             * rather than loop back up the path.\n             */\n            for (var i = 0; i < this.path.length; i++) {\n                var node = this.path[i];\n                var scroll_1 = node.scroll, options = node.options, isScrollRoot = node.isScrollRoot;\n                if (node !== this.root && scroll_1 && options.layoutScroll) {\n                    /**\n                     * If this is a new scroll root, we want to remove all previous scrolls\n                     * from the viewport box.\n                     */\n                    if (isScrollRoot) {\n                        copyBoxInto(boxWithoutScroll, box);\n                        var rootScroll = this.root.scroll;\n                        /**\n                         * Undo the application of page scroll that was originally added\n                         * to the measured bounding box.\n                         */\n                        if (rootScroll) {\n                            translateAxis(boxWithoutScroll.x, -rootScroll.x);\n                            translateAxis(boxWithoutScroll.y, -rootScroll.y);\n                        }\n                    }\n                    translateAxis(boxWithoutScroll.x, scroll_1.x);\n                    translateAxis(boxWithoutScroll.y, scroll_1.y);\n                }\n            }\n            return boxWithoutScroll;\n        };\n        ProjectionNode.prototype.applyTransform = function (box, transformOnly) {\n            if (transformOnly === void 0) { transformOnly = false; }\n            var withTransforms = createBox();\n            copyBoxInto(withTransforms, box);\n            for (var i = 0; i < this.path.length; i++) {\n                var node = this.path[i];\n                if (!transformOnly &&\n                    node.options.layoutScroll &&\n                    node.scroll &&\n                    node !== node.root) {\n                    transformBox(withTransforms, {\n                        x: -node.scroll.x,\n                        y: -node.scroll.y,\n                    });\n                }\n                if (!hasTransform(node.latestValues))\n                    continue;\n                transformBox(withTransforms, node.latestValues);\n            }\n            if (hasTransform(this.latestValues)) {\n                transformBox(withTransforms, this.latestValues);\n            }\n            return withTransforms;\n        };\n        ProjectionNode.prototype.removeTransform = function (box) {\n            var _a;\n            var boxWithoutTransform = createBox();\n            copyBoxInto(boxWithoutTransform, box);\n            for (var i = 0; i < this.path.length; i++) {\n                var node = this.path[i];\n                if (!node.instance)\n                    continue;\n                if (!hasTransform(node.latestValues))\n                    continue;\n                hasScale(node.latestValues) && node.updateSnapshot();\n                var sourceBox = createBox();\n                var nodeBox = node.measure();\n                copyBoxInto(sourceBox, nodeBox);\n                removeBoxTransforms(boxWithoutTransform, node.latestValues, (_a = node.snapshot) === null || _a === void 0 ? void 0 : _a.layout, sourceBox);\n            }\n            if (hasTransform(this.latestValues)) {\n                removeBoxTransforms(boxWithoutTransform, this.latestValues);\n            }\n            return boxWithoutTransform;\n        };\n        /**\n         *\n         */\n        ProjectionNode.prototype.setTargetDelta = function (delta) {\n            this.targetDelta = delta;\n            this.root.scheduleUpdateProjection();\n        };\n        ProjectionNode.prototype.setOptions = function (options) {\n            var _a;\n            this.options = __assign(__assign(__assign({}, this.options), options), { crossfade: (_a = options.crossfade) !== null && _a !== void 0 ? _a : true });\n        };\n        ProjectionNode.prototype.clearMeasurements = function () {\n            this.scroll = undefined;\n            this.layout = undefined;\n            this.snapshot = undefined;\n            this.prevTransformTemplateValue = undefined;\n            this.targetDelta = undefined;\n            this.target = undefined;\n            this.isLayoutDirty = false;\n        };\n        /**\n         * Frame calculations\n         */\n        ProjectionNode.prototype.resolveTargetDelta = function () {\n            var _a;\n            var _b = this.options, layout = _b.layout, layoutId = _b.layoutId;\n            /**\n             * If we have no layout, we can\'t perform projection, so early return\n             */\n            if (!this.layout || !(layout || layoutId))\n                return;\n            /**\n             * If we don\'t have a targetDelta but do have a layout, we can attempt to resolve\n             * a relativeParent. This will allow a component to perform scale correction\n             * even if no animation has started.\n             */\n            // TODO If this is unsuccessful this currently happens every frame\n            if (!this.targetDelta && !this.relativeTarget) {\n                // TODO: This is a semi-repetition of further down this function, make DRY\n                this.relativeParent = this.getClosestProjectingParent();\n                if (this.relativeParent && this.relativeParent.layout) {\n                    this.relativeTarget = createBox();\n                    this.relativeTargetOrigin = createBox();\n                    calcRelativePosition(this.relativeTargetOrigin, this.layout.actual, this.relativeParent.layout.actual);\n                    copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);\n                }\n            }\n            /**\n             * If we have no relative target or no target delta our target isn\'t valid\n             * for this frame.\n             */\n            if (!this.relativeTarget && !this.targetDelta)\n                return;\n            /**\n             * Lazy-init target data structure\n             */\n            if (!this.target) {\n                this.target = createBox();\n                this.targetWithTransforms = createBox();\n            }\n            /**\n             * If we\'ve got a relative box for this component, resolve it into a target relative to the parent.\n             */\n            if (this.relativeTarget &&\n                this.relativeTargetOrigin &&\n                ((_a = this.relativeParent) === null || _a === void 0 ? void 0 : _a.target)) {\n                calcRelativeBox(this.target, this.relativeTarget, this.relativeParent.target);\n                /**\n                 * If we\'ve only got a targetDelta, resolve it into a target\n                 */\n            }\n            else if (this.targetDelta) {\n                if (Boolean(this.resumingFrom)) {\n                    // TODO: This is creating a new object every frame\n                    this.target = this.applyTransform(this.layout.actual);\n                }\n                else {\n                    copyBoxInto(this.target, this.layout.actual);\n                }\n                applyBoxDelta(this.target, this.targetDelta);\n            }\n            else {\n                /**\n                 * If no target, use own layout as target\n                 */\n                copyBoxInto(this.target, this.layout.actual);\n            }\n            /**\n             * If we\'ve been told to attempt to resolve a relative target, do so.\n             */\n            if (this.attemptToResolveRelativeTarget) {\n                this.attemptToResolveRelativeTarget = false;\n                this.relativeParent = this.getClosestProjectingParent();\n                if (this.relativeParent &&\n                    Boolean(this.relativeParent.resumingFrom) ===\n                        Boolean(this.resumingFrom) &&\n                    !this.relativeParent.options.layoutScroll &&\n                    this.relativeParent.target) {\n                    this.relativeTarget = createBox();\n                    this.relativeTargetOrigin = createBox();\n                    calcRelativePosition(this.relativeTargetOrigin, this.target, this.relativeParent.target);\n                    copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);\n                }\n            }\n        };\n        ProjectionNode.prototype.getClosestProjectingParent = function () {\n            if (!this.parent || hasTransform(this.parent.latestValues))\n                return undefined;\n            if ((this.parent.relativeTarget || this.parent.targetDelta) &&\n                this.parent.layout) {\n                return this.parent;\n            }\n            else {\n                return this.parent.getClosestProjectingParent();\n            }\n        };\n        ProjectionNode.prototype.calcProjection = function () {\n            var _a;\n            var _b = this.options, layout = _b.layout, layoutId = _b.layoutId;\n            /**\n             * If this section of the tree isn\'t animating we can\n             * delete our target sources for the following frame.\n             */\n            this.isTreeAnimating = Boolean(((_a = this.parent) === null || _a === void 0 ? void 0 : _a.isTreeAnimating) ||\n                this.currentAnimation ||\n                this.pendingAnimation);\n            if (!this.isTreeAnimating) {\n                this.targetDelta = this.relativeTarget = undefined;\n            }\n            if (!this.layout || !(layout || layoutId))\n                return;\n            var lead = this.getLead();\n            /**\n             * Reset the corrected box with the latest values from box, as we\'re then going\n             * to perform mutative operations on it.\n             */\n            copyBoxInto(this.layoutCorrected, this.layout.actual);\n            /**\n             * Apply all the parent deltas to this box to produce the corrected box. This\n             * is the layout box, as it will appear on screen as a result of the transforms of its parents.\n             */\n            applyTreeDeltas(this.layoutCorrected, this.treeScale, this.path, Boolean(this.resumingFrom) || this !== lead);\n            var target = lead.target;\n            if (!target)\n                return;\n            if (!this.projectionDelta) {\n                this.projectionDelta = createDelta();\n                this.projectionDeltaWithTransform = createDelta();\n            }\n            var prevTreeScaleX = this.treeScale.x;\n            var prevTreeScaleY = this.treeScale.y;\n            var prevProjectionTransform = this.projectionTransform;\n            /**\n             * Update the delta between the corrected box and the target box before user-set transforms were applied.\n             * This will allow us to calculate the corrected borderRadius and boxShadow to compensate\n             * for our layout reprojection, but still allow them to be scaled correctly by the user.\n             * It might be that to simplify this we may want to accept that user-set scale is also corrected\n             * and we wouldn\'t have to keep and calc both deltas, OR we could support a user setting\n             * to allow people to choose whether these styles are corrected based on just the\n             * layout reprojection or the final bounding box.\n             */\n            calcBoxDelta(this.projectionDelta, this.layoutCorrected, target, this.latestValues);\n            this.projectionTransform = buildProjectionTransform(this.projectionDelta, this.treeScale);\n            if (this.projectionTransform !== prevProjectionTransform ||\n                this.treeScale.x !== prevTreeScaleX ||\n                this.treeScale.y !== prevTreeScaleY) {\n                this.hasProjected = true;\n                this.scheduleRender();\n                this.notifyListeners("projectionUpdate", target);\n            }\n        };\n        ProjectionNode.prototype.hide = function () {\n            this.isVisible = false;\n            // TODO: Schedule render\n        };\n        ProjectionNode.prototype.show = function () {\n            this.isVisible = true;\n            // TODO: Schedule render\n        };\n        ProjectionNode.prototype.scheduleRender = function (notifyAll) {\n            var _a, _b, _c;\n            if (notifyAll === void 0) { notifyAll = true; }\n            (_b = (_a = this.options).scheduleRender) === null || _b === void 0 ? void 0 : _b.call(_a);\n            notifyAll && ((_c = this.getStack()) === null || _c === void 0 ? void 0 : _c.scheduleRender());\n            if (this.resumingFrom && !this.resumingFrom.instance) {\n                this.resumingFrom = undefined;\n            }\n        };\n        ProjectionNode.prototype.setAnimationOrigin = function (delta, hasOnlyRelativeTargetChanged) {\n            var _this = this;\n            var _a;\n            if (hasOnlyRelativeTargetChanged === void 0) { hasOnlyRelativeTargetChanged = false; }\n            var snapshot = this.snapshot;\n            var snapshotLatestValues = (snapshot === null || snapshot === void 0 ? void 0 : snapshot.latestValues) || {};\n            var mixedValues = __assign({}, this.latestValues);\n            var targetDelta = createDelta();\n            this.relativeTarget = this.relativeTargetOrigin = undefined;\n            this.attemptToResolveRelativeTarget = !hasOnlyRelativeTargetChanged;\n            var relativeLayout = createBox();\n            var isSharedLayoutAnimation = snapshot === null || snapshot === void 0 ? void 0 : snapshot.isShared;\n            var isOnlyMember = (((_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.members.length) || 0) <= 1;\n            var shouldCrossfadeOpacity = Boolean(isSharedLayoutAnimation &&\n                !isOnlyMember &&\n                this.options.crossfade === true &&\n                !this.path.some(hasOpacityCrossfade));\n            this.animationProgress = 0;\n            this.mixTargetDelta = function (latest) {\n                var _a;\n                var progress = latest / 1000;\n                mixAxisDelta(targetDelta.x, delta.x, progress);\n                mixAxisDelta(targetDelta.y, delta.y, progress);\n                _this.setTargetDelta(targetDelta);\n                if (_this.relativeTarget &&\n                    _this.relativeTargetOrigin &&\n                    _this.layout &&\n                    ((_a = _this.relativeParent) === null || _a === void 0 ? void 0 : _a.layout)) {\n                    calcRelativePosition(relativeLayout, _this.layout.actual, _this.relativeParent.layout.actual);\n                    mixBox(_this.relativeTarget, _this.relativeTargetOrigin, relativeLayout, progress);\n                }\n                if (isSharedLayoutAnimation) {\n                    _this.animationValues = mixedValues;\n                    mixValues(mixedValues, snapshotLatestValues, _this.latestValues, progress, shouldCrossfadeOpacity, isOnlyMember);\n                }\n                _this.root.scheduleUpdateProjection();\n                _this.scheduleRender();\n                _this.animationProgress = progress;\n            };\n            this.mixTargetDelta(0);\n        };\n        ProjectionNode.prototype.startAnimation = function (options) {\n            var _this = this;\n            var _a, _b;\n            this.notifyListeners("animationStart");\n            (_a = this.currentAnimation) === null || _a === void 0 ? void 0 : _a.stop();\n            if (this.resumingFrom) {\n                (_b = this.resumingFrom.currentAnimation) === null || _b === void 0 ? void 0 : _b.stop();\n            }\n            if (this.pendingAnimation) {\n                cancelSync.update(this.pendingAnimation);\n                this.pendingAnimation = undefined;\n            }\n            /**\n             * Start the animation in the next frame to have a frame with progress 0,\n             * where the target is the same as when the animation started, so we can\n             * calculate the relative positions correctly for instant transitions.\n             */\n            this.pendingAnimation = es.update(function () {\n                globalProjectionState.hasAnimatedSinceResize = true;\n                _this.currentAnimation = animate_animate(0, animationTarget, __assign(__assign({}, options), { onUpdate: function (latest) {\n                        var _a;\n                        _this.mixTargetDelta(latest);\n                        (_a = options.onUpdate) === null || _a === void 0 ? void 0 : _a.call(options, latest);\n                    }, onComplete: function () {\n                        var _a;\n                        (_a = options.onComplete) === null || _a === void 0 ? void 0 : _a.call(options);\n                        _this.completeAnimation();\n                    } }));\n                if (_this.resumingFrom) {\n                    _this.resumingFrom.currentAnimation = _this.currentAnimation;\n                }\n                _this.pendingAnimation = undefined;\n            });\n        };\n        ProjectionNode.prototype.completeAnimation = function () {\n            var _a;\n            if (this.resumingFrom) {\n                this.resumingFrom.currentAnimation = undefined;\n                this.resumingFrom.preserveOpacity = undefined;\n            }\n            (_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.exitAnimationComplete();\n            this.resumingFrom =\n                this.currentAnimation =\n                    this.animationValues =\n                        undefined;\n            this.notifyListeners("animationComplete");\n        };\n        ProjectionNode.prototype.finishAnimation = function () {\n            var _a;\n            if (this.currentAnimation) {\n                (_a = this.mixTargetDelta) === null || _a === void 0 ? void 0 : _a.call(this, animationTarget);\n                this.currentAnimation.stop();\n            }\n            this.completeAnimation();\n        };\n        ProjectionNode.prototype.applyTransformsToTarget = function () {\n            var _a = this.getLead(), targetWithTransforms = _a.targetWithTransforms, target = _a.target, layout = _a.layout, latestValues = _a.latestValues;\n            if (!targetWithTransforms || !target || !layout)\n                return;\n            copyBoxInto(targetWithTransforms, target);\n            /**\n             * Apply the latest user-set transforms to the targetBox to produce the targetBoxFinal.\n             * This is the final box that we will then project into by calculating a transform delta and\n             * applying it to the corrected box.\n             */\n            transformBox(targetWithTransforms, latestValues);\n            /**\n             * Update the delta between the corrected box and the final target box, after\n             * user-set transforms are applied to it. This will be used by the renderer to\n             * create a transform style that will reproject the element from its actual layout\n             * into the desired bounding box.\n             */\n            calcBoxDelta(this.projectionDeltaWithTransform, this.layoutCorrected, targetWithTransforms, latestValues);\n        };\n        ProjectionNode.prototype.registerSharedNode = function (layoutId, node) {\n            var _a, _b, _c;\n            if (!this.sharedNodes.has(layoutId)) {\n                this.sharedNodes.set(layoutId, new NodeStack());\n            }\n            var stack = this.sharedNodes.get(layoutId);\n            stack.add(node);\n            node.promote({\n                transition: (_a = node.options.initialPromotionConfig) === null || _a === void 0 ? void 0 : _a.transition,\n                preserveFollowOpacity: (_c = (_b = node.options.initialPromotionConfig) === null || _b === void 0 ? void 0 : _b.shouldPreserveFollowOpacity) === null || _c === void 0 ? void 0 : _c.call(_b, node),\n            });\n        };\n        ProjectionNode.prototype.isLead = function () {\n            var stack = this.getStack();\n            return stack ? stack.lead === this : true;\n        };\n        ProjectionNode.prototype.getLead = function () {\n            var _a;\n            var layoutId = this.options.layoutId;\n            return layoutId ? ((_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.lead) || this : this;\n        };\n        ProjectionNode.prototype.getPrevLead = function () {\n            var _a;\n            var layoutId = this.options.layoutId;\n            return layoutId ? (_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.prevLead : undefined;\n        };\n        ProjectionNode.prototype.getStack = function () {\n            var layoutId = this.options.layoutId;\n            if (layoutId)\n                return this.root.sharedNodes.get(layoutId);\n        };\n        ProjectionNode.prototype.promote = function (_a) {\n            var _b = _a === void 0 ? {} : _a, needsReset = _b.needsReset, transition = _b.transition, preserveFollowOpacity = _b.preserveFollowOpacity;\n            var stack = this.getStack();\n            if (stack)\n                stack.promote(this, preserveFollowOpacity);\n            if (needsReset) {\n                this.projectionDelta = undefined;\n                this.needsReset = true;\n            }\n            if (transition)\n                this.setOptions({ transition: transition });\n        };\n        ProjectionNode.prototype.relegate = function () {\n            var stack = this.getStack();\n            if (stack) {\n                return stack.relegate(this);\n            }\n            else {\n                return false;\n            }\n        };\n        ProjectionNode.prototype.resetRotation = function () {\n            var visualElement = this.options.visualElement;\n            if (!visualElement)\n                return;\n            // If there\'s no detected rotation values, we can early return without a forced render.\n            var hasRotate = false;\n            // Keep a record of all the values we\'ve reset\n            var resetValues = {};\n            // Check the rotate value of all axes and reset to 0\n            for (var i = 0; i < transformAxes.length; i++) {\n                var axis = transformAxes[i];\n                var key = "rotate" + axis;\n                // If this rotation doesn\'t exist as a motion value, then we don\'t\n                // need to reset it\n                if (!visualElement.getStaticValue(key)) {\n                    continue;\n                }\n                hasRotate = true;\n                // Record the rotation and then temporarily set it to 0\n                resetValues[key] = visualElement.getStaticValue(key);\n                visualElement.setStaticValue(key, 0);\n            }\n            // If there\'s no rotation values, we don\'t need to do any more.\n            if (!hasRotate)\n                return;\n            // Force a render of this element to apply the transform with all rotations\n            // set to 0.\n            visualElement === null || visualElement === void 0 ? void 0 : visualElement.syncRender();\n            // Put back all the values we reset\n            for (var key in resetValues) {\n                visualElement.setStaticValue(key, resetValues[key]);\n            }\n            // Schedule a render for the next frame. This ensures we won\'t visually\n            // see the element with the reset rotate value applied.\n            visualElement.scheduleRender();\n        };\n        ProjectionNode.prototype.getProjectionStyles = function (styleProp) {\n            var _a, _b, _c, _d, _e, _f;\n            if (styleProp === void 0) { styleProp = {}; }\n            // TODO: Return lifecycle-persistent object\n            var styles = {};\n            if (!this.instance || this.isSVG)\n                return styles;\n            if (!this.isVisible) {\n                return { visibility: "hidden" };\n            }\n            else {\n                styles.visibility = "";\n            }\n            var transformTemplate = (_a = this.options.visualElement) === null || _a === void 0 ? void 0 : _a.getProps().transformTemplate;\n            if (this.needsReset) {\n                this.needsReset = false;\n                styles.opacity = "";\n                styles.pointerEvents =\n                    resolveMotionValue(styleProp.pointerEvents) || "";\n                styles.transform = transformTemplate\n                    ? transformTemplate(this.latestValues, "")\n                    : "none";\n                return styles;\n            }\n            var lead = this.getLead();\n            if (!this.projectionDelta || !this.layout || !lead.target) {\n                var emptyStyles = {};\n                if (this.options.layoutId) {\n                    emptyStyles.opacity = (_b = this.latestValues.opacity) !== null && _b !== void 0 ? _b : 1;\n                    emptyStyles.pointerEvents =\n                        resolveMotionValue(styleProp.pointerEvents) || "";\n                }\n                if (this.hasProjected && !hasTransform(this.latestValues)) {\n                    emptyStyles.transform = transformTemplate\n                        ? transformTemplate({}, "")\n                        : "none";\n                    this.hasProjected = false;\n                }\n                return emptyStyles;\n            }\n            var valuesToRender = lead.animationValues || lead.latestValues;\n            this.applyTransformsToTarget();\n            styles.transform = buildProjectionTransform(this.projectionDeltaWithTransform, this.treeScale, valuesToRender);\n            if (transformTemplate) {\n                styles.transform = transformTemplate(valuesToRender, styles.transform);\n            }\n            var _g = this.projectionDelta, x = _g.x, y = _g.y;\n            styles.transformOrigin = "".concat(x.origin * 100, "% ").concat(y.origin * 100, "% 0");\n            if (lead.animationValues) {\n                /**\n                 * If the lead component is animating, assign this either the entering/leaving\n                 * opacity\n                 */\n                styles.opacity =\n                    lead === this\n                        ? (_d = (_c = valuesToRender.opacity) !== null && _c !== void 0 ? _c : this.latestValues.opacity) !== null && _d !== void 0 ? _d : 1\n                        : this.preserveOpacity\n                            ? this.latestValues.opacity\n                            : valuesToRender.opacityExit;\n            }\n            else {\n                /**\n                 * Or we\'re not animating at all, set the lead component to its actual\n                 * opacity and other components to hidden.\n                 */\n                styles.opacity =\n                    lead === this\n                        ? (_e = valuesToRender.opacity) !== null && _e !== void 0 ? _e : ""\n                        : (_f = valuesToRender.opacityExit) !== null && _f !== void 0 ? _f : 0;\n            }\n            /**\n             * Apply scale correction\n             */\n            for (var key in scaleCorrectors) {\n                if (valuesToRender[key] === undefined)\n                    continue;\n                var _h = scaleCorrectors[key], correct = _h.correct, applyTo = _h.applyTo;\n                var corrected = correct(valuesToRender[key], lead);\n                if (applyTo) {\n                    var num = applyTo.length;\n                    for (var i = 0; i < num; i++) {\n                        styles[applyTo[i]] = corrected;\n                    }\n                }\n                else {\n                    styles[key] = corrected;\n                }\n            }\n            /**\n             * Disable pointer events on follow components. This is to ensure\n             * that if a follow component covers a lead component it doesn\'t block\n             * pointer events on the lead.\n             */\n            if (this.options.layoutId) {\n                styles.pointerEvents =\n                    lead === this\n                        ? resolveMotionValue(styleProp.pointerEvents) || ""\n                        : "none";\n            }\n            return styles;\n        };\n        ProjectionNode.prototype.clearSnapshot = function () {\n            this.resumeFrom = this.snapshot = undefined;\n        };\n        // Only run on root\n        ProjectionNode.prototype.resetTree = function () {\n            this.root.nodes.forEach(function (node) { var _a; return (_a = node.currentAnimation) === null || _a === void 0 ? void 0 : _a.stop(); });\n            this.root.nodes.forEach(clearMeasurements);\n            this.root.sharedNodes.clear();\n        };\n        return ProjectionNode;\n    }());\n}\nfunction updateLayout(node) {\n    node.updateLayout();\n}\nfunction notifyLayoutUpdate(node) {\n    var _a, _b, _c, _d;\n    var snapshot = (_b = (_a = node.resumeFrom) === null || _a === void 0 ? void 0 : _a.snapshot) !== null && _b !== void 0 ? _b : node.snapshot;\n    if (node.isLead() &&\n        node.layout &&\n        snapshot &&\n        node.hasListeners("didUpdate")) {\n        var _e = node.layout, layout_1 = _e.actual, measuredLayout = _e.measured;\n        // TODO Maybe we want to also resize the layout snapshot so we don\'t trigger\n        // animations for instance if layout="size" and an element has only changed position\n        if (node.options.animationType === "size") {\n            eachAxis(function (axis) {\n                var axisSnapshot = snapshot.isShared\n                    ? snapshot.measured[axis]\n                    : snapshot.layout[axis];\n                var length = calcLength(axisSnapshot);\n                axisSnapshot.min = layout_1[axis].min;\n                axisSnapshot.max = axisSnapshot.min + length;\n            });\n        }\n        else if (node.options.animationType === "position") {\n            eachAxis(function (axis) {\n                var axisSnapshot = snapshot.isShared\n                    ? snapshot.measured[axis]\n                    : snapshot.layout[axis];\n                var length = calcLength(layout_1[axis]);\n                axisSnapshot.max = axisSnapshot.min + length;\n            });\n        }\n        var layoutDelta = createDelta();\n        calcBoxDelta(layoutDelta, layout_1, snapshot.layout);\n        var visualDelta = createDelta();\n        if (snapshot.isShared) {\n            calcBoxDelta(visualDelta, node.applyTransform(measuredLayout, true), snapshot.measured);\n        }\n        else {\n            calcBoxDelta(visualDelta, layout_1, snapshot.layout);\n        }\n        var hasLayoutChanged = !isDeltaZero(layoutDelta);\n        var hasRelativeTargetChanged = false;\n        if (!node.resumeFrom) {\n            node.relativeParent = node.getClosestProjectingParent();\n            /**\n             * If the relativeParent is itself resuming from a different element then\n             * the relative snapshot is not relavent\n             */\n            if (node.relativeParent && !node.relativeParent.resumeFrom) {\n                var _f = node.relativeParent, parentSnapshot = _f.snapshot, parentLayout = _f.layout;\n                if (parentSnapshot && parentLayout) {\n                    var relativeSnapshot = createBox();\n                    calcRelativePosition(relativeSnapshot, snapshot.layout, parentSnapshot.layout);\n                    var relativeLayout = createBox();\n                    calcRelativePosition(relativeLayout, layout_1, parentLayout.actual);\n                    if (!boxEquals(relativeSnapshot, relativeLayout)) {\n                        hasRelativeTargetChanged = true;\n                    }\n                }\n            }\n        }\n        node.notifyListeners("didUpdate", {\n            layout: layout_1,\n            snapshot: snapshot,\n            delta: visualDelta,\n            layoutDelta: layoutDelta,\n            hasLayoutChanged: hasLayoutChanged,\n            hasRelativeTargetChanged: hasRelativeTargetChanged,\n        });\n    }\n    else if (node.isLead()) {\n        (_d = (_c = node.options).onExitComplete) === null || _d === void 0 ? void 0 : _d.call(_c);\n    }\n    /**\n     * Clearing transition\n     * TODO: Investigate why this transition is being passed in as {type: false } from Framer\n     * and why we need it at all\n     */\n    node.options.transition = undefined;\n}\nfunction clearSnapshot(node) {\n    node.clearSnapshot();\n}\nfunction clearMeasurements(node) {\n    node.clearMeasurements();\n}\nfunction resetTransformStyle(node) {\n    var visualElement = node.options.visualElement;\n    if (visualElement === null || visualElement === void 0 ? void 0 : visualElement.getProps().onBeforeLayoutMeasure) {\n        visualElement.notifyBeforeLayoutMeasure();\n    }\n    node.resetTransform();\n}\nfunction finishAnimation(node) {\n    node.finishAnimation();\n    node.targetDelta = node.relativeTarget = node.target = undefined;\n}\nfunction resolveTargetDelta(node) {\n    node.resolveTargetDelta();\n}\nfunction calcProjection(node) {\n    node.calcProjection();\n}\nfunction resetRotation(node) {\n    node.resetRotation();\n}\nfunction removeLeadSnapshots(stack) {\n    stack.removeLeadSnapshot();\n}\nfunction mixAxisDelta(output, delta, p) {\n    output.translate = mix(delta.translate, 0, p);\n    output.scale = mix(delta.scale, 1, p);\n    output.origin = delta.origin;\n    output.originPoint = delta.originPoint;\n}\nfunction mixAxis(output, from, to, p) {\n    output.min = mix(from.min, to.min, p);\n    output.max = mix(from.max, to.max, p);\n}\nfunction mixBox(output, from, to, p) {\n    mixAxis(output.x, from.x, to.x, p);\n    mixAxis(output.y, from.y, to.y, p);\n}\nfunction hasOpacityCrossfade(node) {\n    return (node.animationValues && node.animationValues.opacityExit !== undefined);\n}\nvar defaultLayoutTransition = {\n    duration: 0.45,\n    ease: [0.4, 0, 0.1, 1],\n};\nfunction mountNodeEarly(node, id) {\n    /**\n     * Rather than searching the DOM from document we can search the\n     * path for the deepest mounted ancestor and search from there\n     */\n    var searchNode = node.root;\n    for (var i = node.path.length - 1; i >= 0; i--) {\n        if (Boolean(node.path[i].instance)) {\n            searchNode = node.path[i];\n            break;\n        }\n    }\n    var searchElement = searchNode && searchNode !== node.root ? searchNode.instance : document;\n    var element = searchElement.querySelector("[data-projection-id=\\"".concat(id, "\\"]"));\n    if (element)\n        node.mount(element, true);\n}\nfunction roundAxis(axis) {\n    axis.min = Math.round(axis.min);\n    axis.max = Math.round(axis.max);\n}\nfunction roundBox(box) {\n    roundAxis(box.x);\n    roundAxis(box.y);\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/projection/node/DocumentProjectionNode.mjs\n\n\n\nvar DocumentProjectionNode = createProjectionNode({\n    attachResizeListener: function (ref, notify) { return addDomEvent(ref, "resize", notify); },\n    measureScroll: function () { return ({\n        x: document.documentElement.scrollLeft || document.body.scrollLeft,\n        y: document.documentElement.scrollTop || document.body.scrollTop,\n    }); },\n    checkIsScrollRoot: function () { return true; },\n});\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/projection/node/HTMLProjectionNode.mjs\n\n\n\nvar rootProjectionNode = {\n    current: undefined,\n};\nvar HTMLProjectionNode = createProjectionNode({\n    measureScroll: function (instance) { return ({\n        x: instance.scrollLeft,\n        y: instance.scrollTop,\n    }); },\n    defaultParent: function () {\n        if (!rootProjectionNode.current) {\n            var documentNode = new DocumentProjectionNode(0, {});\n            documentNode.mount(window);\n            documentNode.setOptions({ layoutScroll: true });\n            rootProjectionNode.current = documentNode;\n        }\n        return rootProjectionNode.current;\n    },\n    resetTransform: function (instance, value) {\n        instance.style.transform = value !== null && value !== void 0 ? value : "none";\n    },\n    checkIsScrollRoot: function (instance) {\n        return Boolean(window.getComputedStyle(instance).position === "fixed");\n    },\n});\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/render/dom/motion.mjs\n\n\n\n\n\n\n\n\n\n\n\nvar featureBundle = __assign(__assign(__assign(__assign({}, animations), gestureAnimations), drag), layoutFeatures);\n/**\n * HTML & SVG components, optimised for use with gestures and animation. These can be used as\n * drop-in replacements for any HTML & SVG component, all CSS & SVG properties are supported.\n *\n * @public\n */\nvar motion = /*@__PURE__*/ createMotionProxy(function (Component, config) {\n    return createDomMotionConfig(Component, config, featureBundle, createDomVisualElement, HTMLProjectionNode);\n});\n/**\n * Create a DOM `motion` component with the provided string. This is primarily intended\n * as a full alternative to `motion` for consumers who have to support environments that don\'t\n * support `Proxy`.\n *\n * ```javascript\n * import { createDomMotionComponent } from "framer-motion"\n *\n * const motion = {\n *   div: createDomMotionComponent(\'div\')\n * }\n * ```\n *\n * @public\n */\nfunction createDomMotionComponent(key) {\n    return createMotionComponent(createDomMotionConfig(key, { forwardMotionProps: false }, featureBundle, createDomVisualElement, HTMLProjectionNode));\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/render/dom/motion-minimal.mjs\n\n\n\n/**\n * @public\n */\nvar m = createMotionProxy(createDomMotionConfig);\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/utils/use-is-mounted.mjs\n\n\n\nfunction useIsMounted() {\n    var isMounted = (0,index_js_.useRef)(false);\n    useIsomorphicLayoutEffect(function () {\n        isMounted.current = true;\n        return function () {\n            isMounted.current = false;\n        };\n    }, []);\n    return isMounted;\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/utils/use-force-update.mjs\n\n\n\n\n\nfunction useForceUpdate() {\n    var isMounted = useIsMounted();\n    var _a = __read((0,index_js_.useState)(0), 2), forcedRenderCount = _a[0], setForcedRenderCount = _a[1];\n    var forceRender = (0,index_js_.useCallback)(function () {\n        isMounted.current && setForcedRenderCount(forcedRenderCount + 1);\n    }, [forcedRenderCount]);\n    /**\n     * Defer this to the end of the next animation frame in case there are multiple\n     * synchronous calls.\n     */\n    var deferredForceRender = (0,index_js_.useCallback)(function () { return es.postRender(forceRender); }, [forceRender]);\n    return [deferredForceRender, forcedRenderCount];\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/components/AnimatePresence/PresenceChild.mjs\n\n\n\n\n\n\n\nvar PresenceChild = function (_a) {\n    var children = _a.children, initial = _a.initial, isPresent = _a.isPresent, onExitComplete = _a.onExitComplete, custom = _a.custom, presenceAffectsLayout = _a.presenceAffectsLayout;\n    var presenceChildren = useConstant(newChildrenMap);\n    var id = useId();\n    var context = (0,index_js_.useMemo)(function () { return ({\n        id: id,\n        initial: initial,\n        isPresent: isPresent,\n        custom: custom,\n        onExitComplete: function (childId) {\n            var e_1, _a;\n            presenceChildren.set(childId, true);\n            try {\n                for (var _b = __values(presenceChildren.values()), _c = _b.next(); !_c.done; _c = _b.next()) {\n                    var isComplete = _c.value;\n                    if (!isComplete)\n                        return; // can stop searching when any is incomplete\n                }\n            }\n            catch (e_1_1) { e_1 = { error: e_1_1 }; }\n            finally {\n                try {\n                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n                }\n                finally { if (e_1) throw e_1.error; }\n            }\n            onExitComplete === null || onExitComplete === void 0 ? void 0 : onExitComplete();\n        },\n        register: function (childId) {\n            presenceChildren.set(childId, false);\n            return function () { return presenceChildren.delete(childId); };\n        },\n    }); }, \n    /**\n     * If the presence of a child affects the layout of the components around it,\n     * we want to make a new context value to ensure they get re-rendered\n     * so they can detect that layout change.\n     */\n    presenceAffectsLayout ? undefined : [isPresent]);\n    (0,index_js_.useMemo)(function () {\n        presenceChildren.forEach(function (_, key) { return presenceChildren.set(key, false); });\n    }, [isPresent]);\n    /**\n     * If there\'s no `motion` components to fire exit animations, we want to remove this\n     * component immediately.\n     */\n    index_js_.useEffect(function () {\n        !isPresent && !presenceChildren.size && (onExitComplete === null || onExitComplete === void 0 ? void 0 : onExitComplete());\n    }, [isPresent]);\n    return (index_js_.createElement(PresenceContext.Provider, { value: context }, children));\n};\nfunction newChildrenMap() {\n    return new Map();\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/components/AnimatePresence/index.mjs\n\n\n\n\n\n\n\n\n\n\n\nvar getChildKey = function (child) { return child.key || ""; };\nfunction updateChildLookup(children, allChildren) {\n    children.forEach(function (child) {\n        var key = getChildKey(child);\n        allChildren.set(key, child);\n    });\n}\nfunction onlyElements(children) {\n    var filtered = [];\n    // We use forEach here instead of map as map mutates the component key by preprending `.$`\n    index_js_.Children.forEach(children, function (child) {\n        if ((0,index_js_.isValidElement)(child))\n            filtered.push(child);\n    });\n    return filtered;\n}\n/**\n * `AnimatePresence` enables the animation of components that have been removed from the tree.\n *\n * When adding/removing more than a single child, every child **must** be given a unique `key` prop.\n *\n * Any `motion` components that have an `exit` property defined will animate out when removed from\n * the tree.\n *\n * ```jsx\n * import { motion, AnimatePresence } from \'framer-motion\'\n *\n * export const Items = ({ items }) => (\n *   <AnimatePresence>\n *     {items.map(item => (\n *       <motion.div\n *         key={item.id}\n *         initial={{ opacity: 0 }}\n *         animate={{ opacity: 1 }}\n *         exit={{ opacity: 0 }}\n *       />\n *     ))}\n *   </AnimatePresence>\n * )\n * ```\n *\n * You can sequence exit animations throughout a tree using variants.\n *\n * If a child contains multiple `motion` components with `exit` props, it will only unmount the child\n * once all `motion` components have finished animating out. Likewise, any components using\n * `usePresence` all need to call `safeToRemove`.\n *\n * @public\n */\nvar AnimatePresence = function (_a) {\n    var children = _a.children, custom = _a.custom, _b = _a.initial, initial = _b === void 0 ? true : _b, onExitComplete = _a.onExitComplete, exitBeforeEnter = _a.exitBeforeEnter, _c = _a.presenceAffectsLayout, presenceAffectsLayout = _c === void 0 ? true : _c;\n    // We want to force a re-render once all exiting animations have finished. We\n    // either use a local forceRender function, or one from a parent context if it exists.\n    var _d = __read(useForceUpdate(), 1), forceRender = _d[0];\n    var forceRenderLayoutGroup = (0,index_js_.useContext)(LayoutGroupContext).forceRender;\n    if (forceRenderLayoutGroup)\n        forceRender = forceRenderLayoutGroup;\n    var isMounted = useIsMounted();\n    // Filter out any children that aren\'t ReactElements. We can only track ReactElements with a props.key\n    var filteredChildren = onlyElements(children);\n    var childrenToRender = filteredChildren;\n    var exiting = new Set();\n    // Keep a living record of the children we\'re actually rendering so we\n    // can diff to figure out which are entering and exiting\n    var presentChildren = (0,index_js_.useRef)(childrenToRender);\n    // A lookup table to quickly reference components by key\n    var allChildren = (0,index_js_.useRef)(new Map()).current;\n    // If this is the initial component render, just deal with logic surrounding whether\n    // we play onMount animations or not.\n    var isInitialRender = (0,index_js_.useRef)(true);\n    useIsomorphicLayoutEffect(function () {\n        isInitialRender.current = false;\n        updateChildLookup(filteredChildren, allChildren);\n        presentChildren.current = childrenToRender;\n    });\n    useUnmountEffect(function () {\n        isInitialRender.current = true;\n        allChildren.clear();\n        exiting.clear();\n    });\n    if (isInitialRender.current) {\n        return (index_js_.createElement(index_js_.Fragment, null, childrenToRender.map(function (child) { return (index_js_.createElement(PresenceChild, { key: getChildKey(child), isPresent: true, initial: initial ? undefined : false, presenceAffectsLayout: presenceAffectsLayout }, child)); })));\n    }\n    // If this is a subsequent render, deal with entering and exiting children\n    childrenToRender = __spreadArray([], __read(childrenToRender), false);\n    // Diff the keys of the currently-present and target children to update our\n    // exiting list.\n    var presentKeys = presentChildren.current.map(getChildKey);\n    var targetKeys = filteredChildren.map(getChildKey);\n    // Diff the present children with our target children and mark those that are exiting\n    var numPresent = presentKeys.length;\n    for (var i = 0; i < numPresent; i++) {\n        var key = presentKeys[i];\n        if (targetKeys.indexOf(key) === -1) {\n            exiting.add(key);\n        }\n    }\n    // If we currently have exiting children, and we\'re deferring rendering incoming children\n    // until after all current children have exiting, empty the childrenToRender array\n    if (exitBeforeEnter && exiting.size) {\n        childrenToRender = [];\n    }\n    // Loop through all currently exiting components and clone them to overwrite `animate`\n    // with any `exit` prop they might have defined.\n    exiting.forEach(function (key) {\n        // If this component is actually entering again, early return\n        if (targetKeys.indexOf(key) !== -1)\n            return;\n        var child = allChildren.get(key);\n        if (!child)\n            return;\n        var insertionIndex = presentKeys.indexOf(key);\n        var onExit = function () {\n            allChildren.delete(key);\n            exiting.delete(key);\n            // Remove this child from the present children\n            var removeIndex = presentChildren.current.findIndex(function (presentChild) { return presentChild.key === key; });\n            presentChildren.current.splice(removeIndex, 1);\n            // Defer re-rendering until all exiting children have indeed left\n            if (!exiting.size) {\n                presentChildren.current = filteredChildren;\n                if (isMounted.current === false)\n                    return;\n                forceRender();\n                onExitComplete && onExitComplete();\n            }\n        };\n        childrenToRender.splice(insertionIndex, 0, index_js_.createElement(PresenceChild, { key: getChildKey(child), isPresent: false, onExitComplete: onExit, custom: custom, presenceAffectsLayout: presenceAffectsLayout }, child));\n    });\n    // Add `MotionContext` even to children that don\'t need it to ensure we\'re rendering\n    // the same tree between renders\n    childrenToRender = childrenToRender.map(function (child) {\n        var key = child.key;\n        return exiting.has(key) ? (child) : (index_js_.createElement(PresenceChild, { key: getChildKey(child), isPresent: true, presenceAffectsLayout: presenceAffectsLayout }, child));\n    });\n    if (env !== "production" &&\n        exitBeforeEnter &&\n        childrenToRender.length > 1) {\n        console.warn("You\'re attempting to animate multiple children within AnimatePresence, but its exitBeforeEnter prop is set to true. This will lead to odd visual behaviour.");\n    }\n    return (index_js_.createElement(index_js_.Fragment, null, exiting.size\n        ? childrenToRender\n        : childrenToRender.map(function (child) { return (0,index_js_.cloneElement)(child); })));\n};\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/context/DeprecatedLayoutGroupContext.mjs\n\n\n/**\n * @deprecated\n */\nvar DeprecatedLayoutGroupContext = (0,index_js_.createContext)(null);\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/projection/node/group.mjs\nvar notify = function (node) {\n    return !node.isLayoutDirty && node.willUpdate(false);\n};\nfunction nodeGroup() {\n    var nodes = new Set();\n    var subscriptions = new WeakMap();\n    var dirtyAll = function () { return nodes.forEach(notify); };\n    return {\n        add: function (node) {\n            nodes.add(node);\n            subscriptions.set(node, node.addEventListener("willUpdate", dirtyAll));\n        },\n        remove: function (node) {\n            var _a;\n            nodes.delete(node);\n            (_a = subscriptions.get(node)) === null || _a === void 0 ? void 0 : _a();\n            subscriptions.delete(node);\n            dirtyAll();\n        },\n        dirty: dirtyAll,\n    };\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/components/LayoutGroup/index.mjs\n\n\n\n\n\n\n\n\nvar shouldInheritGroup = function (inherit) { return inherit === true; };\nvar shouldInheritId = function (inherit) {\n    return shouldInheritGroup(inherit === true) || inherit === "id";\n};\nvar LayoutGroup = function (_a) {\n    var _b, _c;\n    var children = _a.children, id = _a.id, inheritId = _a.inheritId, _d = _a.inherit, inherit = _d === void 0 ? true : _d;\n    // Maintain backwards-compatibility with inheritId until 7.0\n    if (inheritId !== undefined)\n        inherit = inheritId;\n    var layoutGroupContext = (0,index_js_.useContext)(LayoutGroupContext);\n    var deprecatedLayoutGroupContext = (0,index_js_.useContext)(DeprecatedLayoutGroupContext);\n    var _e = __read(useForceUpdate(), 2), forceRender = _e[0], key = _e[1];\n    var context = (0,index_js_.useRef)(null);\n    var upstreamId = (_b = layoutGroupContext.id) !== null && _b !== void 0 ? _b : deprecatedLayoutGroupContext;\n    if (context.current === null) {\n        if (shouldInheritId(inherit) && upstreamId) {\n            id = id ? upstreamId + "-" + id : upstreamId;\n        }\n        context.current = {\n            id: id,\n            group: shouldInheritGroup(inherit)\n                ? (_c = layoutGroupContext === null || layoutGroupContext === void 0 ? void 0 : layoutGroupContext.group) !== null && _c !== void 0 ? _c : nodeGroup()\n                : nodeGroup(),\n        };\n    }\n    var memoizedContext = (0,index_js_.useMemo)(function () { return (__assign(__assign({}, context.current), { forceRender: forceRender })); }, [key]);\n    return (index_js_.createElement(LayoutGroupContext.Provider, { value: memoizedContext }, children));\n};\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/components/AnimateSharedLayout.mjs\n\n\n\n\n\nvar AnimateSharedLayout_id = 0;\nvar AnimateSharedLayout = function (_a) {\n    var children = _a.children;\n    index_js_.useEffect(function () {\n        warning(false, "AnimateSharedLayout is deprecated: https://www.framer.com/docs/guide-upgrade/##shared-layout-animations");\n    }, []);\n    return (index_js_.createElement(LayoutGroup, { id: useConstant(function () { return "asl-".concat(AnimateSharedLayout_id++); }) }, children));\n};\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/components/MotionConfig/index.mjs\n\n\n\n\n\n\n\n/**\n * `MotionConfig` is used to set configuration options for all children `motion` components.\n *\n * ```jsx\n * import { motion, MotionConfig } from "framer-motion"\n *\n * export function App() {\n *   return (\n *     <MotionConfig transition={{ type: "spring" }}>\n *       <motion.div animate={{ x: 100 }} />\n *     </MotionConfig>\n *   )\n * }\n * ```\n *\n * @public\n */\nfunction MotionConfig(_a) {\n    var children = _a.children, isValidProp = _a.isValidProp, config = __rest(_a, ["children", "isValidProp"]);\n    isValidProp && loadExternalIsValidProp(isValidProp);\n    /**\n     * Inherit props from any parent MotionConfig components\n     */\n    config = __assign(__assign({}, (0,index_js_.useContext)(MotionConfigContext)), config);\n    /**\n     * Don\'t allow isStatic to change between renders as it affects how many hooks\n     * motion components fire.\n     */\n    config.isStatic = useConstant(function () { return config.isStatic; });\n    /**\n     * Creating a new config context object will re-render every `motion` component\n     * every time it renders. So we only want to create a new one sparingly.\n     */\n    var context = (0,index_js_.useMemo)(function () { return config; }, [JSON.stringify(config.transition), config.transformPagePoint, config.reducedMotion]);\n    return (index_js_.createElement(MotionConfigContext.Provider, { value: context }, children));\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/components/LazyMotion/index.mjs\n\n\n\n\n\n\n/**\n * Used in conjunction with the `m` component to reduce bundle size.\n *\n * `m` is a version of the `motion` component that only loads functionality\n * critical for the initial render.\n *\n * `LazyMotion` can then be used to either synchronously or asynchronously\n * load animation and gesture support.\n *\n * ```jsx\n * // Synchronous loading\n * import { LazyMotion, m, domAnimations } from "framer-motion"\n *\n * function App() {\n *   return (\n *     <LazyMotion features={domAnimations}>\n *       <m.div animate={{ scale: 2 }} />\n *     </LazyMotion>\n *   )\n * }\n *\n * // Asynchronous loading\n * import { LazyMotion, m } from "framer-motion"\n *\n * function App() {\n *   return (\n *     <LazyMotion features={() => import(\'./path/to/domAnimations\')}>\n *       <m.div animate={{ scale: 2 }} />\n *     </LazyMotion>\n *   )\n * }\n * ```\n *\n * @public\n */\nfunction LazyMotion(_a) {\n    var children = _a.children, features = _a.features, _b = _a.strict, strict = _b === void 0 ? false : _b;\n    var _c = __read((0,index_js_.useState)(!isLazyBundle(features)), 2), setIsLoaded = _c[1];\n    var loadedRenderer = (0,index_js_.useRef)(undefined);\n    /**\n     * If this is a synchronous load, load features immediately\n     */\n    if (!isLazyBundle(features)) {\n        var renderer = features.renderer, loadedFeatures = __rest(features, ["renderer"]);\n        loadedRenderer.current = renderer;\n        loadFeatures(loadedFeatures);\n    }\n    (0,index_js_.useEffect)(function () {\n        if (isLazyBundle(features)) {\n            features().then(function (_a) {\n                var renderer = _a.renderer, loadedFeatures = __rest(_a, ["renderer"]);\n                loadFeatures(loadedFeatures);\n                loadedRenderer.current = renderer;\n                setIsLoaded(true);\n            });\n        }\n    }, []);\n    return (index_js_.createElement(LazyContext.Provider, { value: { renderer: loadedRenderer.current, strict: strict } }, children));\n}\nfunction isLazyBundle(features) {\n    return typeof features === "function";\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/context/ReorderContext.mjs\n\n\nvar ReorderContext = (0,index_js_.createContext)(null);\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/components/Reorder/utils/check-reorder.mjs\n\n\n\nfunction checkReorder(order, value, offset, velocity) {\n    if (!velocity)\n        return order;\n    var index = order.findIndex(function (item) { return item.value === value; });\n    if (index === -1)\n        return order;\n    var nextOffset = velocity > 0 ? 1 : -1;\n    var nextItem = order[index + nextOffset];\n    if (!nextItem)\n        return order;\n    var item = order[index];\n    var nextLayout = nextItem.layout;\n    var nextItemCenter = mix(nextLayout.min, nextLayout.max, 0.5);\n    if ((nextOffset === 1 && item.layout.max + offset > nextItemCenter) ||\n        (nextOffset === -1 && item.layout.min + offset < nextItemCenter)) {\n        return moveItem(order, index, index + nextOffset);\n    }\n    return order;\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/components/Reorder/Group.mjs\n\n\n\n\n\n\n\n\n\nfunction ReorderGroup(_a, externalRef) {\n    var children = _a.children, _b = _a.as, as = _b === void 0 ? "ul" : _b, _c = _a.axis, axis = _c === void 0 ? "y" : _c, onReorder = _a.onReorder, values = _a.values, props = __rest(_a, ["children", "as", "axis", "onReorder", "values"]);\n    var Component = useConstant(function () { return motion(as); });\n    var order = [];\n    var isReordering = (0,index_js_.useRef)(false);\n    invariant(Boolean(values), "Reorder.Group must be provided a values prop");\n    var context = {\n        axis: axis,\n        registerItem: function (value, layout) {\n            /**\n             * Ensure entries can\'t add themselves more than once\n             */\n            if (layout &&\n                order.findIndex(function (entry) { return value === entry.value; }) === -1) {\n                order.push({ value: value, layout: layout[axis] });\n                order.sort(compareMin);\n            }\n        },\n        updateOrder: function (id, offset, velocity) {\n            if (isReordering.current)\n                return;\n            var newOrder = checkReorder(order, id, offset, velocity);\n            if (order !== newOrder) {\n                isReordering.current = true;\n                onReorder(newOrder\n                    .map(getValue)\n                    .filter(function (value) { return values.indexOf(value) !== -1; }));\n            }\n        },\n    };\n    (0,index_js_.useEffect)(function () {\n        isReordering.current = false;\n    });\n    return (index_js_.createElement(Component, __assign({}, props, { ref: externalRef }),\n        index_js_.createElement(ReorderContext.Provider, { value: context }, children)));\n}\nvar Group = (0,index_js_.forwardRef)(ReorderGroup);\nfunction getValue(item) {\n    return item.value;\n}\nfunction compareMin(a, b) {\n    return a.layout.min - b.layout.min;\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/value/use-motion-value.mjs\n\n\n\n\n\n\n/**\n * Creates a `MotionValue` to track the state and velocity of a value.\n *\n * Usually, these are created automatically. For advanced use-cases, like use with `useTransform`, you can create `MotionValue`s externally and pass them into the animated component via the `style` prop.\n *\n * ```jsx\n * export const MyComponent = () => {\n *   const scale = useMotionValue(1)\n *\n *   return <motion.div style={{ scale }} />\n * }\n * ```\n *\n * @param initial - The initial state.\n *\n * @public\n */\nfunction useMotionValue(initial) {\n    var value = useConstant(function () { return motionValue(initial); });\n    /**\n     * If this motion value is being used in static mode, like on\n     * the Framer canvas, force components to rerender when the motion\n     * value is updated.\n     */\n    var isStatic = (0,index_js_.useContext)(MotionConfigContext).isStatic;\n    if (isStatic) {\n        var _a = __read((0,index_js_.useState)(initial), 2), setLatest_1 = _a[1];\n        (0,index_js_.useEffect)(function () { return value.onChange(setLatest_1); }, []);\n    }\n    return value;\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/utils/transform.mjs\n\n\n\nvar isCustomValueType = function (v) {\n    return typeof v === "object" && v.mix;\n};\nvar transform_getMixer = function (v) { return (isCustomValueType(v) ? v.mix : undefined); };\nfunction transform() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    var useImmediate = !Array.isArray(args[0]);\n    var argOffset = useImmediate ? 0 : -1;\n    var inputValue = args[0 + argOffset];\n    var inputRange = args[1 + argOffset];\n    var outputRange = args[2 + argOffset];\n    var options = args[3 + argOffset];\n    var interpolator = interpolate(inputRange, outputRange, __assign({ mixer: transform_getMixer(outputRange[0]) }, options));\n    return useImmediate ? interpolator(inputValue) : interpolator;\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/value/use-on-change.mjs\n\n\n\nfunction useOnChange(value, callback) {\n    useIsomorphicLayoutEffect(function () {\n        if (isMotionValue(value))\n            return value.onChange(callback);\n    }, [callback]);\n}\nfunction useMultiOnChange(values, handler) {\n    useIsomorphicLayoutEffect(function () {\n        var subscriptions = values.map(function (value) { return value.onChange(handler); });\n        return function () { return subscriptions.forEach(function (unsubscribe) { return unsubscribe(); }); };\n    });\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/value/use-combine-values.mjs\n\n\n\n\nfunction useCombineMotionValues(values, combineValues) {\n    /**\n     * Initialise the returned motion value. This remains the same between renders.\n     */\n    var value = useMotionValue(combineValues());\n    /**\n     * Create a function that will update the template motion value with the latest values.\n     * This is pre-bound so whenever a motion value updates it can schedule its\n     * execution in Framesync. If it\'s already been scheduled it won\'t be fired twice\n     * in a single frame.\n     */\n    var updateValue = function () { return value.set(combineValues()); };\n    /**\n     * Synchronously update the motion value with the latest values during the render.\n     * This ensures that within a React render, the styles applied to the DOM are up-to-date.\n     */\n    updateValue();\n    /**\n     * Subscribe to all motion values found within the template. Whenever any of them change,\n     * schedule an update.\n     */\n    useMultiOnChange(values, function () { return es.update(updateValue, false, true); });\n    return value;\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/value/use-transform.mjs\n\n\n\n\n\nfunction useTransform(input, inputRangeOrTransformer, outputRange, options) {\n    var transformer = typeof inputRangeOrTransformer === "function"\n        ? inputRangeOrTransformer\n        : transform(inputRangeOrTransformer, outputRange, options);\n    return Array.isArray(input)\n        ? useListTransform(input, transformer)\n        : useListTransform([input], function (_a) {\n            var _b = __read(_a, 1), latest = _b[0];\n            return transformer(latest);\n        });\n}\nfunction useListTransform(values, transformer) {\n    var latest = useConstant(function () { return []; });\n    return useCombineMotionValues(values, function () {\n        latest.length = 0;\n        var numValues = values.length;\n        for (var i = 0; i < numValues; i++) {\n            latest[i] = values[i].get();\n        }\n        return transformer(latest);\n    });\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/components/Reorder/Item.mjs\n\n\n\n\n\n\n\n\n\n\n\nfunction useDefaultMotionValue(value, defaultValue) {\n    if (defaultValue === void 0) { defaultValue = 0; }\n    return isMotionValue(value) ? value : useMotionValue(defaultValue);\n}\nfunction ReorderItem(_a, externalRef) {\n    var children = _a.children, style = _a.style, value = _a.value, _b = _a.as, as = _b === void 0 ? "li" : _b, onDrag = _a.onDrag, _c = _a.layout, layout = _c === void 0 ? true : _c, props = __rest(_a, ["children", "style", "value", "as", "onDrag", "layout"]);\n    var Component = useConstant(function () { return motion(as); });\n    var context = (0,index_js_.useContext)(ReorderContext);\n    var point = {\n        x: useDefaultMotionValue(style === null || style === void 0 ? void 0 : style.x),\n        y: useDefaultMotionValue(style === null || style === void 0 ? void 0 : style.y),\n    };\n    var zIndex = useTransform([point.x, point.y], function (_a) {\n        var _b = __read(_a, 2), latestX = _b[0], latestY = _b[1];\n        return latestX || latestY ? 1 : "unset";\n    });\n    var measuredLayout = (0,index_js_.useRef)(null);\n    invariant(Boolean(context), "Reorder.Item must be a child of Reorder.Group");\n    var _d = context, axis = _d.axis, registerItem = _d.registerItem, updateOrder = _d.updateOrder;\n    (0,index_js_.useEffect)(function () {\n        registerItem(value, measuredLayout.current);\n    }, [context]);\n    return (index_js_.createElement(Component, __assign({ drag: axis }, props, { dragSnapToOrigin: true, style: __assign(__assign({}, style), { x: point.x, y: point.y, zIndex: zIndex }), layout: layout, onDrag: function (event, gesturePoint) {\n            var velocity = gesturePoint.velocity;\n            velocity[axis] &&\n                updateOrder(value, point[axis].get(), velocity[axis]);\n            onDrag === null || onDrag === void 0 ? void 0 : onDrag(event, gesturePoint);\n        }, onLayoutMeasure: function (measured) {\n            measuredLayout.current = measured;\n        }, ref: externalRef }), children));\n}\nvar Item = (0,index_js_.forwardRef)(ReorderItem);\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/components/Reorder/index.mjs\n\n\n\nvar Reorder = {\n    Group: Group,\n    Item: Item,\n};\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/render/dom/features-animation.mjs\n\n\n\n\n\n/**\n * @public\n */\nvar domAnimation = __assign(__assign({ renderer: createDomVisualElement }, animations), gestureAnimations);\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/render/dom/features-max.mjs\n\n\n\n\n\n\n/**\n * @public\n */\nvar domMax = __assign(__assign(__assign(__assign({}, domAnimation), drag), layoutFeatures), { projectionNodeConstructor: HTMLProjectionNode });\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/value/use-motion-template.mjs\n\n\n/**\n * Combine multiple motion values into a new one using a string template literal.\n *\n * ```jsx\n * import {\n *   motion,\n *   useSpring,\n *   useMotionValue,\n *   useMotionTemplate\n * } from "framer-motion"\n *\n * function Component() {\n *   const shadowX = useSpring(0)\n *   const shadowY = useMotionValue(0)\n *   const shadow = useMotionTemplate`drop-shadow(${shadowX}px ${shadowY}px 20px rgba(0,0,0,0.3))`\n *\n *   return <motion.div style={{ filter: shadow }} />\n * }\n * ```\n *\n * @public\n */\nfunction useMotionTemplate(fragments) {\n    var values = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        values[_i - 1] = arguments[_i];\n    }\n    /**\n     * Create a function that will build a string from the latest motion values.\n     */\n    var numFragments = fragments.length;\n    function buildValue() {\n        var output = "";\n        for (var i = 0; i < numFragments; i++) {\n            output += fragments[i];\n            var value = values[i];\n            if (value)\n                output += values[i].get();\n        }\n        return output;\n    }\n    return useCombineMotionValues(values, buildValue);\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/value/use-spring.mjs\n\n\n\n\n\n\n\n\n/**\n * Creates a `MotionValue` that, when `set`, will use a spring animation to animate to its new state.\n *\n * It can either work as a stand-alone `MotionValue` by initialising it with a value, or as a subscriber\n * to another `MotionValue`.\n *\n * @remarks\n *\n * ```jsx\n * const x = useSpring(0, { stiffness: 300 })\n * const y = useSpring(x, { damping: 10 })\n * ```\n *\n * @param inputValue - `MotionValue` or number. If provided a `MotionValue`, when the input `MotionValue` changes, the created `MotionValue` will spring towards that value.\n * @param springConfig - Configuration options for the spring.\n * @returns `MotionValue`\n *\n * @public\n */\nfunction useSpring(source, config) {\n    if (config === void 0) { config = {}; }\n    var isStatic = (0,index_js_.useContext)(MotionConfigContext).isStatic;\n    var activeSpringAnimation = (0,index_js_.useRef)(null);\n    var value = useMotionValue(isMotionValue(source) ? source.get() : source);\n    (0,index_js_.useMemo)(function () {\n        return value.attach(function (v, set) {\n            /**\n             * A more hollistic approach to this might be to use isStatic to fix VisualElement animations\n             * at that level, but this will work for now\n             */\n            if (isStatic)\n                return set(v);\n            if (activeSpringAnimation.current) {\n                activeSpringAnimation.current.stop();\n            }\n            activeSpringAnimation.current = animate(__assign(__assign({ from: value.get(), to: v, velocity: value.getVelocity() }, config), { onUpdate: set }));\n            return value.get();\n        });\n    }, [JSON.stringify(config)]);\n    useOnChange(source, function (v) { return value.set(parseFloat(v)); });\n    return value;\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/value/use-velocity.mjs\n\n\n\n/**\n * Creates a `MotionValue` that updates when the velocity of the provided `MotionValue` changes.\n *\n * ```javascript\n * const x = useMotionValue(0)\n * const xVelocity = useVelocity(x)\n * const xAcceleration = useVelocity(xVelocity)\n * ```\n *\n * @public\n */\nfunction useVelocity(value) {\n    var velocity = useMotionValue(value.getVelocity());\n    (0,index_js_.useEffect)(function () {\n        return value.velocityUpdateSubscribers.add(function (newVelocity) {\n            velocity.set(newVelocity);\n        });\n    }, [value]);\n    return velocity;\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@motionone/dom/dist/utils/resolve-elements.es.js\nfunction resolveElements(elements, selectorCache) {\n    var _a;\n    if (typeof elements === "string") {\n        if (selectorCache) {\n            (_a = selectorCache[elements]) !== null && _a !== void 0 ? _a : (selectorCache[elements] = document.querySelectorAll(elements));\n            elements = selectorCache[elements];\n        }\n        else {\n            elements = document.querySelectorAll(elements);\n        }\n    }\n    else if (elements instanceof Element) {\n        elements = [elements];\n    }\n    /**\n     * Return an empty array\n     */\n    return Array.from(elements || []);\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@motionone/dom/dist/gestures/resize/handle-element.es.js\n\n\nconst resizeHandlers = new WeakMap();\nlet observer;\nfunction getElementSize(target, borderBoxSize) {\n    if (borderBoxSize) {\n        const { inlineSize, blockSize } = borderBoxSize[0];\n        return { width: inlineSize, height: blockSize };\n    }\n    else if (target instanceof SVGElement && "getBBox" in target) {\n        return target.getBBox();\n    }\n    else {\n        return {\n            width: target.offsetWidth,\n            height: target.offsetHeight,\n        };\n    }\n}\nfunction notifyTarget({ target, contentRect, borderBoxSize, }) {\n    var _a;\n    (_a = resizeHandlers.get(target)) === null || _a === void 0 ? void 0 : _a.forEach((handler) => {\n        handler({\n            target,\n            contentSize: contentRect,\n            get size() {\n                return getElementSize(target, borderBoxSize);\n            },\n        });\n    });\n}\nfunction notifyAll(entries) {\n    entries.forEach(notifyTarget);\n}\nfunction createResizeObserver() {\n    if (typeof ResizeObserver === "undefined")\n        return;\n    observer = new ResizeObserver(notifyAll);\n}\nfunction resizeElement(target, handler) {\n    if (!observer)\n        createResizeObserver();\n    const elements = resolveElements(target);\n    elements.forEach((element) => {\n        let elementHandlers = resizeHandlers.get(element);\n        if (!elementHandlers) {\n            elementHandlers = new Set();\n            resizeHandlers.set(element, elementHandlers);\n        }\n        elementHandlers.add(handler);\n        observer === null || observer === void 0 ? void 0 : observer.observe(element);\n    });\n    return () => {\n        elements.forEach((element) => {\n            const elementHandlers = resizeHandlers.get(element);\n            elementHandlers === null || elementHandlers === void 0 ? void 0 : elementHandlers.delete(handler);\n            if (!(elementHandlers === null || elementHandlers === void 0 ? void 0 : elementHandlers.size)) {\n                observer === null || observer === void 0 ? void 0 : observer.unobserve(element);\n            }\n        });\n    };\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@motionone/dom/dist/gestures/resize/handle-window.es.js\nconst windowCallbacks = new Set();\nlet windowResizeHandler;\nfunction createWindowResizeHandler() {\n    windowResizeHandler = () => {\n        const size = {\n            width: window.innerWidth,\n            height: window.innerHeight,\n        };\n        const info = {\n            target: window,\n            size,\n            contentSize: size,\n        };\n        windowCallbacks.forEach((callback) => callback(info));\n    };\n    window.addEventListener("resize", windowResizeHandler);\n}\nfunction resizeWindow(callback) {\n    windowCallbacks.add(callback);\n    if (!windowResizeHandler)\n        createWindowResizeHandler();\n    return () => {\n        windowCallbacks.delete(callback);\n        if (!windowCallbacks.size && windowResizeHandler) {\n            windowResizeHandler = undefined;\n        }\n    };\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@motionone/dom/dist/gestures/resize/index.es.js\n\n\n\nfunction resize(a, b) {\n    return typeof a === "function" ? resizeWindow(a) : resizeElement(a, b);\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@motionone/utils/dist/progress.es.js\nconst progress_es_progress = (min, max, value) => max - min === 0 ? 1 : (value - min) / (max - min);\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@motionone/utils/dist/velocity.es.js\n/*\n  Convert velocity into velocity per second\n\n  @param [number]: Unit per frame\n  @param [number]: Frame duration in ms\n*/\nfunction velocity_es_velocityPerSecond(velocity, frameDuration) {\n    return frameDuration ? velocity * (1000 / frameDuration) : 0;\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@motionone/dom/dist/gestures/scroll/info.es.js\n\n\n/**\n * A time in milliseconds, beyond which we consider the scroll velocity to be 0.\n */\nconst info_es_maxElapsed = 50;\nconst createAxisInfo = () => ({\n    current: 0,\n    offset: [],\n    progress: 0,\n    scrollLength: 0,\n    targetOffset: 0,\n    targetLength: 0,\n    containerLength: 0,\n    velocity: 0,\n});\nconst createScrollInfo = () => ({\n    time: 0,\n    x: createAxisInfo(),\n    y: createAxisInfo(),\n});\nconst keys = {\n    x: {\n        length: "Width",\n        position: "Left",\n    },\n    y: {\n        length: "Height",\n        position: "Top",\n    },\n};\nfunction updateAxisInfo(element, axisName, info, time) {\n    const axis = info[axisName];\n    const { length, position } = keys[axisName];\n    const prev = axis.current;\n    const prevTime = info.time;\n    axis.current = element["scroll" + position];\n    axis.scrollLength = element["scroll" + length] - element["client" + length];\n    axis.offset.length = 0;\n    axis.offset[0] = 0;\n    axis.offset[1] = axis.scrollLength;\n    axis.progress = progress_es_progress(0, axis.scrollLength, axis.current);\n    const elapsed = time - prevTime;\n    axis.velocity =\n        elapsed > info_es_maxElapsed ? 0 : velocity_es_velocityPerSecond(axis.current - prev, elapsed);\n}\nfunction updateScrollInfo(element, info, time) {\n    updateAxisInfo(element, "x", info, time);\n    updateAxisInfo(element, "y", info, time);\n    info.time = time;\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@motionone/utils/dist/noop.es.js\nconst noop = () => { };\nconst noopReturn = (v) => v;\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@motionone/utils/dist/mix.es.js\nconst mix_es_mix = (min, max, progress) => -progress * min + progress * max + min;\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@motionone/utils/dist/offset.es.js\n\n\n\nfunction fillOffset(offset, remaining) {\n    const min = offset[offset.length - 1];\n    for (let i = 1; i <= remaining; i++) {\n        const offsetProgress = progress_es_progress(0, remaining, i);\n        offset.push(mix_es_mix(min, 1, offsetProgress));\n    }\n}\nfunction offset_es_defaultOffset(length) {\n    const offset = [0];\n    fillOffset(offset, length - 1);\n    return offset;\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@motionone/utils/dist/is-number.es.js\nconst isNumber = (value) => typeof value === "number";\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@motionone/utils/dist/is-easing-list.es.js\n\n\nconst isEasingList = (easing) => Array.isArray(easing) && !isNumber(easing[0]);\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@motionone/utils/dist/wrap.es.js\nconst wrap = (min, max, v) => {\n    const rangeSize = max - min;\n    return ((((v - min) % rangeSize) + rangeSize) % rangeSize) + min;\n};\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@motionone/utils/dist/easing.es.js\n\n\n\nfunction getEasingForSegment(easing, i) {\n    return isEasingList(easing)\n        ? easing[wrap(0, easing.length, i)]\n        : easing;\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@motionone/utils/dist/clamp.es.js\nconst clamp_es_clamp = (min, max, v) => Math.min(Math.max(v, min), max);\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@motionone/utils/dist/interpolate.es.js\n\n\n\n\n\n\n\nfunction interpolate_es_interpolate(output, input = offset_es_defaultOffset(output.length), easing = noopReturn) {\n    const length = output.length;\n    /**\n     * If the input length is lower than the output we\n     * fill the input to match. This currently assumes the input\n     * is an animation progress value so is a good candidate for\n     * moving outside the function.\n     */\n    const remainder = length - input.length;\n    remainder > 0 && fillOffset(input, remainder);\n    return (t) => {\n        let i = 0;\n        for (; i < length - 2; i++) {\n            if (t < input[i + 1])\n                break;\n        }\n        let progressInRange = clamp_es_clamp(0, 1, progress_es_progress(input[i], input[i + 1], t));\n        const segmentEasing = getEasingForSegment(easing, i);\n        progressInRange = segmentEasing(progressInRange);\n        return mix_es_mix(output[i], output[i + 1], progressInRange);\n    };\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@motionone/dom/dist/gestures/scroll/offsets/inset.es.js\nfunction calcInset(element, container) {\n    let inset = { x: 0, y: 0 };\n    let current = element;\n    while (current && current !== container) {\n        if (current instanceof HTMLElement) {\n            inset.x += current.offsetLeft;\n            inset.y += current.offsetTop;\n            current = current.offsetParent;\n        }\n        else if (current instanceof SVGGraphicsElement && "getBBox" in current) {\n            const { top, left } = current.getBBox();\n            inset.x += left;\n            inset.y += top;\n            /**\n             * Assign the next parent element as the <svg /> tag.\n             */\n            while (current && current.tagName !== "svg") {\n                current = current.parentNode;\n            }\n        }\n    }\n    return inset;\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@motionone/dom/dist/gestures/scroll/offsets/presets.es.js\nconst ScrollOffset = {\n    Enter: [\n        [0, 1],\n        [1, 1],\n    ],\n    Exit: [\n        [0, 0],\n        [1, 0],\n    ],\n    Any: [\n        [1, 0],\n        [0, 1],\n    ],\n    All: [\n        [0, 0],\n        [1, 1],\n    ],\n};\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@motionone/utils/dist/is-string.es.js\nconst is_string_es_isString = (value) => typeof value === "string";\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@motionone/dom/dist/gestures/scroll/offsets/edge.es.js\n\n\nconst namedEdges = {\n    start: 0,\n    center: 0.5,\n    end: 1,\n};\nfunction resolveEdge(edge, length, inset = 0) {\n    let delta = 0;\n    /**\n     * If we have this edge defined as a preset, replace the definition\n     * with the numerical value.\n     */\n    if (namedEdges[edge] !== undefined) {\n        edge = namedEdges[edge];\n    }\n    /**\n     * Handle unit values\n     */\n    if (is_string_es_isString(edge)) {\n        const asNumber = parseFloat(edge);\n        if (edge.endsWith("px")) {\n            delta = asNumber;\n        }\n        else if (edge.endsWith("%")) {\n            edge = asNumber / 100;\n        }\n        else if (edge.endsWith("vw")) {\n            delta = (asNumber / 100) * document.documentElement.clientWidth;\n        }\n        else if (edge.endsWith("vh")) {\n            delta = (asNumber / 100) * document.documentElement.clientHeight;\n        }\n        else {\n            edge = asNumber;\n        }\n    }\n    /**\n     * If the edge is defined as a number, handle as a progress value.\n     */\n    if (isNumber(edge)) {\n        delta = length * edge;\n    }\n    return inset + delta;\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@motionone/dom/dist/gestures/scroll/offsets/offset.es.js\n\n\n\nconst offsets_offset_es_defaultOffset = [0, 0];\nfunction resolveOffset(offset, containerLength, targetLength, targetInset) {\n    let offsetDefinition = Array.isArray(offset) ? offset : offsets_offset_es_defaultOffset;\n    let targetPoint = 0;\n    let containerPoint = 0;\n    if (isNumber(offset)) {\n        /**\n         * If we\'re provided offset: [0, 0.5, 1] then each number x should become\n         * [x, x], so we default to the behaviour of mapping 0 => 0 of both target\n         * and container etc.\n         */\n        offsetDefinition = [offset, offset];\n    }\n    else if (is_string_es_isString(offset)) {\n        offset = offset.trim();\n        if (offset.includes(" ")) {\n            offsetDefinition = offset.split(" ");\n        }\n        else {\n            /**\n             * If we\'re provided a definition like "100px" then we want to apply\n             * that only to the top of the target point, leaving the container at 0.\n             * Whereas a named offset like "end" should be applied to both.\n             */\n            offsetDefinition = [offset, namedEdges[offset] ? offset : `0`];\n        }\n    }\n    targetPoint = resolveEdge(offsetDefinition[0], targetLength, targetInset);\n    containerPoint = resolveEdge(offsetDefinition[1], containerLength);\n    return targetPoint - containerPoint;\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@motionone/dom/dist/gestures/scroll/offsets/index.es.js\n\n\n\n\n\nconst point = { x: 0, y: 0 };\nfunction resolveOffsets(container, info, options) {\n    let { offset: offsetDefinition = ScrollOffset.All } = options;\n    const { target = container, axis = "y" } = options;\n    const lengthLabel = axis === "y" ? "height" : "width";\n    const inset = target !== container ? calcInset(target, container) : point;\n    /**\n     * Measure the target and container. If they\'re the same thing then we\n     * use the container\'s scrollWidth/Height as the target, from there\n     * all other calculations can remain the same.\n     */\n    const targetSize = target === container\n        ? { width: container.scrollWidth, height: container.scrollHeight }\n        : { width: target.clientWidth, height: target.clientHeight };\n    const containerSize = {\n        width: container.clientWidth,\n        height: container.clientHeight,\n    };\n    /**\n     * Reset the length of the resolved offset array rather than creating a new one.\n     * TODO: More reusable data structures for targetSize/containerSize would also be good.\n     */\n    info[axis].offset.length = 0;\n    /**\n     * Populate the offset array by resolving the user\'s offset definition into\n     * a list of pixel scroll offets.\n     */\n    let hasChanged = !info[axis].interpolate;\n    const numOffsets = offsetDefinition.length;\n    for (let i = 0; i < numOffsets; i++) {\n        const offset = resolveOffset(offsetDefinition[i], containerSize[lengthLabel], targetSize[lengthLabel], inset[axis]);\n        if (!hasChanged && offset !== info[axis].interpolatorOffsets[i]) {\n            hasChanged = true;\n        }\n        info[axis].offset[i] = offset;\n    }\n    /**\n     * If the pixel scroll offsets have changed, create a new interpolator function\n     * to map scroll value into a progress.\n     */\n    if (hasChanged) {\n        info[axis].interpolate = interpolate_es_interpolate(offset_es_defaultOffset(numOffsets), info[axis].offset);\n        info[axis].interpolatorOffsets = [...info[axis].offset];\n    }\n    info[axis].progress = info[axis].interpolate(info[axis].current);\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@motionone/dom/dist/gestures/scroll/on-scroll-handler.es.js\n\n\n\n\nfunction measure(container, target = container, info) {\n    /**\n     * Find inset of target within scrollable container\n     */\n    info.x.targetOffset = 0;\n    info.y.targetOffset = 0;\n    if (target !== container) {\n        let node = target;\n        while (node && node != container) {\n            info.x.targetOffset += node.offsetLeft;\n            info.y.targetOffset += node.offsetTop;\n            node = node.offsetParent;\n        }\n    }\n    info.x.targetLength =\n        target === container ? target.scrollWidth : target.clientWidth;\n    info.y.targetLength =\n        target === container ? target.scrollHeight : target.clientHeight;\n    info.x.containerLength = container.clientWidth;\n    info.y.containerLength = container.clientHeight;\n}\nfunction createOnScrollHandler(element, onScroll, info, options = {}) {\n    const axis = options.axis || "y";\n    return {\n        measure: () => measure(element, options.target, info),\n        update: (time) => {\n            updateScrollInfo(element, info, time);\n            if (options.offset || options.target) {\n                resolveOffsets(element, info, options);\n            }\n        },\n        notify: typeof onScroll === "function"\n            ? () => onScroll(info)\n            : scrubAnimation(onScroll, info[axis]),\n    };\n}\nfunction scrubAnimation(controls, axisInfo) {\n    controls.pause();\n    controls.forEachNative((animation, { easing }) => {\n        var _a, _b;\n        if (animation.updateDuration) {\n            if (!easing)\n                animation.easing = noopReturn;\n            animation.updateDuration(1);\n        }\n        else {\n            const timingOptions = { duration: 1000 };\n            if (!easing)\n                timingOptions.easing = "linear";\n            (_b = (_a = animation.effect) === null || _a === void 0 ? void 0 : _a.updateTiming) === null || _b === void 0 ? void 0 : _b.call(_a, timingOptions);\n        }\n    });\n    return () => {\n        controls.currentTime = axisInfo.progress;\n    };\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@motionone/dom/dist/gestures/scroll/index.es.js\n\n\n\n\n\nconst scrollListeners = new WeakMap();\nconst resizeListeners = new WeakMap();\nconst onScrollHandlers = new WeakMap();\nconst getEventTarget = (element) => element === document.documentElement ? window : element;\nfunction index_es_scroll(onScroll, _a = {}) {\n    var { container = document.documentElement } = _a, options = __rest(_a, ["container"]);\n    let containerHandlers = onScrollHandlers.get(container);\n    /**\n     * Get the onScroll handlers for this container.\n     * If one isn\'t found, create a new one.\n     */\n    if (!containerHandlers) {\n        containerHandlers = new Set();\n        onScrollHandlers.set(container, containerHandlers);\n    }\n    /**\n     * Create a new onScroll handler for the provided callback.\n     */\n    const info = createScrollInfo();\n    const containerHandler = createOnScrollHandler(container, onScroll, info, options);\n    containerHandlers.add(containerHandler);\n    /**\n     * Check if there\'s a scroll event listener for this container.\n     * If not, create one.\n     */\n    if (!scrollListeners.has(container)) {\n        const listener = () => {\n            const time = performance.now();\n            for (const handler of containerHandlers)\n                handler.measure();\n            for (const handler of containerHandlers)\n                handler.update(time);\n            for (const handler of containerHandlers)\n                handler.notify();\n        };\n        scrollListeners.set(container, listener);\n        const target = getEventTarget(container);\n        window.addEventListener("resize", listener, { passive: true });\n        if (container !== document.documentElement) {\n            resizeListeners.set(container, resize(container, listener));\n        }\n        target.addEventListener("scroll", listener, { passive: true });\n    }\n    const listener = scrollListeners.get(container);\n    const onLoadProcesss = requestAnimationFrame(listener);\n    return () => {\n        var _a;\n        if (typeof onScroll !== "function")\n            onScroll.stop();\n        cancelAnimationFrame(onLoadProcesss);\n        /**\n         * Check if we even have any handlers for this container.\n         */\n        const containerHandlers = onScrollHandlers.get(container);\n        if (!containerHandlers)\n            return;\n        containerHandlers.delete(containerHandler);\n        if (containerHandlers.size)\n            return;\n        /**\n         * If no more handlers, remove the scroll listener too.\n         */\n        const listener = scrollListeners.get(container);\n        scrollListeners.delete(container);\n        if (listener) {\n            getEventTarget(container).removeEventListener("scroll", listener);\n            (_a = resizeListeners.get(container)) === null || _a === void 0 ? void 0 : _a();\n            window.removeEventListener("resize", listener);\n        }\n    };\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/value/use-scroll.mjs\n\n\n\n\n\n\nvar createScrollMotionValues = function () { return ({\n    scrollX: motionValue(0),\n    scrollY: motionValue(0),\n    scrollXProgress: motionValue(0),\n    scrollYProgress: motionValue(0),\n}); };\nfunction useScroll(_a) {\n    if (_a === void 0) { _a = {}; }\n    var container = _a.container, target = _a.target, options = __rest(_a, ["container", "target"]);\n    var values = useConstant(createScrollMotionValues);\n    useIsomorphicLayoutEffect(function () {\n        return index_es_scroll(function (_a) {\n            var x = _a.x, y = _a.y;\n            values.scrollX.set(x.current);\n            values.scrollXProgress.set(x.progress);\n            values.scrollY.set(y.current);\n            values.scrollYProgress.set(y.progress);\n        }, __assign(__assign({}, options), { container: (container === null || container === void 0 ? void 0 : container.current) || undefined, target: (target === null || target === void 0 ? void 0 : target.current) || undefined }));\n    }, []);\n    return values;\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/value/scroll/use-element-scroll.mjs\n\n\n\nfunction useElementScroll(ref) {\n    warnOnce(false, "useElementScroll is deprecated. Convert to useScroll({ container: ref }).");\n    return useScroll({ container: ref });\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/value/scroll/use-viewport-scroll.mjs\n\n\n\nfunction useViewportScroll() {\n    warnOnce(false, "useViewportScroll is deprecated. Convert to useScroll().");\n    return useScroll();\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/utils/use-animation-frame.mjs\n\n\n\n\n\nvar use_animation_frame_getCurrentTime = typeof performance !== "undefined"\n    ? function () { return performance.now(); }\n    : function () { return Date.now(); };\nfunction useAnimationFrame(callback) {\n    var initialTimestamp = useConstant(use_animation_frame_getCurrentTime);\n    var isStatic = (0,index_js_.useContext)(MotionConfigContext).isStatic;\n    (0,index_js_.useEffect)(function () {\n        if (isStatic)\n            return;\n        var provideTimeSinceStart = function (_a) {\n            var timestamp = _a.timestamp;\n            callback(timestamp - initialTimestamp);\n        };\n        es.update(provideTimeSinceStart, true);\n        return function () { return cancelSync.update(provideTimeSinceStart); };\n    }, [callback]);\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/value/use-time.mjs\n\n\n\nfunction useTime() {\n    var time = useMotionValue(0);\n    useAnimationFrame(function (t) { return time.set(t); });\n    return time;\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/animation/animation-controls.mjs\n\n\n\n\n\n/**\n * @public\n */\nfunction animationControls() {\n    /**\n     * Track whether the host component has mounted.\n     */\n    var hasMounted = false;\n    /**\n     * Pending animations that are started before a component is mounted.\n     * TODO: Remove this as animations should only run in effects\n     */\n    var pendingAnimations = [];\n    /**\n     * A collection of linked component animation controls.\n     */\n    var subscribers = new Set();\n    var controls = {\n        subscribe: function (visualElement) {\n            subscribers.add(visualElement);\n            return function () { return void subscribers.delete(visualElement); };\n        },\n        start: function (definition, transitionOverride) {\n            /**\n             * TODO: We only perform this hasMounted check because in Framer we used to\n             * encourage the ability to start an animation within the render phase. This\n             * isn\'t behaviour concurrent-safe so when we make Framer concurrent-safe\n             * we can ditch this.\n             */\n            if (hasMounted) {\n                var animations_1 = [];\n                subscribers.forEach(function (visualElement) {\n                    animations_1.push(animateVisualElement(visualElement, definition, {\n                        transitionOverride: transitionOverride,\n                    }));\n                });\n                return Promise.all(animations_1);\n            }\n            else {\n                return new Promise(function (resolve) {\n                    pendingAnimations.push({\n                        animation: [definition, transitionOverride],\n                        resolve: resolve,\n                    });\n                });\n            }\n        },\n        set: function (definition) {\n            invariant(hasMounted, "controls.set() should only be called after a component has mounted. Consider calling within a useEffect hook.");\n            return subscribers.forEach(function (visualElement) {\n                setValues(visualElement, definition);\n            });\n        },\n        stop: function () {\n            subscribers.forEach(function (visualElement) {\n                stopAnimation(visualElement);\n            });\n        },\n        mount: function () {\n            hasMounted = true;\n            pendingAnimations.forEach(function (_a) {\n                var animation = _a.animation, resolve = _a.resolve;\n                controls.start.apply(controls, __spreadArray([], __read(animation), false)).then(resolve);\n            });\n            return function () {\n                hasMounted = false;\n                controls.stop();\n            };\n        },\n    };\n    return controls;\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/animation/use-animation.mjs\n\n\n\n\n/**\n * Creates `AnimationControls`, which can be used to manually start, stop\n * and sequence animations on one or more components.\n *\n * The returned `AnimationControls` should be passed to the `animate` property\n * of the components you want to animate.\n *\n * These components can then be animated with the `start` method.\n *\n * ```jsx\n * import * as React from \'react\'\n * import { motion, useAnimation } from \'framer-motion\'\n *\n * export function MyComponent(props) {\n *    const controls = useAnimation()\n *\n *    controls.start({\n *        x: 100,\n *        transition: { duration: 0.5 },\n *    })\n *\n *    return <motion.div animate={controls} />\n * }\n * ```\n *\n * @returns Animation controller with `start` and `stop` methods\n *\n * @public\n */\nfunction useAnimationControls() {\n    var controls = useConstant(animationControls);\n    (0,index_js_.useEffect)(controls.mount, []);\n    return controls;\n}\nvar useAnimation = useAnimationControls;\n\n\n\n;// CONCATENATED MODULE: ./node_modules/popmotion/dist/es/utils/wrap.mjs\nconst wrap_wrap = (min, max, v) => {\n    const rangeSize = max - min;\n    return ((((v - min) % rangeSize) + rangeSize) % rangeSize) + min;\n};\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/utils/use-cycle.mjs\n\n\n\n\n/**\n * Cycles through a series of visual properties. Can be used to toggle between or cycle through animations. It works similar to `useState` in React. It is provided an initial array of possible states, and returns an array of two arguments.\n *\n * An index value can be passed to the returned `cycle` function to cycle to a specific index.\n *\n * ```jsx\n * import * as React from "react"\n * import { motion, useCycle } from "framer-motion"\n *\n * export const MyComponent = () => {\n *   const [x, cycleX] = useCycle(0, 50, 100)\n *\n *   return (\n *     <motion.div\n *       animate={{ x: x }}\n *       onTap={() => cycleX()}\n *      />\n *    )\n * }\n * ```\n *\n * @param items - items to cycle through\n * @returns [currentState, cycleState]\n *\n * @public\n */\nfunction useCycle() {\n    var items = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        items[_i] = arguments[_i];\n    }\n    var index = (0,index_js_.useRef)(0);\n    var _a = __read((0,index_js_.useState)(items[index.current]), 2), item = _a[0], setItem = _a[1];\n    var runCycle = (0,index_js_.useCallback)(function (next) {\n        index.current =\n            typeof next !== "number"\n                ? wrap_wrap(0, items.length, index.current + 1)\n                : next;\n        setItem(items[index.current]);\n    }, __spreadArray([items.length], __read(items), false));\n    return [item, runCycle];\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/@motionone/dom/dist/gestures/in-view.es.js\n\n\nconst thresholds = {\n    any: 0,\n    all: 1,\n};\nfunction inView(elementOrSelector, onStart, { root, margin: rootMargin, amount = "any" } = {}) {\n    /**\n     * If this browser doesn\'t support IntersectionObserver, return a dummy stop function.\n     * Default triggering of onStart is tricky - it could be used for starting/stopping\n     * videos, lazy loading content etc. We could provide an option to enable a fallback, or\n     * provide a fallback callback option.\n     */\n    if (typeof IntersectionObserver === "undefined") {\n        return () => { };\n    }\n    const elements = resolveElements(elementOrSelector);\n    const activeIntersections = new WeakMap();\n    const onIntersectionChange = (entries) => {\n        entries.forEach((entry) => {\n            const onEnd = activeIntersections.get(entry.target);\n            /**\n             * If there\'s no change to the intersection, we don\'t need to\n             * do anything here.\n             */\n            if (entry.isIntersecting === Boolean(onEnd))\n                return;\n            if (entry.isIntersecting) {\n                const newOnEnd = onStart(entry);\n                if (typeof newOnEnd === "function") {\n                    activeIntersections.set(entry.target, newOnEnd);\n                }\n                else {\n                    observer.unobserve(entry.target);\n                }\n            }\n            else if (onEnd) {\n                onEnd(entry);\n                activeIntersections.delete(entry.target);\n            }\n        });\n    };\n    const observer = new IntersectionObserver(onIntersectionChange, {\n        root,\n        rootMargin,\n        threshold: typeof amount === "number" ? amount : thresholds[amount],\n    });\n    elements.forEach((element) => observer.observe(element));\n    return () => observer.disconnect();\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/utils/use-in-view.mjs\n\n\n\n\nfunction useInView(ref, _a) {\n    var _b = _a === void 0 ? {} : _a, root = _b.root, margin = _b.margin, amount = _b.amount, _c = _b.once, once = _c === void 0 ? false : _c;\n    var _d = __read((0,index_js_.useState)(false), 2), isInView = _d[0], setInView = _d[1];\n    (0,index_js_.useEffect)(function () {\n        var _a;\n        if (!ref.current || (once && isInView))\n            return;\n        var onEnter = function () {\n            setInView(true);\n            return once ? undefined : function () { return setInView(false); };\n        };\n        var options = {\n            root: (_a = root === null || root === void 0 ? void 0 : root.current) !== null && _a !== void 0 ? _a : undefined,\n            margin: margin,\n            amount: amount === "some" ? "any" : amount,\n        };\n        return inView(ref.current, onEnter, options);\n    }, [root, ref, margin, once]);\n    return isInView;\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/gestures/drag/use-drag-controls.mjs\n\n\n/**\n * Can manually trigger a drag gesture on one or more `drag`-enabled `motion` components.\n *\n * ```jsx\n * const dragControls = useDragControls()\n *\n * function startDrag(event) {\n *   dragControls.start(event, { snapToCursor: true })\n * }\n *\n * return (\n *   <>\n *     <div onPointerDown={startDrag} />\n *     <motion.div drag="x" dragControls={dragControls} />\n *   </>\n * )\n * ```\n *\n * @public\n */\nvar DragControls = /** @class */ (function () {\n    function DragControls() {\n        this.componentControls = new Set();\n    }\n    /**\n     * Subscribe a component\'s internal `VisualElementDragControls` to the user-facing API.\n     *\n     * @internal\n     */\n    DragControls.prototype.subscribe = function (controls) {\n        var _this = this;\n        this.componentControls.add(controls);\n        return function () { return _this.componentControls.delete(controls); };\n    };\n    /**\n     * Start a drag gesture on every `motion` component that has this set of drag controls\n     * passed into it via the `dragControls` prop.\n     *\n     * ```jsx\n     * dragControls.start(e, {\n     *   snapToCursor: true\n     * })\n     * ```\n     *\n     * @param event - PointerEvent\n     * @param options - Options\n     *\n     * @public\n     */\n    DragControls.prototype.start = function (event, options) {\n        this.componentControls.forEach(function (controls) {\n            controls.start(event.nativeEvent || event, options);\n        });\n    };\n    return DragControls;\n}());\nvar createDragControls = function () { return new DragControls(); };\n/**\n * Usually, dragging is initiated by pressing down on a `motion` component with a `drag` prop\n * and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we\n * might want to initiate that dragging from a different component than the draggable one.\n *\n * By creating a `dragControls` using the `useDragControls` hook, we can pass this into\n * the draggable component\'s `dragControls` prop. It exposes a `start` method\n * that can start dragging from pointer events on other components.\n *\n * ```jsx\n * const dragControls = useDragControls()\n *\n * function startDrag(event) {\n *   dragControls.start(event, { snapToCursor: true })\n * }\n *\n * return (\n *   <>\n *     <div onPointerDown={startDrag} />\n *     <motion.div drag="x" dragControls={dragControls} />\n *   </>\n * )\n * ```\n *\n * @public\n */\nfunction useDragControls() {\n    return useConstant(createDragControls);\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/projection/use-instant-layout-transition.mjs\n\n\nfunction useInstantLayoutTransition() {\n    return startTransition;\n}\nfunction startTransition(cb) {\n    if (!rootProjectionNode.current)\n        return;\n    rootProjectionNode.current.isUpdating = false;\n    rootProjectionNode.current.blockUpdate();\n    cb === null || cb === void 0 ? void 0 : cb();\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/utils/use-instant-transition.mjs\n\n\n\n\n\n\n\nfunction useInstantTransition() {\n    var _a = __read(useForceUpdate(), 2), forceUpdate = _a[0], forcedRenderCount = _a[1];\n    var startInstantLayoutTransition = useInstantLayoutTransition();\n    (0,index_js_.useEffect)(function () {\n        /**\n         * Unblock after two animation frames, otherwise this will unblock too soon.\n         */\n        es.postRender(function () {\n            return es.postRender(function () { return (instantAnimationState.current = false); });\n        });\n    }, [forcedRenderCount]);\n    return function (callback) {\n        startInstantLayoutTransition(function () {\n            instantAnimationState.current = true;\n            forceUpdate();\n            callback();\n        });\n    };\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/projection/use-reset-projection.mjs\n\n\n\nfunction useResetProjection() {\n    var reset = index_js_.useCallback(function () {\n        var root = rootProjectionNode.current;\n        if (!root)\n            return;\n        root.resetTree();\n    }, []);\n    return reset;\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/animation/use-animated-state.mjs\n\n\n\n\n\n\n\n\n\nvar createObject = function () { return ({}); };\nvar stateVisualElement = visualElement({\n    build: function () { },\n    measureViewportBox: createBox,\n    resetTransform: function () { },\n    restoreTransform: function () { },\n    removeValueFromRenderState: function () { },\n    render: function () { },\n    scrapeMotionValuesFromProps: createObject,\n    readValueFromInstance: function (_state, key, options) {\n        return options.initialState[key] || 0;\n    },\n    makeTargetAnimatable: function (element, _a) {\n        var transition = _a.transition, transitionEnd = _a.transitionEnd, target = __rest(_a, ["transition", "transitionEnd"]);\n        var origin = getOrigin(target, transition || {}, element);\n        checkTargetForNewValues(element, target, origin);\n        return __assign({ transition: transition, transitionEnd: transitionEnd }, target);\n    },\n});\nvar useVisualState = makeUseVisualState({\n    scrapeMotionValuesFromProps: createObject,\n    createRenderState: createObject,\n});\n/**\n * This is not an officially supported API and may be removed\n * on any version.\n */\nfunction useAnimatedState(initialState) {\n    var _a = __read((0,index_js_.useState)(initialState), 2), animationState = _a[0], setAnimationState = _a[1];\n    var visualState = useVisualState({}, false);\n    var element = useConstant(function () {\n        return stateVisualElement({ props: {}, visualState: visualState }, { initialState: initialState });\n    });\n    (0,index_js_.useEffect)(function () {\n        element.mount({});\n        return element.unmount;\n    }, [element]);\n    (0,index_js_.useEffect)(function () {\n        element.setProps({\n            onUpdate: function (v) {\n                setAnimationState(__assign({}, v));\n            },\n        });\n    }, [setAnimationState, element]);\n    var startAnimation = useConstant(function () { return function (animationDefinition) {\n        return animateVisualElement(element, animationDefinition);\n    }; });\n    return [animationState, startAnimation];\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/value/use-inverted-scale.mjs\n\n\n\n\n\n// Keep things reasonable and avoid scale: Infinity. In practise we might need\n// to add another value, opacity, that could interpolate scaleX/Y [0,0.01] => [0,1]\n// to simply hide content at unreasonable scales.\nvar maxScale = 100000;\nvar invertScale = function (scale) {\n    return scale > 0.001 ? 1 / scale : maxScale;\n};\nvar hasWarned = false;\n/**\n * Returns a `MotionValue` each for `scaleX` and `scaleY` that update with the inverse\n * of their respective parent scales.\n *\n * This is useful for undoing the distortion of content when scaling a parent component.\n *\n * By default, `useInvertedScale` will automatically fetch `scaleX` and `scaleY` from the nearest parent.\n * By passing other `MotionValue`s in as `useInvertedScale({ scaleX, scaleY })`, it will invert the output\n * of those instead.\n *\n * ```jsx\n * const MyComponent = () => {\n *   const { scaleX, scaleY } = useInvertedScale()\n *   return <motion.div style={{ scaleX, scaleY }} />\n * }\n * ```\n *\n * @deprecated\n */\nfunction useInvertedScale(scale) {\n    var parentScaleX = useMotionValue(1);\n    var parentScaleY = useMotionValue(1);\n    var visualElement = useVisualElementContext();\n    invariant(!!(scale || visualElement), "If no scale values are provided, useInvertedScale must be used within a child of another motion component.");\n    warning(hasWarned, "useInvertedScale is deprecated and will be removed in 3.0. Use the layout prop instead.");\n    hasWarned = true;\n    if (scale) {\n        parentScaleX = scale.scaleX || parentScaleX;\n        parentScaleY = scale.scaleY || parentScaleY;\n    }\n    else if (visualElement) {\n        parentScaleX = visualElement.getValue("scaleX", 1);\n        parentScaleY = visualElement.getValue("scaleY", 1);\n    }\n    var scaleX = useTransform(parentScaleX, invertScale);\n    var scaleY = useTransform(parentScaleY, invertScale);\n    return { scaleX: scaleX, scaleY: scaleY };\n}\n\n\n\n;// CONCATENATED MODULE: ./node_modules/framer-motion/dist/es/index.mjs\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNIO0FBQ1E7QUFDcUI7O0FBRTdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxnQkFBZ0I7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGlCQUFpQjtBQUM5QixpQ0FBaUMsa0JBQWtCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixjQUFjO0FBQ3JDLHVCQUF1QixjQUFjO0FBQ3JDLHdCQUF3Qix1QkFBdUI7QUFDL0MsSUFBSSxTQUFTO0FBQ2IsSUFBSSxPQUFPO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFlBQVk7QUFDN0IsaUJBQWlCLFlBQVk7QUFDN0IsYUFBYTtBQUNiOztBQUV5Qzs7O0FDcERrQztBQUN2QjtBQUNxQjtBQUNFO0FBQ1I7QUFDSjtBQUNFO0FBQ1I7QUFDVTtBQUNaO0FBQ087QUFDTTtBQUNQO0FBQ2U7QUFDbkI7QUFDTjtBQUNJO0FBQ0o7QUFDc0I7QUFDRTtBQUM1QjtBQUMyQztBQUNuQjtBQUNZO0FBQ2Y7QUFDbEI7QUFDa0I7QUFDbkI7QUFDQztBQUNnQjtBQUN3QjtBQUN0QztBQUNrQztBQUM3QjtBQUNFO0FBQ1I7QUFDMEI7QUFDSDtBQUNrQjtBQUNqQjtBQUNnQjtBQUNuQjtBQUNSO0FBQ007QUFDb0I7QUFDUjtBQUMxQjtBQUM0QztBQUNKO0FBQ3ZDO0FBQ0s7QUFDTztBQUNSO0FBQ0s7QUFDQTtBQUNPO0FBQ1g7QUFDRztBQUNYO0FBQ1k7QUFDZjtBQUNlO0FBQ1k7QUFDaEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvdHNsaWIvdHNsaWIuZXM2Lm1qcz9kMzA0Iiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdXRpbHMvcHJvY2Vzcy5tanM/ZDgyMyIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL21vdGlvbi9mZWF0dXJlcy9kZWZpbml0aW9ucy5tanM/ZDkyOCIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvaGV5LWxpc3Rlbi9kaXN0L2hleS1saXN0ZW4uZXMuanM/ZjM2OCIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2NvbnRleHQvTGF6eUNvbnRleHQubWpzPzhiMTIiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9tb3Rpb24vZmVhdHVyZXMvdXNlLWZlYXR1cmVzLm1qcz9hNGU4Iiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvY29udGV4dC9Nb3Rpb25Db25maWdDb250ZXh0Lm1qcz85NjE4Iiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvY29udGV4dC9Nb3Rpb25Db250ZXh0L2luZGV4Lm1qcz8wM2FiIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvY29udGV4dC9QcmVzZW5jZUNvbnRleHQubWpzPzk1NGYiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy91dGlscy9pcy1icm93c2VyLm1qcz8zYjY1Iiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdXRpbHMvdXNlLWlzb21vcnBoaWMtZWZmZWN0Lm1qcz9iNGZlIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdXRpbHMvdXNlLXJlZHVjZWQtbW90aW9uLm1qcz9iYjRmIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvbW90aW9uL3V0aWxzL3VzZS12aXN1YWwtZWxlbWVudC5tanM/NjI0OSIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3V0aWxzL2lzLXJlZi1vYmplY3QubWpzPzE2MDIiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9tb3Rpb24vdXRpbHMvdXNlLW1vdGlvbi1yZWYubWpzP2EzNWMiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvdXRpbHMvdmFyaWFudHMubWpzPzE0NmEiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9jb250ZXh0L01vdGlvbkNvbnRleHQvdXRpbHMubWpzP2NkMzYiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9jb250ZXh0L01vdGlvbkNvbnRleHQvY3JlYXRlLm1qcz8zNTMxIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdXRpbHMvdXNlLWNvbnN0YW50Lm1qcz9mZGY0Iiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcHJvamVjdGlvbi9ub2RlL3N0YXRlLm1qcz84N2MzIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcHJvamVjdGlvbi9ub2RlL2lkLm1qcz8wMzk3Iiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvY29udGV4dC9MYXlvdXRHcm91cENvbnRleHQubWpzPzQwM2YiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9jb250ZXh0L1N3aXRjaExheW91dEdyb3VwQ29udGV4dC5tanM/MzUzMyIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL21vdGlvbi9mZWF0dXJlcy91c2UtcHJvamVjdGlvbi5tanM/NTIyOCIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL21vdGlvbi91dGlscy9WaXN1YWxFbGVtZW50SGFuZGxlci5tanM/M2FmZSIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL21vdGlvbi9pbmRleC5tanM/YzBiMSIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9kb20vbW90aW9uLXByb3h5Lm1qcz8xYWU4Iiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL3N2Zy9sb3dlcmNhc2UtZWxlbWVudHMubWpzPzIxMDciLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvZG9tL3V0aWxzL2lzLXN2Zy1jb21wb25lbnQubWpzPzE1ZDkiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9wcm9qZWN0aW9uL3N0eWxlcy9zY2FsZS1jb3JyZWN0aW9uLm1qcz80OWY1Iiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2h0bWwvdXRpbHMvdHJhbnNmb3JtLm1qcz83M2NiIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvbW90aW9uL3V0aWxzL2lzLWZvcmNlZC1tb3Rpb24tdmFsdWUubWpzP2RkODQiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy92YWx1ZS91dGlscy9pcy1tb3Rpb24tdmFsdWUubWpzPzRkZTkiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvaHRtbC91dGlscy9idWlsZC10cmFuc2Zvcm0ubWpzP2E0MWEiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvZG9tL3V0aWxzL2lzLWNzcy12YXJpYWJsZS5tanM/M2YzNyIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9kb20vdmFsdWUtdHlwZXMvZ2V0LWFzLXR5cGUubWpzP2IwMTgiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL3N0eWxlLXZhbHVlLXR5cGVzL2Rpc3QvZXMvdXRpbHMubWpzPzQzNzAiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL3N0eWxlLXZhbHVlLXR5cGVzL2Rpc3QvZXMvbnVtYmVycy91bml0cy5tanM/Yzk3YyIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvc3R5bGUtdmFsdWUtdHlwZXMvZGlzdC9lcy9udW1iZXJzL2luZGV4Lm1qcz8xYTQ2Iiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2RvbS92YWx1ZS10eXBlcy90eXBlLWludC5tanM/Y2RmYyIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9kb20vdmFsdWUtdHlwZXMvbnVtYmVyLm1qcz84YTUwIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2h0bWwvdXRpbHMvYnVpbGQtc3R5bGVzLm1qcz84ZjYwIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2h0bWwvdXRpbHMvY3JlYXRlLXJlbmRlci1zdGF0ZS5tanM/NDE4OCIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9odG1sL3VzZS1wcm9wcy5tanM/MDMxMyIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL21vdGlvbi91dGlscy92YWxpZC1wcm9wLm1qcz83ZWVmIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2RvbS91dGlscy9maWx0ZXItcHJvcHMubWpzPzNiNTciLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvc3ZnL3V0aWxzL3RyYW5zZm9ybS1vcmlnaW4ubWpzPzk0NzEiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvc3ZnL3V0aWxzL3BhdGgubWpzP2JjYzgiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvc3ZnL3V0aWxzL2J1aWxkLWF0dHJzLm1qcz80NDY3Iiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL3N2Zy91dGlscy9jcmVhdGUtcmVuZGVyLXN0YXRlLm1qcz8yZmU4Iiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL3N2Zy91c2UtcHJvcHMubWpzPzk1NDgiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvZG9tL3VzZS1yZW5kZXIubWpzPzQ5MTMiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvZG9tL3V0aWxzL2NhbWVsLXRvLWRhc2gubWpzP2Q4MGUiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvaHRtbC91dGlscy9yZW5kZXIubWpzPzgxZTciLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvc3ZnL3V0aWxzL2NhbWVsLWNhc2UtYXR0cnMubWpzPzg3ODYiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvc3ZnL3V0aWxzL3JlbmRlci5tanM/NDgwMCIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9odG1sL3V0aWxzL3NjcmFwZS1tb3Rpb24tdmFsdWVzLm1qcz83OGE5Iiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL3N2Zy91dGlscy9zY3JhcGUtbW90aW9uLXZhbHVlcy5tanM/NmVmYiIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2FuaW1hdGlvbi91dGlscy9pcy1hbmltYXRpb24tY29udHJvbHMubWpzPzcxZGMiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9hbmltYXRpb24vdXRpbHMvaXMta2V5ZnJhbWVzLXRhcmdldC5tanM/ZmE2MiIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3V0aWxzL3Jlc29sdmUtdmFsdWUubWpzPzdmYzAiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy92YWx1ZS91dGlscy9yZXNvbHZlLW1vdGlvbi12YWx1ZS5tanM/ODgwNSIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL21vdGlvbi91dGlscy91c2UtdmlzdWFsLXN0YXRlLm1qcz8zMDIxIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL3N2Zy9jb25maWctbW90aW9uLm1qcz82MDgxIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2h0bWwvY29uZmlnLW1vdGlvbi5tanM/ZjFiMCIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9kb20vdXRpbHMvY3JlYXRlLWNvbmZpZy5tanM/MDkxZCIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci91dGlscy90eXBlcy5tanM/NDQwMiIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2V2ZW50cy91c2UtZG9tLWV2ZW50Lm1qcz9hODEzIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvZ2VzdHVyZXMvdXNlLWZvY3VzLWdlc3R1cmUubWpzP2IwMTAiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9nZXN0dXJlcy91dGlscy9ldmVudC10eXBlLm1qcz9lMzNmIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvZXZlbnRzL2V2ZW50LWluZm8ubWpzP2E0ZjMiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9ldmVudHMvdXRpbHMubWpzP2NhZWEiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9ldmVudHMvdXNlLXBvaW50ZXItZXZlbnQubWpzPzE1NWMiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9nZXN0dXJlcy9kcmFnL3V0aWxzL2xvY2subWpzP2MyMzUiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9nZXN0dXJlcy91c2UtaG92ZXItZ2VzdHVyZS5tanM/NTU4ZSIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2dlc3R1cmVzL3V0aWxzL2lzLW5vZGUtb3ItY2hpbGQubWpzP2U2MzMiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy91dGlscy91c2UtdW5tb3VudC1lZmZlY3QubWpzP2U5NDkiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL3BvcG1vdGlvbi9kaXN0L2VzL3V0aWxzL3BpcGUubWpzPzY1MmMiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9nZXN0dXJlcy91c2UtdGFwLWdlc3R1cmUubWpzPzcyYWEiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy91dGlscy93YXJuLW9uY2UubWpzP2YzNTciLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9tb3Rpb24vZmVhdHVyZXMvdmlld3BvcnQvb2JzZXJ2ZXJzLm1qcz8zZmE3Iiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvbW90aW9uL2ZlYXR1cmVzL3ZpZXdwb3J0L3VzZS12aWV3cG9ydC5tanM/NWE1NSIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL21vdGlvbi91dGlscy9tYWtlLXJlbmRlcmxlc3MtY29tcG9uZW50Lm1qcz83NWIzIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvbW90aW9uL2ZlYXR1cmVzL2dlc3R1cmVzLm1qcz8zZGQ2Iiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdXRpbHMvdXNlLWlkLm1qcz85N2VkIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvY29tcG9uZW50cy9BbmltYXRlUHJlc2VuY2UvdXNlLXByZXNlbmNlLm1qcz84OTU3Iiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdXRpbHMvc2hhbGxvdy1jb21wYXJlLm1qcz8zYjBiIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9wb3Btb3Rpb24vZGlzdC9lcy91dGlscy9jbGFtcC5tanM/MTQwZCIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvcG9wbW90aW9uL2Rpc3QvZXMvYW5pbWF0aW9ucy91dGlscy9maW5kLXNwcmluZy5tanM/MzgyMiIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvcG9wbW90aW9uL2Rpc3QvZXMvYW5pbWF0aW9ucy9nZW5lcmF0b3JzL3NwcmluZy5tanM/YzVkYiIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvcG9wbW90aW9uL2Rpc3QvZXMvdXRpbHMvcHJvZ3Jlc3MubWpzPzdkODQiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL3BvcG1vdGlvbi9kaXN0L2VzL3V0aWxzL21peC5tanM/YTVmZSIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvc3R5bGUtdmFsdWUtdHlwZXMvZGlzdC9lcy9jb2xvci91dGlscy5tanM/YzdiOCIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvc3R5bGUtdmFsdWUtdHlwZXMvZGlzdC9lcy9jb2xvci9yZ2JhLm1qcz8zZjljIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9zdHlsZS12YWx1ZS10eXBlcy9kaXN0L2VzL2NvbG9yL2hleC5tanM/MTVlOSIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvc3R5bGUtdmFsdWUtdHlwZXMvZGlzdC9lcy9jb2xvci9oc2xhLm1qcz82YTkwIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9wb3Btb3Rpb24vZGlzdC9lcy91dGlscy9oc2xhLXRvLXJnYmEubWpzPzliYmIiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL3BvcG1vdGlvbi9kaXN0L2VzL3V0aWxzL21peC1jb2xvci5tanM/MDNhMyIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvc3R5bGUtdmFsdWUtdHlwZXMvZGlzdC9lcy9jb2xvci9pbmRleC5tanM/ZWZmNyIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvc3R5bGUtdmFsdWUtdHlwZXMvZGlzdC9lcy9jb21wbGV4L2luZGV4Lm1qcz85NjE0Iiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9wb3Btb3Rpb24vZGlzdC9lcy91dGlscy9pbmMubWpzP2RlNzgiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL3BvcG1vdGlvbi9kaXN0L2VzL3V0aWxzL21peC1jb21wbGV4Lm1qcz82NjI1Iiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9wb3Btb3Rpb24vZGlzdC9lcy91dGlscy9pbnRlcnBvbGF0ZS5tanM/ZDVhOSIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvcG9wbW90aW9uL2Rpc3QvZXMvZWFzaW5nL3V0aWxzLm1qcz8yMTU0Iiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9wb3Btb3Rpb24vZGlzdC9lcy9lYXNpbmcvaW5kZXgubWpzP2YyY2QiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL3BvcG1vdGlvbi9kaXN0L2VzL2FuaW1hdGlvbnMvZ2VuZXJhdG9ycy9rZXlmcmFtZXMubWpzPzY0NDgiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL3BvcG1vdGlvbi9kaXN0L2VzL2FuaW1hdGlvbnMvZ2VuZXJhdG9ycy9kZWNheS5tanM/MTNjYyIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvcG9wbW90aW9uL2Rpc3QvZXMvYW5pbWF0aW9ucy91dGlscy9kZXRlY3QtYW5pbWF0aW9uLWZyb20tb3B0aW9ucy5tanM/ZDM3OCIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZnJhbWVzeW5jL2Rpc3QvZXMvb24tbmV4dC1mcmFtZS5tanM/YjA3MiIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZnJhbWVzeW5jL2Rpc3QvZXMvY3JlYXRlLXJlbmRlci1zdGVwLm1qcz8zZTY5Iiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9mcmFtZXN5bmMvZGlzdC9lcy9pbmRleC5tanM/Mjc1MCIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvcG9wbW90aW9uL2Rpc3QvZXMvYW5pbWF0aW9ucy91dGlscy9lbGFwc2VkLm1qcz8xMTM3Iiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9wb3Btb3Rpb24vZGlzdC9lcy9hbmltYXRpb25zL2luZGV4Lm1qcz8zNWU5Iiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9wb3Btb3Rpb24vZGlzdC9lcy91dGlscy92ZWxvY2l0eS1wZXItc2Vjb25kLm1qcz9kNmI3Iiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9wb3Btb3Rpb24vZGlzdC9lcy9hbmltYXRpb25zL2luZXJ0aWEubWpzPzVhNWYiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy91dGlscy90aW1lLWNvbnZlcnNpb24ubWpzPzQ4OGYiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL3BvcG1vdGlvbi9kaXN0L2VzL2Vhc2luZy9jdWJpYy1iZXppZXIubWpzPzM0YWYiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9hbmltYXRpb24vdXRpbHMvZWFzaW5nLm1qcz9hOWVjIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvYW5pbWF0aW9uL3V0aWxzL2lzLWFuaW1hdGFibGUubWpzPzBjYTEiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9hbmltYXRpb24vdXRpbHMvZGVmYXVsdC10cmFuc2l0aW9ucy5tanM/Yjg5NyIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvc3R5bGUtdmFsdWUtdHlwZXMvZGlzdC9lcy9jb21wbGV4L2ZpbHRlci5tanM/MDA5MCIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9kb20vdmFsdWUtdHlwZXMvZGVmYXVsdHMubWpzPzU0MmEiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvZG9tL3ZhbHVlLXR5cGVzL2FuaW1hdGFibGUtbm9uZS5tanM/Zjk2ZCIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3V0aWxzL3VzZS1pbnN0YW50LXRyYW5zaXRpb24tc3RhdGUubWpzP2UzMzUiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9hbmltYXRpb24vdXRpbHMvdHJhbnNpdGlvbnMubWpzPzVkZGMiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy91dGlscy9pcy1udW1lcmljYWwtc3RyaW5nLm1qcz83ZjBlIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdXRpbHMvaXMtemVyby12YWx1ZS1zdHJpbmcubWpzPzM1YzMiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy91dGlscy9hcnJheS5tanM/OWY3MSIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3V0aWxzL3N1YnNjcmlwdGlvbi1tYW5hZ2VyLm1qcz8yODMyIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdmFsdWUvaW5kZXgubWpzPzc1MWIiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvZG9tL3ZhbHVlLXR5cGVzL3Rlc3QubWpzP2I5ZGQiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvZG9tL3ZhbHVlLXR5cGVzL3R5cGUtYXV0by5tanM/MDkxNSIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9kb20vdmFsdWUtdHlwZXMvZGltZW5zaW9ucy5tanM/NGJjMyIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9kb20vdmFsdWUtdHlwZXMvZmluZC5tanM/NzEyMyIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci91dGlscy9zZXR0ZXJzLm1qcz82NzgwIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL3V0aWxzL2FuaW1hdGlvbi5tanM/OGE1OCIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci91dGlscy9hbmltYXRpb24tc3RhdGUubWpzPzRiNWMiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9tb3Rpb24vZmVhdHVyZXMvYW5pbWF0aW9ucy5tanM/NDM4NSIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvcG9wbW90aW9uL2Rpc3QvZXMvdXRpbHMvaXMtcG9pbnQubWpzPzI5Y2EiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL3BvcG1vdGlvbi9kaXN0L2VzL3V0aWxzL2lzLXBvaW50LTNkLm1qcz8zMGQ2Iiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9wb3Btb3Rpb24vZGlzdC9lcy91dGlscy9kaXN0YW5jZS5tanM/N2RmYSIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2dlc3R1cmVzL1BhblNlc3Npb24ubWpzPzNiZTkiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9wcm9qZWN0aW9uL2dlb21ldHJ5L2RlbHRhLWNhbGMubWpzP2JkYjgiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9nZXN0dXJlcy9kcmFnL3V0aWxzL2NvbnN0cmFpbnRzLm1qcz9jOGNkIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcHJvamVjdGlvbi9nZW9tZXRyeS9tb2RlbHMubWpzPzJmZmEiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9wcm9qZWN0aW9uL3V0aWxzL2VhY2gtYXhpcy5tanM/ZGE4NiIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3Byb2plY3Rpb24vZ2VvbWV0cnkvY29udmVyc2lvbi5tanM/OTkxZiIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3Byb2plY3Rpb24vdXRpbHMvaGFzLXRyYW5zZm9ybS5tanM/NWY3MCIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3Byb2plY3Rpb24vZ2VvbWV0cnkvZGVsdGEtYXBwbHkubWpzPzFkYjYiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9wcm9qZWN0aW9uL3V0aWxzL21lYXN1cmUubWpzPzczMTAiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9nZXN0dXJlcy9kcmFnL1Zpc3VhbEVsZW1lbnREcmFnQ29udHJvbHMubWpzPzlhYjkiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9nZXN0dXJlcy9kcmFnL3VzZS1kcmFnLm1qcz80M2U5Iiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvZ2VzdHVyZXMvdXNlLXBhbi1nZXN0dXJlLm1qcz80ODVkIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvbW90aW9uL2ZlYXR1cmVzL2RyYWcubWpzPzkwYTkiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvdXRpbHMvbGlmZWN5Y2xlcy5tanM/MWRkMyIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci91dGlscy9tb3Rpb24tdmFsdWVzLm1qcz84MjUxIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2luZGV4Lm1qcz9iNjE1Iiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2RvbS91dGlscy9jc3MtdmFyaWFibGVzLWNvbnZlcnNpb24ubWpzP2I5YzEiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvZG9tL3V0aWxzL3VuaXQtY29udmVyc2lvbi5tanM/NzJjOCIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9kb20vdXRpbHMvcGFyc2UtZG9tLXZhcmlhbnQubWpzPzI3NGMiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvaHRtbC92aXN1YWwtZWxlbWVudC5tanM/NGMyMyIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9zdmcvdmlzdWFsLWVsZW1lbnQubWpzPzk4YmYiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvZG9tL2NyZWF0ZS12aXN1YWwtZWxlbWVudC5tanM/MWRmYiIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3Byb2plY3Rpb24vc3R5bGVzL3NjYWxlLWJvcmRlci1yYWRpdXMubWpzPzRhNmUiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9wcm9qZWN0aW9uL3N0eWxlcy9zY2FsZS1ib3gtc2hhZG93Lm1qcz82YjMwIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvbW90aW9uL2ZlYXR1cmVzL2xheW91dC9NZWFzdXJlTGF5b3V0Lm1qcz9kZDE5Iiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvbW90aW9uL2ZlYXR1cmVzL2xheW91dC9pbmRleC5tanM/ZjI2NSIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2FuaW1hdGlvbi9hbmltYXRlLm1qcz8xNGZiIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcHJvamVjdGlvbi9hbmltYXRpb24vbWl4LXZhbHVlcy5tanM/YzNmYiIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3Byb2plY3Rpb24vZ2VvbWV0cnkvY29weS5tanM/OWVmNyIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3Byb2plY3Rpb24vZ2VvbWV0cnkvZGVsdGEtcmVtb3ZlLm1qcz9iYzdmIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcHJvamVjdGlvbi9nZW9tZXRyeS91dGlscy5tanM/ODkzMiIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3Byb2plY3Rpb24vc2hhcmVkL3N0YWNrLm1qcz83NjRkIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcHJvamVjdGlvbi9zdHlsZXMvdHJhbnNmb3JtLm1qcz82MDViIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL3V0aWxzL2NvbXBhcmUtYnktZGVwdGgubWpzP2EyYjgiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvdXRpbHMvZmxhdC10cmVlLm1qcz9mYjM3Iiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcHJvamVjdGlvbi9ub2RlL2NyZWF0ZS1wcm9qZWN0aW9uLW5vZGUubWpzPzNlN2YiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9wcm9qZWN0aW9uL25vZGUvRG9jdW1lbnRQcm9qZWN0aW9uTm9kZS5tanM/NGMwZCIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3Byb2plY3Rpb24vbm9kZS9IVE1MUHJvamVjdGlvbk5vZGUubWpzPzA5YmQiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9yZW5kZXIvZG9tL21vdGlvbi5tanM/ZDJkMyIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9kb20vbW90aW9uLW1pbmltYWwubWpzPzY2NWUiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy91dGlscy91c2UtaXMtbW91bnRlZC5tanM/ZGFiNiIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3V0aWxzL3VzZS1mb3JjZS11cGRhdGUubWpzPzBlNTAiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9jb21wb25lbnRzL0FuaW1hdGVQcmVzZW5jZS9QcmVzZW5jZUNoaWxkLm1qcz8wNmRhIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvY29tcG9uZW50cy9BbmltYXRlUHJlc2VuY2UvaW5kZXgubWpzP2Q2ZDciLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9jb250ZXh0L0RlcHJlY2F0ZWRMYXlvdXRHcm91cENvbnRleHQubWpzPzcwYWQiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9wcm9qZWN0aW9uL25vZGUvZ3JvdXAubWpzPzg2ZTMiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9jb21wb25lbnRzL0xheW91dEdyb3VwL2luZGV4Lm1qcz81MTY5Iiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvY29tcG9uZW50cy9BbmltYXRlU2hhcmVkTGF5b3V0Lm1qcz85ODkyIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvY29tcG9uZW50cy9Nb3Rpb25Db25maWcvaW5kZXgubWpzP2NlMzciLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9jb21wb25lbnRzL0xhenlNb3Rpb24vaW5kZXgubWpzPzg5NWYiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9jb250ZXh0L1Jlb3JkZXJDb250ZXh0Lm1qcz9mZjRjIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvY29tcG9uZW50cy9SZW9yZGVyL3V0aWxzL2NoZWNrLXJlb3JkZXIubWpzPzUxNTYiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9jb21wb25lbnRzL1Jlb3JkZXIvR3JvdXAubWpzPzA4MTAiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy92YWx1ZS91c2UtbW90aW9uLXZhbHVlLm1qcz80Y2I0Iiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdXRpbHMvdHJhbnNmb3JtLm1qcz8wMTA3Iiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdmFsdWUvdXNlLW9uLWNoYW5nZS5tanM/NzgyMCIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3ZhbHVlL3VzZS1jb21iaW5lLXZhbHVlcy5tanM/NTI3YSIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3ZhbHVlL3VzZS10cmFuc2Zvcm0ubWpzP2I4MmUiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9jb21wb25lbnRzL1Jlb3JkZXIvSXRlbS5tanM/ZGMzMyIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2NvbXBvbmVudHMvUmVvcmRlci9pbmRleC5tanM/MjJmZiIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3JlbmRlci9kb20vZmVhdHVyZXMtYW5pbWF0aW9uLm1qcz8xYzAzIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvcmVuZGVyL2RvbS9mZWF0dXJlcy1tYXgubWpzPzQ1MzgiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy92YWx1ZS91c2UtbW90aW9uLXRlbXBsYXRlLm1qcz9iN2RjIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdmFsdWUvdXNlLXNwcmluZy5tanM/MDBmYyIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3ZhbHVlL3VzZS12ZWxvY2l0eS5tanM/ZmZlZiIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvQG1vdGlvbm9uZS9kb20vZGlzdC91dGlscy9yZXNvbHZlLWVsZW1lbnRzLmVzLmpzPzg2ZjgiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL0Btb3Rpb25vbmUvZG9tL2Rpc3QvZ2VzdHVyZXMvcmVzaXplL2hhbmRsZS1lbGVtZW50LmVzLmpzP2ZhNzUiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL0Btb3Rpb25vbmUvZG9tL2Rpc3QvZ2VzdHVyZXMvcmVzaXplL2hhbmRsZS13aW5kb3cuZXMuanM/ZTNlZCIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvQG1vdGlvbm9uZS9kb20vZGlzdC9nZXN0dXJlcy9yZXNpemUvaW5kZXguZXMuanM/NDFkOCIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvQG1vdGlvbm9uZS91dGlscy9kaXN0L3Byb2dyZXNzLmVzLmpzPzBjZDgiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL0Btb3Rpb25vbmUvdXRpbHMvZGlzdC92ZWxvY2l0eS5lcy5qcz85NWJhIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9AbW90aW9ub25lL2RvbS9kaXN0L2dlc3R1cmVzL3Njcm9sbC9pbmZvLmVzLmpzPzE0NmEiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL0Btb3Rpb25vbmUvdXRpbHMvZGlzdC9ub29wLmVzLmpzP2IzZmEiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL0Btb3Rpb25vbmUvdXRpbHMvZGlzdC9taXguZXMuanM/YTYwNyIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvQG1vdGlvbm9uZS91dGlscy9kaXN0L29mZnNldC5lcy5qcz9lOTczIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9AbW90aW9ub25lL3V0aWxzL2Rpc3QvaXMtbnVtYmVyLmVzLmpzPzY4OTYiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL0Btb3Rpb25vbmUvdXRpbHMvZGlzdC9pcy1lYXNpbmctbGlzdC5lcy5qcz9jZTE5Iiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9AbW90aW9ub25lL3V0aWxzL2Rpc3Qvd3JhcC5lcy5qcz82NDAwIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9AbW90aW9ub25lL3V0aWxzL2Rpc3QvZWFzaW5nLmVzLmpzPzlhZDIiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL0Btb3Rpb25vbmUvdXRpbHMvZGlzdC9jbGFtcC5lcy5qcz85NDljIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9AbW90aW9ub25lL3V0aWxzL2Rpc3QvaW50ZXJwb2xhdGUuZXMuanM/ZjA3NyIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvQG1vdGlvbm9uZS9kb20vZGlzdC9nZXN0dXJlcy9zY3JvbGwvb2Zmc2V0cy9pbnNldC5lcy5qcz8xYWFhIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9AbW90aW9ub25lL2RvbS9kaXN0L2dlc3R1cmVzL3Njcm9sbC9vZmZzZXRzL3ByZXNldHMuZXMuanM/MmIwMiIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvQG1vdGlvbm9uZS91dGlscy9kaXN0L2lzLXN0cmluZy5lcy5qcz8zNTdmIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9AbW90aW9ub25lL2RvbS9kaXN0L2dlc3R1cmVzL3Njcm9sbC9vZmZzZXRzL2VkZ2UuZXMuanM/NzE4MyIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvQG1vdGlvbm9uZS9kb20vZGlzdC9nZXN0dXJlcy9zY3JvbGwvb2Zmc2V0cy9vZmZzZXQuZXMuanM/ZjE5YSIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvQG1vdGlvbm9uZS9kb20vZGlzdC9nZXN0dXJlcy9zY3JvbGwvb2Zmc2V0cy9pbmRleC5lcy5qcz9mNmUxIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9AbW90aW9ub25lL2RvbS9kaXN0L2dlc3R1cmVzL3Njcm9sbC9vbi1zY3JvbGwtaGFuZGxlci5lcy5qcz84ZWFjIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9AbW90aW9ub25lL2RvbS9kaXN0L2dlc3R1cmVzL3Njcm9sbC9pbmRleC5lcy5qcz80Y2ZmIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdmFsdWUvdXNlLXNjcm9sbC5tanM/NDYyOSIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3ZhbHVlL3Njcm9sbC91c2UtZWxlbWVudC1zY3JvbGwubWpzPzgxYWUiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy92YWx1ZS9zY3JvbGwvdXNlLXZpZXdwb3J0LXNjcm9sbC5tanM/MWMxMyIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3V0aWxzL3VzZS1hbmltYXRpb24tZnJhbWUubWpzPzhkNzEiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy92YWx1ZS91c2UtdGltZS5tanM/NWE5OCIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2FuaW1hdGlvbi9hbmltYXRpb24tY29udHJvbHMubWpzP2ZmODciLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9hbmltYXRpb24vdXNlLWFuaW1hdGlvbi5tanM/Y2QzZiIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvcG9wbW90aW9uL2Rpc3QvZXMvdXRpbHMvd3JhcC5tanM/NjNjZCIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3V0aWxzL3VzZS1jeWNsZS5tanM/MDI5OSIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvQG1vdGlvbm9uZS9kb20vZGlzdC9nZXN0dXJlcy9pbi12aWV3LmVzLmpzPzBkMDIiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy91dGlscy91c2UtaW4tdmlldy5tanM/YWI3YyIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL2dlc3R1cmVzL2RyYWcvdXNlLWRyYWctY29udHJvbHMubWpzPzFhNGQiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9wcm9qZWN0aW9uL3VzZS1pbnN0YW50LWxheW91dC10cmFuc2l0aW9uLm1qcz9hMGFmIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdXRpbHMvdXNlLWluc3RhbnQtdHJhbnNpdGlvbi5tanM/YmUwNCIsIndlYnBhY2s6Ly93ZWIvLi9ub2RlX21vZHVsZXMvZnJhbWVyLW1vdGlvbi9kaXN0L2VzL3Byb2plY3Rpb24vdXNlLXJlc2V0LXByb2plY3Rpb24ubWpzP2I5YWIiLCJ3ZWJwYWNrOi8vd2ViLy4vbm9kZV9tb2R1bGVzL2ZyYW1lci1tb3Rpb24vZGlzdC9lcy9hbmltYXRpb24vdXNlLWFuaW1hdGVkLXN0YXRlLm1qcz80ZGNhIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvdmFsdWUvdXNlLWludmVydGVkLXNjYWxlLm1qcz9mMGYxIiwid2VicGFjazovL3dlYi8uL25vZGVfbW9kdWxlcy9mcmFtZXItbW90aW9uL2Rpc3QvZXMvaW5kZXgubWpzPzVmOTIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXG5cblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxuXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1Jcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UsIFN1cHByZXNzZWRFcnJvciwgU3ltYm9sICovXG5cbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24oZCwgYikge1xuICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2V4dGVuZHMoZCwgYikge1xuICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xufVxuXG5leHBvcnQgdmFyIF9fYXNzaWduID0gZnVuY3Rpb24oKSB7XG4gIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XG4gICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XG4gICAgICB9XG4gICAgICByZXR1cm4gdDtcbiAgfVxuICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVzdChzLCBlKSB7XG4gIHZhciB0ID0ge307XG4gIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxuICAgICAgdFtwXSA9IHNbcF07XG4gIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXG4gICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xuICAgICAgfVxuICByZXR1cm4gdDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcbiAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcbiAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fcGFyYW0ocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gX19lc0RlY29yYXRlKGN0b3IsIGRlc2NyaXB0b3JJbiwgZGVjb3JhdG9ycywgY29udGV4dEluLCBpbml0aWFsaXplcnMsIGV4dHJhSW5pdGlhbGl6ZXJzKSB7XG4gIGZ1bmN0aW9uIGFjY2VwdChmKSB7IGlmIChmICE9PSB2b2lkIDAgJiYgdHlwZW9mIGYgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZ1bmN0aW9uIGV4cGVjdGVkXCIpOyByZXR1cm4gZjsgfVxuICB2YXIga2luZCA9IGNvbnRleHRJbi5raW5kLCBrZXkgPSBraW5kID09PSBcImdldHRlclwiID8gXCJnZXRcIiA6IGtpbmQgPT09IFwic2V0dGVyXCIgPyBcInNldFwiIDogXCJ2YWx1ZVwiO1xuICB2YXIgdGFyZ2V0ID0gIWRlc2NyaXB0b3JJbiAmJiBjdG9yID8gY29udGV4dEluW1wic3RhdGljXCJdID8gY3RvciA6IGN0b3IucHJvdG90eXBlIDogbnVsbDtcbiAgdmFyIGRlc2NyaXB0b3IgPSBkZXNjcmlwdG9ySW4gfHwgKHRhcmdldCA/IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBjb250ZXh0SW4ubmFtZSkgOiB7fSk7XG4gIHZhciBfLCBkb25lID0gZmFsc2U7XG4gIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgY29udGV4dCA9IHt9O1xuICAgICAgZm9yICh2YXIgcCBpbiBjb250ZXh0SW4pIGNvbnRleHRbcF0gPSBwID09PSBcImFjY2Vzc1wiID8ge30gOiBjb250ZXh0SW5bcF07XG4gICAgICBmb3IgKHZhciBwIGluIGNvbnRleHRJbi5hY2Nlc3MpIGNvbnRleHQuYWNjZXNzW3BdID0gY29udGV4dEluLmFjY2Vzc1twXTtcbiAgICAgIGNvbnRleHQuYWRkSW5pdGlhbGl6ZXIgPSBmdW5jdGlvbiAoZikgeyBpZiAoZG9uZSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBhZGQgaW5pdGlhbGl6ZXJzIGFmdGVyIGRlY29yYXRpb24gaGFzIGNvbXBsZXRlZFwiKTsgZXh0cmFJbml0aWFsaXplcnMucHVzaChhY2NlcHQoZiB8fCBudWxsKSk7IH07XG4gICAgICB2YXIgcmVzdWx0ID0gKDAsIGRlY29yYXRvcnNbaV0pKGtpbmQgPT09IFwiYWNjZXNzb3JcIiA/IHsgZ2V0OiBkZXNjcmlwdG9yLmdldCwgc2V0OiBkZXNjcmlwdG9yLnNldCB9IDogZGVzY3JpcHRvcltrZXldLCBjb250ZXh0KTtcbiAgICAgIGlmIChraW5kID09PSBcImFjY2Vzc29yXCIpIHtcbiAgICAgICAgICBpZiAocmVzdWx0ID09PSB2b2lkIDApIGNvbnRpbnVlO1xuICAgICAgICAgIGlmIChyZXN1bHQgPT09IG51bGwgfHwgdHlwZW9mIHJlc3VsdCAhPT0gXCJvYmplY3RcIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk9iamVjdCBleHBlY3RlZFwiKTtcbiAgICAgICAgICBpZiAoXyA9IGFjY2VwdChyZXN1bHQuZ2V0KSkgZGVzY3JpcHRvci5nZXQgPSBfO1xuICAgICAgICAgIGlmIChfID0gYWNjZXB0KHJlc3VsdC5zZXQpKSBkZXNjcmlwdG9yLnNldCA9IF87XG4gICAgICAgICAgaWYgKF8gPSBhY2NlcHQocmVzdWx0LmluaXQpKSBpbml0aWFsaXplcnMudW5zaGlmdChfKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKF8gPSBhY2NlcHQocmVzdWx0KSkge1xuICAgICAgICAgIGlmIChraW5kID09PSBcImZpZWxkXCIpIGluaXRpYWxpemVycy51bnNoaWZ0KF8pO1xuICAgICAgICAgIGVsc2UgZGVzY3JpcHRvcltrZXldID0gXztcbiAgICAgIH1cbiAgfVxuICBpZiAodGFyZ2V0KSBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBjb250ZXh0SW4ubmFtZSwgZGVzY3JpcHRvcik7XG4gIGRvbmUgPSB0cnVlO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fcnVuSW5pdGlhbGl6ZXJzKHRoaXNBcmcsIGluaXRpYWxpemVycywgdmFsdWUpIHtcbiAgdmFyIHVzZVZhbHVlID0gYXJndW1lbnRzLmxlbmd0aCA+IDI7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaW5pdGlhbGl6ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YWx1ZSA9IHVzZVZhbHVlID8gaW5pdGlhbGl6ZXJzW2ldLmNhbGwodGhpc0FyZywgdmFsdWUpIDogaW5pdGlhbGl6ZXJzW2ldLmNhbGwodGhpc0FyZyk7XG4gIH1cbiAgcmV0dXJuIHVzZVZhbHVlID8gdmFsdWUgOiB2b2lkIDA7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gX19wcm9wS2V5KHgpIHtcbiAgcmV0dXJuIHR5cGVvZiB4ID09PSBcInN5bWJvbFwiID8geCA6IFwiXCIuY29uY2F0KHgpO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fc2V0RnVuY3Rpb25OYW1lKGYsIG5hbWUsIHByZWZpeCkge1xuICBpZiAodHlwZW9mIG5hbWUgPT09IFwic3ltYm9sXCIpIG5hbWUgPSBuYW1lLmRlc2NyaXB0aW9uID8gXCJbXCIuY29uY2F0KG5hbWUuZGVzY3JpcHRpb24sIFwiXVwiKSA6IFwiXCI7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZiwgXCJuYW1lXCIsIHsgY29uZmlndXJhYmxlOiB0cnVlLCB2YWx1ZTogcHJlZml4ID8gXCJcIi5jb25jYXQocHJlZml4LCBcIiBcIiwgbmFtZSkgOiBuYW1lIH0pO1xufTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9fbWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpIHtcbiAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fZ2VuZXJhdG9yKHRoaXNBcmcsIGJvZHkpIHtcbiAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcbiAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxuICBmdW5jdGlvbiBzdGVwKG9wKSB7XG4gICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICB3aGlsZSAoZyAmJiAoZyA9IDAsIG9wWzBdICYmIChfID0gMCkpLCBfKSB0cnkge1xuICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IG9wWzBdICYgMiA/IHlbXCJyZXR1cm5cIl0gOiBvcFswXSA/IHlbXCJ0aHJvd1wiXSB8fCAoKHQgPSB5W1wicmV0dXJuXCJdKSAmJiB0LmNhbGwoeSksIDApIDogeS5uZXh0KSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcbiAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XG4gICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcbiAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcbiAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xuICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxuICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gIH1cbn1cblxuZXhwb3J0IHZhciBfX2NyZWF0ZUJpbmRpbmcgPSBPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgaWYgKCFkZXNjIHx8IChcImdldFwiIGluIGRlc2MgPyAhbS5fX2VzTW9kdWxlIDogZGVzYy53cml0YWJsZSB8fCBkZXNjLmNvbmZpZ3VyYWJsZSkpIHtcbiAgICAgIGRlc2MgPSB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH07XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gIG9bazJdID0gbVtrXTtcbn0pO1xuXG5leHBvcnQgZnVuY3Rpb24gX19leHBvcnRTdGFyKG0sIG8pIHtcbiAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLCBwKSkgX19jcmVhdGVCaW5kaW5nKG8sIG0sIHApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX192YWx1ZXMobykge1xuICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xuICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcbiAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xuICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XG4gICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xuICAgICAgfVxuICB9O1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX3JlYWQobywgbikge1xuICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XG4gIGlmICghbSkgcmV0dXJuIG87XG4gIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xuICB0cnkge1xuICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gIH1cbiAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XG4gIGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcbiAgICAgIH1cbiAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxuICB9XG4gIHJldHVybiBhcjtcbn1cblxuLyoqIEBkZXByZWNhdGVkICovXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWQoKSB7XG4gIGZvciAodmFyIGFyID0gW10sIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKVxuICAgICAgYXIgPSBhci5jb25jYXQoX19yZWFkKGFyZ3VtZW50c1tpXSkpO1xuICByZXR1cm4gYXI7XG59XG5cbi8qKiBAZGVwcmVjYXRlZCAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkQXJyYXlzKCkge1xuICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcbiAgZm9yICh2YXIgciA9IEFycmF5KHMpLCBrID0gMCwgaSA9IDA7IGkgPCBpbDsgaSsrKVxuICAgICAgZm9yICh2YXIgYSA9IGFyZ3VtZW50c1tpXSwgaiA9IDAsIGpsID0gYS5sZW5ndGg7IGogPCBqbDsgaisrLCBrKyspXG4gICAgICAgICAgcltrXSA9IGFbal07XG4gIHJldHVybiByO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWRBcnJheSh0bywgZnJvbSwgcGFjaykge1xuICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xuICAgICAgICAgIGlmICghYXIpIGFyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSwgMCwgaSk7XG4gICAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xuICAgICAgfVxuICB9XG4gIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19hd2FpdCh2KSB7XG4gIHJldHVybiB0aGlzIGluc3RhbmNlb2YgX19hd2FpdCA/ICh0aGlzLnYgPSB2LCB0aGlzKSA6IG5ldyBfX2F3YWl0KHYpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY0dlbmVyYXRvcih0aGlzQXJnLCBfYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcbiAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbiAgdmFyIGcgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSksIGksIHEgPSBbXTtcbiAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xuICBmdW5jdGlvbiB2ZXJiKG4pIHsgaWYgKGdbbl0pIGlbbl0gPSBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGEsIGIpIHsgcS5wdXNoKFtuLCB2LCBhLCBiXSkgPiAxIHx8IHJlc3VtZShuLCB2KTsgfSk7IH07IH1cbiAgZnVuY3Rpb24gcmVzdW1lKG4sIHYpIHsgdHJ5IHsgc3RlcChnW25dKHYpKTsgfSBjYXRjaCAoZSkgeyBzZXR0bGUocVswXVszXSwgZSk7IH0gfVxuICBmdW5jdGlvbiBzdGVwKHIpIHsgci52YWx1ZSBpbnN0YW5jZW9mIF9fYXdhaXQgPyBQcm9taXNlLnJlc29sdmUoci52YWx1ZS52KS50aGVuKGZ1bGZpbGwsIHJlamVjdCkgOiBzZXR0bGUocVswXVsyXSwgcik7IH1cbiAgZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkgeyByZXN1bWUoXCJuZXh0XCIsIHZhbHVlKTsgfVxuICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XG4gIGZ1bmN0aW9uIHNldHRsZShmLCB2KSB7IGlmIChmKHYpLCBxLnNoaWZ0KCksIHEubGVuZ3RoKSByZXN1bWUocVswXVswXSwgcVswXVsxXSk7IH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNEZWxlZ2F0b3Iobykge1xuICB2YXIgaSwgcDtcbiAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiLCBmdW5jdGlvbiAoZSkgeyB0aHJvdyBlOyB9KSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcbiAgZnVuY3Rpb24gdmVyYihuLCBmKSB7IGlbbl0gPSBvW25dID8gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIChwID0gIXApID8geyB2YWx1ZTogX19hd2FpdChvW25dKHYpKSwgZG9uZTogZmFsc2UgfSA6IGYgPyBmKHYpIDogdjsgfSA6IGY7IH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fYXN5bmNWYWx1ZXMobykge1xuICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xuICB2YXIgbSA9IG9bU3ltYm9sLmFzeW5jSXRlcmF0b3JdLCBpO1xuICByZXR1cm4gbSA/IG0uY2FsbChvKSA6IChvID0gdHlwZW9mIF9fdmFsdWVzID09PSBcImZ1bmN0aW9uXCIgPyBfX3ZhbHVlcyhvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpLCBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaSk7XG4gIGZ1bmN0aW9uIHZlcmIobikgeyBpW25dID0gb1tuXSAmJiBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyB2ID0gb1tuXSh2KSwgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgdi5kb25lLCB2LnZhbHVlKTsgfSk7IH07IH1cbiAgZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgZCwgdikgeyBQcm9taXNlLnJlc29sdmUodikudGhlbihmdW5jdGlvbih2KSB7IHJlc29sdmUoeyB2YWx1ZTogdiwgZG9uZTogZCB9KTsgfSwgcmVqZWN0KTsgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gX19tYWtlVGVtcGxhdGVPYmplY3QoY29va2VkLCByYXcpIHtcbiAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cbiAgcmV0dXJuIGNvb2tlZDtcbn07XG5cbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSBPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gIG9bXCJkZWZhdWx0XCJdID0gdjtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2ltcG9ydFN0YXIobW9kKSB7XG4gIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gIHZhciByZXN1bHQgPSB7fTtcbiAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19pbXBvcnREZWZhdWx0KG1vZCkge1xuICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IGRlZmF1bHQ6IG1vZCB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZEdldChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcbiAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgZ2V0dGVyXCIpO1xuICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRTZXQocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZikge1xuICBpZiAoa2luZCA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XG4gIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIHNldHRlclwiKTtcbiAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgcmV0dXJuIChraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpKSwgdmFsdWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkSW4oc3RhdGUsIHJlY2VpdmVyKSB7XG4gIGlmIChyZWNlaXZlciA9PT0gbnVsbCB8fCAodHlwZW9mIHJlY2VpdmVyICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiByZWNlaXZlciAhPT0gXCJmdW5jdGlvblwiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB1c2UgJ2luJyBvcGVyYXRvciBvbiBub24tb2JqZWN0XCIpO1xuICByZXR1cm4gdHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciA9PT0gc3RhdGUgOiBzdGF0ZS5oYXMocmVjZWl2ZXIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX19hZGREaXNwb3NhYmxlUmVzb3VyY2UoZW52LCB2YWx1ZSwgYXN5bmMpIHtcbiAgaWYgKHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB2b2lkIDApIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiT2JqZWN0IGV4cGVjdGVkLlwiKTtcbiAgICB2YXIgZGlzcG9zZTtcbiAgICBpZiAoYXN5bmMpIHtcbiAgICAgICAgaWYgKCFTeW1ib2wuYXN5bmNEaXNwb3NlKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jRGlzcG9zZSBpcyBub3QgZGVmaW5lZC5cIik7XG4gICAgICAgIGRpc3Bvc2UgPSB2YWx1ZVtTeW1ib2wuYXN5bmNEaXNwb3NlXTtcbiAgICB9XG4gICAgaWYgKGRpc3Bvc2UgPT09IHZvaWQgMCkge1xuICAgICAgICBpZiAoIVN5bWJvbC5kaXNwb3NlKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmRpc3Bvc2UgaXMgbm90IGRlZmluZWQuXCIpO1xuICAgICAgICBkaXNwb3NlID0gdmFsdWVbU3ltYm9sLmRpc3Bvc2VdO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGRpc3Bvc2UgIT09IFwiZnVuY3Rpb25cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIk9iamVjdCBub3QgZGlzcG9zYWJsZS5cIik7XG4gICAgZW52LnN0YWNrLnB1c2goeyB2YWx1ZTogdmFsdWUsIGRpc3Bvc2U6IGRpc3Bvc2UsIGFzeW5jOiBhc3luYyB9KTtcbiAgfVxuICBlbHNlIGlmIChhc3luYykge1xuICAgIGVudi5zdGFjay5wdXNoKHsgYXN5bmM6IHRydWUgfSk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG52YXIgX1N1cHByZXNzZWRFcnJvciA9IHR5cGVvZiBTdXBwcmVzc2VkRXJyb3IgPT09IFwiZnVuY3Rpb25cIiA/IFN1cHByZXNzZWRFcnJvciA6IGZ1bmN0aW9uIChlcnJvciwgc3VwcHJlc3NlZCwgbWVzc2FnZSkge1xuICB2YXIgZSA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgcmV0dXJuIGUubmFtZSA9IFwiU3VwcHJlc3NlZEVycm9yXCIsIGUuZXJyb3IgPSBlcnJvciwgZS5zdXBwcmVzc2VkID0gc3VwcHJlc3NlZCwgZTtcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBfX2Rpc3Bvc2VSZXNvdXJjZXMoZW52KSB7XG4gIGZ1bmN0aW9uIGZhaWwoZSkge1xuICAgIGVudi5lcnJvciA9IGVudi5oYXNFcnJvciA/IG5ldyBfU3VwcHJlc3NlZEVycm9yKGUsIGVudi5lcnJvciwgXCJBbiBlcnJvciB3YXMgc3VwcHJlc3NlZCBkdXJpbmcgZGlzcG9zYWwuXCIpIDogZTtcbiAgICBlbnYuaGFzRXJyb3IgPSB0cnVlO1xuICB9XG4gIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgd2hpbGUgKGVudi5zdGFjay5sZW5ndGgpIHtcbiAgICAgIHZhciByZWMgPSBlbnYuc3RhY2sucG9wKCk7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gcmVjLmRpc3Bvc2UgJiYgcmVjLmRpc3Bvc2UuY2FsbChyZWMudmFsdWUpO1xuICAgICAgICBpZiAocmVjLmFzeW5jKSByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCkudGhlbihuZXh0LCBmdW5jdGlvbihlKSB7IGZhaWwoZSk7IHJldHVybiBuZXh0KCk7IH0pO1xuICAgICAgfVxuICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICBmYWlsKGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZW52Lmhhc0Vycm9yKSB0aHJvdyBlbnYuZXJyb3I7XG4gIH1cbiAgcmV0dXJuIG5leHQoKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBfX2V4dGVuZHMsXG4gIF9fYXNzaWduLFxuICBfX3Jlc3QsXG4gIF9fZGVjb3JhdGUsXG4gIF9fcGFyYW0sXG4gIF9fbWV0YWRhdGEsXG4gIF9fYXdhaXRlcixcbiAgX19nZW5lcmF0b3IsXG4gIF9fY3JlYXRlQmluZGluZyxcbiAgX19leHBvcnRTdGFyLFxuICBfX3ZhbHVlcyxcbiAgX19yZWFkLFxuICBfX3NwcmVhZCxcbiAgX19zcHJlYWRBcnJheXMsXG4gIF9fc3ByZWFkQXJyYXksXG4gIF9fYXdhaXQsXG4gIF9fYXN5bmNHZW5lcmF0b3IsXG4gIF9fYXN5bmNEZWxlZ2F0b3IsXG4gIF9fYXN5bmNWYWx1ZXMsXG4gIF9fbWFrZVRlbXBsYXRlT2JqZWN0LFxuICBfX2ltcG9ydFN0YXIsXG4gIF9faW1wb3J0RGVmYXVsdCxcbiAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCxcbiAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCxcbiAgX19jbGFzc1ByaXZhdGVGaWVsZEluLFxuICBfX2FkZERpc3Bvc2FibGVSZXNvdXJjZSxcbiAgX19kaXNwb3NlUmVzb3VyY2VzLFxufTtcbiIsIi8qKlxuICogQnJvd3Nlci1zYWZlIHVzYWdlIG9mIHByb2Nlc3NcbiAqL1xudmFyIGRlZmF1bHRFbnZpcm9ubWVudCA9IFwicHJvZHVjdGlvblwiO1xudmFyIGVudiA9IHR5cGVvZiBwcm9jZXNzID09PSBcInVuZGVmaW5lZFwiIHx8IHByb2Nlc3MuZW52ID09PSB1bmRlZmluZWRcbiAgICA/IGRlZmF1bHRFbnZpcm9ubWVudFxuICAgIDogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgfHwgZGVmYXVsdEVudmlyb25tZW50O1xuXG5leHBvcnQgeyBlbnYgfTtcbiIsInZhciBjcmVhdGVEZWZpbml0aW9uID0gZnVuY3Rpb24gKHByb3BOYW1lcykgeyByZXR1cm4gKHtcbiAgICBpc0VuYWJsZWQ6IGZ1bmN0aW9uIChwcm9wcykgeyByZXR1cm4gcHJvcE5hbWVzLnNvbWUoZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuICEhcHJvcHNbbmFtZV07IH0pOyB9LFxufSk7IH07XG52YXIgZmVhdHVyZURlZmluaXRpb25zID0ge1xuICAgIG1lYXN1cmVMYXlvdXQ6IGNyZWF0ZURlZmluaXRpb24oW1wibGF5b3V0XCIsIFwibGF5b3V0SWRcIiwgXCJkcmFnXCJdKSxcbiAgICBhbmltYXRpb246IGNyZWF0ZURlZmluaXRpb24oW1xuICAgICAgICBcImFuaW1hdGVcIixcbiAgICAgICAgXCJleGl0XCIsXG4gICAgICAgIFwidmFyaWFudHNcIixcbiAgICAgICAgXCJ3aGlsZUhvdmVyXCIsXG4gICAgICAgIFwid2hpbGVUYXBcIixcbiAgICAgICAgXCJ3aGlsZUZvY3VzXCIsXG4gICAgICAgIFwid2hpbGVEcmFnXCIsXG4gICAgICAgIFwid2hpbGVJblZpZXdcIixcbiAgICBdKSxcbiAgICBleGl0OiBjcmVhdGVEZWZpbml0aW9uKFtcImV4aXRcIl0pLFxuICAgIGRyYWc6IGNyZWF0ZURlZmluaXRpb24oW1wiZHJhZ1wiLCBcImRyYWdDb250cm9sc1wiXSksXG4gICAgZm9jdXM6IGNyZWF0ZURlZmluaXRpb24oW1wid2hpbGVGb2N1c1wiXSksXG4gICAgaG92ZXI6IGNyZWF0ZURlZmluaXRpb24oW1wid2hpbGVIb3ZlclwiLCBcIm9uSG92ZXJTdGFydFwiLCBcIm9uSG92ZXJFbmRcIl0pLFxuICAgIHRhcDogY3JlYXRlRGVmaW5pdGlvbihbXCJ3aGlsZVRhcFwiLCBcIm9uVGFwXCIsIFwib25UYXBTdGFydFwiLCBcIm9uVGFwQ2FuY2VsXCJdKSxcbiAgICBwYW46IGNyZWF0ZURlZmluaXRpb24oW1xuICAgICAgICBcIm9uUGFuXCIsXG4gICAgICAgIFwib25QYW5TdGFydFwiLFxuICAgICAgICBcIm9uUGFuU2Vzc2lvblN0YXJ0XCIsXG4gICAgICAgIFwib25QYW5FbmRcIixcbiAgICBdKSxcbiAgICBpblZpZXc6IGNyZWF0ZURlZmluaXRpb24oW1xuICAgICAgICBcIndoaWxlSW5WaWV3XCIsXG4gICAgICAgIFwib25WaWV3cG9ydEVudGVyXCIsXG4gICAgICAgIFwib25WaWV3cG9ydExlYXZlXCIsXG4gICAgXSksXG59O1xuZnVuY3Rpb24gbG9hZEZlYXR1cmVzKGZlYXR1cmVzKSB7XG4gICAgZm9yICh2YXIga2V5IGluIGZlYXR1cmVzKSB7XG4gICAgICAgIGlmIChmZWF0dXJlc1trZXldID09PSBudWxsKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGlmIChrZXkgPT09IFwicHJvamVjdGlvbk5vZGVDb25zdHJ1Y3RvclwiKSB7XG4gICAgICAgICAgICBmZWF0dXJlRGVmaW5pdGlvbnMucHJvamVjdGlvbk5vZGVDb25zdHJ1Y3RvciA9IGZlYXR1cmVzW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmZWF0dXJlRGVmaW5pdGlvbnNba2V5XS5Db21wb25lbnQgPSBmZWF0dXJlc1trZXldO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgeyBmZWF0dXJlRGVmaW5pdGlvbnMsIGxvYWRGZWF0dXJlcyB9O1xuIiwidmFyIHdhcm5pbmcgPSBmdW5jdGlvbiAoKSB7IH07XHJcbnZhciBpbnZhcmlhbnQgPSBmdW5jdGlvbiAoKSB7IH07XHJcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XHJcbiAgICB3YXJuaW5nID0gZnVuY3Rpb24gKGNoZWNrLCBtZXNzYWdlKSB7XHJcbiAgICAgICAgaWYgKCFjaGVjayAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBpbnZhcmlhbnQgPSBmdW5jdGlvbiAoY2hlY2ssIG1lc3NhZ2UpIHtcclxuICAgICAgICBpZiAoIWNoZWNrKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XG5cbmV4cG9ydCB7IGludmFyaWFudCwgd2FybmluZyB9O1xuIiwiaW1wb3J0IHsgY3JlYXRlQ29udGV4dCB9IGZyb20gJ3JlYWN0JztcblxudmFyIExhenlDb250ZXh0ID0gY3JlYXRlQ29udGV4dCh7IHN0cmljdDogZmFsc2UgfSk7XG5cbmV4cG9ydCB7IExhenlDb250ZXh0IH07XG4iLCJpbXBvcnQgeyBfX2Fzc2lnbiB9IGZyb20gJ3RzbGliJztcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZUNvbnRleHQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBlbnYgfSBmcm9tICcuLi8uLi91dGlscy9wcm9jZXNzLm1qcyc7XG5pbXBvcnQgeyBmZWF0dXJlRGVmaW5pdGlvbnMgfSBmcm9tICcuL2RlZmluaXRpb25zLm1qcyc7XG5pbXBvcnQgeyBpbnZhcmlhbnQgfSBmcm9tICdoZXktbGlzdGVuJztcbmltcG9ydCB7IExhenlDb250ZXh0IH0gZnJvbSAnLi4vLi4vY29udGV4dC9MYXp5Q29udGV4dC5tanMnO1xuXG52YXIgZmVhdHVyZU5hbWVzID0gT2JqZWN0LmtleXMoZmVhdHVyZURlZmluaXRpb25zKTtcbnZhciBudW1GZWF0dXJlcyA9IGZlYXR1cmVOYW1lcy5sZW5ndGg7XG4vKipcbiAqIExvYWQgZmVhdHVyZXMgdmlhIHJlbmRlcmxlc3MgY29tcG9uZW50cyBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgTW90aW9uUHJvcHMuXG4gKi9cbmZ1bmN0aW9uIHVzZUZlYXR1cmVzKHByb3BzLCB2aXN1YWxFbGVtZW50LCBwcmVsb2FkZWRGZWF0dXJlcykge1xuICAgIHZhciBmZWF0dXJlcyA9IFtdO1xuICAgIHZhciBsYXp5Q29udGV4dCA9IHVzZUNvbnRleHQoTGF6eUNvbnRleHQpO1xuICAgIGlmICghdmlzdWFsRWxlbWVudClcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgLyoqXG4gICAgICogSWYgd2UncmUgaW4gZGV2ZWxvcG1lbnQgbW9kZSwgY2hlY2sgdG8gbWFrZSBzdXJlIHdlJ3JlIG5vdCByZW5kZXJpbmcgYSBtb3Rpb24gY29tcG9uZW50XG4gICAgICogYXMgYSBjaGlsZCBvZiBMYXp5TW90aW9uLCBhcyB0aGlzIHdpbGwgYnJlYWsgdGhlIGZpbGUtc2l6ZSBiZW5lZml0cyBvZiB1c2luZyBpdC5cbiAgICAgKi9cbiAgICBpZiAoZW52ICE9PSBcInByb2R1Y3Rpb25cIiAmJiBwcmVsb2FkZWRGZWF0dXJlcyAmJiBsYXp5Q29udGV4dC5zdHJpY3QpIHtcbiAgICAgICAgaW52YXJpYW50KGZhbHNlLCBcIllvdSBoYXZlIHJlbmRlcmVkIGEgYG1vdGlvbmAgY29tcG9uZW50IHdpdGhpbiBhIGBMYXp5TW90aW9uYCBjb21wb25lbnQuIFRoaXMgd2lsbCBicmVhayB0cmVlIHNoYWtpbmcuIEltcG9ydCBhbmQgcmVuZGVyIGEgYG1gIGNvbXBvbmVudCBpbnN0ZWFkLlwiKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1GZWF0dXJlczsgaSsrKSB7XG4gICAgICAgIHZhciBuYW1lXzEgPSBmZWF0dXJlTmFtZXNbaV07XG4gICAgICAgIHZhciBfYSA9IGZlYXR1cmVEZWZpbml0aW9uc1tuYW1lXzFdLCBpc0VuYWJsZWQgPSBfYS5pc0VuYWJsZWQsIENvbXBvbmVudCA9IF9hLkNvbXBvbmVudDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEl0IG1pZ2h0IGJlIHBvc3NpYmxlIGluIHRoZSBmdXR1cmUgdG8gdXNlIHRoaXMgbW9tZW50IHRvXG4gICAgICAgICAqIGR5bmFtaWNhbGx5IHJlcXVlc3QgZnVuY3Rpb25hbGl0eS4gSW4gaW5pdGlhbCB0ZXN0cyB0aGlzXG4gICAgICAgICAqIHdhcyBwcm9kdWNpbmcgYSBsb3Qgb2YgZHVwbGljYXRpb24gYW1vbmdzdCBidW5kbGVzLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKGlzRW5hYmxlZChwcm9wcykgJiYgQ29tcG9uZW50KSB7XG4gICAgICAgICAgICBmZWF0dXJlcy5wdXNoKFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29tcG9uZW50LCBfX2Fzc2lnbih7IGtleTogbmFtZV8xIH0sIHByb3BzLCB7IHZpc3VhbEVsZW1lbnQ6IHZpc3VhbEVsZW1lbnQgfSkpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmVhdHVyZXM7XG59XG5cbmV4cG9ydCB7IHVzZUZlYXR1cmVzIH07XG4iLCJpbXBvcnQgeyBjcmVhdGVDb250ZXh0IH0gZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIEBwdWJsaWNcbiAqL1xudmFyIE1vdGlvbkNvbmZpZ0NvbnRleHQgPSBjcmVhdGVDb250ZXh0KHtcbiAgICB0cmFuc2Zvcm1QYWdlUG9pbnQ6IGZ1bmN0aW9uIChwKSB7IHJldHVybiBwOyB9LFxuICAgIGlzU3RhdGljOiBmYWxzZSxcbiAgICByZWR1Y2VkTW90aW9uOiBcIm5ldmVyXCIsXG59KTtcblxuZXhwb3J0IHsgTW90aW9uQ29uZmlnQ29udGV4dCB9O1xuIiwiaW1wb3J0IHsgY3JlYXRlQ29udGV4dCwgdXNlQ29udGV4dCB9IGZyb20gJ3JlYWN0JztcblxudmFyIE1vdGlvbkNvbnRleHQgPSBjcmVhdGVDb250ZXh0KHt9KTtcbmZ1bmN0aW9uIHVzZVZpc3VhbEVsZW1lbnRDb250ZXh0KCkge1xuICAgIHJldHVybiB1c2VDb250ZXh0KE1vdGlvbkNvbnRleHQpLnZpc3VhbEVsZW1lbnQ7XG59XG5cbmV4cG9ydCB7IE1vdGlvbkNvbnRleHQsIHVzZVZpc3VhbEVsZW1lbnRDb250ZXh0IH07XG4iLCJpbXBvcnQgeyBjcmVhdGVDb250ZXh0IH0gZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIEBwdWJsaWNcbiAqL1xudmFyIFByZXNlbmNlQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQobnVsbCk7XG5cbmV4cG9ydCB7IFByZXNlbmNlQ29udGV4dCB9O1xuIiwidmFyIGlzQnJvd3NlciA9IHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIjtcblxuZXhwb3J0IHsgaXNCcm93c2VyIH07XG4iLCJpbXBvcnQgeyB1c2VMYXlvdXRFZmZlY3QsIHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGlzQnJvd3NlciB9IGZyb20gJy4vaXMtYnJvd3Nlci5tanMnO1xuXG52YXIgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCA9IGlzQnJvd3NlciA/IHVzZUxheW91dEVmZmVjdCA6IHVzZUVmZmVjdDtcblxuZXhwb3J0IHsgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCB9O1xuIiwiaW1wb3J0IHsgX19yZWFkIH0gZnJvbSAndHNsaWInO1xuaW1wb3J0IHsgdXNlU3RhdGUsIHVzZUNvbnRleHQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBNb3Rpb25Db25maWdDb250ZXh0IH0gZnJvbSAnLi4vY29udGV4dC9Nb3Rpb25Db25maWdDb250ZXh0Lm1qcyc7XG5pbXBvcnQgeyBpc0Jyb3dzZXIgfSBmcm9tICcuL2lzLWJyb3dzZXIubWpzJztcblxuLy8gRG9lcyB0aGlzIGRldmljZSBwcmVmZXIgcmVkdWNlZCBtb3Rpb24/IFJldHVybnMgYG51bGxgIHNlcnZlci1zaWRlLlxudmFyIHByZWZlcnNSZWR1Y2VkTW90aW9uID0geyBjdXJyZW50OiBudWxsIH07XG52YXIgaGFzRGV0ZWN0ZWQgPSBmYWxzZTtcbmZ1bmN0aW9uIGluaXRQcmVmZXJzUmVkdWNlZE1vdGlvbigpIHtcbiAgICBoYXNEZXRlY3RlZCA9IHRydWU7XG4gICAgaWYgKCFpc0Jyb3dzZXIpXG4gICAgICAgIHJldHVybjtcbiAgICBpZiAod2luZG93Lm1hdGNoTWVkaWEpIHtcbiAgICAgICAgdmFyIG1vdGlvbk1lZGlhUXVlcnlfMSA9IHdpbmRvdy5tYXRjaE1lZGlhKFwiKHByZWZlcnMtcmVkdWNlZC1tb3Rpb24pXCIpO1xuICAgICAgICB2YXIgc2V0UmVkdWNlZE1vdGlvblByZWZlcmVuY2VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIChwcmVmZXJzUmVkdWNlZE1vdGlvbi5jdXJyZW50ID0gbW90aW9uTWVkaWFRdWVyeV8xLm1hdGNoZXMpO1xuICAgICAgICB9O1xuICAgICAgICBtb3Rpb25NZWRpYVF1ZXJ5XzEuYWRkTGlzdGVuZXIoc2V0UmVkdWNlZE1vdGlvblByZWZlcmVuY2VzKTtcbiAgICAgICAgc2V0UmVkdWNlZE1vdGlvblByZWZlcmVuY2VzKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBwcmVmZXJzUmVkdWNlZE1vdGlvbi5jdXJyZW50ID0gZmFsc2U7XG4gICAgfVxufVxuLyoqXG4gKiBBIGhvb2sgdGhhdCByZXR1cm5zIGB0cnVlYCBpZiB3ZSBzaG91bGQgYmUgdXNpbmcgcmVkdWNlZCBtb3Rpb24gYmFzZWQgb24gdGhlIGN1cnJlbnQgZGV2aWNlJ3MgUmVkdWNlZCBNb3Rpb24gc2V0dGluZy5cbiAqXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGltcGxlbWVudCBjaGFuZ2VzIHRvIHlvdXIgVUkgYmFzZWQgb24gUmVkdWNlZCBNb3Rpb24uIEZvciBpbnN0YW5jZSwgcmVwbGFjaW5nIG1vdGlvbi1zaWNrbmVzcyBpbmR1Y2luZ1xuICogYHhgL2B5YCBhbmltYXRpb25zIHdpdGggYG9wYWNpdHlgLCBkaXNhYmxpbmcgdGhlIGF1dG9wbGF5IG9mIGJhY2tncm91bmQgdmlkZW9zLCBvciB0dXJuaW5nIG9mZiBwYXJhbGxheCBtb3Rpb24uXG4gKlxuICogSXQgd2lsbCBhY3RpdmVseSByZXNwb25kIHRvIGNoYW5nZXMgYW5kIHJlLXJlbmRlciB5b3VyIGNvbXBvbmVudHMgd2l0aCB0aGUgbGF0ZXN0IHNldHRpbmcuXG4gKlxuICogYGBganN4XG4gKiBleHBvcnQgZnVuY3Rpb24gU2lkZWJhcih7IGlzT3BlbiB9KSB7XG4gKiAgIGNvbnN0IHNob3VsZFJlZHVjZU1vdGlvbiA9IHVzZVJlZHVjZWRNb3Rpb24oKVxuICogICBjb25zdCBjbG9zZWRYID0gc2hvdWxkUmVkdWNlTW90aW9uID8gMCA6IFwiLTEwMCVcIlxuICpcbiAqICAgcmV0dXJuIChcbiAqICAgICA8bW90aW9uLmRpdiBhbmltYXRlPXt7XG4gKiAgICAgICBvcGFjaXR5OiBpc09wZW4gPyAxIDogMCxcbiAqICAgICAgIHg6IGlzT3BlbiA/IDAgOiBjbG9zZWRYXG4gKiAgICAgfX0gLz5cbiAqICAgKVxuICogfVxuICogYGBgXG4gKlxuICogQHJldHVybiBib29sZWFuXG4gKlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiB1c2VSZWR1Y2VkTW90aW9uKCkge1xuICAgIC8qKlxuICAgICAqIExhenkgaW5pdGlhbGlzYXRpb24gb2YgcHJlZmVyc1JlZHVjZWRNb3Rpb25cbiAgICAgKi9cbiAgICAhaGFzRGV0ZWN0ZWQgJiYgaW5pdFByZWZlcnNSZWR1Y2VkTW90aW9uKCk7XG4gICAgdmFyIF9hID0gX19yZWFkKHVzZVN0YXRlKHByZWZlcnNSZWR1Y2VkTW90aW9uLmN1cnJlbnQpLCAxKSwgc2hvdWxkUmVkdWNlTW90aW9uID0gX2FbMF07XG4gICAgLyoqXG4gICAgICogVE9ETyBTZWUgaWYgcGVvcGxlIG1pc3MgYXV0b21hdGljYWxseSB1cGRhdGluZyBzaG91bGRSZWR1Y2VNb3Rpb24gc2V0dGluZ1xuICAgICAqL1xuICAgIHJldHVybiBzaG91bGRSZWR1Y2VNb3Rpb247XG59XG5mdW5jdGlvbiB1c2VSZWR1Y2VkTW90aW9uQ29uZmlnKCkge1xuICAgIHZhciByZWR1Y2VkTW90aW9uUHJlZmVyZW5jZSA9IHVzZVJlZHVjZWRNb3Rpb24oKTtcbiAgICB2YXIgcmVkdWNlZE1vdGlvbiA9IHVzZUNvbnRleHQoTW90aW9uQ29uZmlnQ29udGV4dCkucmVkdWNlZE1vdGlvbjtcbiAgICBpZiAocmVkdWNlZE1vdGlvbiA9PT0gXCJuZXZlclwiKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZWxzZSBpZiAocmVkdWNlZE1vdGlvbiA9PT0gXCJhbHdheXNcIikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiByZWR1Y2VkTW90aW9uUHJlZmVyZW5jZTtcbiAgICB9XG59XG5cbmV4cG9ydCB7IHVzZVJlZHVjZWRNb3Rpb24sIHVzZVJlZHVjZWRNb3Rpb25Db25maWcgfTtcbiIsImltcG9ydCB7IHVzZUNvbnRleHQsIHVzZVJlZiwgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgUHJlc2VuY2VDb250ZXh0IH0gZnJvbSAnLi4vLi4vY29udGV4dC9QcmVzZW5jZUNvbnRleHQubWpzJztcbmltcG9ydCB7IHVzZVZpc3VhbEVsZW1lbnRDb250ZXh0IH0gZnJvbSAnLi4vLi4vY29udGV4dC9Nb3Rpb25Db250ZXh0L2luZGV4Lm1qcyc7XG5pbXBvcnQgeyB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0IH0gZnJvbSAnLi4vLi4vdXRpbHMvdXNlLWlzb21vcnBoaWMtZWZmZWN0Lm1qcyc7XG5pbXBvcnQgeyBMYXp5Q29udGV4dCB9IGZyb20gJy4uLy4uL2NvbnRleHQvTGF6eUNvbnRleHQubWpzJztcbmltcG9ydCB7IHVzZVJlZHVjZWRNb3Rpb25Db25maWcgfSBmcm9tICcuLi8uLi91dGlscy91c2UtcmVkdWNlZC1tb3Rpb24ubWpzJztcblxuZnVuY3Rpb24gdXNlVmlzdWFsRWxlbWVudChDb21wb25lbnQsIHZpc3VhbFN0YXRlLCBwcm9wcywgY3JlYXRlVmlzdWFsRWxlbWVudCkge1xuICAgIHZhciBsYXp5Q29udGV4dCA9IHVzZUNvbnRleHQoTGF6eUNvbnRleHQpO1xuICAgIHZhciBwYXJlbnQgPSB1c2VWaXN1YWxFbGVtZW50Q29udGV4dCgpO1xuICAgIHZhciBwcmVzZW5jZUNvbnRleHQgPSB1c2VDb250ZXh0KFByZXNlbmNlQ29udGV4dCk7XG4gICAgdmFyIHNob3VsZFJlZHVjZU1vdGlvbiA9IHVzZVJlZHVjZWRNb3Rpb25Db25maWcoKTtcbiAgICB2YXIgdmlzdWFsRWxlbWVudFJlZiA9IHVzZVJlZih1bmRlZmluZWQpO1xuICAgIC8qKlxuICAgICAqIElmIHdlIGhhdmVuJ3QgcHJlbG9hZGVkIGEgcmVuZGVyZXIsIGNoZWNrIHRvIHNlZSBpZiB3ZSBoYXZlIG9uZSBsYXp5LWxvYWRlZFxuICAgICAqL1xuICAgIGlmICghY3JlYXRlVmlzdWFsRWxlbWVudClcbiAgICAgICAgY3JlYXRlVmlzdWFsRWxlbWVudCA9IGxhenlDb250ZXh0LnJlbmRlcmVyO1xuICAgIGlmICghdmlzdWFsRWxlbWVudFJlZi5jdXJyZW50ICYmIGNyZWF0ZVZpc3VhbEVsZW1lbnQpIHtcbiAgICAgICAgdmlzdWFsRWxlbWVudFJlZi5jdXJyZW50ID0gY3JlYXRlVmlzdWFsRWxlbWVudChDb21wb25lbnQsIHtcbiAgICAgICAgICAgIHZpc3VhbFN0YXRlOiB2aXN1YWxTdGF0ZSxcbiAgICAgICAgICAgIHBhcmVudDogcGFyZW50LFxuICAgICAgICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgICAgICAgcHJlc2VuY2VJZDogcHJlc2VuY2VDb250ZXh0ID09PSBudWxsIHx8IHByZXNlbmNlQ29udGV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJlc2VuY2VDb250ZXh0LmlkLFxuICAgICAgICAgICAgYmxvY2tJbml0aWFsQW5pbWF0aW9uOiAocHJlc2VuY2VDb250ZXh0ID09PSBudWxsIHx8IHByZXNlbmNlQ29udGV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJlc2VuY2VDb250ZXh0LmluaXRpYWwpID09PSBmYWxzZSxcbiAgICAgICAgICAgIHNob3VsZFJlZHVjZU1vdGlvbjogc2hvdWxkUmVkdWNlTW90aW9uLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdmFyIHZpc3VhbEVsZW1lbnQgPSB2aXN1YWxFbGVtZW50UmVmLmN1cnJlbnQ7XG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZpc3VhbEVsZW1lbnQgPT09IG51bGwgfHwgdmlzdWFsRWxlbWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmlzdWFsRWxlbWVudC5zeW5jUmVuZGVyKCk7XG4gICAgfSk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSB2aXN1YWxFbGVtZW50ID09PSBudWxsIHx8IHZpc3VhbEVsZW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZpc3VhbEVsZW1lbnQuYW5pbWF0aW9uU3RhdGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hbmltYXRlQ2hhbmdlcygpO1xuICAgIH0pO1xuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkgeyByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gdmlzdWFsRWxlbWVudCA9PT0gbnVsbCB8fCB2aXN1YWxFbGVtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2aXN1YWxFbGVtZW50Lm5vdGlmeVVubW91bnQoKTsgfTsgfSwgW10pO1xuICAgIHJldHVybiB2aXN1YWxFbGVtZW50O1xufVxuXG5leHBvcnQgeyB1c2VWaXN1YWxFbGVtZW50IH07XG4iLCJmdW5jdGlvbiBpc1JlZk9iamVjdChyZWYpIHtcbiAgICByZXR1cm4gKHR5cGVvZiByZWYgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHJlZiwgXCJjdXJyZW50XCIpKTtcbn1cblxuZXhwb3J0IHsgaXNSZWZPYmplY3QgfTtcbiIsImltcG9ydCB7IHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgaXNSZWZPYmplY3QgfSBmcm9tICcuLi8uLi91dGlscy9pcy1yZWYtb2JqZWN0Lm1qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHJlZiBmdW5jdGlvbiB0aGF0LCB3aGVuIGNhbGxlZCwgaHlkcmF0ZXMgdGhlIHByb3ZpZGVkXG4gKiBleHRlcm5hbCByZWYgYW5kIFZpc3VhbEVsZW1lbnQuXG4gKi9cbmZ1bmN0aW9uIHVzZU1vdGlvblJlZih2aXN1YWxTdGF0ZSwgdmlzdWFsRWxlbWVudCwgZXh0ZXJuYWxSZWYpIHtcbiAgICByZXR1cm4gdXNlQ2FsbGJhY2soZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaW5zdGFuY2UgJiYgKChfYSA9IHZpc3VhbFN0YXRlLm1vdW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh2aXN1YWxTdGF0ZSwgaW5zdGFuY2UpKTtcbiAgICAgICAgaWYgKHZpc3VhbEVsZW1lbnQpIHtcbiAgICAgICAgICAgIGluc3RhbmNlXG4gICAgICAgICAgICAgICAgPyB2aXN1YWxFbGVtZW50Lm1vdW50KGluc3RhbmNlKVxuICAgICAgICAgICAgICAgIDogdmlzdWFsRWxlbWVudC51bm1vdW50KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4dGVybmFsUmVmKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGV4dGVybmFsUmVmID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBleHRlcm5hbFJlZihpbnN0YW5jZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc1JlZk9iamVjdChleHRlcm5hbFJlZikpIHtcbiAgICAgICAgICAgICAgICBleHRlcm5hbFJlZi5jdXJyZW50ID0gaW5zdGFuY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBcbiAgICAvKipcbiAgICAgKiBPbmx5IHBhc3MgYSBuZXcgcmVmIGNhbGxiYWNrIHRvIFJlYWN0IGlmIHdlJ3ZlIHJlY2VpdmVkIGEgdmlzdWFsIGVsZW1lbnRcbiAgICAgKiBmYWN0b3J5LiBPdGhlcndpc2Ugd2UnbGwgYmUgbW91bnRpbmcvcmVtb3VudGluZyBldmVyeSB0aW1lIGV4dGVybmFsUmVmXG4gICAgICogb3Igb3RoZXIgZGVwZW5kZW5jaWVzIGNoYW5nZS5cbiAgICAgKi9cbiAgICBbdmlzdWFsRWxlbWVudF0pO1xufVxuXG5leHBvcnQgeyB1c2VNb3Rpb25SZWYgfTtcbiIsIi8qKlxuICogRGVjaWRlcyBpZiB0aGUgc3VwcGxpZWQgdmFyaWFibGUgaXMgYW4gYXJyYXkgb2YgdmFyaWFudCBsYWJlbHNcbiAqL1xuZnVuY3Rpb24gaXNWYXJpYW50TGFiZWxzKHYpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2KTtcbn1cbi8qKlxuICogRGVjaWRlcyBpZiB0aGUgc3VwcGxpZWQgdmFyaWFibGUgaXMgdmFyaWFudCBsYWJlbFxuICovXG5mdW5jdGlvbiBpc1ZhcmlhbnRMYWJlbCh2KSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2ID09PSBcInN0cmluZ1wiIHx8IGlzVmFyaWFudExhYmVscyh2KTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgbGF0ZXN0IHN0YXRlIG9mIGV2ZXJ5IE1vdGlvblZhbHVlIG9uIGEgVmlzdWFsRWxlbWVudFxuICovXG5mdW5jdGlvbiBnZXRDdXJyZW50KHZpc3VhbEVsZW1lbnQpIHtcbiAgICB2YXIgY3VycmVudCA9IHt9O1xuICAgIHZpc3VhbEVsZW1lbnQuZm9yRWFjaFZhbHVlKGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7IHJldHVybiAoY3VycmVudFtrZXldID0gdmFsdWUuZ2V0KCkpOyB9KTtcbiAgICByZXR1cm4gY3VycmVudDtcbn1cbi8qKlxuICogQ3JlYXRlcyBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgbGF0ZXN0IHZlbG9jaXR5IG9mIGV2ZXJ5IE1vdGlvblZhbHVlIG9uIGEgVmlzdWFsRWxlbWVudFxuICovXG5mdW5jdGlvbiBnZXRWZWxvY2l0eSh2aXN1YWxFbGVtZW50KSB7XG4gICAgdmFyIHZlbG9jaXR5ID0ge307XG4gICAgdmlzdWFsRWxlbWVudC5mb3JFYWNoVmFsdWUoZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHsgcmV0dXJuICh2ZWxvY2l0eVtrZXldID0gdmFsdWUuZ2V0VmVsb2NpdHkoKSk7IH0pO1xuICAgIHJldHVybiB2ZWxvY2l0eTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVWYXJpYW50RnJvbVByb3BzKHByb3BzLCBkZWZpbml0aW9uLCBjdXN0b20sIGN1cnJlbnRWYWx1ZXMsIGN1cnJlbnRWZWxvY2l0eSkge1xuICAgIHZhciBfYTtcbiAgICBpZiAoY3VycmVudFZhbHVlcyA9PT0gdm9pZCAwKSB7IGN1cnJlbnRWYWx1ZXMgPSB7fTsgfVxuICAgIGlmIChjdXJyZW50VmVsb2NpdHkgPT09IHZvaWQgMCkgeyBjdXJyZW50VmVsb2NpdHkgPSB7fTsgfVxuICAgIC8qKlxuICAgICAqIElmIHRoZSB2YXJpYW50IGRlZmluaXRpb24gaXMgYSBmdW5jdGlvbiwgcmVzb2x2ZS5cbiAgICAgKi9cbiAgICBpZiAodHlwZW9mIGRlZmluaXRpb24gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBkZWZpbml0aW9uID0gZGVmaW5pdGlvbihjdXN0b20gIT09IG51bGwgJiYgY3VzdG9tICE9PSB2b2lkIDAgPyBjdXN0b20gOiBwcm9wcy5jdXN0b20sIGN1cnJlbnRWYWx1ZXMsIGN1cnJlbnRWZWxvY2l0eSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElmIHRoZSB2YXJpYW50IGRlZmluaXRpb24gaXMgYSB2YXJpYW50IGxhYmVsLCBvclxuICAgICAqIHRoZSBmdW5jdGlvbiByZXR1cm5lZCBhIHZhcmlhbnQgbGFiZWwsIHJlc29sdmUuXG4gICAgICovXG4gICAgaWYgKHR5cGVvZiBkZWZpbml0aW9uID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGRlZmluaXRpb24gPSAoX2EgPSBwcm9wcy52YXJpYW50cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW2RlZmluaXRpb25dO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBdCB0aGlzIHBvaW50IHdlJ3ZlIHJlc29sdmVkIGJvdGggZnVuY3Rpb25zIGFuZCB2YXJpYW50IGxhYmVscyxcbiAgICAgKiBidXQgdGhlIHJlc29sdmVkIHZhcmlhbnQgbGFiZWwgbWlnaHQgaXRzZWxmIGhhdmUgYmVlbiBhIGZ1bmN0aW9uLlxuICAgICAqIElmIHNvLCByZXNvbHZlLiBUaGlzIGNhbiBvbmx5IGhhdmUgcmV0dXJuZWQgYSB2YWxpZCB0YXJnZXQgb2JqZWN0LlxuICAgICAqL1xuICAgIGlmICh0eXBlb2YgZGVmaW5pdGlvbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGRlZmluaXRpb24gPSBkZWZpbml0aW9uKGN1c3RvbSAhPT0gbnVsbCAmJiBjdXN0b20gIT09IHZvaWQgMCA/IGN1c3RvbSA6IHByb3BzLmN1c3RvbSwgY3VycmVudFZhbHVlcywgY3VycmVudFZlbG9jaXR5KTtcbiAgICB9XG4gICAgcmV0dXJuIGRlZmluaXRpb247XG59XG5mdW5jdGlvbiByZXNvbHZlVmFyaWFudCh2aXN1YWxFbGVtZW50LCBkZWZpbml0aW9uLCBjdXN0b20pIHtcbiAgICB2YXIgcHJvcHMgPSB2aXN1YWxFbGVtZW50LmdldFByb3BzKCk7XG4gICAgcmV0dXJuIHJlc29sdmVWYXJpYW50RnJvbVByb3BzKHByb3BzLCBkZWZpbml0aW9uLCBjdXN0b20gIT09IG51bGwgJiYgY3VzdG9tICE9PSB2b2lkIDAgPyBjdXN0b20gOiBwcm9wcy5jdXN0b20sIGdldEN1cnJlbnQodmlzdWFsRWxlbWVudCksIGdldFZlbG9jaXR5KHZpc3VhbEVsZW1lbnQpKTtcbn1cbmZ1bmN0aW9uIGNoZWNrSWZDb250cm9sbGluZ1ZhcmlhbnRzKHByb3BzKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAodHlwZW9mICgoX2EgPSBwcm9wcy5hbmltYXRlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc3RhcnQpID09PSBcImZ1bmN0aW9uXCIgfHxcbiAgICAgICAgaXNWYXJpYW50TGFiZWwocHJvcHMuaW5pdGlhbCkgfHxcbiAgICAgICAgaXNWYXJpYW50TGFiZWwocHJvcHMuYW5pbWF0ZSkgfHxcbiAgICAgICAgaXNWYXJpYW50TGFiZWwocHJvcHMud2hpbGVIb3ZlcikgfHxcbiAgICAgICAgaXNWYXJpYW50TGFiZWwocHJvcHMud2hpbGVEcmFnKSB8fFxuICAgICAgICBpc1ZhcmlhbnRMYWJlbChwcm9wcy53aGlsZVRhcCkgfHxcbiAgICAgICAgaXNWYXJpYW50TGFiZWwocHJvcHMud2hpbGVGb2N1cykgfHxcbiAgICAgICAgaXNWYXJpYW50TGFiZWwocHJvcHMuZXhpdCkpO1xufVxuZnVuY3Rpb24gY2hlY2tJZlZhcmlhbnROb2RlKHByb3BzKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4oY2hlY2tJZkNvbnRyb2xsaW5nVmFyaWFudHMocHJvcHMpIHx8IHByb3BzLnZhcmlhbnRzKTtcbn1cblxuZXhwb3J0IHsgY2hlY2tJZkNvbnRyb2xsaW5nVmFyaWFudHMsIGNoZWNrSWZWYXJpYW50Tm9kZSwgaXNWYXJpYW50TGFiZWwsIGlzVmFyaWFudExhYmVscywgcmVzb2x2ZVZhcmlhbnQsIHJlc29sdmVWYXJpYW50RnJvbVByb3BzIH07XG4iLCJpbXBvcnQgeyBjaGVja0lmQ29udHJvbGxpbmdWYXJpYW50cywgaXNWYXJpYW50TGFiZWwgfSBmcm9tICcuLi8uLi9yZW5kZXIvdXRpbHMvdmFyaWFudHMubWpzJztcblxuZnVuY3Rpb24gZ2V0Q3VycmVudFRyZWVWYXJpYW50cyhwcm9wcywgY29udGV4dCkge1xuICAgIGlmIChjaGVja0lmQ29udHJvbGxpbmdWYXJpYW50cyhwcm9wcykpIHtcbiAgICAgICAgdmFyIGluaXRpYWwgPSBwcm9wcy5pbml0aWFsLCBhbmltYXRlID0gcHJvcHMuYW5pbWF0ZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGluaXRpYWw6IGluaXRpYWwgPT09IGZhbHNlIHx8IGlzVmFyaWFudExhYmVsKGluaXRpYWwpXG4gICAgICAgICAgICAgICAgPyBpbml0aWFsXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBhbmltYXRlOiBpc1ZhcmlhbnRMYWJlbChhbmltYXRlKSA/IGFuaW1hdGUgOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBwcm9wcy5pbmhlcml0ICE9PSBmYWxzZSA/IGNvbnRleHQgOiB7fTtcbn1cblxuZXhwb3J0IHsgZ2V0Q3VycmVudFRyZWVWYXJpYW50cyB9O1xuIiwiaW1wb3J0IHsgdXNlTWVtbywgdXNlQ29udGV4dCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IE1vdGlvbkNvbnRleHQgfSBmcm9tICcuL2luZGV4Lm1qcyc7XG5pbXBvcnQgeyBnZXRDdXJyZW50VHJlZVZhcmlhbnRzIH0gZnJvbSAnLi91dGlscy5tanMnO1xuXG5mdW5jdGlvbiB1c2VDcmVhdGVNb3Rpb25Db250ZXh0KHByb3BzKSB7XG4gICAgdmFyIF9hID0gZ2V0Q3VycmVudFRyZWVWYXJpYW50cyhwcm9wcywgdXNlQ29udGV4dChNb3Rpb25Db250ZXh0KSksIGluaXRpYWwgPSBfYS5pbml0aWFsLCBhbmltYXRlID0gX2EuYW5pbWF0ZTtcbiAgICByZXR1cm4gdXNlTWVtbyhmdW5jdGlvbiAoKSB7IHJldHVybiAoeyBpbml0aWFsOiBpbml0aWFsLCBhbmltYXRlOiBhbmltYXRlIH0pOyB9LCBbdmFyaWFudExhYmVsc0FzRGVwZW5kZW5jeShpbml0aWFsKSwgdmFyaWFudExhYmVsc0FzRGVwZW5kZW5jeShhbmltYXRlKV0pO1xufVxuZnVuY3Rpb24gdmFyaWFudExhYmVsc0FzRGVwZW5kZW5jeShwcm9wKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkocHJvcCkgPyBwcm9wLmpvaW4oXCIgXCIpIDogcHJvcDtcbn1cblxuZXhwb3J0IHsgdXNlQ3JlYXRlTW90aW9uQ29udGV4dCB9O1xuIiwiaW1wb3J0IHsgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBjb25zdGFudCB2YWx1ZSBvdmVyIHRoZSBsaWZlY3ljbGUgb2YgYSBjb21wb25lbnQuXG4gKlxuICogRXZlbiBpZiBgdXNlTWVtb2AgaXMgcHJvdmlkZWQgYW4gZW1wdHkgYXJyYXkgYXMgaXRzIGZpbmFsIGFyZ3VtZW50LCBpdCBkb2Vzbid0IG9mZmVyXG4gKiBhIGd1YXJhbnRlZSB0aGF0IGl0IHdvbid0IHJlLXJ1biBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucyBsYXRlciBvbi4gQnkgdXNpbmcgYHVzZUNvbnN0YW50YFxuICogeW91IGNhbiBlbnN1cmUgdGhhdCBpbml0aWFsaXNlcnMgZG9uJ3QgZXhlY3V0ZSB0d2ljZSBvciBtb3JlLlxuICovXG5mdW5jdGlvbiB1c2VDb25zdGFudChpbml0KSB7XG4gICAgdmFyIHJlZiA9IHVzZVJlZihudWxsKTtcbiAgICBpZiAocmVmLmN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgcmVmLmN1cnJlbnQgPSBpbml0KCk7XG4gICAgfVxuICAgIHJldHVybiByZWYuY3VycmVudDtcbn1cblxuZXhwb3J0IHsgdXNlQ29uc3RhbnQgfTtcbiIsIi8qKlxuICogVGhpcyBzaG91bGQgb25seSBldmVyIGJlIG1vZGlmaWVkIG9uIHRoZSBjbGllbnQgb3RoZXJ3aXNlIGl0J2xsXG4gKiBwZXJzaXN0IHRocm91Z2ggc2VydmVyIHJlcXVlc3RzLiBJZiB3ZSBuZWVkIGluc3RhbmNlZCBzdGF0ZXMgd2VcbiAqIGNvdWxkIGxhenktaW5pdCB2aWEgcm9vdC5cbiAqL1xudmFyIGdsb2JhbFByb2plY3Rpb25TdGF0ZSA9IHtcbiAgICAvKipcbiAgICAgKiBHbG9iYWwgZmxhZyBhcyB0byB3aGV0aGVyIHRoZSB0cmVlIGhhcyBhbmltYXRlZCBzaW5jZSB0aGUgbGFzdCB0aW1lXG4gICAgICogd2UgcmVzaXplZCB0aGUgd2luZG93XG4gICAgICovXG4gICAgaGFzQW5pbWF0ZWRTaW5jZVJlc2l6ZTogdHJ1ZSxcbiAgICAvKipcbiAgICAgKiBXZSBzZXQgdGhpcyB0byB0cnVlIG9uY2UsIG9uIHRoZSBmaXJzdCB1cGRhdGUuIEFueSBub2RlcyBhZGRlZCB0byB0aGUgdHJlZSBiZXlvbmQgdGhhdFxuICAgICAqIHVwZGF0ZSB3aWxsIGJlIGdpdmVuIGEgYGRhdGEtcHJvamVjdGlvbi1pZGAgYXR0cmlidXRlLlxuICAgICAqL1xuICAgIGhhc0V2ZXJVcGRhdGVkOiBmYWxzZSxcbn07XG5cbmV4cG9ydCB7IGdsb2JhbFByb2plY3Rpb25TdGF0ZSB9O1xuIiwiaW1wb3J0IHsgdXNlQ29uc3RhbnQgfSBmcm9tICcuLi8uLi91dGlscy91c2UtY29uc3RhbnQubWpzJztcbmltcG9ydCB7IGdsb2JhbFByb2plY3Rpb25TdGF0ZSB9IGZyb20gJy4vc3RhdGUubWpzJztcblxudmFyIGlkID0gMTtcbmZ1bmN0aW9uIHVzZVByb2plY3Rpb25JZCgpIHtcbiAgICByZXR1cm4gdXNlQ29uc3RhbnQoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoZ2xvYmFsUHJvamVjdGlvblN0YXRlLmhhc0V2ZXJVcGRhdGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gaWQrKztcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG5leHBvcnQgeyB1c2VQcm9qZWN0aW9uSWQgfTtcbiIsImltcG9ydCB7IGNyZWF0ZUNvbnRleHQgfSBmcm9tICdyZWFjdCc7XG5cbnZhciBMYXlvdXRHcm91cENvbnRleHQgPSBjcmVhdGVDb250ZXh0KHt9KTtcblxuZXhwb3J0IHsgTGF5b3V0R3JvdXBDb250ZXh0IH07XG4iLCJpbXBvcnQgeyBjcmVhdGVDb250ZXh0IH0gZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIEludGVybmFsLCBleHBvcnRlZCBvbmx5IGZvciB1c2FnZSBpbiBGcmFtZXJcbiAqL1xudmFyIFN3aXRjaExheW91dEdyb3VwQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQoe30pO1xuXG5leHBvcnQgeyBTd2l0Y2hMYXlvdXRHcm91cENvbnRleHQgfTtcbiIsImltcG9ydCB7IGlzUmVmT2JqZWN0IH0gZnJvbSAnLi4vLi4vdXRpbHMvaXMtcmVmLW9iamVjdC5tanMnO1xuaW1wb3J0IHsgdXNlQ29udGV4dCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IFN3aXRjaExheW91dEdyb3VwQ29udGV4dCB9IGZyb20gJy4uLy4uL2NvbnRleHQvU3dpdGNoTGF5b3V0R3JvdXBDb250ZXh0Lm1qcyc7XG5cbmZ1bmN0aW9uIHVzZVByb2plY3Rpb24ocHJvamVjdGlvbklkLCBfYSwgdmlzdWFsRWxlbWVudCwgUHJvamVjdGlvbk5vZGVDb25zdHJ1Y3Rvcikge1xuICAgIHZhciBfYjtcbiAgICB2YXIgbGF5b3V0SWQgPSBfYS5sYXlvdXRJZCwgbGF5b3V0ID0gX2EubGF5b3V0LCBkcmFnID0gX2EuZHJhZywgZHJhZ0NvbnN0cmFpbnRzID0gX2EuZHJhZ0NvbnN0cmFpbnRzLCBsYXlvdXRTY3JvbGwgPSBfYS5sYXlvdXRTY3JvbGw7XG4gICAgdmFyIGluaXRpYWxQcm9tb3Rpb25Db25maWcgPSB1c2VDb250ZXh0KFN3aXRjaExheW91dEdyb3VwQ29udGV4dCk7XG4gICAgaWYgKCFQcm9qZWN0aW9uTm9kZUNvbnN0cnVjdG9yIHx8XG4gICAgICAgICF2aXN1YWxFbGVtZW50IHx8XG4gICAgICAgICh2aXN1YWxFbGVtZW50ID09PSBudWxsIHx8IHZpc3VhbEVsZW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZpc3VhbEVsZW1lbnQucHJvamVjdGlvbikpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2aXN1YWxFbGVtZW50LnByb2plY3Rpb24gPSBuZXcgUHJvamVjdGlvbk5vZGVDb25zdHJ1Y3Rvcihwcm9qZWN0aW9uSWQsIHZpc3VhbEVsZW1lbnQuZ2V0TGF0ZXN0VmFsdWVzKCksIChfYiA9IHZpc3VhbEVsZW1lbnQucGFyZW50KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IucHJvamVjdGlvbik7XG4gICAgdmlzdWFsRWxlbWVudC5wcm9qZWN0aW9uLnNldE9wdGlvbnMoe1xuICAgICAgICBsYXlvdXRJZDogbGF5b3V0SWQsXG4gICAgICAgIGxheW91dDogbGF5b3V0LFxuICAgICAgICBhbHdheXNNZWFzdXJlTGF5b3V0OiBCb29sZWFuKGRyYWcpIHx8IChkcmFnQ29uc3RyYWludHMgJiYgaXNSZWZPYmplY3QoZHJhZ0NvbnN0cmFpbnRzKSksXG4gICAgICAgIHZpc3VhbEVsZW1lbnQ6IHZpc3VhbEVsZW1lbnQsXG4gICAgICAgIHNjaGVkdWxlUmVuZGVyOiBmdW5jdGlvbiAoKSB7IHJldHVybiB2aXN1YWxFbGVtZW50LnNjaGVkdWxlUmVuZGVyKCk7IH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUT0RPOiBVcGRhdGUgb3B0aW9ucyBpbiBhbiBlZmZlY3QuIFRoaXMgY291bGQgYmUgdHJpY2t5IGFzIGl0J2xsIGJlIHRvbyBsYXRlXG4gICAgICAgICAqIHRvIHVwZGF0ZSBieSB0aGUgdGltZSBsYXlvdXQgYW5pbWF0aW9ucyBydW4uXG4gICAgICAgICAqIFdlIGFsc28gbmVlZCB0byBmaXggdGhpcyBzYWZlVG9SZW1vdmUgYnkgbGlua2luZyBpdCB1cCB0byB0aGUgb25lIHJldHVybmVkIGJ5IHVzZVByZXNlbmNlLFxuICAgICAgICAgKiBlbnN1cmluZyBpdCBnZXRzIGNhbGxlZCBpZiB0aGVyZSdzIG5vIHBvdGVudGlhbCBsYXlvdXQgYW5pbWF0aW9ucy5cbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGFuaW1hdGlvblR5cGU6IHR5cGVvZiBsYXlvdXQgPT09IFwic3RyaW5nXCIgPyBsYXlvdXQgOiBcImJvdGhcIixcbiAgICAgICAgaW5pdGlhbFByb21vdGlvbkNvbmZpZzogaW5pdGlhbFByb21vdGlvbkNvbmZpZyxcbiAgICAgICAgbGF5b3V0U2Nyb2xsOiBsYXlvdXRTY3JvbGwsXG4gICAgfSk7XG59XG5cbmV4cG9ydCB7IHVzZVByb2plY3Rpb24gfTtcbiIsImltcG9ydCB7IF9fZXh0ZW5kcyB9IGZyb20gJ3RzbGliJztcbmltcG9ydCBSZWFjdF9fZGVmYXVsdCBmcm9tICdyZWFjdCc7XG5cbnZhciBWaXN1YWxFbGVtZW50SGFuZGxlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoVmlzdWFsRWxlbWVudEhhbmRsZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gVmlzdWFsRWxlbWVudEhhbmRsZXIoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlIHZpc3VhbCBlbGVtZW50IHByb3BzIGFzIHNvb24gYXMgd2Uga25vdyB0aGlzIHVwZGF0ZSBpcyBnb2luZyB0byBiZSBjb21taXRlZC5cbiAgICAgKi9cbiAgICBWaXN1YWxFbGVtZW50SGFuZGxlci5wcm90b3R5cGUuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlUHJvcHMoKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBWaXN1YWxFbGVtZW50SGFuZGxlci5wcm90b3R5cGUuY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgIFZpc3VhbEVsZW1lbnRIYW5kbGVyLnByb3RvdHlwZS51cGRhdGVQcm9wcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5wcm9wcywgdmlzdWFsRWxlbWVudCA9IF9hLnZpc3VhbEVsZW1lbnQsIHByb3BzID0gX2EucHJvcHM7XG4gICAgICAgIGlmICh2aXN1YWxFbGVtZW50KVxuICAgICAgICAgICAgdmlzdWFsRWxlbWVudC5zZXRQcm9wcyhwcm9wcyk7XG4gICAgfTtcbiAgICBWaXN1YWxFbGVtZW50SGFuZGxlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5jaGlsZHJlbjtcbiAgICB9O1xuICAgIHJldHVybiBWaXN1YWxFbGVtZW50SGFuZGxlcjtcbn0oUmVhY3RfX2RlZmF1bHQuQ29tcG9uZW50KSk7XG5cbmV4cG9ydCB7IFZpc3VhbEVsZW1lbnRIYW5kbGVyIH07XG4iLCJpbXBvcnQgeyBfX2Fzc2lnbiB9IGZyb20gJ3RzbGliJztcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGZvcndhcmRSZWYsIHVzZUNvbnRleHQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VGZWF0dXJlcyB9IGZyb20gJy4vZmVhdHVyZXMvdXNlLWZlYXR1cmVzLm1qcyc7XG5pbXBvcnQgeyBNb3Rpb25Db25maWdDb250ZXh0IH0gZnJvbSAnLi4vY29udGV4dC9Nb3Rpb25Db25maWdDb250ZXh0Lm1qcyc7XG5pbXBvcnQgeyBNb3Rpb25Db250ZXh0IH0gZnJvbSAnLi4vY29udGV4dC9Nb3Rpb25Db250ZXh0L2luZGV4Lm1qcyc7XG5pbXBvcnQgeyB1c2VWaXN1YWxFbGVtZW50IH0gZnJvbSAnLi91dGlscy91c2UtdmlzdWFsLWVsZW1lbnQubWpzJztcbmltcG9ydCB7IHVzZU1vdGlvblJlZiB9IGZyb20gJy4vdXRpbHMvdXNlLW1vdGlvbi1yZWYubWpzJztcbmltcG9ydCB7IHVzZUNyZWF0ZU1vdGlvbkNvbnRleHQgfSBmcm9tICcuLi9jb250ZXh0L01vdGlvbkNvbnRleHQvY3JlYXRlLm1qcyc7XG5pbXBvcnQgeyBsb2FkRmVhdHVyZXMsIGZlYXR1cmVEZWZpbml0aW9ucyB9IGZyb20gJy4vZmVhdHVyZXMvZGVmaW5pdGlvbnMubWpzJztcbmltcG9ydCB7IGlzQnJvd3NlciB9IGZyb20gJy4uL3V0aWxzL2lzLWJyb3dzZXIubWpzJztcbmltcG9ydCB7IHVzZVByb2plY3Rpb25JZCB9IGZyb20gJy4uL3Byb2plY3Rpb24vbm9kZS9pZC5tanMnO1xuaW1wb3J0IHsgTGF5b3V0R3JvdXBDb250ZXh0IH0gZnJvbSAnLi4vY29udGV4dC9MYXlvdXRHcm91cENvbnRleHQubWpzJztcbmltcG9ydCB7IHVzZVByb2plY3Rpb24gfSBmcm9tICcuL2ZlYXR1cmVzL3VzZS1wcm9qZWN0aW9uLm1qcyc7XG5pbXBvcnQgeyBWaXN1YWxFbGVtZW50SGFuZGxlciB9IGZyb20gJy4vdXRpbHMvVmlzdWFsRWxlbWVudEhhbmRsZXIubWpzJztcblxuLyoqXG4gKiBDcmVhdGUgYSBgbW90aW9uYCBjb21wb25lbnQuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBhY2NlcHRzIGEgQ29tcG9uZW50IGFyZ3VtZW50LCB3aGljaCBjYW4gYmUgZWl0aGVyIGEgc3RyaW5nIChpZSBcImRpdlwiXG4gKiBmb3IgYG1vdGlvbi5kaXZgKSwgb3IgYW4gYWN0dWFsIFJlYWN0IGNvbXBvbmVudC5cbiAqXG4gKiBBbG9uZ3NpZGUgdGhpcyBpcyBhIGNvbmZpZyBvcHRpb24gd2hpY2ggcHJvdmlkZXMgYSB3YXkgb2YgcmVuZGVyaW5nIHRoZSBwcm92aWRlZFxuICogY29tcG9uZW50IFwib2ZmbGluZVwiLCBvciBvdXRzaWRlIHRoZSBSZWFjdCByZW5kZXIgY3ljbGUuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU1vdGlvbkNvbXBvbmVudChfYSkge1xuICAgIHZhciBwcmVsb2FkZWRGZWF0dXJlcyA9IF9hLnByZWxvYWRlZEZlYXR1cmVzLCBjcmVhdGVWaXN1YWxFbGVtZW50ID0gX2EuY3JlYXRlVmlzdWFsRWxlbWVudCwgcHJvamVjdGlvbk5vZGVDb25zdHJ1Y3RvciA9IF9hLnByb2plY3Rpb25Ob2RlQ29uc3RydWN0b3IsIHVzZVJlbmRlciA9IF9hLnVzZVJlbmRlciwgdXNlVmlzdWFsU3RhdGUgPSBfYS51c2VWaXN1YWxTdGF0ZSwgQ29tcG9uZW50ID0gX2EuQ29tcG9uZW50O1xuICAgIHByZWxvYWRlZEZlYXR1cmVzICYmIGxvYWRGZWF0dXJlcyhwcmVsb2FkZWRGZWF0dXJlcyk7XG4gICAgZnVuY3Rpb24gTW90aW9uQ29tcG9uZW50KHByb3BzLCBleHRlcm5hbFJlZikge1xuICAgICAgICB2YXIgbGF5b3V0SWQgPSB1c2VMYXlvdXRJZChwcm9wcyk7XG4gICAgICAgIHByb3BzID0gX19hc3NpZ24oX19hc3NpZ24oe30sIHByb3BzKSwgeyBsYXlvdXRJZDogbGF5b3V0SWQgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB3ZSdyZSByZW5kZXJpbmcgaW4gYSBzdGF0aWMgZW52aXJvbm1lbnQsIHdlIG9ubHkgdmlzdWFsbHkgdXBkYXRlIHRoZSBjb21wb25lbnRcbiAgICAgICAgICogYXMgYSByZXN1bHQgb2YgYSBSZWFjdC1yZXJlbmRlciByYXRoZXIgdGhhbiBpbnRlcmFjdGlvbnMgb3IgYW5pbWF0aW9ucy4gVGhpc1xuICAgICAgICAgKiBtZWFucyB3ZSBkb24ndCBuZWVkIHRvIGxvYWQgYWRkaXRpb25hbCBtZW1vcnkgc3RydWN0dXJlcyBsaWtlIFZpc3VhbEVsZW1lbnQsXG4gICAgICAgICAqIG9yIGFueSBnZXN0dXJlL2FuaW1hdGlvbiBmZWF0dXJlcy5cbiAgICAgICAgICovXG4gICAgICAgIHZhciBjb25maWcgPSB1c2VDb250ZXh0KE1vdGlvbkNvbmZpZ0NvbnRleHQpO1xuICAgICAgICB2YXIgZmVhdHVyZXMgPSBudWxsO1xuICAgICAgICB2YXIgY29udGV4dCA9IHVzZUNyZWF0ZU1vdGlvbkNvbnRleHQocHJvcHMpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGEgdW5pcXVlIHByb2plY3Rpb24gSUQgZm9yIHRoaXMgY29tcG9uZW50LiBJZiBhIG5ldyBjb21wb25lbnQgaXMgYWRkZWRcbiAgICAgICAgICogZHVyaW5nIGEgbGF5b3V0IGFuaW1hdGlvbiB3ZSdsbCB1c2UgdGhpcyB0byBxdWVyeSB0aGUgRE9NIGFuZCBoeWRyYXRlIGl0cyByZWYgZWFybHksIGFsbG93aW5nXG4gICAgICAgICAqIHVzIHRvIG1lYXN1cmUgaXQgYXMgc29vbiBhcyBhbnkgbGF5b3V0IGVmZmVjdCBmbHVzaGVzIHBlbmRpbmcgbGF5b3V0IGFuaW1hdGlvbnMuXG4gICAgICAgICAqXG4gICAgICAgICAqIFBlcmZvcm1hbmNlIG5vdGU6IEl0J2QgYmUgYmV0dGVyIG5vdCB0byBoYXZlIHRvIHNlYXJjaCB0aGUgRE9NIGZvciB0aGVzZSBlbGVtZW50cy5cbiAgICAgICAgICogRm9yIG5ld2x5LWVudGVyaW5nIGNvbXBvbmVudHMgaXQgY291bGQgYmUgZW5vdWdoIHRvIG9ubHkgY29ycmVjdCB0cmVlU2NhbGUsIGluIHdoaWNoXG4gICAgICAgICAqIGNhc2Ugd2UgY291bGQgbW91bnQgaW4gYSBzY2FsZS1jb3JyZWN0aW9uIG1vZGUuIFRoaXMgd291bGRuJ3QgYmUgZW5vdWdoIGZvclxuICAgICAgICAgKiBzaGFyZWQgZWxlbWVudCB0cmFuc2l0aW9ucyBob3dldmVyLiBQZXJoYXBzIGZvciB0aG9zZSB3ZSBjb3VsZCByZXZlcnQgdG8gYSByb290IG5vZGVcbiAgICAgICAgICogdGhhdCBnZXRzIGZvcmNlUmVuZGVyZWQgYW5kIGxheW91dCBhbmltYXRpb25zIGFyZSB0cmlnZ2VyZWQgb24gaXRzIGxheW91dCBlZmZlY3QuXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgcHJvamVjdGlvbklkID0gY29uZmlnLmlzU3RhdGljID8gdW5kZWZpbmVkIDogdXNlUHJvamVjdGlvbklkKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIHZpc3VhbFN0YXRlID0gdXNlVmlzdWFsU3RhdGUocHJvcHMsIGNvbmZpZy5pc1N0YXRpYyk7XG4gICAgICAgIGlmICghY29uZmlnLmlzU3RhdGljICYmIGlzQnJvd3Nlcikge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDcmVhdGUgYSBWaXN1YWxFbGVtZW50IGZvciB0aGlzIGNvbXBvbmVudC4gQSBWaXN1YWxFbGVtZW50IHByb3ZpZGVzIGEgY29tbW9uXG4gICAgICAgICAgICAgKiBpbnRlcmZhY2UgdG8gcmVuZGVyZXItc3BlY2lmaWMgQVBJcyAoaWUgRE9NL1RocmVlLmpzIGV0YykgYXMgd2VsbCBhc1xuICAgICAgICAgICAgICogcHJvdmlkaW5nIGEgd2F5IG9mIHJlbmRlcmluZyB0byB0aGVzZSBBUElzIG91dHNpZGUgb2YgdGhlIFJlYWN0IHJlbmRlciBsb29wXG4gICAgICAgICAgICAgKiBmb3IgbW9yZSBwZXJmb3JtYW50IGFuaW1hdGlvbnMgYW5kIGludGVyYWN0aW9uc1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjb250ZXh0LnZpc3VhbEVsZW1lbnQgPSB1c2VWaXN1YWxFbGVtZW50KENvbXBvbmVudCwgdmlzdWFsU3RhdGUsIF9fYXNzaWduKF9fYXNzaWduKHt9LCBjb25maWcpLCBwcm9wcyksIGNyZWF0ZVZpc3VhbEVsZW1lbnQpO1xuICAgICAgICAgICAgdXNlUHJvamVjdGlvbihwcm9qZWN0aW9uSWQsIHByb3BzLCBjb250ZXh0LnZpc3VhbEVsZW1lbnQsIHByb2plY3Rpb25Ob2RlQ29uc3RydWN0b3IgfHxcbiAgICAgICAgICAgICAgICBmZWF0dXJlRGVmaW5pdGlvbnMucHJvamVjdGlvbk5vZGVDb25zdHJ1Y3Rvcik7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIExvYWQgTW90aW9uIGdlc3R1cmUgYW5kIGFuaW1hdGlvbiBmZWF0dXJlcy4gVGhlc2UgYXJlIHJlbmRlcmVkIGFzIHJlbmRlcmxlc3NcbiAgICAgICAgICAgICAqIGNvbXBvbmVudHMgc28gZWFjaCBmZWF0dXJlIGNhbiBvcHRpb25hbGx5IG1ha2UgdXNlIG9mIFJlYWN0IGxpZmVjeWNsZSBtZXRob2RzLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmZWF0dXJlcyA9IHVzZUZlYXR1cmVzKHByb3BzLCBjb250ZXh0LnZpc3VhbEVsZW1lbnQsIHByZWxvYWRlZEZlYXR1cmVzKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIG1vdW50IG9yZGVyIGFuZCBoaWVyYXJjaHkgaXMgc3BlY2lmaWMgdG8gZW5zdXJlIG91ciBlbGVtZW50IHJlZlxuICAgICAgICAgKiBpcyBoeWRyYXRlZCBieSB0aGUgdGltZSBmZWF0dXJlcyBmaXJlIHRoZWlyIGVmZmVjdHMuXG4gICAgICAgICAqL1xuICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoVmlzdWFsRWxlbWVudEhhbmRsZXIsIHsgdmlzdWFsRWxlbWVudDogY29udGV4dC52aXN1YWxFbGVtZW50LCBwcm9wczogX19hc3NpZ24oX19hc3NpZ24oe30sIGNvbmZpZyksIHByb3BzKSB9LFxuICAgICAgICAgICAgZmVhdHVyZXMsXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KE1vdGlvbkNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IGNvbnRleHQgfSwgdXNlUmVuZGVyKENvbXBvbmVudCwgcHJvcHMsIHByb2plY3Rpb25JZCwgdXNlTW90aW9uUmVmKHZpc3VhbFN0YXRlLCBjb250ZXh0LnZpc3VhbEVsZW1lbnQsIGV4dGVybmFsUmVmKSwgdmlzdWFsU3RhdGUsIGNvbmZpZy5pc1N0YXRpYywgY29udGV4dC52aXN1YWxFbGVtZW50KSkpKTtcbiAgICB9XG4gICAgcmV0dXJuIGZvcndhcmRSZWYoTW90aW9uQ29tcG9uZW50KTtcbn1cbmZ1bmN0aW9uIHVzZUxheW91dElkKF9hKSB7XG4gICAgdmFyIF9iO1xuICAgIHZhciBsYXlvdXRJZCA9IF9hLmxheW91dElkO1xuICAgIHZhciBsYXlvdXRHcm91cElkID0gKF9iID0gdXNlQ29udGV4dChMYXlvdXRHcm91cENvbnRleHQpKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuaWQ7XG4gICAgcmV0dXJuIGxheW91dEdyb3VwSWQgJiYgbGF5b3V0SWQgIT09IHVuZGVmaW5lZFxuICAgICAgICA/IGxheW91dEdyb3VwSWQgKyBcIi1cIiArIGxheW91dElkXG4gICAgICAgIDogbGF5b3V0SWQ7XG59XG5cbmV4cG9ydCB7IGNyZWF0ZU1vdGlvbkNvbXBvbmVudCB9O1xuIiwiaW1wb3J0IHsgY3JlYXRlTW90aW9uQ29tcG9uZW50IH0gZnJvbSAnLi4vLi4vbW90aW9uL2luZGV4Lm1qcyc7XG5cbi8qKlxuICogQ29udmVydCBhbnkgUmVhY3QgY29tcG9uZW50IGludG8gYSBgbW90aW9uYCBjb21wb25lbnQuIFRoZSBwcm92aWRlZCBjb21wb25lbnRcbiAqICoqbXVzdCoqIHVzZSBgUmVhY3QuZm9yd2FyZFJlZmAgdG8gdGhlIHVuZGVybHlpbmcgRE9NIGNvbXBvbmVudCB5b3Ugd2FudCB0byBhbmltYXRlLlxuICpcbiAqIGBgYGpzeFxuICogY29uc3QgQ29tcG9uZW50ID0gUmVhY3QuZm9yd2FyZFJlZigocHJvcHMsIHJlZikgPT4ge1xuICogICByZXR1cm4gPGRpdiByZWY9e3JlZn0gLz5cbiAqIH0pXG4gKlxuICogY29uc3QgTW90aW9uQ29tcG9uZW50ID0gbW90aW9uKENvbXBvbmVudClcbiAqIGBgYFxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gY3JlYXRlTW90aW9uUHJveHkoY3JlYXRlQ29uZmlnKSB7XG4gICAgZnVuY3Rpb24gY3VzdG9tKENvbXBvbmVudCwgY3VzdG9tTW90aW9uQ29tcG9uZW50Q29uZmlnKSB7XG4gICAgICAgIGlmIChjdXN0b21Nb3Rpb25Db21wb25lbnRDb25maWcgPT09IHZvaWQgMCkgeyBjdXN0b21Nb3Rpb25Db21wb25lbnRDb25maWcgPSB7fTsgfVxuICAgICAgICByZXR1cm4gY3JlYXRlTW90aW9uQ29tcG9uZW50KGNyZWF0ZUNvbmZpZyhDb21wb25lbnQsIGN1c3RvbU1vdGlvbkNvbXBvbmVudENvbmZpZykpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIFByb3h5ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHJldHVybiBjdXN0b207XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgY2FjaGUgb2YgZ2VuZXJhdGVkIGBtb3Rpb25gIGNvbXBvbmVudHMsIGUuZyBgbW90aW9uLmRpdmAsIGBtb3Rpb24uaW5wdXRgIGV0Yy5cbiAgICAgKiBSYXRoZXIgdGhhbiBnZW5lcmF0aW5nIHRoZW0gYW5ldyBldmVyeSByZW5kZXIuXG4gICAgICovXG4gICAgdmFyIGNvbXBvbmVudENhY2hlID0gbmV3IE1hcCgpO1xuICAgIHJldHVybiBuZXcgUHJveHkoY3VzdG9tLCB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxsZWQgd2hlbiBgbW90aW9uYCBpcyByZWZlcmVuY2VkIHdpdGggYSBwcm9wOiBgbW90aW9uLmRpdmAsIGBtb3Rpb24uaW5wdXRgIGV0Yy5cbiAgICAgICAgICogVGhlIHByb3AgbmFtZSBpcyBwYXNzZWQgdGhyb3VnaCBhcyBga2V5YCBhbmQgd2UgY2FuIHVzZSB0aGF0IHRvIGdlbmVyYXRlIGEgYG1vdGlvbmBcbiAgICAgICAgICogRE9NIGNvbXBvbmVudCB3aXRoIHRoYXQgbmFtZS5cbiAgICAgICAgICovXG4gICAgICAgIGdldDogZnVuY3Rpb24gKF90YXJnZXQsIGtleSkge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJZiB0aGlzIGVsZW1lbnQgZG9lc24ndCBleGlzdCBpbiB0aGUgY29tcG9uZW50IGNhY2hlLCBjcmVhdGUgaXQgYW5kIGNhY2hlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoIWNvbXBvbmVudENhY2hlLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50Q2FjaGUuc2V0KGtleSwgY3VzdG9tKGtleSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvbXBvbmVudENhY2hlLmdldChrZXkpO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuXG5leHBvcnQgeyBjcmVhdGVNb3Rpb25Qcm94eSB9O1xuIiwiLyoqXG4gKiBXZSBrZWVwIHRoZXNlIGxpc3RlZCBzZXBlcmF0ZWx5IGFzIHdlIHVzZSB0aGUgbG93ZXJjYXNlIHRhZyBuYW1lcyBhcyBwYXJ0XG4gKiBvZiB0aGUgcnVudGltZSBidW5kbGUgdG8gZGV0ZWN0IFNWRyBjb21wb25lbnRzXG4gKi9cbnZhciBsb3dlcmNhc2VTVkdFbGVtZW50cyA9IFtcbiAgICBcImFuaW1hdGVcIixcbiAgICBcImNpcmNsZVwiLFxuICAgIFwiZGVmc1wiLFxuICAgIFwiZGVzY1wiLFxuICAgIFwiZWxsaXBzZVwiLFxuICAgIFwiZ1wiLFxuICAgIFwiaW1hZ2VcIixcbiAgICBcImxpbmVcIixcbiAgICBcImZpbHRlclwiLFxuICAgIFwibWFya2VyXCIsXG4gICAgXCJtYXNrXCIsXG4gICAgXCJtZXRhZGF0YVwiLFxuICAgIFwicGF0aFwiLFxuICAgIFwicGF0dGVyblwiLFxuICAgIFwicG9seWdvblwiLFxuICAgIFwicG9seWxpbmVcIixcbiAgICBcInJlY3RcIixcbiAgICBcInN0b3BcIixcbiAgICBcInN2Z1wiLFxuICAgIFwic3dpdGNoXCIsXG4gICAgXCJzeW1ib2xcIixcbiAgICBcInRleHRcIixcbiAgICBcInRzcGFuXCIsXG4gICAgXCJ1c2VcIixcbiAgICBcInZpZXdcIixcbl07XG5cbmV4cG9ydCB7IGxvd2VyY2FzZVNWR0VsZW1lbnRzIH07XG4iLCJpbXBvcnQgeyBsb3dlcmNhc2VTVkdFbGVtZW50cyB9IGZyb20gJy4uLy4uL3N2Zy9sb3dlcmNhc2UtZWxlbWVudHMubWpzJztcblxuZnVuY3Rpb24gaXNTVkdDb21wb25lbnQoQ29tcG9uZW50KSB7XG4gICAgaWYgKFxuICAgIC8qKlxuICAgICAqIElmIGl0J3Mgbm90IGEgc3RyaW5nLCBpdCdzIGEgY3VzdG9tIFJlYWN0IGNvbXBvbmVudC4gQ3VycmVudGx5IHdlIG9ubHkgc3VwcG9ydFxuICAgICAqIEhUTUwgY3VzdG9tIFJlYWN0IGNvbXBvbmVudHMuXG4gICAgICovXG4gICAgdHlwZW9mIENvbXBvbmVudCAhPT0gXCJzdHJpbmdcIiB8fFxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgaXQgY29udGFpbnMgYSBkYXNoLCB0aGUgZWxlbWVudCBpcyBhIGN1c3RvbSBIVE1MIHdlYmNvbXBvbmVudC5cbiAgICAgICAgICovXG4gICAgICAgIENvbXBvbmVudC5pbmNsdWRlcyhcIi1cIikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBlbHNlIGlmIChcbiAgICAvKipcbiAgICAgKiBJZiBpdCdzIGluIG91ciBsaXN0IG9mIGxvd2VyY2FzZSBTVkcgdGFncywgaXQncyBhbiBTVkcgY29tcG9uZW50XG4gICAgICovXG4gICAgbG93ZXJjYXNlU1ZHRWxlbWVudHMuaW5kZXhPZihDb21wb25lbnQpID4gLTEgfHxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIGl0IGNvbnRhaW5zIGEgY2FwaXRhbCBsZXR0ZXIsIGl0J3MgYW4gU1ZHIGNvbXBvbmVudFxuICAgICAgICAgKi9cbiAgICAgICAgL1tBLVpdLy50ZXN0KENvbXBvbmVudCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IHsgaXNTVkdDb21wb25lbnQgfTtcbiIsInZhciBzY2FsZUNvcnJlY3RvcnMgPSB7fTtcbmZ1bmN0aW9uIGFkZFNjYWxlQ29ycmVjdG9yKGNvcnJlY3RvcnMpIHtcbiAgICBPYmplY3QuYXNzaWduKHNjYWxlQ29ycmVjdG9ycywgY29ycmVjdG9ycyk7XG59XG5cbmV4cG9ydCB7IGFkZFNjYWxlQ29ycmVjdG9yLCBzY2FsZUNvcnJlY3RvcnMgfTtcbiIsIi8qKlxuICogQSBsaXN0IG9mIGFsbCB0cmFuc2Zvcm1hYmxlIGF4ZXMuIFdlJ2xsIHVzZSB0aGlzIGxpc3QgdG8gZ2VuZXJhdGVkIGEgdmVyc2lvblxuICogb2YgZWFjaCBheGVzIGZvciBlYWNoIHRyYW5zZm9ybS5cbiAqL1xudmFyIHRyYW5zZm9ybUF4ZXMgPSBbXCJcIiwgXCJYXCIsIFwiWVwiLCBcIlpcIl07XG4vKipcbiAqIEFuIG9yZGVyZWQgYXJyYXkgb2YgZWFjaCB0cmFuc2Zvcm1hYmxlIHZhbHVlLiBCeSBkZWZhdWx0LCB0cmFuc2Zvcm0gdmFsdWVzXG4gKiB3aWxsIGJlIHNvcnRlZCB0byB0aGlzIG9yZGVyLlxuICovXG52YXIgb3JkZXIgPSBbXCJ0cmFuc2xhdGVcIiwgXCJzY2FsZVwiLCBcInJvdGF0ZVwiLCBcInNrZXdcIl07XG4vKipcbiAqIEdlbmVyYXRlIGEgbGlzdCBvZiBldmVyeSBwb3NzaWJsZSB0cmFuc2Zvcm0ga2V5LlxuICovXG52YXIgdHJhbnNmb3JtUHJvcHMgPSBbXCJ0cmFuc2Zvcm1QZXJzcGVjdGl2ZVwiLCBcInhcIiwgXCJ5XCIsIFwielwiXTtcbm9yZGVyLmZvckVhY2goZnVuY3Rpb24gKG9wZXJhdGlvbktleSkge1xuICAgIHJldHVybiB0cmFuc2Zvcm1BeGVzLmZvckVhY2goZnVuY3Rpb24gKGF4ZXNLZXkpIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybVByb3BzLnB1c2gob3BlcmF0aW9uS2V5ICsgYXhlc0tleSk7XG4gICAgfSk7XG59KTtcbi8qKlxuICogQSBmdW5jdGlvbiB0byB1c2Ugd2l0aCBBcnJheS5zb3J0IHRvIHNvcnQgdHJhbnNmb3JtIGtleXMgYnkgdGhlaXIgZGVmYXVsdCBvcmRlci5cbiAqL1xuZnVuY3Rpb24gc29ydFRyYW5zZm9ybVByb3BzKGEsIGIpIHtcbiAgICByZXR1cm4gdHJhbnNmb3JtUHJvcHMuaW5kZXhPZihhKSAtIHRyYW5zZm9ybVByb3BzLmluZGV4T2YoYik7XG59XG4vKipcbiAqIEEgcXVpY2sgbG9va3VwIGZvciB0cmFuc2Zvcm0gcHJvcHMuXG4gKi9cbnZhciB0cmFuc2Zvcm1Qcm9wU2V0ID0gbmV3IFNldCh0cmFuc2Zvcm1Qcm9wcyk7XG5mdW5jdGlvbiBpc1RyYW5zZm9ybVByb3Aoa2V5KSB7XG4gICAgcmV0dXJuIHRyYW5zZm9ybVByb3BTZXQuaGFzKGtleSk7XG59XG4vKipcbiAqIEEgcXVpY2sgbG9va3VwIGZvciB0cmFuc2Zvcm0gb3JpZ2luIHByb3BzXG4gKi9cbnZhciB0cmFuc2Zvcm1PcmlnaW5Qcm9wcyA9IG5ldyBTZXQoW1wib3JpZ2luWFwiLCBcIm9yaWdpbllcIiwgXCJvcmlnaW5aXCJdKTtcbmZ1bmN0aW9uIGlzVHJhbnNmb3JtT3JpZ2luUHJvcChrZXkpIHtcbiAgICByZXR1cm4gdHJhbnNmb3JtT3JpZ2luUHJvcHMuaGFzKGtleSk7XG59XG5cbmV4cG9ydCB7IGlzVHJhbnNmb3JtT3JpZ2luUHJvcCwgaXNUcmFuc2Zvcm1Qcm9wLCBzb3J0VHJhbnNmb3JtUHJvcHMsIHRyYW5zZm9ybUF4ZXMsIHRyYW5zZm9ybVByb3BzIH07XG4iLCJpbXBvcnQgeyBzY2FsZUNvcnJlY3RvcnMgfSBmcm9tICcuLi8uLi9wcm9qZWN0aW9uL3N0eWxlcy9zY2FsZS1jb3JyZWN0aW9uLm1qcyc7XG5pbXBvcnQgeyBpc1RyYW5zZm9ybVByb3AsIGlzVHJhbnNmb3JtT3JpZ2luUHJvcCB9IGZyb20gJy4uLy4uL3JlbmRlci9odG1sL3V0aWxzL3RyYW5zZm9ybS5tanMnO1xuXG5mdW5jdGlvbiBpc0ZvcmNlZE1vdGlvblZhbHVlKGtleSwgX2EpIHtcbiAgICB2YXIgbGF5b3V0ID0gX2EubGF5b3V0LCBsYXlvdXRJZCA9IF9hLmxheW91dElkO1xuICAgIHJldHVybiAoaXNUcmFuc2Zvcm1Qcm9wKGtleSkgfHxcbiAgICAgICAgaXNUcmFuc2Zvcm1PcmlnaW5Qcm9wKGtleSkgfHxcbiAgICAgICAgKChsYXlvdXQgfHwgbGF5b3V0SWQgIT09IHVuZGVmaW5lZCkgJiZcbiAgICAgICAgICAgICghIXNjYWxlQ29ycmVjdG9yc1trZXldIHx8IGtleSA9PT0gXCJvcGFjaXR5XCIpKSk7XG59XG5cbmV4cG9ydCB7IGlzRm9yY2VkTW90aW9uVmFsdWUgfTtcbiIsInZhciBpc01vdGlvblZhbHVlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4odmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIHZhbHVlLmdldFZlbG9jaXR5KTtcbn07XG5cbmV4cG9ydCB7IGlzTW90aW9uVmFsdWUgfTtcbiIsImltcG9ydCB7IHNvcnRUcmFuc2Zvcm1Qcm9wcyB9IGZyb20gJy4vdHJhbnNmb3JtLm1qcyc7XG5cbnZhciB0cmFuc2xhdGVBbGlhcyA9IHtcbiAgICB4OiBcInRyYW5zbGF0ZVhcIixcbiAgICB5OiBcInRyYW5zbGF0ZVlcIixcbiAgICB6OiBcInRyYW5zbGF0ZVpcIixcbiAgICB0cmFuc2Zvcm1QZXJzcGVjdGl2ZTogXCJwZXJzcGVjdGl2ZVwiLFxufTtcbi8qKlxuICogQnVpbGQgYSBDU1MgdHJhbnNmb3JtIHN0eWxlIGZyb20gaW5kaXZpZHVhbCB4L3kvc2NhbGUgZXRjIHByb3BlcnRpZXMuXG4gKlxuICogVGhpcyBvdXRwdXRzIHdpdGggYSBkZWZhdWx0IG9yZGVyIG9mIHRyYW5zZm9ybXMvc2NhbGVzL3JvdGF0aW9ucywgdGhpcyBjYW4gYmUgY3VzdG9taXNlZCBieVxuICogcHJvdmlkaW5nIGEgdHJhbnNmb3JtVGVtcGxhdGUgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkVHJhbnNmb3JtKF9hLCBfYiwgdHJhbnNmb3JtSXNEZWZhdWx0LCB0cmFuc2Zvcm1UZW1wbGF0ZSkge1xuICAgIHZhciB0cmFuc2Zvcm0gPSBfYS50cmFuc2Zvcm0sIHRyYW5zZm9ybUtleXMgPSBfYS50cmFuc2Zvcm1LZXlzO1xuICAgIHZhciBfYyA9IF9iLmVuYWJsZUhhcmR3YXJlQWNjZWxlcmF0aW9uLCBlbmFibGVIYXJkd2FyZUFjY2VsZXJhdGlvbiA9IF9jID09PSB2b2lkIDAgPyB0cnVlIDogX2MsIF9kID0gX2IuYWxsb3dUcmFuc2Zvcm1Ob25lLCBhbGxvd1RyYW5zZm9ybU5vbmUgPSBfZCA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9kO1xuICAgIC8vIFRoZSB0cmFuc2Zvcm0gc3RyaW5nIHdlJ3JlIGdvaW5nIHRvIGJ1aWxkIGludG8uXG4gICAgdmFyIHRyYW5zZm9ybVN0cmluZyA9IFwiXCI7XG4gICAgLy8gVHJhbnNmb3JtIGtleXMgaW50byB0aGVpciBkZWZhdWx0IG9yZGVyIC0gdGhpcyB3aWxsIGRldGVybWluZSB0aGUgb3V0cHV0IG9yZGVyLlxuICAgIHRyYW5zZm9ybUtleXMuc29ydChzb3J0VHJhbnNmb3JtUHJvcHMpO1xuICAgIC8vIFRyYWNrIHdoZXRoZXIgdGhlIGRlZmluZWQgdHJhbnNmb3JtIGhhcyBhIGRlZmluZWQgeiBzbyB3ZSBkb24ndCBhZGQgYVxuICAgIC8vIHNlY29uZCB0byBlbmFibGUgaGFyZHdhcmUgYWNjZWxlcmF0aW9uXG4gICAgdmFyIHRyYW5zZm9ybUhhc1ogPSBmYWxzZTtcbiAgICAvLyBMb29wIG92ZXIgZWFjaCB0cmFuc2Zvcm0gYW5kIGJ1aWxkIHRoZW0gaW50byB0cmFuc2Zvcm1TdHJpbmdcbiAgICB2YXIgbnVtVHJhbnNmb3JtS2V5cyA9IHRyYW5zZm9ybUtleXMubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtVHJhbnNmb3JtS2V5czsgaSsrKSB7XG4gICAgICAgIHZhciBrZXkgPSB0cmFuc2Zvcm1LZXlzW2ldO1xuICAgICAgICB0cmFuc2Zvcm1TdHJpbmcgKz0gXCJcIi5jb25jYXQodHJhbnNsYXRlQWxpYXNba2V5XSB8fCBrZXksIFwiKFwiKS5jb25jYXQodHJhbnNmb3JtW2tleV0sIFwiKSBcIik7XG4gICAgICAgIGlmIChrZXkgPT09IFwielwiKVxuICAgICAgICAgICAgdHJhbnNmb3JtSGFzWiA9IHRydWU7XG4gICAgfVxuICAgIGlmICghdHJhbnNmb3JtSGFzWiAmJiBlbmFibGVIYXJkd2FyZUFjY2VsZXJhdGlvbikge1xuICAgICAgICB0cmFuc2Zvcm1TdHJpbmcgKz0gXCJ0cmFuc2xhdGVaKDApXCI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0cmFuc2Zvcm1TdHJpbmcgPSB0cmFuc2Zvcm1TdHJpbmcudHJpbSgpO1xuICAgIH1cbiAgICAvLyBJZiB3ZSBoYXZlIGEgY3VzdG9tIGB0cmFuc2Zvcm1gIHRlbXBsYXRlLCBwYXNzIG91ciB0cmFuc2Zvcm0gdmFsdWVzIGFuZFxuICAgIC8vIGdlbmVyYXRlZCB0cmFuc2Zvcm1TdHJpbmcgdG8gdGhhdCBiZWZvcmUgcmV0dXJuaW5nXG4gICAgaWYgKHRyYW5zZm9ybVRlbXBsYXRlKSB7XG4gICAgICAgIHRyYW5zZm9ybVN0cmluZyA9IHRyYW5zZm9ybVRlbXBsYXRlKHRyYW5zZm9ybSwgdHJhbnNmb3JtSXNEZWZhdWx0ID8gXCJcIiA6IHRyYW5zZm9ybVN0cmluZyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGFsbG93VHJhbnNmb3JtTm9uZSAmJiB0cmFuc2Zvcm1Jc0RlZmF1bHQpIHtcbiAgICAgICAgdHJhbnNmb3JtU3RyaW5nID0gXCJub25lXCI7XG4gICAgfVxuICAgIHJldHVybiB0cmFuc2Zvcm1TdHJpbmc7XG59XG4vKipcbiAqIEJ1aWxkIGEgdHJhbnNmb3JtT3JpZ2luIHN0eWxlLiBVc2VzIHRoZSBzYW1lIGRlZmF1bHRzIGFzIHRoZSBicm93c2VyIGZvclxuICogdW5kZWZpbmVkIG9yaWdpbnMuXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkVHJhbnNmb3JtT3JpZ2luKF9hKSB7XG4gICAgdmFyIF9iID0gX2Eub3JpZ2luWCwgb3JpZ2luWCA9IF9iID09PSB2b2lkIDAgPyBcIjUwJVwiIDogX2IsIF9jID0gX2Eub3JpZ2luWSwgb3JpZ2luWSA9IF9jID09PSB2b2lkIDAgPyBcIjUwJVwiIDogX2MsIF9kID0gX2Eub3JpZ2luWiwgb3JpZ2luWiA9IF9kID09PSB2b2lkIDAgPyAwIDogX2Q7XG4gICAgcmV0dXJuIFwiXCIuY29uY2F0KG9yaWdpblgsIFwiIFwiKS5jb25jYXQob3JpZ2luWSwgXCIgXCIpLmNvbmNhdChvcmlnaW5aKTtcbn1cblxuZXhwb3J0IHsgYnVpbGRUcmFuc2Zvcm0sIGJ1aWxkVHJhbnNmb3JtT3JpZ2luIH07XG4iLCIvKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcHJvdmlkZWQga2V5IGlzIGEgQ1NTIHZhcmlhYmxlXG4gKi9cbmZ1bmN0aW9uIGlzQ1NTVmFyaWFibGUoa2V5KSB7XG4gICAgcmV0dXJuIGtleS5zdGFydHNXaXRoKFwiLS1cIik7XG59XG5cbmV4cG9ydCB7IGlzQ1NTVmFyaWFibGUgfTtcbiIsIi8qKlxuICogUHJvdmlkZWQgYSB2YWx1ZSBhbmQgYSBWYWx1ZVR5cGUsIHJldHVybnMgdGhlIHZhbHVlIGFzIHRoYXQgdmFsdWUgdHlwZS5cbiAqL1xudmFyIGdldFZhbHVlQXNUeXBlID0gZnVuY3Rpb24gKHZhbHVlLCB0eXBlKSB7XG4gICAgcmV0dXJuIHR5cGUgJiYgdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiXG4gICAgICAgID8gdHlwZS50cmFuc2Zvcm0odmFsdWUpXG4gICAgICAgIDogdmFsdWU7XG59O1xuXG5leHBvcnQgeyBnZXRWYWx1ZUFzVHlwZSB9O1xuIiwiY29uc3QgY2xhbXAgPSAobWluLCBtYXgpID0+ICh2KSA9PiBNYXRoLm1heChNYXRoLm1pbih2LCBtYXgpLCBtaW4pO1xuY29uc3Qgc2FuaXRpemUgPSAodikgPT4gKHYgJSAxID8gTnVtYmVyKHYudG9GaXhlZCg1KSkgOiB2KTtcbmNvbnN0IGZsb2F0UmVnZXggPSAvKC0pPyhbXFxkXSpcXC4/W1xcZF0pKy9nO1xuY29uc3QgY29sb3JSZWdleCA9IC8oI1swLTlhLWZdezZ9fCNbMC05YS1mXXszfXwjKD86WzAtOWEtZl17Mn0pezIsNH18KHJnYnxoc2wpYT9cXCgoLT9bXFxkXFwuXSslP1ssXFxzXSspezIsM31cXHMqXFwvKlxccypbXFxkXFwuXSslP1xcKSkvZ2k7XG5jb25zdCBzaW5nbGVDb2xvclJlZ2V4ID0gL14oI1swLTlhLWZdezN9fCMoPzpbMC05YS1mXXsyfSl7Miw0fXwocmdifGhzbClhP1xcKCgtP1tcXGRcXC5dKyU/WyxcXHNdKyl7MiwzfVxccypcXC8qXFxzKltcXGRcXC5dKyU/XFwpKSQvaTtcbmZ1bmN0aW9uIGlzU3RyaW5nKHYpIHtcbiAgICByZXR1cm4gdHlwZW9mIHYgPT09ICdzdHJpbmcnO1xufVxuXG5leHBvcnQgeyBjbGFtcCwgY29sb3JSZWdleCwgZmxvYXRSZWdleCwgaXNTdHJpbmcsIHNhbml0aXplLCBzaW5nbGVDb2xvclJlZ2V4IH07XG4iLCJpbXBvcnQgeyBpc1N0cmluZyB9IGZyb20gJy4uL3V0aWxzLm1qcyc7XG5cbmNvbnN0IGNyZWF0ZVVuaXRUeXBlID0gKHVuaXQpID0+ICh7XG4gICAgdGVzdDogKHYpID0+IGlzU3RyaW5nKHYpICYmIHYuZW5kc1dpdGgodW5pdCkgJiYgdi5zcGxpdCgnICcpLmxlbmd0aCA9PT0gMSxcbiAgICBwYXJzZTogcGFyc2VGbG9hdCxcbiAgICB0cmFuc2Zvcm06ICh2KSA9PiBgJHt2fSR7dW5pdH1gLFxufSk7XG5jb25zdCBkZWdyZWVzID0gY3JlYXRlVW5pdFR5cGUoJ2RlZycpO1xuY29uc3QgcGVyY2VudCA9IGNyZWF0ZVVuaXRUeXBlKCclJyk7XG5jb25zdCBweCA9IGNyZWF0ZVVuaXRUeXBlKCdweCcpO1xuY29uc3QgdmggPSBjcmVhdGVVbml0VHlwZSgndmgnKTtcbmNvbnN0IHZ3ID0gY3JlYXRlVW5pdFR5cGUoJ3Z3Jyk7XG5jb25zdCBwcm9ncmVzc1BlcmNlbnRhZ2UgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHBlcmNlbnQpLCB7IHBhcnNlOiAodikgPT4gcGVyY2VudC5wYXJzZSh2KSAvIDEwMCwgdHJhbnNmb3JtOiAodikgPT4gcGVyY2VudC50cmFuc2Zvcm0odiAqIDEwMCkgfSk7XG5cbmV4cG9ydCB7IGRlZ3JlZXMsIHBlcmNlbnQsIHByb2dyZXNzUGVyY2VudGFnZSwgcHgsIHZoLCB2dyB9O1xuIiwiaW1wb3J0IHsgY2xhbXAgfSBmcm9tICcuLi91dGlscy5tanMnO1xuXG5jb25zdCBudW1iZXIgPSB7XG4gICAgdGVzdDogKHYpID0+IHR5cGVvZiB2ID09PSAnbnVtYmVyJyxcbiAgICBwYXJzZTogcGFyc2VGbG9hdCxcbiAgICB0cmFuc2Zvcm06ICh2KSA9PiB2LFxufTtcbmNvbnN0IGFscGhhID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBudW1iZXIpLCB7IHRyYW5zZm9ybTogY2xhbXAoMCwgMSkgfSk7XG5jb25zdCBzY2FsZSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbnVtYmVyKSwgeyBkZWZhdWx0OiAxIH0pO1xuXG5leHBvcnQgeyBhbHBoYSwgbnVtYmVyLCBzY2FsZSB9O1xuIiwiaW1wb3J0IHsgX19hc3NpZ24gfSBmcm9tICd0c2xpYic7XG5pbXBvcnQgeyBudW1iZXIgfSBmcm9tICdzdHlsZS12YWx1ZS10eXBlcyc7XG5cbnZhciBpbnQgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgbnVtYmVyKSwgeyB0cmFuc2Zvcm06IE1hdGgucm91bmQgfSk7XG5cbmV4cG9ydCB7IGludCB9O1xuIiwiaW1wb3J0IHsgcHgsIGRlZ3JlZXMsIHNjYWxlLCBhbHBoYSwgcHJvZ3Jlc3NQZXJjZW50YWdlIH0gZnJvbSAnc3R5bGUtdmFsdWUtdHlwZXMnO1xuaW1wb3J0IHsgaW50IH0gZnJvbSAnLi90eXBlLWludC5tanMnO1xuXG52YXIgbnVtYmVyVmFsdWVUeXBlcyA9IHtcbiAgICAvLyBCb3JkZXIgcHJvcHNcbiAgICBib3JkZXJXaWR0aDogcHgsXG4gICAgYm9yZGVyVG9wV2lkdGg6IHB4LFxuICAgIGJvcmRlclJpZ2h0V2lkdGg6IHB4LFxuICAgIGJvcmRlckJvdHRvbVdpZHRoOiBweCxcbiAgICBib3JkZXJMZWZ0V2lkdGg6IHB4LFxuICAgIGJvcmRlclJhZGl1czogcHgsXG4gICAgcmFkaXVzOiBweCxcbiAgICBib3JkZXJUb3BMZWZ0UmFkaXVzOiBweCxcbiAgICBib3JkZXJUb3BSaWdodFJhZGl1czogcHgsXG4gICAgYm9yZGVyQm90dG9tUmlnaHRSYWRpdXM6IHB4LFxuICAgIGJvcmRlckJvdHRvbUxlZnRSYWRpdXM6IHB4LFxuICAgIC8vIFBvc2l0aW9uaW5nIHByb3BzXG4gICAgd2lkdGg6IHB4LFxuICAgIG1heFdpZHRoOiBweCxcbiAgICBoZWlnaHQ6IHB4LFxuICAgIG1heEhlaWdodDogcHgsXG4gICAgc2l6ZTogcHgsXG4gICAgdG9wOiBweCxcbiAgICByaWdodDogcHgsXG4gICAgYm90dG9tOiBweCxcbiAgICBsZWZ0OiBweCxcbiAgICAvLyBTcGFjaW5nIHByb3BzXG4gICAgcGFkZGluZzogcHgsXG4gICAgcGFkZGluZ1RvcDogcHgsXG4gICAgcGFkZGluZ1JpZ2h0OiBweCxcbiAgICBwYWRkaW5nQm90dG9tOiBweCxcbiAgICBwYWRkaW5nTGVmdDogcHgsXG4gICAgbWFyZ2luOiBweCxcbiAgICBtYXJnaW5Ub3A6IHB4LFxuICAgIG1hcmdpblJpZ2h0OiBweCxcbiAgICBtYXJnaW5Cb3R0b206IHB4LFxuICAgIG1hcmdpbkxlZnQ6IHB4LFxuICAgIC8vIFRyYW5zZm9ybSBwcm9wc1xuICAgIHJvdGF0ZTogZGVncmVlcyxcbiAgICByb3RhdGVYOiBkZWdyZWVzLFxuICAgIHJvdGF0ZVk6IGRlZ3JlZXMsXG4gICAgcm90YXRlWjogZGVncmVlcyxcbiAgICBzY2FsZTogc2NhbGUsXG4gICAgc2NhbGVYOiBzY2FsZSxcbiAgICBzY2FsZVk6IHNjYWxlLFxuICAgIHNjYWxlWjogc2NhbGUsXG4gICAgc2tldzogZGVncmVlcyxcbiAgICBza2V3WDogZGVncmVlcyxcbiAgICBza2V3WTogZGVncmVlcyxcbiAgICBkaXN0YW5jZTogcHgsXG4gICAgdHJhbnNsYXRlWDogcHgsXG4gICAgdHJhbnNsYXRlWTogcHgsXG4gICAgdHJhbnNsYXRlWjogcHgsXG4gICAgeDogcHgsXG4gICAgeTogcHgsXG4gICAgejogcHgsXG4gICAgcGVyc3BlY3RpdmU6IHB4LFxuICAgIHRyYW5zZm9ybVBlcnNwZWN0aXZlOiBweCxcbiAgICBvcGFjaXR5OiBhbHBoYSxcbiAgICBvcmlnaW5YOiBwcm9ncmVzc1BlcmNlbnRhZ2UsXG4gICAgb3JpZ2luWTogcHJvZ3Jlc3NQZXJjZW50YWdlLFxuICAgIG9yaWdpblo6IHB4LFxuICAgIC8vIE1pc2NcbiAgICB6SW5kZXg6IGludCxcbiAgICAvLyBTVkdcbiAgICBmaWxsT3BhY2l0eTogYWxwaGEsXG4gICAgc3Ryb2tlT3BhY2l0eTogYWxwaGEsXG4gICAgbnVtT2N0YXZlczogaW50LFxufTtcblxuZXhwb3J0IHsgbnVtYmVyVmFsdWVUeXBlcyB9O1xuIiwiaW1wb3J0IHsgYnVpbGRUcmFuc2Zvcm0sIGJ1aWxkVHJhbnNmb3JtT3JpZ2luIH0gZnJvbSAnLi9idWlsZC10cmFuc2Zvcm0ubWpzJztcbmltcG9ydCB7IGlzQ1NTVmFyaWFibGUgfSBmcm9tICcuLi8uLi9kb20vdXRpbHMvaXMtY3NzLXZhcmlhYmxlLm1qcyc7XG5pbXBvcnQgeyBpc1RyYW5zZm9ybVByb3AsIGlzVHJhbnNmb3JtT3JpZ2luUHJvcCB9IGZyb20gJy4vdHJhbnNmb3JtLm1qcyc7XG5pbXBvcnQgeyBnZXRWYWx1ZUFzVHlwZSB9IGZyb20gJy4uLy4uL2RvbS92YWx1ZS10eXBlcy9nZXQtYXMtdHlwZS5tanMnO1xuaW1wb3J0IHsgbnVtYmVyVmFsdWVUeXBlcyB9IGZyb20gJy4uLy4uL2RvbS92YWx1ZS10eXBlcy9udW1iZXIubWpzJztcblxuZnVuY3Rpb24gYnVpbGRIVE1MU3R5bGVzKHN0YXRlLCBsYXRlc3RWYWx1ZXMsIG9wdGlvbnMsIHRyYW5zZm9ybVRlbXBsYXRlKSB7XG4gICAgdmFyIF9hO1xuICAgIHZhciBzdHlsZSA9IHN0YXRlLnN0eWxlLCB2YXJzID0gc3RhdGUudmFycywgdHJhbnNmb3JtID0gc3RhdGUudHJhbnNmb3JtLCB0cmFuc2Zvcm1LZXlzID0gc3RhdGUudHJhbnNmb3JtS2V5cywgdHJhbnNmb3JtT3JpZ2luID0gc3RhdGUudHJhbnNmb3JtT3JpZ2luO1xuICAgIC8vIEVtcHR5IHRoZSB0cmFuc2Zvcm1LZXlzIGFycmF5LiBBcyB3ZSdyZSB0aHJvd2luZyBvdXQgcmVmcyB0byBpdHMgaXRlbXNcbiAgICAvLyB0aGlzIG1pZ2h0IG5vdCBiZSBhcyBjaGVhcCBhcyBzdXNwZWN0ZWQuIE1heWJlIHVzaW5nIHRoZSBhcnJheSBhcyBhIGJ1ZmZlclxuICAgIC8vIHdpdGggYSBtYW51YWwgaW5jcmVtZW50YXRpb24gd291bGQgYmUgYmV0dGVyLlxuICAgIHRyYW5zZm9ybUtleXMubGVuZ3RoID0gMDtcbiAgICAvLyBUcmFjayB3aGV0aGVyIHdlIGVuY291bnRlciBhbnkgdHJhbnNmb3JtIG9yIHRyYW5zZm9ybU9yaWdpbiB2YWx1ZXMuXG4gICAgdmFyIGhhc1RyYW5zZm9ybSA9IGZhbHNlO1xuICAgIHZhciBoYXNUcmFuc2Zvcm1PcmlnaW4gPSBmYWxzZTtcbiAgICAvLyBEb2VzIHRoZSBjYWxjdWxhdGVkIHRyYW5zZm9ybSBlc3NlbnRpYWxseSBlcXVhbCBcIm5vbmVcIj9cbiAgICB2YXIgdHJhbnNmb3JtSXNOb25lID0gdHJ1ZTtcbiAgICAvKipcbiAgICAgKiBMb29wIG92ZXIgYWxsIG91ciBsYXRlc3QgYW5pbWF0ZWQgdmFsdWVzIGFuZCBkZWNpZGUgd2hldGhlciB0byBoYW5kbGUgdGhlbVxuICAgICAqIGFzIGEgc3R5bGUgb3IgQ1NTIHZhcmlhYmxlLlxuICAgICAqXG4gICAgICogVHJhbnNmb3JtcyBhbmQgdHJhbnNmb3JtIG9yaWdpbnMgYXJlIGtlcHQgc2VwZXJhdGVseSBmb3IgZnVydGhlciBwcm9jZXNzaW5nLlxuICAgICAqL1xuICAgIGZvciAodmFyIGtleSBpbiBsYXRlc3RWYWx1ZXMpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gbGF0ZXN0VmFsdWVzW2tleV07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0aGlzIGlzIGEgQ1NTIHZhcmlhYmxlIHdlIGRvbid0IGRvIGFueSBmdXJ0aGVyIHByb2Nlc3NpbmcuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoaXNDU1NWYXJpYWJsZShrZXkpKSB7XG4gICAgICAgICAgICB2YXJzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbnZlcnQgdGhlIHZhbHVlIHRvIGl0cyBkZWZhdWx0IHZhbHVlIHR5cGUsIGllIDAgLT4gXCIwcHhcIlxuICAgICAgICB2YXIgdmFsdWVUeXBlID0gbnVtYmVyVmFsdWVUeXBlc1trZXldO1xuICAgICAgICB2YXIgdmFsdWVBc1R5cGUgPSBnZXRWYWx1ZUFzVHlwZSh2YWx1ZSwgdmFsdWVUeXBlKTtcbiAgICAgICAgaWYgKGlzVHJhbnNmb3JtUHJvcChrZXkpKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGlzIGlzIGEgdHJhbnNmb3JtLCBmbGFnIHRvIGVuYWJsZSBmdXJ0aGVyIHRyYW5zZm9ybSBwcm9jZXNzaW5nXG4gICAgICAgICAgICBoYXNUcmFuc2Zvcm0gPSB0cnVlO1xuICAgICAgICAgICAgdHJhbnNmb3JtW2tleV0gPSB2YWx1ZUFzVHlwZTtcbiAgICAgICAgICAgIHRyYW5zZm9ybUtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgLy8gSWYgd2UgYWxyZWFkeSBrbm93IHdlIGhhdmUgYSBub24tZGVmYXVsdCB0cmFuc2Zvcm0sIGVhcmx5IHJldHVyblxuICAgICAgICAgICAgaWYgKCF0cmFuc2Zvcm1Jc05vbmUpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAvLyBPdGhlcndpc2UgY2hlY2sgdG8gc2VlIGlmIHRoaXMgaXMgYSBkZWZhdWx0IHRyYW5zZm9ybVxuICAgICAgICAgICAgaWYgKHZhbHVlICE9PSAoKF9hID0gdmFsdWVUeXBlLmRlZmF1bHQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDApKVxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybUlzTm9uZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzVHJhbnNmb3JtT3JpZ2luUHJvcChrZXkpKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1PcmlnaW5ba2V5XSA9IHZhbHVlQXNUeXBlO1xuICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyBhIHRyYW5zZm9ybSBvcmlnaW4sIGZsYWcgYW5kIGVuYWJsZSBmdXJ0aGVyIHRyYW5zZm9ybS1vcmlnaW4gcHJvY2Vzc2luZ1xuICAgICAgICAgICAgaGFzVHJhbnNmb3JtT3JpZ2luID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0eWxlW2tleV0gPSB2YWx1ZUFzVHlwZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoaGFzVHJhbnNmb3JtKSB7XG4gICAgICAgIHN0eWxlLnRyYW5zZm9ybSA9IGJ1aWxkVHJhbnNmb3JtKHN0YXRlLCBvcHRpb25zLCB0cmFuc2Zvcm1Jc05vbmUsIHRyYW5zZm9ybVRlbXBsYXRlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHJhbnNmb3JtVGVtcGxhdGUpIHtcbiAgICAgICAgc3R5bGUudHJhbnNmb3JtID0gdHJhbnNmb3JtVGVtcGxhdGUoe30sIFwiXCIpO1xuICAgIH1cbiAgICBlbHNlIGlmICghbGF0ZXN0VmFsdWVzLnRyYW5zZm9ybSAmJiBzdHlsZS50cmFuc2Zvcm0pIHtcbiAgICAgICAgc3R5bGUudHJhbnNmb3JtID0gXCJub25lXCI7XG4gICAgfVxuICAgIGlmIChoYXNUcmFuc2Zvcm1PcmlnaW4pIHtcbiAgICAgICAgc3R5bGUudHJhbnNmb3JtT3JpZ2luID0gYnVpbGRUcmFuc2Zvcm1PcmlnaW4odHJhbnNmb3JtT3JpZ2luKTtcbiAgICB9XG59XG5cbmV4cG9ydCB7IGJ1aWxkSFRNTFN0eWxlcyB9O1xuIiwidmFyIGNyZWF0ZUh0bWxSZW5kZXJTdGF0ZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7XG4gICAgc3R5bGU6IHt9LFxuICAgIHRyYW5zZm9ybToge30sXG4gICAgdHJhbnNmb3JtS2V5czogW10sXG4gICAgdHJhbnNmb3JtT3JpZ2luOiB7fSxcbiAgICB2YXJzOiB7fSxcbn0pOyB9O1xuXG5leHBvcnQgeyBjcmVhdGVIdG1sUmVuZGVyU3RhdGUgfTtcbiIsImltcG9ydCB7IF9fYXNzaWduIH0gZnJvbSAndHNsaWInO1xuaW1wb3J0IHsgdXNlTWVtbyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGlzRm9yY2VkTW90aW9uVmFsdWUgfSBmcm9tICcuLi8uLi9tb3Rpb24vdXRpbHMvaXMtZm9yY2VkLW1vdGlvbi12YWx1ZS5tanMnO1xuaW1wb3J0IHsgaXNNb3Rpb25WYWx1ZSB9IGZyb20gJy4uLy4uL3ZhbHVlL3V0aWxzL2lzLW1vdGlvbi12YWx1ZS5tanMnO1xuaW1wb3J0IHsgYnVpbGRIVE1MU3R5bGVzIH0gZnJvbSAnLi91dGlscy9idWlsZC1zdHlsZXMubWpzJztcbmltcG9ydCB7IGNyZWF0ZUh0bWxSZW5kZXJTdGF0ZSB9IGZyb20gJy4vdXRpbHMvY3JlYXRlLXJlbmRlci1zdGF0ZS5tanMnO1xuXG5mdW5jdGlvbiBjb3B5UmF3VmFsdWVzT25seSh0YXJnZXQsIHNvdXJjZSwgcHJvcHMpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmICghaXNNb3Rpb25WYWx1ZShzb3VyY2Vba2V5XSkgJiYgIWlzRm9yY2VkTW90aW9uVmFsdWUoa2V5LCBwcm9wcykpIHtcbiAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiB1c2VJbml0aWFsTW90aW9uVmFsdWVzKF9hLCB2aXN1YWxTdGF0ZSwgaXNTdGF0aWMpIHtcbiAgICB2YXIgdHJhbnNmb3JtVGVtcGxhdGUgPSBfYS50cmFuc2Zvcm1UZW1wbGF0ZTtcbiAgICByZXR1cm4gdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IGNyZWF0ZUh0bWxSZW5kZXJTdGF0ZSgpO1xuICAgICAgICBidWlsZEhUTUxTdHlsZXMoc3RhdGUsIHZpc3VhbFN0YXRlLCB7IGVuYWJsZUhhcmR3YXJlQWNjZWxlcmF0aW9uOiAhaXNTdGF0aWMgfSwgdHJhbnNmb3JtVGVtcGxhdGUpO1xuICAgICAgICB2YXIgdmFycyA9IHN0YXRlLnZhcnMsIHN0eWxlID0gc3RhdGUuc3R5bGU7XG4gICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgdmFycyksIHN0eWxlKTtcbiAgICB9LCBbdmlzdWFsU3RhdGVdKTtcbn1cbmZ1bmN0aW9uIHVzZVN0eWxlKHByb3BzLCB2aXN1YWxTdGF0ZSwgaXNTdGF0aWMpIHtcbiAgICB2YXIgc3R5bGVQcm9wID0gcHJvcHMuc3R5bGUgfHwge307XG4gICAgdmFyIHN0eWxlID0ge307XG4gICAgLyoqXG4gICAgICogQ29weSBub24tTW90aW9uIFZhbHVlcyBzdHJhaWdodCBpbnRvIHN0eWxlXG4gICAgICovXG4gICAgY29weVJhd1ZhbHVlc09ubHkoc3R5bGUsIHN0eWxlUHJvcCwgcHJvcHMpO1xuICAgIE9iamVjdC5hc3NpZ24oc3R5bGUsIHVzZUluaXRpYWxNb3Rpb25WYWx1ZXMocHJvcHMsIHZpc3VhbFN0YXRlLCBpc1N0YXRpYykpO1xuICAgIGlmIChwcm9wcy50cmFuc2Zvcm1WYWx1ZXMpIHtcbiAgICAgICAgc3R5bGUgPSBwcm9wcy50cmFuc2Zvcm1WYWx1ZXMoc3R5bGUpO1xuICAgIH1cbiAgICByZXR1cm4gc3R5bGU7XG59XG5mdW5jdGlvbiB1c2VIVE1MUHJvcHMocHJvcHMsIHZpc3VhbFN0YXRlLCBpc1N0YXRpYykge1xuICAgIC8vIFRoZSBgYW55YCBpc24ndCBpZGVhbCBidXQgaXQgaXMgdGhlIHR5cGUgb2YgY3JlYXRlRWxlbWVudCBwcm9wcyBhcmd1bWVudFxuICAgIHZhciBodG1sUHJvcHMgPSB7fTtcbiAgICB2YXIgc3R5bGUgPSB1c2VTdHlsZShwcm9wcywgdmlzdWFsU3RhdGUsIGlzU3RhdGljKTtcbiAgICBpZiAoQm9vbGVhbihwcm9wcy5kcmFnKSAmJiBwcm9wcy5kcmFnTGlzdGVuZXIgIT09IGZhbHNlKSB7XG4gICAgICAgIC8vIERpc2FibGUgdGhlIGdob3N0IGVsZW1lbnQgd2hlbiBhIHVzZXIgZHJhZ3NcbiAgICAgICAgaHRtbFByb3BzLmRyYWdnYWJsZSA9IGZhbHNlO1xuICAgICAgICAvLyBEaXNhYmxlIHRleHQgc2VsZWN0aW9uXG4gICAgICAgIHN0eWxlLnVzZXJTZWxlY3QgPVxuICAgICAgICAgICAgc3R5bGUuV2Via2l0VXNlclNlbGVjdCA9XG4gICAgICAgICAgICAgICAgc3R5bGUuV2Via2l0VG91Y2hDYWxsb3V0ID1cbiAgICAgICAgICAgICAgICAgICAgXCJub25lXCI7XG4gICAgICAgIC8vIERpc2FibGUgc2Nyb2xsaW5nIG9uIHRoZSBkcmFnZ2FibGUgZGlyZWN0aW9uXG4gICAgICAgIHN0eWxlLnRvdWNoQWN0aW9uID1cbiAgICAgICAgICAgIHByb3BzLmRyYWcgPT09IHRydWVcbiAgICAgICAgICAgICAgICA/IFwibm9uZVwiXG4gICAgICAgICAgICAgICAgOiBcInBhbi1cIi5jb25jYXQocHJvcHMuZHJhZyA9PT0gXCJ4XCIgPyBcInlcIiA6IFwieFwiKTtcbiAgICB9XG4gICAgaHRtbFByb3BzLnN0eWxlID0gc3R5bGU7XG4gICAgcmV0dXJuIGh0bWxQcm9wcztcbn1cblxuZXhwb3J0IHsgY29weVJhd1ZhbHVlc09ubHksIHVzZUhUTUxQcm9wcywgdXNlU3R5bGUgfTtcbiIsIi8qKlxuICogQSBsaXN0IG9mIGFsbCB2YWxpZCBNb3Rpb25Qcm9wcy5cbiAqXG4gKiBAcHJpdmF0ZVJlbWFya3NcbiAqIFRoaXMgZG9lc24ndCB0aHJvdyBpZiBhIGBNb3Rpb25Qcm9wYCBuYW1lIGlzIG1pc3NpbmcgLSBpdCBzaG91bGQuXG4gKi9cbnZhciB2YWxpZE1vdGlvblByb3BzID0gbmV3IFNldChbXG4gICAgXCJpbml0aWFsXCIsXG4gICAgXCJhbmltYXRlXCIsXG4gICAgXCJleGl0XCIsXG4gICAgXCJzdHlsZVwiLFxuICAgIFwidmFyaWFudHNcIixcbiAgICBcInRyYW5zaXRpb25cIixcbiAgICBcInRyYW5zZm9ybVRlbXBsYXRlXCIsXG4gICAgXCJ0cmFuc2Zvcm1WYWx1ZXNcIixcbiAgICBcImN1c3RvbVwiLFxuICAgIFwiaW5oZXJpdFwiLFxuICAgIFwibGF5b3V0XCIsXG4gICAgXCJsYXlvdXRJZFwiLFxuICAgIFwibGF5b3V0RGVwZW5kZW5jeVwiLFxuICAgIFwib25MYXlvdXRBbmltYXRpb25TdGFydFwiLFxuICAgIFwib25MYXlvdXRBbmltYXRpb25Db21wbGV0ZVwiLFxuICAgIFwib25MYXlvdXRNZWFzdXJlXCIsXG4gICAgXCJvbkJlZm9yZUxheW91dE1lYXN1cmVcIixcbiAgICBcIm9uQW5pbWF0aW9uU3RhcnRcIixcbiAgICBcIm9uQW5pbWF0aW9uQ29tcGxldGVcIixcbiAgICBcIm9uVXBkYXRlXCIsXG4gICAgXCJvbkRyYWdTdGFydFwiLFxuICAgIFwib25EcmFnXCIsXG4gICAgXCJvbkRyYWdFbmRcIixcbiAgICBcIm9uTWVhc3VyZURyYWdDb25zdHJhaW50c1wiLFxuICAgIFwib25EaXJlY3Rpb25Mb2NrXCIsXG4gICAgXCJvbkRyYWdUcmFuc2l0aW9uRW5kXCIsXG4gICAgXCJkcmFnXCIsXG4gICAgXCJkcmFnQ29udHJvbHNcIixcbiAgICBcImRyYWdMaXN0ZW5lclwiLFxuICAgIFwiZHJhZ0NvbnN0cmFpbnRzXCIsXG4gICAgXCJkcmFnRGlyZWN0aW9uTG9ja1wiLFxuICAgIFwiZHJhZ1NuYXBUb09yaWdpblwiLFxuICAgIFwiX2RyYWdYXCIsXG4gICAgXCJfZHJhZ1lcIixcbiAgICBcImRyYWdFbGFzdGljXCIsXG4gICAgXCJkcmFnTW9tZW50dW1cIixcbiAgICBcImRyYWdQcm9wYWdhdGlvblwiLFxuICAgIFwiZHJhZ1RyYW5zaXRpb25cIixcbiAgICBcIndoaWxlRHJhZ1wiLFxuICAgIFwib25QYW5cIixcbiAgICBcIm9uUGFuU3RhcnRcIixcbiAgICBcIm9uUGFuRW5kXCIsXG4gICAgXCJvblBhblNlc3Npb25TdGFydFwiLFxuICAgIFwib25UYXBcIixcbiAgICBcIm9uVGFwU3RhcnRcIixcbiAgICBcIm9uVGFwQ2FuY2VsXCIsXG4gICAgXCJvbkhvdmVyU3RhcnRcIixcbiAgICBcIm9uSG92ZXJFbmRcIixcbiAgICBcIndoaWxlRm9jdXNcIixcbiAgICBcIndoaWxlVGFwXCIsXG4gICAgXCJ3aGlsZUhvdmVyXCIsXG4gICAgXCJ3aGlsZUluVmlld1wiLFxuICAgIFwib25WaWV3cG9ydEVudGVyXCIsXG4gICAgXCJvblZpZXdwb3J0TGVhdmVcIixcbiAgICBcInZpZXdwb3J0XCIsXG4gICAgXCJsYXlvdXRTY3JvbGxcIixcbl0pO1xuLyoqXG4gKiBDaGVjayB3aGV0aGVyIGEgcHJvcCBuYW1lIGlzIGEgdmFsaWQgYE1vdGlvblByb3BgIGtleS5cbiAqXG4gKiBAcGFyYW0ga2V5IC0gTmFtZSBvZiB0aGUgcHJvcGVydHkgdG8gY2hlY2tcbiAqIEByZXR1cm5zIGB0cnVlYCBpcyBrZXkgaXMgYSB2YWxpZCBgTW90aW9uUHJvcGAuXG4gKlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBpc1ZhbGlkTW90aW9uUHJvcChrZXkpIHtcbiAgICByZXR1cm4gdmFsaWRNb3Rpb25Qcm9wcy5oYXMoa2V5KTtcbn1cblxuZXhwb3J0IHsgaXNWYWxpZE1vdGlvblByb3AgfTtcbiIsImltcG9ydCB7IGlzVmFsaWRNb3Rpb25Qcm9wIH0gZnJvbSAnLi4vLi4vLi4vbW90aW9uL3V0aWxzL3ZhbGlkLXByb3AubWpzJztcblxudmFyIHNob3VsZEZvcndhcmQgPSBmdW5jdGlvbiAoa2V5KSB7IHJldHVybiAhaXNWYWxpZE1vdGlvblByb3Aoa2V5KTsgfTtcbmZ1bmN0aW9uIGxvYWRFeHRlcm5hbElzVmFsaWRQcm9wKGlzVmFsaWRQcm9wKSB7XG4gICAgaWYgKCFpc1ZhbGlkUHJvcClcbiAgICAgICAgcmV0dXJuO1xuICAgIC8vIEV4cGxpY2l0bHkgZmlsdGVyIG91ciBldmVudHNcbiAgICBzaG91bGRGb3J3YXJkID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4ga2V5LnN0YXJ0c1dpdGgoXCJvblwiKSA/ICFpc1ZhbGlkTW90aW9uUHJvcChrZXkpIDogaXNWYWxpZFByb3Aoa2V5KTtcbiAgICB9O1xufVxuLyoqXG4gKiBFbW90aW9uIGFuZCBTdHlsZWQgQ29tcG9uZW50cyBib3RoIGFsbG93IHVzZXJzIHRvIHBhc3MgdGhyb3VnaCBhcmJpdHJhcnkgcHJvcHMgdG8gdGhlaXIgY29tcG9uZW50c1xuICogdG8gZHluYW1pY2FsbHkgZ2VuZXJhdGUgQ1NTLiBUaGV5IGJvdGggdXNlIHRoZSBgQGVtb3Rpb24vaXMtcHJvcC12YWxpZGAgcGFja2FnZSB0byBkZXRlcm1pbmUgd2hpY2hcbiAqIG9mIHRoZXNlIHNob3VsZCBiZSBwYXNzZWQgdG8gdGhlIHVuZGVybHlpbmcgRE9NIG5vZGUuXG4gKlxuICogSG93ZXZlciwgd2hlbiBzdHlsaW5nIGEgTW90aW9uIGNvbXBvbmVudCBgc3R5bGVkKG1vdGlvbi5kaXYpYCwgYm90aCBwYWNrYWdlcyBwYXNzIHRocm91Z2ggKmFsbCogcHJvcHNcbiAqIGFzIGl0J3Mgc2VlbiBhcyBhbiBhcmJpdHJhcnkgY29tcG9uZW50IHJhdGhlciB0aGFuIGEgRE9NIG5vZGUuIE1vdGlvbiBvbmx5IGFsbG93cyBhcmJpdHJhcnkgcHJvcHNcbiAqIHBhc3NlZCB0aHJvdWdoIHRoZSBgY3VzdG9tYCBwcm9wIHNvIGl0IGRvZXNuJ3QgKm5lZWQqIHRoZSBwYXlsb2FkIG9yIGNvbXB1dGF0aW9uYWwgb3ZlcmhlYWQgb2ZcbiAqIGBAZW1vdGlvbi9pcy1wcm9wLXZhbGlkYCwgaG93ZXZlciB0byBmaXggdGhpcyBwcm9ibGVtIHdlIG5lZWQgdG8gdXNlIGl0LlxuICpcbiAqIEJ5IG1ha2luZyBpdCBhbiBvcHRpb25hbERlcGVuZGVuY3kgd2UgY2FuIG9mZmVyIHRoaXMgZnVuY3Rpb25hbGl0eSBvbmx5IGluIHRoZSBzaXR1YXRpb25zIHdoZXJlIGl0J3NcbiAqIGFjdHVhbGx5IHJlcXVpcmVkLlxuICovXG50cnkge1xuICAgIC8qKlxuICAgICAqIFdlIGF0dGVtcHQgdG8gaW1wb3J0IHRoaXMgcGFja2FnZSBidXQgcmVxdWlyZSB3b24ndCBiZSBkZWZpbmVkIGluIGVzbSBlbnZpcm9ubWVudHMsIGluIHRoYXQgY2FzZVxuICAgICAqIGlzUHJvcFZhbGlkIHdpbGwgaGF2ZSB0byBiZSBwcm92aWRlZCB2aWEgYE1vdGlvbkNvbnRleHRgLiBJbiBhIDYuMC4wIHRoaXMgc2hvdWxkIHByb2JhYmx5IGJlIHJlbW92ZWRcbiAgICAgKiBpbiBmYXZvdXIgb2YgZXhwbGljaXQgaW5qZWN0aW9uLlxuICAgICAqL1xuICAgIGxvYWRFeHRlcm5hbElzVmFsaWRQcm9wKHJlcXVpcmUoXCJAZW1vdGlvbi9pcy1wcm9wLXZhbGlkXCIpLmRlZmF1bHQpO1xufVxuY2F0Y2ggKF9hKSB7XG4gICAgLy8gV2UgZG9uJ3QgbmVlZCB0byBhY3R1YWxseSBkbyBhbnl0aGluZyBoZXJlIC0gdGhlIGZhbGxiYWNrIGlzIHRoZSBleGlzdGluZyBgaXNQcm9wVmFsaWRgLlxufVxuZnVuY3Rpb24gZmlsdGVyUHJvcHMocHJvcHMsIGlzRG9tLCBmb3J3YXJkTW90aW9uUHJvcHMpIHtcbiAgICB2YXIgZmlsdGVyZWRQcm9wcyA9IHt9O1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgICAgICBpZiAoc2hvdWxkRm9yd2FyZChrZXkpIHx8XG4gICAgICAgICAgICAoZm9yd2FyZE1vdGlvblByb3BzID09PSB0cnVlICYmIGlzVmFsaWRNb3Rpb25Qcm9wKGtleSkpIHx8XG4gICAgICAgICAgICAoIWlzRG9tICYmICFpc1ZhbGlkTW90aW9uUHJvcChrZXkpKSB8fFxuICAgICAgICAgICAgLy8gSWYgdHJ5aW5nIHRvIHVzZSBuYXRpdmUgSFRNTCBkcmFnIGV2ZW50cywgZm9yd2FyZCBkcmFnIGxpc3RlbmVyc1xuICAgICAgICAgICAgKHByb3BzW1wiZHJhZ2dhYmxlXCJdICYmIGtleS5zdGFydHNXaXRoKFwib25EcmFnXCIpKSkge1xuICAgICAgICAgICAgZmlsdGVyZWRQcm9wc1trZXldID0gcHJvcHNba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmlsdGVyZWRQcm9wcztcbn1cblxuZXhwb3J0IHsgZmlsdGVyUHJvcHMsIGxvYWRFeHRlcm5hbElzVmFsaWRQcm9wIH07XG4iLCJpbXBvcnQgeyBweCB9IGZyb20gJ3N0eWxlLXZhbHVlLXR5cGVzJztcblxuZnVuY3Rpb24gY2FsY09yaWdpbihvcmlnaW4sIG9mZnNldCwgc2l6ZSkge1xuICAgIHJldHVybiB0eXBlb2Ygb3JpZ2luID09PSBcInN0cmluZ1wiXG4gICAgICAgID8gb3JpZ2luXG4gICAgICAgIDogcHgudHJhbnNmb3JtKG9mZnNldCArIHNpemUgKiBvcmlnaW4pO1xufVxuLyoqXG4gKiBUaGUgU1ZHIHRyYW5zZm9ybSBvcmlnaW4gZGVmYXVsdHMgYXJlIGRpZmZlcmVudCB0byBDU1MgYW5kIGlzIGxlc3MgaW50dWl0aXZlLFxuICogc28gd2UgdXNlIHRoZSBtZWFzdXJlZCBkaW1lbnNpb25zIG9mIHRoZSBTVkcgdG8gcmVjb25jaWxlIHRoZXNlLlxuICovXG5mdW5jdGlvbiBjYWxjU1ZHVHJhbnNmb3JtT3JpZ2luKGRpbWVuc2lvbnMsIG9yaWdpblgsIG9yaWdpblkpIHtcbiAgICB2YXIgcHhPcmlnaW5YID0gY2FsY09yaWdpbihvcmlnaW5YLCBkaW1lbnNpb25zLngsIGRpbWVuc2lvbnMud2lkdGgpO1xuICAgIHZhciBweE9yaWdpblkgPSBjYWxjT3JpZ2luKG9yaWdpblksIGRpbWVuc2lvbnMueSwgZGltZW5zaW9ucy5oZWlnaHQpO1xuICAgIHJldHVybiBcIlwiLmNvbmNhdChweE9yaWdpblgsIFwiIFwiKS5jb25jYXQocHhPcmlnaW5ZKTtcbn1cblxuZXhwb3J0IHsgY2FsY1NWR1RyYW5zZm9ybU9yaWdpbiB9O1xuIiwiaW1wb3J0IHsgcHggfSBmcm9tICdzdHlsZS12YWx1ZS10eXBlcyc7XG5cbnZhciBkYXNoS2V5cyA9IHtcbiAgICBvZmZzZXQ6IFwic3Ryb2tlLWRhc2hvZmZzZXRcIixcbiAgICBhcnJheTogXCJzdHJva2UtZGFzaGFycmF5XCIsXG59O1xudmFyIGNhbWVsS2V5cyA9IHtcbiAgICBvZmZzZXQ6IFwic3Ryb2tlRGFzaG9mZnNldFwiLFxuICAgIGFycmF5OiBcInN0cm9rZURhc2hhcnJheVwiLFxufTtcbi8qKlxuICogQnVpbGQgU1ZHIHBhdGggcHJvcGVydGllcy4gVXNlcyB0aGUgcGF0aCdzIG1lYXN1cmVkIGxlbmd0aCB0byBjb252ZXJ0XG4gKiBvdXIgY3VzdG9tIHBhdGhMZW5ndGgsIHBhdGhTcGFjaW5nIGFuZCBwYXRoT2Zmc2V0IGludG8gc3Ryb2tlLWRhc2hvZmZzZXRcbiAqIGFuZCBzdHJva2UtZGFzaGFycmF5IGF0dHJpYnV0ZXMuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBpcyBtdXRhdGl2ZSB0byByZWR1Y2UgcGVyLWZyYW1lIEdDLlxuICovXG5mdW5jdGlvbiBidWlsZFNWR1BhdGgoYXR0cnMsIGxlbmd0aCwgc3BhY2luZywgb2Zmc2V0LCB1c2VEYXNoQ2FzZSkge1xuICAgIGlmIChzcGFjaW5nID09PSB2b2lkIDApIHsgc3BhY2luZyA9IDE7IH1cbiAgICBpZiAob2Zmc2V0ID09PSB2b2lkIDApIHsgb2Zmc2V0ID0gMDsgfVxuICAgIGlmICh1c2VEYXNoQ2FzZSA9PT0gdm9pZCAwKSB7IHVzZURhc2hDYXNlID0gdHJ1ZTsgfVxuICAgIC8vIE5vcm1hbGlzZSBwYXRoIGxlbmd0aCBieSBzZXR0aW5nIFNWRyBhdHRyaWJ1dGUgcGF0aExlbmd0aCB0byAxXG4gICAgYXR0cnMucGF0aExlbmd0aCA9IDE7XG4gICAgLy8gV2UgdXNlIGRhc2ggY2FzZSB3aGVuIHNldHRpbmcgYXR0cmlidXRlcyBkaXJlY3RseSB0byB0aGUgRE9NIG5vZGUgYW5kIGNhbWVsIGNhc2VcbiAgICAvLyB3aGVuIGRlZmluaW5nIHByb3BzIG9uIGEgUmVhY3QgY29tcG9uZW50LlxuICAgIHZhciBrZXlzID0gdXNlRGFzaENhc2UgPyBkYXNoS2V5cyA6IGNhbWVsS2V5cztcbiAgICAvLyBCdWlsZCB0aGUgZGFzaCBvZmZzZXRcbiAgICBhdHRyc1trZXlzLm9mZnNldF0gPSBweC50cmFuc2Zvcm0oLW9mZnNldCk7XG4gICAgLy8gQnVpbGQgdGhlIGRhc2ggYXJyYXlcbiAgICB2YXIgcGF0aExlbmd0aCA9IHB4LnRyYW5zZm9ybShsZW5ndGgpO1xuICAgIHZhciBwYXRoU3BhY2luZyA9IHB4LnRyYW5zZm9ybShzcGFjaW5nKTtcbiAgICBhdHRyc1trZXlzLmFycmF5XSA9IFwiXCIuY29uY2F0KHBhdGhMZW5ndGgsIFwiIFwiKS5jb25jYXQocGF0aFNwYWNpbmcpO1xufVxuXG5leHBvcnQgeyBidWlsZFNWR1BhdGggfTtcbiIsImltcG9ydCB7IF9fcmVzdCB9IGZyb20gJ3RzbGliJztcbmltcG9ydCB7IGJ1aWxkSFRNTFN0eWxlcyB9IGZyb20gJy4uLy4uL2h0bWwvdXRpbHMvYnVpbGQtc3R5bGVzLm1qcyc7XG5pbXBvcnQgeyBjYWxjU1ZHVHJhbnNmb3JtT3JpZ2luIH0gZnJvbSAnLi90cmFuc2Zvcm0tb3JpZ2luLm1qcyc7XG5pbXBvcnQgeyBidWlsZFNWR1BhdGggfSBmcm9tICcuL3BhdGgubWpzJztcblxuLyoqXG4gKiBCdWlsZCBTVkcgdmlzdWFsIGF0dHJidXRlcywgbGlrZSBjeCBhbmQgc3R5bGUudHJhbnNmb3JtXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkU1ZHQXR0cnMoc3RhdGUsIF9hLCBvcHRpb25zLCB0cmFuc2Zvcm1UZW1wbGF0ZSkge1xuICAgIHZhciBhdHRyWCA9IF9hLmF0dHJYLCBhdHRyWSA9IF9hLmF0dHJZLCBvcmlnaW5YID0gX2Eub3JpZ2luWCwgb3JpZ2luWSA9IF9hLm9yaWdpblksIHBhdGhMZW5ndGggPSBfYS5wYXRoTGVuZ3RoLCBfYiA9IF9hLnBhdGhTcGFjaW5nLCBwYXRoU3BhY2luZyA9IF9iID09PSB2b2lkIDAgPyAxIDogX2IsIF9jID0gX2EucGF0aE9mZnNldCwgcGF0aE9mZnNldCA9IF9jID09PSB2b2lkIDAgPyAwIDogX2MsIFxuICAgIC8vIFRoaXMgaXMgb2JqZWN0IGNyZWF0aW9uLCB3aGljaCB3ZSB0cnkgdG8gYXZvaWQgcGVyLWZyYW1lLlxuICAgIGxhdGVzdCA9IF9fcmVzdChfYSwgW1wiYXR0clhcIiwgXCJhdHRyWVwiLCBcIm9yaWdpblhcIiwgXCJvcmlnaW5ZXCIsIFwicGF0aExlbmd0aFwiLCBcInBhdGhTcGFjaW5nXCIsIFwicGF0aE9mZnNldFwiXSk7XG4gICAgYnVpbGRIVE1MU3R5bGVzKHN0YXRlLCBsYXRlc3QsIG9wdGlvbnMsIHRyYW5zZm9ybVRlbXBsYXRlKTtcbiAgICBzdGF0ZS5hdHRycyA9IHN0YXRlLnN0eWxlO1xuICAgIHN0YXRlLnN0eWxlID0ge307XG4gICAgdmFyIGF0dHJzID0gc3RhdGUuYXR0cnMsIHN0eWxlID0gc3RhdGUuc3R5bGUsIGRpbWVuc2lvbnMgPSBzdGF0ZS5kaW1lbnNpb25zO1xuICAgIC8qKlxuICAgICAqIEhvd2V2ZXIsIHdlIGFwcGx5IHRyYW5zZm9ybXMgYXMgQ1NTIHRyYW5zZm9ybXMuIFNvIGlmIHdlIGRldGVjdCBhIHRyYW5zZm9ybSB3ZSB0YWtlIGl0IGZyb20gYXR0cnNcbiAgICAgKiBhbmQgY29weSBpdCBpbnRvIHN0eWxlLlxuICAgICAqL1xuICAgIGlmIChhdHRycy50cmFuc2Zvcm0pIHtcbiAgICAgICAgaWYgKGRpbWVuc2lvbnMpXG4gICAgICAgICAgICBzdHlsZS50cmFuc2Zvcm0gPSBhdHRycy50cmFuc2Zvcm07XG4gICAgICAgIGRlbGV0ZSBhdHRycy50cmFuc2Zvcm07XG4gICAgfVxuICAgIC8vIFBhcnNlIHRyYW5zZm9ybU9yaWdpblxuICAgIGlmIChkaW1lbnNpb25zICYmXG4gICAgICAgIChvcmlnaW5YICE9PSB1bmRlZmluZWQgfHwgb3JpZ2luWSAhPT0gdW5kZWZpbmVkIHx8IHN0eWxlLnRyYW5zZm9ybSkpIHtcbiAgICAgICAgc3R5bGUudHJhbnNmb3JtT3JpZ2luID0gY2FsY1NWR1RyYW5zZm9ybU9yaWdpbihkaW1lbnNpb25zLCBvcmlnaW5YICE9PSB1bmRlZmluZWQgPyBvcmlnaW5YIDogMC41LCBvcmlnaW5ZICE9PSB1bmRlZmluZWQgPyBvcmlnaW5ZIDogMC41KTtcbiAgICB9XG4gICAgLy8gVHJlYXQgeC95IG5vdCBhcyBzaG9ydGN1dHMgYnV0IGFzIGFjdHVhbCBhdHRyaWJ1dGVzXG4gICAgaWYgKGF0dHJYICE9PSB1bmRlZmluZWQpXG4gICAgICAgIGF0dHJzLnggPSBhdHRyWDtcbiAgICBpZiAoYXR0clkgIT09IHVuZGVmaW5lZClcbiAgICAgICAgYXR0cnMueSA9IGF0dHJZO1xuICAgIC8vIEJ1aWxkIFNWRyBwYXRoIGlmIG9uZSBoYXMgYmVlbiBkZWZpbmVkXG4gICAgaWYgKHBhdGhMZW5ndGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBidWlsZFNWR1BhdGgoYXR0cnMsIHBhdGhMZW5ndGgsIHBhdGhTcGFjaW5nLCBwYXRoT2Zmc2V0LCBmYWxzZSk7XG4gICAgfVxufVxuXG5leHBvcnQgeyBidWlsZFNWR0F0dHJzIH07XG4iLCJpbXBvcnQgeyBfX2Fzc2lnbiB9IGZyb20gJ3RzbGliJztcbmltcG9ydCB7IGNyZWF0ZUh0bWxSZW5kZXJTdGF0ZSB9IGZyb20gJy4uLy4uL2h0bWwvdXRpbHMvY3JlYXRlLXJlbmRlci1zdGF0ZS5tanMnO1xuXG52YXIgY3JlYXRlU3ZnUmVuZGVyU3RhdGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAoX19hc3NpZ24oX19hc3NpZ24oe30sIGNyZWF0ZUh0bWxSZW5kZXJTdGF0ZSgpKSwgeyBhdHRyczoge30gfSkpOyB9O1xuXG5leHBvcnQgeyBjcmVhdGVTdmdSZW5kZXJTdGF0ZSB9O1xuIiwiaW1wb3J0IHsgX19hc3NpZ24gfSBmcm9tICd0c2xpYic7XG5pbXBvcnQgeyB1c2VNZW1vIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgY29weVJhd1ZhbHVlc09ubHkgfSBmcm9tICcuLi9odG1sL3VzZS1wcm9wcy5tanMnO1xuaW1wb3J0IHsgYnVpbGRTVkdBdHRycyB9IGZyb20gJy4vdXRpbHMvYnVpbGQtYXR0cnMubWpzJztcbmltcG9ydCB7IGNyZWF0ZVN2Z1JlbmRlclN0YXRlIH0gZnJvbSAnLi91dGlscy9jcmVhdGUtcmVuZGVyLXN0YXRlLm1qcyc7XG5cbmZ1bmN0aW9uIHVzZVNWR1Byb3BzKHByb3BzLCB2aXN1YWxTdGF0ZSkge1xuICAgIHZhciB2aXN1YWxQcm9wcyA9IHVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc3RhdGUgPSBjcmVhdGVTdmdSZW5kZXJTdGF0ZSgpO1xuICAgICAgICBidWlsZFNWR0F0dHJzKHN0YXRlLCB2aXN1YWxTdGF0ZSwgeyBlbmFibGVIYXJkd2FyZUFjY2VsZXJhdGlvbjogZmFsc2UgfSwgcHJvcHMudHJhbnNmb3JtVGVtcGxhdGUpO1xuICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIHN0YXRlLmF0dHJzKSwgeyBzdHlsZTogX19hc3NpZ24oe30sIHN0YXRlLnN0eWxlKSB9KTtcbiAgICB9LCBbdmlzdWFsU3RhdGVdKTtcbiAgICBpZiAocHJvcHMuc3R5bGUpIHtcbiAgICAgICAgdmFyIHJhd1N0eWxlcyA9IHt9O1xuICAgICAgICBjb3B5UmF3VmFsdWVzT25seShyYXdTdHlsZXMsIHByb3BzLnN0eWxlLCBwcm9wcyk7XG4gICAgICAgIHZpc3VhbFByb3BzLnN0eWxlID0gX19hc3NpZ24oX19hc3NpZ24oe30sIHJhd1N0eWxlcyksIHZpc3VhbFByb3BzLnN0eWxlKTtcbiAgICB9XG4gICAgcmV0dXJuIHZpc3VhbFByb3BzO1xufVxuXG5leHBvcnQgeyB1c2VTVkdQcm9wcyB9O1xuIiwiaW1wb3J0IHsgX19hc3NpZ24gfSBmcm9tICd0c2xpYic7XG5pbXBvcnQgeyBjcmVhdGVFbGVtZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlSFRNTFByb3BzIH0gZnJvbSAnLi4vaHRtbC91c2UtcHJvcHMubWpzJztcbmltcG9ydCB7IGZpbHRlclByb3BzIH0gZnJvbSAnLi91dGlscy9maWx0ZXItcHJvcHMubWpzJztcbmltcG9ydCB7IGlzU1ZHQ29tcG9uZW50IH0gZnJvbSAnLi91dGlscy9pcy1zdmctY29tcG9uZW50Lm1qcyc7XG5pbXBvcnQgeyB1c2VTVkdQcm9wcyB9IGZyb20gJy4uL3N2Zy91c2UtcHJvcHMubWpzJztcblxuZnVuY3Rpb24gY3JlYXRlVXNlUmVuZGVyKGZvcndhcmRNb3Rpb25Qcm9wcykge1xuICAgIGlmIChmb3J3YXJkTW90aW9uUHJvcHMgPT09IHZvaWQgMCkgeyBmb3J3YXJkTW90aW9uUHJvcHMgPSBmYWxzZTsgfVxuICAgIHZhciB1c2VSZW5kZXIgPSBmdW5jdGlvbiAoQ29tcG9uZW50LCBwcm9wcywgcHJvamVjdGlvbklkLCByZWYsIF9hLCBpc1N0YXRpYykge1xuICAgICAgICB2YXIgbGF0ZXN0VmFsdWVzID0gX2EubGF0ZXN0VmFsdWVzO1xuICAgICAgICB2YXIgdXNlVmlzdWFsUHJvcHMgPSBpc1NWR0NvbXBvbmVudChDb21wb25lbnQpXG4gICAgICAgICAgICA/IHVzZVNWR1Byb3BzXG4gICAgICAgICAgICA6IHVzZUhUTUxQcm9wcztcbiAgICAgICAgdmFyIHZpc3VhbFByb3BzID0gdXNlVmlzdWFsUHJvcHMocHJvcHMsIGxhdGVzdFZhbHVlcywgaXNTdGF0aWMpO1xuICAgICAgICB2YXIgZmlsdGVyZWRQcm9wcyA9IGZpbHRlclByb3BzKHByb3BzLCB0eXBlb2YgQ29tcG9uZW50ID09PSBcInN0cmluZ1wiLCBmb3J3YXJkTW90aW9uUHJvcHMpO1xuICAgICAgICB2YXIgZWxlbWVudFByb3BzID0gX19hc3NpZ24oX19hc3NpZ24oX19hc3NpZ24oe30sIGZpbHRlcmVkUHJvcHMpLCB2aXN1YWxQcm9wcyksIHsgcmVmOiByZWYgfSk7XG4gICAgICAgIGlmIChwcm9qZWN0aW9uSWQpIHtcbiAgICAgICAgICAgIGVsZW1lbnRQcm9wc1tcImRhdGEtcHJvamVjdGlvbi1pZFwiXSA9IHByb2plY3Rpb25JZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3JlYXRlRWxlbWVudChDb21wb25lbnQsIGVsZW1lbnRQcm9wcyk7XG4gICAgfTtcbiAgICByZXR1cm4gdXNlUmVuZGVyO1xufVxuXG5leHBvcnQgeyBjcmVhdGVVc2VSZW5kZXIgfTtcbiIsInZhciBDQU1FTF9DQVNFX1BBVFRFUk4gPSAvKFthLXpdKShbQS1aXSkvZztcbnZhciBSRVBMQUNFX1RFTVBMQVRFID0gXCIkMS0kMlwiO1xuLyoqXG4gKiBDb252ZXJ0IGNhbWVsQ2FzZSB0byBkYXNoLWNhc2UgcHJvcGVydGllcy5cbiAqL1xudmFyIGNhbWVsVG9EYXNoID0gZnVuY3Rpb24gKHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZShDQU1FTF9DQVNFX1BBVFRFUk4sIFJFUExBQ0VfVEVNUExBVEUpLnRvTG93ZXJDYXNlKCk7XG59O1xuXG5leHBvcnQgeyBjYW1lbFRvRGFzaCB9O1xuIiwiZnVuY3Rpb24gcmVuZGVySFRNTChlbGVtZW50LCBfYSwgc3R5bGVQcm9wLCBwcm9qZWN0aW9uKSB7XG4gICAgdmFyIHN0eWxlID0gX2Euc3R5bGUsIHZhcnMgPSBfYS52YXJzO1xuICAgIE9iamVjdC5hc3NpZ24oZWxlbWVudC5zdHlsZSwgc3R5bGUsIHByb2plY3Rpb24gJiYgcHJvamVjdGlvbi5nZXRQcm9qZWN0aW9uU3R5bGVzKHN0eWxlUHJvcCkpO1xuICAgIC8vIExvb3Agb3ZlciBhbnkgQ1NTIHZhcmlhYmxlcyBhbmQgYXNzaWduIHRob3NlLlxuICAgIGZvciAodmFyIGtleSBpbiB2YXJzKSB7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkoa2V5LCB2YXJzW2tleV0pO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgcmVuZGVySFRNTCB9O1xuIiwiLyoqXG4gKiBBIHNldCBvZiBhdHRyaWJ1dGUgbmFtZXMgdGhhdCBhcmUgYWx3YXlzIHJlYWQvd3JpdHRlbiBhcyBjYW1lbCBjYXNlLlxuICovXG52YXIgY2FtZWxDYXNlQXR0cmlidXRlcyA9IG5ldyBTZXQoW1xuICAgIFwiYmFzZUZyZXF1ZW5jeVwiLFxuICAgIFwiZGlmZnVzZUNvbnN0YW50XCIsXG4gICAgXCJrZXJuZWxNYXRyaXhcIixcbiAgICBcImtlcm5lbFVuaXRMZW5ndGhcIixcbiAgICBcImtleVNwbGluZXNcIixcbiAgICBcImtleVRpbWVzXCIsXG4gICAgXCJsaW1pdGluZ0NvbmVBbmdsZVwiLFxuICAgIFwibWFya2VySGVpZ2h0XCIsXG4gICAgXCJtYXJrZXJXaWR0aFwiLFxuICAgIFwibnVtT2N0YXZlc1wiLFxuICAgIFwidGFyZ2V0WFwiLFxuICAgIFwidGFyZ2V0WVwiLFxuICAgIFwic3VyZmFjZVNjYWxlXCIsXG4gICAgXCJzcGVjdWxhckNvbnN0YW50XCIsXG4gICAgXCJzcGVjdWxhckV4cG9uZW50XCIsXG4gICAgXCJzdGREZXZpYXRpb25cIixcbiAgICBcInRhYmxlVmFsdWVzXCIsXG4gICAgXCJ2aWV3Qm94XCIsXG4gICAgXCJncmFkaWVudFRyYW5zZm9ybVwiLFxuICAgIFwicGF0aExlbmd0aFwiLFxuXSk7XG5cbmV4cG9ydCB7IGNhbWVsQ2FzZUF0dHJpYnV0ZXMgfTtcbiIsImltcG9ydCB7IGNhbWVsVG9EYXNoIH0gZnJvbSAnLi4vLi4vZG9tL3V0aWxzL2NhbWVsLXRvLWRhc2gubWpzJztcbmltcG9ydCB7IHJlbmRlckhUTUwgfSBmcm9tICcuLi8uLi9odG1sL3V0aWxzL3JlbmRlci5tanMnO1xuaW1wb3J0IHsgY2FtZWxDYXNlQXR0cmlidXRlcyB9IGZyb20gJy4vY2FtZWwtY2FzZS1hdHRycy5tanMnO1xuXG5mdW5jdGlvbiByZW5kZXJTVkcoZWxlbWVudCwgcmVuZGVyU3RhdGUsIF9zdHlsZVByb3AsIHByb2plY3Rpb24pIHtcbiAgICByZW5kZXJIVE1MKGVsZW1lbnQsIHJlbmRlclN0YXRlLCB1bmRlZmluZWQsIHByb2plY3Rpb24pO1xuICAgIGZvciAodmFyIGtleSBpbiByZW5kZXJTdGF0ZS5hdHRycykge1xuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSghY2FtZWxDYXNlQXR0cmlidXRlcy5oYXMoa2V5KSA/IGNhbWVsVG9EYXNoKGtleSkgOiBrZXksIHJlbmRlclN0YXRlLmF0dHJzW2tleV0pO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgcmVuZGVyU1ZHIH07XG4iLCJpbXBvcnQgeyBpc0ZvcmNlZE1vdGlvblZhbHVlIH0gZnJvbSAnLi4vLi4vLi4vbW90aW9uL3V0aWxzL2lzLWZvcmNlZC1tb3Rpb24tdmFsdWUubWpzJztcbmltcG9ydCB7IGlzTW90aW9uVmFsdWUgfSBmcm9tICcuLi8uLi8uLi92YWx1ZS91dGlscy9pcy1tb3Rpb24tdmFsdWUubWpzJztcblxuZnVuY3Rpb24gc2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzKHByb3BzKSB7XG4gICAgdmFyIHN0eWxlID0gcHJvcHMuc3R5bGU7XG4gICAgdmFyIG5ld1ZhbHVlcyA9IHt9O1xuICAgIGZvciAodmFyIGtleSBpbiBzdHlsZSkge1xuICAgICAgICBpZiAoaXNNb3Rpb25WYWx1ZShzdHlsZVtrZXldKSB8fCBpc0ZvcmNlZE1vdGlvblZhbHVlKGtleSwgcHJvcHMpKSB7XG4gICAgICAgICAgICBuZXdWYWx1ZXNba2V5XSA9IHN0eWxlW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ld1ZhbHVlcztcbn1cblxuZXhwb3J0IHsgc2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzIH07XG4iLCJpbXBvcnQgeyBpc01vdGlvblZhbHVlIH0gZnJvbSAnLi4vLi4vLi4vdmFsdWUvdXRpbHMvaXMtbW90aW9uLXZhbHVlLm1qcyc7XG5pbXBvcnQgeyBzY3JhcGVNb3Rpb25WYWx1ZXNGcm9tUHJvcHMgYXMgc2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzJDEgfSBmcm9tICcuLi8uLi9odG1sL3V0aWxzL3NjcmFwZS1tb3Rpb24tdmFsdWVzLm1qcyc7XG5cbmZ1bmN0aW9uIHNjcmFwZU1vdGlvblZhbHVlc0Zyb21Qcm9wcyhwcm9wcykge1xuICAgIHZhciBuZXdWYWx1ZXMgPSBzY3JhcGVNb3Rpb25WYWx1ZXNGcm9tUHJvcHMkMShwcm9wcyk7XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgICAgIGlmIChpc01vdGlvblZhbHVlKHByb3BzW2tleV0pKSB7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0S2V5ID0ga2V5ID09PSBcInhcIiB8fCBrZXkgPT09IFwieVwiID8gXCJhdHRyXCIgKyBrZXkudG9VcHBlckNhc2UoKSA6IGtleTtcbiAgICAgICAgICAgIG5ld1ZhbHVlc1t0YXJnZXRLZXldID0gcHJvcHNba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3VmFsdWVzO1xufVxuXG5leHBvcnQgeyBzY3JhcGVNb3Rpb25WYWx1ZXNGcm9tUHJvcHMgfTtcbiIsImZ1bmN0aW9uIGlzQW5pbWF0aW9uQ29udHJvbHModikge1xuICAgIHJldHVybiB0eXBlb2YgdiA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygdi5zdGFydCA9PT0gXCJmdW5jdGlvblwiO1xufVxuXG5leHBvcnQgeyBpc0FuaW1hdGlvbkNvbnRyb2xzIH07XG4iLCJ2YXIgaXNLZXlmcmFtZXNUYXJnZXQgPSBmdW5jdGlvbiAodikge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHYpO1xufTtcblxuZXhwb3J0IHsgaXNLZXlmcmFtZXNUYXJnZXQgfTtcbiIsImltcG9ydCB7IGlzS2V5ZnJhbWVzVGFyZ2V0IH0gZnJvbSAnLi4vYW5pbWF0aW9uL3V0aWxzL2lzLWtleWZyYW1lcy10YXJnZXQubWpzJztcblxudmFyIGlzQ3VzdG9tVmFsdWUgPSBmdW5jdGlvbiAodikge1xuICAgIHJldHVybiBCb29sZWFuKHYgJiYgdHlwZW9mIHYgPT09IFwib2JqZWN0XCIgJiYgdi5taXggJiYgdi50b1ZhbHVlKTtcbn07XG52YXIgcmVzb2x2ZUZpbmFsVmFsdWVJbktleWZyYW1lcyA9IGZ1bmN0aW9uICh2KSB7XG4gICAgLy8gVE9ETyBtYXliZSB0aHJvdyBpZiB2Lmxlbmd0aCAtIDEgaXMgcGxhY2Vob2xkZXIgdG9rZW4/XG4gICAgcmV0dXJuIGlzS2V5ZnJhbWVzVGFyZ2V0KHYpID8gdlt2Lmxlbmd0aCAtIDFdIHx8IDAgOiB2O1xufTtcblxuZXhwb3J0IHsgaXNDdXN0b21WYWx1ZSwgcmVzb2x2ZUZpbmFsVmFsdWVJbktleWZyYW1lcyB9O1xuIiwiaW1wb3J0IHsgaXNDdXN0b21WYWx1ZSB9IGZyb20gJy4uLy4uL3V0aWxzL3Jlc29sdmUtdmFsdWUubWpzJztcbmltcG9ydCB7IGlzTW90aW9uVmFsdWUgfSBmcm9tICcuL2lzLW1vdGlvbi12YWx1ZS5tanMnO1xuXG4vKipcbiAqIElmIHRoZSBwcm92aWRlZCB2YWx1ZSBpcyBhIE1vdGlvblZhbHVlLCB0aGlzIHJldHVybnMgdGhlIGFjdHVhbCB2YWx1ZSwgb3RoZXJ3aXNlIGp1c3QgdGhlIHZhbHVlIGl0c2VsZlxuICpcbiAqIFRPRE86IFJlbW92ZSBhbmQgbW92ZSB0byBsaWJyYXJ5XG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVNb3Rpb25WYWx1ZSh2YWx1ZSkge1xuICAgIHZhciB1bndyYXBwZWRWYWx1ZSA9IGlzTW90aW9uVmFsdWUodmFsdWUpID8gdmFsdWUuZ2V0KCkgOiB2YWx1ZTtcbiAgICByZXR1cm4gaXNDdXN0b21WYWx1ZSh1bndyYXBwZWRWYWx1ZSlcbiAgICAgICAgPyB1bndyYXBwZWRWYWx1ZS50b1ZhbHVlKClcbiAgICAgICAgOiB1bndyYXBwZWRWYWx1ZTtcbn1cblxuZXhwb3J0IHsgcmVzb2x2ZU1vdGlvblZhbHVlIH07XG4iLCJpbXBvcnQgeyBfX3Jlc3QgfSBmcm9tICd0c2xpYic7XG5pbXBvcnQgeyB1c2VDb250ZXh0IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgaXNBbmltYXRpb25Db250cm9scyB9IGZyb20gJy4uLy4uL2FuaW1hdGlvbi91dGlscy9pcy1hbmltYXRpb24tY29udHJvbHMubWpzJztcbmltcG9ydCB7IFByZXNlbmNlQ29udGV4dCB9IGZyb20gJy4uLy4uL2NvbnRleHQvUHJlc2VuY2VDb250ZXh0Lm1qcyc7XG5pbXBvcnQgeyBjaGVja0lmQ29udHJvbGxpbmdWYXJpYW50cywgY2hlY2tJZlZhcmlhbnROb2RlLCByZXNvbHZlVmFyaWFudEZyb21Qcm9wcyB9IGZyb20gJy4uLy4uL3JlbmRlci91dGlscy92YXJpYW50cy5tanMnO1xuaW1wb3J0IHsgdXNlQ29uc3RhbnQgfSBmcm9tICcuLi8uLi91dGlscy91c2UtY29uc3RhbnQubWpzJztcbmltcG9ydCB7IHJlc29sdmVNb3Rpb25WYWx1ZSB9IGZyb20gJy4uLy4uL3ZhbHVlL3V0aWxzL3Jlc29sdmUtbW90aW9uLXZhbHVlLm1qcyc7XG5pbXBvcnQgeyBNb3Rpb25Db250ZXh0IH0gZnJvbSAnLi4vLi4vY29udGV4dC9Nb3Rpb25Db250ZXh0L2luZGV4Lm1qcyc7XG5cbmZ1bmN0aW9uIG1ha2VTdGF0ZShfYSwgcHJvcHMsIGNvbnRleHQsIHByZXNlbmNlQ29udGV4dCkge1xuICAgIHZhciBzY3JhcGVNb3Rpb25WYWx1ZXNGcm9tUHJvcHMgPSBfYS5zY3JhcGVNb3Rpb25WYWx1ZXNGcm9tUHJvcHMsIGNyZWF0ZVJlbmRlclN0YXRlID0gX2EuY3JlYXRlUmVuZGVyU3RhdGUsIG9uTW91bnQgPSBfYS5vbk1vdW50O1xuICAgIHZhciBzdGF0ZSA9IHtcbiAgICAgICAgbGF0ZXN0VmFsdWVzOiBtYWtlTGF0ZXN0VmFsdWVzKHByb3BzLCBjb250ZXh0LCBwcmVzZW5jZUNvbnRleHQsIHNjcmFwZU1vdGlvblZhbHVlc0Zyb21Qcm9wcyksXG4gICAgICAgIHJlbmRlclN0YXRlOiBjcmVhdGVSZW5kZXJTdGF0ZSgpLFxuICAgIH07XG4gICAgaWYgKG9uTW91bnQpIHtcbiAgICAgICAgc3RhdGUubW91bnQgPSBmdW5jdGlvbiAoaW5zdGFuY2UpIHsgcmV0dXJuIG9uTW91bnQocHJvcHMsIGluc3RhbmNlLCBzdGF0ZSk7IH07XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZTtcbn1cbnZhciBtYWtlVXNlVmlzdWFsU3RhdGUgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChwcm9wcywgaXNTdGF0aWMpIHtcbiAgICAgICAgdmFyIGNvbnRleHQgPSB1c2VDb250ZXh0KE1vdGlvbkNvbnRleHQpO1xuICAgICAgICB2YXIgcHJlc2VuY2VDb250ZXh0ID0gdXNlQ29udGV4dChQcmVzZW5jZUNvbnRleHQpO1xuICAgICAgICByZXR1cm4gaXNTdGF0aWNcbiAgICAgICAgICAgID8gbWFrZVN0YXRlKGNvbmZpZywgcHJvcHMsIGNvbnRleHQsIHByZXNlbmNlQ29udGV4dClcbiAgICAgICAgICAgIDogdXNlQ29uc3RhbnQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYWtlU3RhdGUoY29uZmlnLCBwcm9wcywgY29udGV4dCwgcHJlc2VuY2VDb250ZXh0KTtcbiAgICAgICAgICAgIH0pO1xuICAgIH07XG59O1xuZnVuY3Rpb24gbWFrZUxhdGVzdFZhbHVlcyhwcm9wcywgY29udGV4dCwgcHJlc2VuY2VDb250ZXh0LCBzY3JhcGVNb3Rpb25WYWx1ZXMpIHtcbiAgICB2YXIgdmFsdWVzID0ge307XG4gICAgdmFyIGJsb2NrSW5pdGlhbEFuaW1hdGlvbiA9IChwcmVzZW5jZUNvbnRleHQgPT09IG51bGwgfHwgcHJlc2VuY2VDb250ZXh0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcmVzZW5jZUNvbnRleHQuaW5pdGlhbCkgPT09IGZhbHNlO1xuICAgIHZhciBtb3Rpb25WYWx1ZXMgPSBzY3JhcGVNb3Rpb25WYWx1ZXMocHJvcHMpO1xuICAgIGZvciAodmFyIGtleSBpbiBtb3Rpb25WYWx1ZXMpIHtcbiAgICAgICAgdmFsdWVzW2tleV0gPSByZXNvbHZlTW90aW9uVmFsdWUobW90aW9uVmFsdWVzW2tleV0pO1xuICAgIH1cbiAgICB2YXIgaW5pdGlhbCA9IHByb3BzLmluaXRpYWwsIGFuaW1hdGUgPSBwcm9wcy5hbmltYXRlO1xuICAgIHZhciBpc0NvbnRyb2xsaW5nVmFyaWFudHMgPSBjaGVja0lmQ29udHJvbGxpbmdWYXJpYW50cyhwcm9wcyk7XG4gICAgdmFyIGlzVmFyaWFudE5vZGUgPSBjaGVja0lmVmFyaWFudE5vZGUocHJvcHMpO1xuICAgIGlmIChjb250ZXh0ICYmXG4gICAgICAgIGlzVmFyaWFudE5vZGUgJiZcbiAgICAgICAgIWlzQ29udHJvbGxpbmdWYXJpYW50cyAmJlxuICAgICAgICBwcm9wcy5pbmhlcml0ICE9PSBmYWxzZSkge1xuICAgICAgICBpbml0aWFsICE9PSBudWxsICYmIGluaXRpYWwgIT09IHZvaWQgMCA/IGluaXRpYWwgOiAoaW5pdGlhbCA9IGNvbnRleHQuaW5pdGlhbCk7XG4gICAgICAgIGFuaW1hdGUgIT09IG51bGwgJiYgYW5pbWF0ZSAhPT0gdm9pZCAwID8gYW5pbWF0ZSA6IChhbmltYXRlID0gY29udGV4dC5hbmltYXRlKTtcbiAgICB9XG4gICAgdmFyIGluaXRpYWxBbmltYXRpb25Jc0Jsb2NrZWQgPSBibG9ja0luaXRpYWxBbmltYXRpb24gfHwgaW5pdGlhbCA9PT0gZmFsc2U7XG4gICAgdmFyIHZhcmlhbnRUb1NldCA9IGluaXRpYWxBbmltYXRpb25Jc0Jsb2NrZWQgPyBhbmltYXRlIDogaW5pdGlhbDtcbiAgICBpZiAodmFyaWFudFRvU2V0ICYmXG4gICAgICAgIHR5cGVvZiB2YXJpYW50VG9TZXQgIT09IFwiYm9vbGVhblwiICYmXG4gICAgICAgICFpc0FuaW1hdGlvbkNvbnRyb2xzKHZhcmlhbnRUb1NldCkpIHtcbiAgICAgICAgdmFyIGxpc3QgPSBBcnJheS5pc0FycmF5KHZhcmlhbnRUb1NldCkgPyB2YXJpYW50VG9TZXQgOiBbdmFyaWFudFRvU2V0XTtcbiAgICAgICAgbGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChkZWZpbml0aW9uKSB7XG4gICAgICAgICAgICB2YXIgcmVzb2x2ZWQgPSByZXNvbHZlVmFyaWFudEZyb21Qcm9wcyhwcm9wcywgZGVmaW5pdGlvbik7XG4gICAgICAgICAgICBpZiAoIXJlc29sdmVkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHZhciB0cmFuc2l0aW9uRW5kID0gcmVzb2x2ZWQudHJhbnNpdGlvbkVuZDsgcmVzb2x2ZWQudHJhbnNpdGlvbjsgdmFyIHRhcmdldCA9IF9fcmVzdChyZXNvbHZlZCwgW1widHJhbnNpdGlvbkVuZFwiLCBcInRyYW5zaXRpb25cIl0pO1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIHRhcmdldCkge1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZVRhcmdldCA9IHRhcmdldFtrZXldO1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlVGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogVGFrZSBmaW5hbCBrZXlmcmFtZSBpZiB0aGUgaW5pdGlhbCBhbmltYXRpb24gaXMgYmxvY2tlZCBiZWNhdXNlXG4gICAgICAgICAgICAgICAgICAgICAqIHdlIHdhbnQgdG8gaW5pdGlhbGlzZSBhdCB0aGUgZW5kIG9mIHRoYXQgYmxvY2tlZCBhbmltYXRpb24uXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBpbml0aWFsQW5pbWF0aW9uSXNCbG9ja2VkXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHZhbHVlVGFyZ2V0Lmxlbmd0aCAtIDFcbiAgICAgICAgICAgICAgICAgICAgICAgIDogMDtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVUYXJnZXQgPSB2YWx1ZVRhcmdldFtpbmRleF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZVRhcmdldCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZXNba2V5XSA9IHZhbHVlVGFyZ2V0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiB0cmFuc2l0aW9uRW5kKVxuICAgICAgICAgICAgICAgIHZhbHVlc1trZXldID0gdHJhbnNpdGlvbkVuZFtrZXldO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlcztcbn1cblxuZXhwb3J0IHsgbWFrZVVzZVZpc3VhbFN0YXRlIH07XG4iLCJpbXBvcnQgeyByZW5kZXJTVkcgfSBmcm9tICcuL3V0aWxzL3JlbmRlci5tanMnO1xuaW1wb3J0IHsgc2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzIH0gZnJvbSAnLi91dGlscy9zY3JhcGUtbW90aW9uLXZhbHVlcy5tanMnO1xuaW1wb3J0IHsgbWFrZVVzZVZpc3VhbFN0YXRlIH0gZnJvbSAnLi4vLi4vbW90aW9uL3V0aWxzL3VzZS12aXN1YWwtc3RhdGUubWpzJztcbmltcG9ydCB7IGNyZWF0ZVN2Z1JlbmRlclN0YXRlIH0gZnJvbSAnLi91dGlscy9jcmVhdGUtcmVuZGVyLXN0YXRlLm1qcyc7XG5pbXBvcnQgeyBidWlsZFNWR0F0dHJzIH0gZnJvbSAnLi91dGlscy9idWlsZC1hdHRycy5tanMnO1xuXG52YXIgc3ZnTW90aW9uQ29uZmlnID0ge1xuICAgIHVzZVZpc3VhbFN0YXRlOiBtYWtlVXNlVmlzdWFsU3RhdGUoe1xuICAgICAgICBzY3JhcGVNb3Rpb25WYWx1ZXNGcm9tUHJvcHM6IHNjcmFwZU1vdGlvblZhbHVlc0Zyb21Qcm9wcyxcbiAgICAgICAgY3JlYXRlUmVuZGVyU3RhdGU6IGNyZWF0ZVN2Z1JlbmRlclN0YXRlLFxuICAgICAgICBvbk1vdW50OiBmdW5jdGlvbiAocHJvcHMsIGluc3RhbmNlLCBfYSkge1xuICAgICAgICAgICAgdmFyIHJlbmRlclN0YXRlID0gX2EucmVuZGVyU3RhdGUsIGxhdGVzdFZhbHVlcyA9IF9hLmxhdGVzdFZhbHVlcztcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyU3RhdGUuZGltZW5zaW9ucyA9XG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBpbnN0YW5jZS5nZXRCQm94ID09PVxuICAgICAgICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGluc3RhbmNlLmdldEJCb3goKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBpbnN0YW5jZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgLy8gTW9zdCBsaWtlbHkgdHJ5aW5nIHRvIG1lYXN1cmUgYW4gdW5yZW5kZXJlZCBlbGVtZW50IHVuZGVyIEZpcmVmb3hcbiAgICAgICAgICAgICAgICByZW5kZXJTdGF0ZS5kaW1lbnNpb25zID0ge1xuICAgICAgICAgICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWlsZFNWR0F0dHJzKHJlbmRlclN0YXRlLCBsYXRlc3RWYWx1ZXMsIHsgZW5hYmxlSGFyZHdhcmVBY2NlbGVyYXRpb246IGZhbHNlIH0sIHByb3BzLnRyYW5zZm9ybVRlbXBsYXRlKTtcbiAgICAgICAgICAgIHJlbmRlclNWRyhpbnN0YW5jZSwgcmVuZGVyU3RhdGUpO1xuICAgICAgICB9LFxuICAgIH0pLFxufTtcblxuZXhwb3J0IHsgc3ZnTW90aW9uQ29uZmlnIH07XG4iLCJpbXBvcnQgeyBtYWtlVXNlVmlzdWFsU3RhdGUgfSBmcm9tICcuLi8uLi9tb3Rpb24vdXRpbHMvdXNlLXZpc3VhbC1zdGF0ZS5tanMnO1xuaW1wb3J0IHsgc2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzIH0gZnJvbSAnLi91dGlscy9zY3JhcGUtbW90aW9uLXZhbHVlcy5tanMnO1xuaW1wb3J0IHsgY3JlYXRlSHRtbFJlbmRlclN0YXRlIH0gZnJvbSAnLi91dGlscy9jcmVhdGUtcmVuZGVyLXN0YXRlLm1qcyc7XG5cbnZhciBodG1sTW90aW9uQ29uZmlnID0ge1xuICAgIHVzZVZpc3VhbFN0YXRlOiBtYWtlVXNlVmlzdWFsU3RhdGUoe1xuICAgICAgICBzY3JhcGVNb3Rpb25WYWx1ZXNGcm9tUHJvcHM6IHNjcmFwZU1vdGlvblZhbHVlc0Zyb21Qcm9wcyxcbiAgICAgICAgY3JlYXRlUmVuZGVyU3RhdGU6IGNyZWF0ZUh0bWxSZW5kZXJTdGF0ZSxcbiAgICB9KSxcbn07XG5cbmV4cG9ydCB7IGh0bWxNb3Rpb25Db25maWcgfTtcbiIsImltcG9ydCB7IF9fYXNzaWduIH0gZnJvbSAndHNsaWInO1xuaW1wb3J0IHsgaXNTVkdDb21wb25lbnQgfSBmcm9tICcuL2lzLXN2Zy1jb21wb25lbnQubWpzJztcbmltcG9ydCB7IGNyZWF0ZVVzZVJlbmRlciB9IGZyb20gJy4uL3VzZS1yZW5kZXIubWpzJztcbmltcG9ydCB7IHN2Z01vdGlvbkNvbmZpZyB9IGZyb20gJy4uLy4uL3N2Zy9jb25maWctbW90aW9uLm1qcyc7XG5pbXBvcnQgeyBodG1sTW90aW9uQ29uZmlnIH0gZnJvbSAnLi4vLi4vaHRtbC9jb25maWctbW90aW9uLm1qcyc7XG5cbmZ1bmN0aW9uIGNyZWF0ZURvbU1vdGlvbkNvbmZpZyhDb21wb25lbnQsIF9hLCBwcmVsb2FkZWRGZWF0dXJlcywgY3JlYXRlVmlzdWFsRWxlbWVudCwgcHJvamVjdGlvbk5vZGVDb25zdHJ1Y3Rvcikge1xuICAgIHZhciBfYiA9IF9hLmZvcndhcmRNb3Rpb25Qcm9wcywgZm9yd2FyZE1vdGlvblByb3BzID0gX2IgPT09IHZvaWQgMCA/IGZhbHNlIDogX2I7XG4gICAgdmFyIGJhc2VDb25maWcgPSBpc1NWR0NvbXBvbmVudChDb21wb25lbnQpXG4gICAgICAgID8gc3ZnTW90aW9uQ29uZmlnXG4gICAgICAgIDogaHRtbE1vdGlvbkNvbmZpZztcbiAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIGJhc2VDb25maWcpLCB7IHByZWxvYWRlZEZlYXR1cmVzOiBwcmVsb2FkZWRGZWF0dXJlcywgdXNlUmVuZGVyOiBjcmVhdGVVc2VSZW5kZXIoZm9yd2FyZE1vdGlvblByb3BzKSwgY3JlYXRlVmlzdWFsRWxlbWVudDogY3JlYXRlVmlzdWFsRWxlbWVudCwgcHJvamVjdGlvbk5vZGVDb25zdHJ1Y3RvcjogcHJvamVjdGlvbk5vZGVDb25zdHJ1Y3RvciwgQ29tcG9uZW50OiBDb21wb25lbnQgfSk7XG59XG5cbmV4cG9ydCB7IGNyZWF0ZURvbU1vdGlvbkNvbmZpZyB9O1xuIiwidmFyIEFuaW1hdGlvblR5cGU7XG4oZnVuY3Rpb24gKEFuaW1hdGlvblR5cGUpIHtcbiAgICBBbmltYXRpb25UeXBlW1wiQW5pbWF0ZVwiXSA9IFwiYW5pbWF0ZVwiO1xuICAgIEFuaW1hdGlvblR5cGVbXCJIb3ZlclwiXSA9IFwid2hpbGVIb3ZlclwiO1xuICAgIEFuaW1hdGlvblR5cGVbXCJUYXBcIl0gPSBcIndoaWxlVGFwXCI7XG4gICAgQW5pbWF0aW9uVHlwZVtcIkRyYWdcIl0gPSBcIndoaWxlRHJhZ1wiO1xuICAgIEFuaW1hdGlvblR5cGVbXCJGb2N1c1wiXSA9IFwid2hpbGVGb2N1c1wiO1xuICAgIEFuaW1hdGlvblR5cGVbXCJJblZpZXdcIl0gPSBcIndoaWxlSW5WaWV3XCI7XG4gICAgQW5pbWF0aW9uVHlwZVtcIkV4aXRcIl0gPSBcImV4aXRcIjtcbn0pKEFuaW1hdGlvblR5cGUgfHwgKEFuaW1hdGlvblR5cGUgPSB7fSkpO1xuXG5leHBvcnQgeyBBbmltYXRpb25UeXBlIH07XG4iLCJpbXBvcnQgeyB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5cbmZ1bmN0aW9uIGFkZERvbUV2ZW50KHRhcmdldCwgZXZlbnROYW1lLCBoYW5kbGVyLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0geyBwYXNzaXZlOiB0cnVlIH07IH1cbiAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGhhbmRsZXIsIG9wdGlvbnMpO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGhhbmRsZXIpOyB9O1xufVxuLyoqXG4gKiBBdHRhY2hlcyBhbiBldmVudCBsaXN0ZW5lciBkaXJlY3RseSB0byB0aGUgcHJvdmlkZWQgRE9NIGVsZW1lbnQuXG4gKlxuICogQnlwYXNzaW5nIFJlYWN0J3MgZXZlbnQgc3lzdGVtIGNhbiBiZSBkZXNpcmFibGUsIGZvciBpbnN0YW5jZSB3aGVuIGF0dGFjaGluZyBub24tcGFzc2l2ZVxuICogZXZlbnQgaGFuZGxlcnMuXG4gKlxuICogYGBganN4XG4gKiBjb25zdCByZWYgPSB1c2VSZWYobnVsbClcbiAqXG4gKiB1c2VEb21FdmVudChyZWYsICd3aGVlbCcsIG9uV2hlZWwsIHsgcGFzc2l2ZTogZmFsc2UgfSlcbiAqXG4gKiByZXR1cm4gPGRpdiByZWY9e3JlZn0gLz5cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSByZWYgLSBSZWFjdC5SZWZPYmplY3QgdGhhdCdzIGJlZW4gcHJvdmlkZWQgdG8gdGhlIGVsZW1lbnQgeW91IHdhbnQgdG8gYmluZCB0aGUgbGlzdGVuZXIgdG8uXG4gKiBAcGFyYW0gZXZlbnROYW1lIC0gTmFtZSBvZiB0aGUgZXZlbnQgeW91IHdhbnQgbGlzdGVuIGZvci5cbiAqIEBwYXJhbSBoYW5kbGVyIC0gRnVuY3Rpb24gdG8gZmlyZSB3aGVuIHJlY2VpdmluZyB0aGUgZXZlbnQuXG4gKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgdG8gcGFzcyB0byBgRXZlbnQuYWRkRXZlbnRMaXN0ZW5lcmAuXG4gKlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiB1c2VEb21FdmVudChyZWYsIGV2ZW50TmFtZSwgaGFuZGxlciwgb3B0aW9ucykge1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlbGVtZW50ID0gcmVmLmN1cnJlbnQ7XG4gICAgICAgIGlmIChoYW5kbGVyICYmIGVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBhZGREb21FdmVudChlbGVtZW50LCBldmVudE5hbWUsIGhhbmRsZXIsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfSwgW3JlZiwgZXZlbnROYW1lLCBoYW5kbGVyLCBvcHRpb25zXSk7XG59XG5cbmV4cG9ydCB7IGFkZERvbUV2ZW50LCB1c2VEb21FdmVudCB9O1xuIiwiaW1wb3J0IHsgQW5pbWF0aW9uVHlwZSB9IGZyb20gJy4uL3JlbmRlci91dGlscy90eXBlcy5tanMnO1xuaW1wb3J0IHsgdXNlRG9tRXZlbnQgfSBmcm9tICcuLi9ldmVudHMvdXNlLWRvbS1ldmVudC5tanMnO1xuXG4vKipcbiAqXG4gKiBAcGFyYW0gcHJvcHNcbiAqIEBwYXJhbSByZWZcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiB1c2VGb2N1c0dlc3R1cmUoX2EpIHtcbiAgICB2YXIgd2hpbGVGb2N1cyA9IF9hLndoaWxlRm9jdXMsIHZpc3VhbEVsZW1lbnQgPSBfYS52aXN1YWxFbGVtZW50O1xuICAgIHZhciBvbkZvY3VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IHZpc3VhbEVsZW1lbnQuYW5pbWF0aW9uU3RhdGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zZXRBY3RpdmUoQW5pbWF0aW9uVHlwZS5Gb2N1cywgdHJ1ZSk7XG4gICAgfTtcbiAgICB2YXIgb25CbHVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IHZpc3VhbEVsZW1lbnQuYW5pbWF0aW9uU3RhdGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zZXRBY3RpdmUoQW5pbWF0aW9uVHlwZS5Gb2N1cywgZmFsc2UpO1xuICAgIH07XG4gICAgdXNlRG9tRXZlbnQodmlzdWFsRWxlbWVudCwgXCJmb2N1c1wiLCB3aGlsZUZvY3VzID8gb25Gb2N1cyA6IHVuZGVmaW5lZCk7XG4gICAgdXNlRG9tRXZlbnQodmlzdWFsRWxlbWVudCwgXCJibHVyXCIsIHdoaWxlRm9jdXMgPyBvbkJsdXIgOiB1bmRlZmluZWQpO1xufVxuXG5leHBvcnQgeyB1c2VGb2N1c0dlc3R1cmUgfTtcbiIsImZ1bmN0aW9uIGlzTW91c2VFdmVudChldmVudCkge1xuICAgIC8vIFBvaW50ZXJFdmVudCBpbmhlcml0cyBmcm9tIE1vdXNlRXZlbnQgc28gd2UgY2FuJ3QgdXNlIGEgc3RyYWlnaHQgaW5zdGFuY2VvZiBjaGVjay5cbiAgICBpZiAodHlwZW9mIFBvaW50ZXJFdmVudCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBldmVudCBpbnN0YW5jZW9mIFBvaW50ZXJFdmVudCkge1xuICAgICAgICByZXR1cm4gISEoZXZlbnQucG9pbnRlclR5cGUgPT09IFwibW91c2VcIik7XG4gICAgfVxuICAgIHJldHVybiBldmVudCBpbnN0YW5jZW9mIE1vdXNlRXZlbnQ7XG59XG5mdW5jdGlvbiBpc1RvdWNoRXZlbnQoZXZlbnQpIHtcbiAgICB2YXIgaGFzVG91Y2hlcyA9ICEhZXZlbnQudG91Y2hlcztcbiAgICByZXR1cm4gaGFzVG91Y2hlcztcbn1cblxuZXhwb3J0IHsgaXNNb3VzZUV2ZW50LCBpc1RvdWNoRXZlbnQgfTtcbiIsImltcG9ydCB7IGlzVG91Y2hFdmVudCB9IGZyb20gJy4uL2dlc3R1cmVzL3V0aWxzL2V2ZW50LXR5cGUubWpzJztcblxuLyoqXG4gKiBGaWx0ZXJzIG91dCBldmVudHMgbm90IGF0dGFjaGVkIHRvIHRoZSBwcmltYXJ5IHBvaW50ZXIgKGN1cnJlbnRseSBsZWZ0IG1vdXNlIGJ1dHRvbilcbiAqIEBwYXJhbSBldmVudEhhbmRsZXJcbiAqL1xuZnVuY3Rpb24gZmlsdGVyUHJpbWFyeVBvaW50ZXIoZXZlbnRIYW5kbGVyKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgaXNNb3VzZUV2ZW50ID0gZXZlbnQgaW5zdGFuY2VvZiBNb3VzZUV2ZW50O1xuICAgICAgICB2YXIgaXNQcmltYXJ5UG9pbnRlciA9ICFpc01vdXNlRXZlbnQgfHxcbiAgICAgICAgICAgIChpc01vdXNlRXZlbnQgJiYgZXZlbnQuYnV0dG9uID09PSAwKTtcbiAgICAgICAgaWYgKGlzUHJpbWFyeVBvaW50ZXIpIHtcbiAgICAgICAgICAgIGV2ZW50SGFuZGxlcihldmVudCk7XG4gICAgICAgIH1cbiAgICB9O1xufVxudmFyIGRlZmF1bHRQYWdlUG9pbnQgPSB7IHBhZ2VYOiAwLCBwYWdlWTogMCB9O1xuZnVuY3Rpb24gcG9pbnRGcm9tVG91Y2goZSwgcG9pbnRUeXBlKSB7XG4gICAgaWYgKHBvaW50VHlwZSA9PT0gdm9pZCAwKSB7IHBvaW50VHlwZSA9IFwicGFnZVwiOyB9XG4gICAgdmFyIHByaW1hcnlUb3VjaCA9IGUudG91Y2hlc1swXSB8fCBlLmNoYW5nZWRUb3VjaGVzWzBdO1xuICAgIHZhciBwb2ludCA9IHByaW1hcnlUb3VjaCB8fCBkZWZhdWx0UGFnZVBvaW50O1xuICAgIHJldHVybiB7XG4gICAgICAgIHg6IHBvaW50W3BvaW50VHlwZSArIFwiWFwiXSxcbiAgICAgICAgeTogcG9pbnRbcG9pbnRUeXBlICsgXCJZXCJdLFxuICAgIH07XG59XG5mdW5jdGlvbiBwb2ludEZyb21Nb3VzZShwb2ludCwgcG9pbnRUeXBlKSB7XG4gICAgaWYgKHBvaW50VHlwZSA9PT0gdm9pZCAwKSB7IHBvaW50VHlwZSA9IFwicGFnZVwiOyB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogcG9pbnRbcG9pbnRUeXBlICsgXCJYXCJdLFxuICAgICAgICB5OiBwb2ludFtwb2ludFR5cGUgKyBcIllcIl0sXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGV4dHJhY3RFdmVudEluZm8oZXZlbnQsIHBvaW50VHlwZSkge1xuICAgIGlmIChwb2ludFR5cGUgPT09IHZvaWQgMCkgeyBwb2ludFR5cGUgPSBcInBhZ2VcIjsgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHBvaW50OiBpc1RvdWNoRXZlbnQoZXZlbnQpXG4gICAgICAgICAgICA/IHBvaW50RnJvbVRvdWNoKGV2ZW50LCBwb2ludFR5cGUpXG4gICAgICAgICAgICA6IHBvaW50RnJvbU1vdXNlKGV2ZW50LCBwb2ludFR5cGUpLFxuICAgIH07XG59XG52YXIgd3JhcEhhbmRsZXIgPSBmdW5jdGlvbiAoaGFuZGxlciwgc2hvdWxkRmlsdGVyUHJpbWFyeVBvaW50ZXIpIHtcbiAgICBpZiAoc2hvdWxkRmlsdGVyUHJpbWFyeVBvaW50ZXIgPT09IHZvaWQgMCkgeyBzaG91bGRGaWx0ZXJQcmltYXJ5UG9pbnRlciA9IGZhbHNlOyB9XG4gICAgdmFyIGxpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHJldHVybiBoYW5kbGVyKGV2ZW50LCBleHRyYWN0RXZlbnRJbmZvKGV2ZW50KSk7XG4gICAgfTtcbiAgICByZXR1cm4gc2hvdWxkRmlsdGVyUHJpbWFyeVBvaW50ZXJcbiAgICAgICAgPyBmaWx0ZXJQcmltYXJ5UG9pbnRlcihsaXN0ZW5lcilcbiAgICAgICAgOiBsaXN0ZW5lcjtcbn07XG5cbmV4cG9ydCB7IGV4dHJhY3RFdmVudEluZm8sIHdyYXBIYW5kbGVyIH07XG4iLCJpbXBvcnQgeyBpc0Jyb3dzZXIgfSBmcm9tICcuLi91dGlscy9pcy1icm93c2VyLm1qcyc7XG5cbi8vIFdlIGNoZWNrIGZvciBldmVudCBzdXBwb3J0IHZpYSBmdW5jdGlvbnMgaW4gY2FzZSB0aGV5J3ZlIGJlZW4gbW9ja2VkIGJ5IGEgdGVzdGluZyBzdWl0ZS5cbnZhciBzdXBwb3J0c1BvaW50ZXJFdmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGlzQnJvd3NlciAmJiB3aW5kb3cub25wb2ludGVyZG93biA9PT0gbnVsbDtcbn07XG52YXIgc3VwcG9ydHNUb3VjaEV2ZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gaXNCcm93c2VyICYmIHdpbmRvdy5vbnRvdWNoc3RhcnQgPT09IG51bGw7XG59O1xudmFyIHN1cHBvcnRzTW91c2VFdmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGlzQnJvd3NlciAmJiB3aW5kb3cub25tb3VzZWRvd24gPT09IG51bGw7XG59O1xuXG5leHBvcnQgeyBzdXBwb3J0c01vdXNlRXZlbnRzLCBzdXBwb3J0c1BvaW50ZXJFdmVudHMsIHN1cHBvcnRzVG91Y2hFdmVudHMgfTtcbiIsImltcG9ydCB7IGFkZERvbUV2ZW50LCB1c2VEb21FdmVudCB9IGZyb20gJy4vdXNlLWRvbS1ldmVudC5tanMnO1xuaW1wb3J0IHsgd3JhcEhhbmRsZXIgfSBmcm9tICcuL2V2ZW50LWluZm8ubWpzJztcbmltcG9ydCB7IHN1cHBvcnRzUG9pbnRlckV2ZW50cywgc3VwcG9ydHNUb3VjaEV2ZW50cywgc3VwcG9ydHNNb3VzZUV2ZW50cyB9IGZyb20gJy4vdXRpbHMubWpzJztcblxudmFyIG1vdXNlRXZlbnROYW1lcyA9IHtcbiAgICBwb2ludGVyZG93bjogXCJtb3VzZWRvd25cIixcbiAgICBwb2ludGVybW92ZTogXCJtb3VzZW1vdmVcIixcbiAgICBwb2ludGVydXA6IFwibW91c2V1cFwiLFxuICAgIHBvaW50ZXJjYW5jZWw6IFwibW91c2VjYW5jZWxcIixcbiAgICBwb2ludGVyb3ZlcjogXCJtb3VzZW92ZXJcIixcbiAgICBwb2ludGVyb3V0OiBcIm1vdXNlb3V0XCIsXG4gICAgcG9pbnRlcmVudGVyOiBcIm1vdXNlZW50ZXJcIixcbiAgICBwb2ludGVybGVhdmU6IFwibW91c2VsZWF2ZVwiLFxufTtcbnZhciB0b3VjaEV2ZW50TmFtZXMgPSB7XG4gICAgcG9pbnRlcmRvd246IFwidG91Y2hzdGFydFwiLFxuICAgIHBvaW50ZXJtb3ZlOiBcInRvdWNobW92ZVwiLFxuICAgIHBvaW50ZXJ1cDogXCJ0b3VjaGVuZFwiLFxuICAgIHBvaW50ZXJjYW5jZWw6IFwidG91Y2hjYW5jZWxcIixcbn07XG5mdW5jdGlvbiBnZXRQb2ludGVyRXZlbnROYW1lKG5hbWUpIHtcbiAgICBpZiAoc3VwcG9ydHNQb2ludGVyRXZlbnRzKCkpIHtcbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKHN1cHBvcnRzVG91Y2hFdmVudHMoKSkge1xuICAgICAgICByZXR1cm4gdG91Y2hFdmVudE5hbWVzW25hbWVdO1xuICAgIH1cbiAgICBlbHNlIGlmIChzdXBwb3J0c01vdXNlRXZlbnRzKCkpIHtcbiAgICAgICAgcmV0dXJuIG1vdXNlRXZlbnROYW1lc1tuYW1lXTtcbiAgICB9XG4gICAgcmV0dXJuIG5hbWU7XG59XG5mdW5jdGlvbiBhZGRQb2ludGVyRXZlbnQodGFyZ2V0LCBldmVudE5hbWUsIGhhbmRsZXIsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gYWRkRG9tRXZlbnQodGFyZ2V0LCBnZXRQb2ludGVyRXZlbnROYW1lKGV2ZW50TmFtZSksIHdyYXBIYW5kbGVyKGhhbmRsZXIsIGV2ZW50TmFtZSA9PT0gXCJwb2ludGVyZG93blwiKSwgb3B0aW9ucyk7XG59XG5mdW5jdGlvbiB1c2VQb2ludGVyRXZlbnQocmVmLCBldmVudE5hbWUsIGhhbmRsZXIsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdXNlRG9tRXZlbnQocmVmLCBnZXRQb2ludGVyRXZlbnROYW1lKGV2ZW50TmFtZSksIGhhbmRsZXIgJiYgd3JhcEhhbmRsZXIoaGFuZGxlciwgZXZlbnROYW1lID09PSBcInBvaW50ZXJkb3duXCIpLCBvcHRpb25zKTtcbn1cblxuZXhwb3J0IHsgYWRkUG9pbnRlckV2ZW50LCB1c2VQb2ludGVyRXZlbnQgfTtcbiIsImZ1bmN0aW9uIGNyZWF0ZUxvY2sobmFtZSkge1xuICAgIHZhciBsb2NrID0gbnVsbDtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgb3BlbkxvY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBsb2NrID0gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGxvY2sgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGxvY2sgPSBuYW1lO1xuICAgICAgICAgICAgcmV0dXJuIG9wZW5Mb2NrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xufVxudmFyIGdsb2JhbEhvcml6b250YWxMb2NrID0gY3JlYXRlTG9jayhcImRyYWdIb3Jpem9udGFsXCIpO1xudmFyIGdsb2JhbFZlcnRpY2FsTG9jayA9IGNyZWF0ZUxvY2soXCJkcmFnVmVydGljYWxcIik7XG5mdW5jdGlvbiBnZXRHbG9iYWxMb2NrKGRyYWcpIHtcbiAgICB2YXIgbG9jayA9IGZhbHNlO1xuICAgIGlmIChkcmFnID09PSBcInlcIikge1xuICAgICAgICBsb2NrID0gZ2xvYmFsVmVydGljYWxMb2NrKCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRyYWcgPT09IFwieFwiKSB7XG4gICAgICAgIGxvY2sgPSBnbG9iYWxIb3Jpem9udGFsTG9jaygpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIG9wZW5Ib3Jpem9udGFsXzEgPSBnbG9iYWxIb3Jpem9udGFsTG9jaygpO1xuICAgICAgICB2YXIgb3BlblZlcnRpY2FsXzEgPSBnbG9iYWxWZXJ0aWNhbExvY2soKTtcbiAgICAgICAgaWYgKG9wZW5Ib3Jpem9udGFsXzEgJiYgb3BlblZlcnRpY2FsXzEpIHtcbiAgICAgICAgICAgIGxvY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgb3Blbkhvcml6b250YWxfMSgpO1xuICAgICAgICAgICAgICAgIG9wZW5WZXJ0aWNhbF8xKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gUmVsZWFzZSB0aGUgbG9ja3MgYmVjYXVzZSB3ZSBkb24ndCB1c2UgdGhlbVxuICAgICAgICAgICAgaWYgKG9wZW5Ib3Jpem9udGFsXzEpXG4gICAgICAgICAgICAgICAgb3Blbkhvcml6b250YWxfMSgpO1xuICAgICAgICAgICAgaWYgKG9wZW5WZXJ0aWNhbF8xKVxuICAgICAgICAgICAgICAgIG9wZW5WZXJ0aWNhbF8xKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGxvY2s7XG59XG5mdW5jdGlvbiBpc0RyYWdBY3RpdmUoKSB7XG4gICAgLy8gQ2hlY2sgdGhlIGdlc3R1cmUgbG9jayAtIGlmIHdlIGdldCBpdCwgaXQgbWVhbnMgbm8gZHJhZyBnZXN0dXJlIGlzIGFjdGl2ZVxuICAgIC8vIGFuZCB3ZSBjYW4gc2FmZWx5IGZpcmUgdGhlIHRhcCBnZXN0dXJlLlxuICAgIHZhciBvcGVuR2VzdHVyZUxvY2sgPSBnZXRHbG9iYWxMb2NrKHRydWUpO1xuICAgIGlmICghb3Blbkdlc3R1cmVMb2NrKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBvcGVuR2VzdHVyZUxvY2soKTtcbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCB7IGNyZWF0ZUxvY2ssIGdldEdsb2JhbExvY2ssIGlzRHJhZ0FjdGl2ZSB9O1xuIiwiaW1wb3J0IHsgaXNNb3VzZUV2ZW50IH0gZnJvbSAnLi91dGlscy9ldmVudC10eXBlLm1qcyc7XG5pbXBvcnQgeyBBbmltYXRpb25UeXBlIH0gZnJvbSAnLi4vcmVuZGVyL3V0aWxzL3R5cGVzLm1qcyc7XG5pbXBvcnQgeyB1c2VQb2ludGVyRXZlbnQgfSBmcm9tICcuLi9ldmVudHMvdXNlLXBvaW50ZXItZXZlbnQubWpzJztcbmltcG9ydCB7IGlzRHJhZ0FjdGl2ZSB9IGZyb20gJy4vZHJhZy91dGlscy9sb2NrLm1qcyc7XG5cbmZ1bmN0aW9uIGNyZWF0ZUhvdmVyRXZlbnQodmlzdWFsRWxlbWVudCwgaXNBY3RpdmUsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChldmVudCwgaW5mbykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICghaXNNb3VzZUV2ZW50KGV2ZW50KSB8fCBpc0RyYWdBY3RpdmUoKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuc3VyZSB3ZSB0cmlnZ2VyIGFuaW1hdGlvbnMgYmVmb3JlIGZpcmluZyBldmVudCBjYWxsYmFja1xuICAgICAgICAgKi9cbiAgICAgICAgKF9hID0gdmlzdWFsRWxlbWVudC5hbmltYXRpb25TdGF0ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNldEFjdGl2ZShBbmltYXRpb25UeXBlLkhvdmVyLCBpc0FjdGl2ZSk7XG4gICAgICAgIGNhbGxiYWNrID09PSBudWxsIHx8IGNhbGxiYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYWxsYmFjayhldmVudCwgaW5mbyk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHVzZUhvdmVyR2VzdHVyZShfYSkge1xuICAgIHZhciBvbkhvdmVyU3RhcnQgPSBfYS5vbkhvdmVyU3RhcnQsIG9uSG92ZXJFbmQgPSBfYS5vbkhvdmVyRW5kLCB3aGlsZUhvdmVyID0gX2Eud2hpbGVIb3ZlciwgdmlzdWFsRWxlbWVudCA9IF9hLnZpc3VhbEVsZW1lbnQ7XG4gICAgdXNlUG9pbnRlckV2ZW50KHZpc3VhbEVsZW1lbnQsIFwicG9pbnRlcmVudGVyXCIsIG9uSG92ZXJTdGFydCB8fCB3aGlsZUhvdmVyXG4gICAgICAgID8gY3JlYXRlSG92ZXJFdmVudCh2aXN1YWxFbGVtZW50LCB0cnVlLCBvbkhvdmVyU3RhcnQpXG4gICAgICAgIDogdW5kZWZpbmVkLCB7IHBhc3NpdmU6ICFvbkhvdmVyU3RhcnQgfSk7XG4gICAgdXNlUG9pbnRlckV2ZW50KHZpc3VhbEVsZW1lbnQsIFwicG9pbnRlcmxlYXZlXCIsIG9uSG92ZXJFbmQgfHwgd2hpbGVIb3ZlclxuICAgICAgICA/IGNyZWF0ZUhvdmVyRXZlbnQodmlzdWFsRWxlbWVudCwgZmFsc2UsIG9uSG92ZXJFbmQpXG4gICAgICAgIDogdW5kZWZpbmVkLCB7IHBhc3NpdmU6ICFvbkhvdmVyRW5kIH0pO1xufVxuXG5leHBvcnQgeyB1c2VIb3Zlckdlc3R1cmUgfTtcbiIsIi8qKlxuICogUmVjdXJzaXZlbHkgdHJhdmVyc2UgdXAgdGhlIHRyZWUgdG8gY2hlY2sgd2hldGhlciB0aGUgcHJvdmlkZWQgY2hpbGQgbm9kZVxuICogaXMgdGhlIHBhcmVudCBvciBhIGRlc2NlbmRhbnQgb2YgaXQuXG4gKlxuICogQHBhcmFtIHBhcmVudCAtIEVsZW1lbnQgdG8gZmluZFxuICogQHBhcmFtIGNoaWxkIC0gRWxlbWVudCB0byB0ZXN0IGFnYWluc3QgcGFyZW50XG4gKi9cbnZhciBpc05vZGVPckNoaWxkID0gZnVuY3Rpb24gKHBhcmVudCwgY2hpbGQpIHtcbiAgICBpZiAoIWNoaWxkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZWxzZSBpZiAocGFyZW50ID09PSBjaGlsZCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBpc05vZGVPckNoaWxkKHBhcmVudCwgY2hpbGQucGFyZW50RWxlbWVudCk7XG4gICAgfVxufTtcblxuZXhwb3J0IHsgaXNOb2RlT3JDaGlsZCB9O1xuIiwiaW1wb3J0IHsgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuXG5mdW5jdGlvbiB1c2VVbm1vdW50RWZmZWN0KGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7IHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBjYWxsYmFjaygpOyB9OyB9LCBbXSk7XG59XG5cbmV4cG9ydCB7IHVzZVVubW91bnRFZmZlY3QgfTtcbiIsImNvbnN0IGNvbWJpbmVGdW5jdGlvbnMgPSAoYSwgYikgPT4gKHYpID0+IGIoYSh2KSk7XG5jb25zdCBwaXBlID0gKC4uLnRyYW5zZm9ybWVycykgPT4gdHJhbnNmb3JtZXJzLnJlZHVjZShjb21iaW5lRnVuY3Rpb25zKTtcblxuZXhwb3J0IHsgcGlwZSB9O1xuIiwiaW1wb3J0IHsgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgaXNOb2RlT3JDaGlsZCB9IGZyb20gJy4vdXRpbHMvaXMtbm9kZS1vci1jaGlsZC5tanMnO1xuaW1wb3J0IHsgdXNlUG9pbnRlckV2ZW50LCBhZGRQb2ludGVyRXZlbnQgfSBmcm9tICcuLi9ldmVudHMvdXNlLXBvaW50ZXItZXZlbnQubWpzJztcbmltcG9ydCB7IHVzZVVubW91bnRFZmZlY3QgfSBmcm9tICcuLi91dGlscy91c2UtdW5tb3VudC1lZmZlY3QubWpzJztcbmltcG9ydCB7IHBpcGUgfSBmcm9tICdwb3Btb3Rpb24nO1xuaW1wb3J0IHsgQW5pbWF0aW9uVHlwZSB9IGZyb20gJy4uL3JlbmRlci91dGlscy90eXBlcy5tanMnO1xuaW1wb3J0IHsgaXNEcmFnQWN0aXZlIH0gZnJvbSAnLi9kcmFnL3V0aWxzL2xvY2subWpzJztcblxuLyoqXG4gKiBAcGFyYW0gaGFuZGxlcnMgLVxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIHVzZVRhcEdlc3R1cmUoX2EpIHtcbiAgICB2YXIgb25UYXAgPSBfYS5vblRhcCwgb25UYXBTdGFydCA9IF9hLm9uVGFwU3RhcnQsIG9uVGFwQ2FuY2VsID0gX2Eub25UYXBDYW5jZWwsIHdoaWxlVGFwID0gX2Eud2hpbGVUYXAsIHZpc3VhbEVsZW1lbnQgPSBfYS52aXN1YWxFbGVtZW50O1xuICAgIHZhciBoYXNQcmVzc0xpc3RlbmVycyA9IG9uVGFwIHx8IG9uVGFwU3RhcnQgfHwgb25UYXBDYW5jZWwgfHwgd2hpbGVUYXA7XG4gICAgdmFyIGlzUHJlc3NpbmcgPSB1c2VSZWYoZmFsc2UpO1xuICAgIHZhciBjYW5jZWxQb2ludGVyRW5kTGlzdGVuZXJzID0gdXNlUmVmKG51bGwpO1xuICAgIC8qKlxuICAgICAqIE9ubHkgc2V0IGxpc3RlbmVyIHRvIHBhc3NpdmUgaWYgdGhlcmUgYXJlIG5vIGV4dGVybmFsIGxpc3RlbmVycy5cbiAgICAgKi9cbiAgICB2YXIgZXZlbnRPcHRpb25zID0ge1xuICAgICAgICBwYXNzaXZlOiAhKG9uVGFwU3RhcnQgfHwgb25UYXAgfHwgb25UYXBDYW5jZWwgfHwgb25Qb2ludGVyRG93biksXG4gICAgfTtcbiAgICBmdW5jdGlvbiByZW1vdmVQb2ludGVyRW5kTGlzdGVuZXIoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gY2FuY2VsUG9pbnRlckVuZExpc3RlbmVycy5jdXJyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChjYW5jZWxQb2ludGVyRW5kTGlzdGVuZXJzKTtcbiAgICAgICAgY2FuY2VsUG9pbnRlckVuZExpc3RlbmVycy5jdXJyZW50ID0gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tQb2ludGVyRW5kKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJlbW92ZVBvaW50ZXJFbmRMaXN0ZW5lcigpO1xuICAgICAgICBpc1ByZXNzaW5nLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgKF9hID0gdmlzdWFsRWxlbWVudC5hbmltYXRpb25TdGF0ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNldEFjdGl2ZShBbmltYXRpb25UeXBlLlRhcCwgZmFsc2UpO1xuICAgICAgICByZXR1cm4gIWlzRHJhZ0FjdGl2ZSgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvblBvaW50ZXJVcChldmVudCwgaW5mbykge1xuICAgICAgICBpZiAoIWNoZWNrUG9pbnRlckVuZCgpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2Ugb25seSBjb3VudCB0aGlzIGFzIGEgdGFwIGdlc3R1cmUgaWYgdGhlIGV2ZW50LnRhcmdldCBpcyB0aGUgc2FtZVxuICAgICAgICAgKiBhcywgb3IgYSBjaGlsZCBvZiwgdGhpcyBjb21wb25lbnQncyBlbGVtZW50XG4gICAgICAgICAqL1xuICAgICAgICAhaXNOb2RlT3JDaGlsZCh2aXN1YWxFbGVtZW50LmdldEluc3RhbmNlKCksIGV2ZW50LnRhcmdldClcbiAgICAgICAgICAgID8gb25UYXBDYW5jZWwgPT09IG51bGwgfHwgb25UYXBDYW5jZWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uVGFwQ2FuY2VsKGV2ZW50LCBpbmZvKVxuICAgICAgICAgICAgOiBvblRhcCA9PT0gbnVsbCB8fCBvblRhcCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25UYXAoZXZlbnQsIGluZm8pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvblBvaW50ZXJDYW5jZWwoZXZlbnQsIGluZm8pIHtcbiAgICAgICAgaWYgKCFjaGVja1BvaW50ZXJFbmQoKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgb25UYXBDYW5jZWwgPT09IG51bGwgfHwgb25UYXBDYW5jZWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uVGFwQ2FuY2VsKGV2ZW50LCBpbmZvKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25Qb2ludGVyRG93bihldmVudCwgaW5mbykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJlbW92ZVBvaW50ZXJFbmRMaXN0ZW5lcigpO1xuICAgICAgICBpZiAoaXNQcmVzc2luZy5jdXJyZW50KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpc1ByZXNzaW5nLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICBjYW5jZWxQb2ludGVyRW5kTGlzdGVuZXJzLmN1cnJlbnQgPSBwaXBlKGFkZFBvaW50ZXJFdmVudCh3aW5kb3csIFwicG9pbnRlcnVwXCIsIG9uUG9pbnRlclVwLCBldmVudE9wdGlvbnMpLCBhZGRQb2ludGVyRXZlbnQod2luZG93LCBcInBvaW50ZXJjYW5jZWxcIiwgb25Qb2ludGVyQ2FuY2VsLCBldmVudE9wdGlvbnMpKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVuc3VyZSB3ZSB0cmlnZ2VyIGFuaW1hdGlvbnMgYmVmb3JlIGZpcmluZyBldmVudCBjYWxsYmFja1xuICAgICAgICAgKi9cbiAgICAgICAgKF9hID0gdmlzdWFsRWxlbWVudC5hbmltYXRpb25TdGF0ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNldEFjdGl2ZShBbmltYXRpb25UeXBlLlRhcCwgdHJ1ZSk7XG4gICAgICAgIG9uVGFwU3RhcnQgPT09IG51bGwgfHwgb25UYXBTdGFydCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25UYXBTdGFydChldmVudCwgaW5mbyk7XG4gICAgfVxuICAgIHVzZVBvaW50ZXJFdmVudCh2aXN1YWxFbGVtZW50LCBcInBvaW50ZXJkb3duXCIsIGhhc1ByZXNzTGlzdGVuZXJzID8gb25Qb2ludGVyRG93biA6IHVuZGVmaW5lZCwgZXZlbnRPcHRpb25zKTtcbiAgICB1c2VVbm1vdW50RWZmZWN0KHJlbW92ZVBvaW50ZXJFbmRMaXN0ZW5lcik7XG59XG5cbmV4cG9ydCB7IHVzZVRhcEdlc3R1cmUgfTtcbiIsInZhciB3YXJuZWQgPSBuZXcgU2V0KCk7XG5mdW5jdGlvbiB3YXJuT25jZShjb25kaXRpb24sIG1lc3NhZ2UsIGVsZW1lbnQpIHtcbiAgICBpZiAoY29uZGl0aW9uIHx8IHdhcm5lZC5oYXMobWVzc2FnZSkpXG4gICAgICAgIHJldHVybjtcbiAgICBjb25zb2xlLndhcm4obWVzc2FnZSk7XG4gICAgaWYgKGVsZW1lbnQpXG4gICAgICAgIGNvbnNvbGUud2FybihlbGVtZW50KTtcbiAgICB3YXJuZWQuYWRkKG1lc3NhZ2UpO1xufVxuXG5leHBvcnQgeyB3YXJuT25jZSB9O1xuIiwiaW1wb3J0IHsgX19yZXN0LCBfX2Fzc2lnbiB9IGZyb20gJ3RzbGliJztcblxuLyoqXG4gKiBNYXAgYW4gSW50ZXJzZWN0aW9uSGFuZGxlciBjYWxsYmFjayB0byBhbiBlbGVtZW50LiBXZSBvbmx5IGV2ZXIgbWFrZSBvbmUgaGFuZGxlciBmb3Igb25lXG4gKiBlbGVtZW50LCBzbyBldmVuIHRob3VnaCB0aGVzZSBoYW5kbGVycyBtaWdodCBhbGwgYmUgdHJpZ2dlcmVkIGJ5IGRpZmZlcmVudFxuICogb2JzZXJ2ZXJzLCB3ZSBjYW4ga2VlcCB0aGVtIGluIHRoZSBzYW1lIG1hcC5cbiAqL1xudmFyIG9ic2VydmVyQ2FsbGJhY2tzID0gbmV3IFdlYWtNYXAoKTtcbi8qKlxuICogTXVsdGlwbGUgb2JzZXJ2ZXJzIGNhbiBiZSBjcmVhdGVkIGZvciBtdWx0aXBsZSBlbGVtZW50L2RvY3VtZW50IHJvb3RzLiBFYWNoIHdpdGhcbiAqIGRpZmZlcmVudCBzZXR0aW5ncy4gU28gaGVyZSB3ZSBzdG9yZSBkaWN0aW9uYXJpZXMgb2Ygb2JzZXJ2ZXJzIHRvIGVhY2ggcm9vdCxcbiAqIHVzaW5nIHNlcmlhbGlzZWQgc2V0dGluZ3MgKHRocmVzaG9sZC9tYXJnaW4pIGFzIGxvb2t1cCBrZXlzLlxuICovXG52YXIgb2JzZXJ2ZXJzID0gbmV3IFdlYWtNYXAoKTtcbnZhciBmaXJlT2JzZXJ2ZXJDYWxsYmFjayA9IGZ1bmN0aW9uIChlbnRyeSkge1xuICAgIHZhciBfYTtcbiAgICAoX2EgPSBvYnNlcnZlckNhbGxiYWNrcy5nZXQoZW50cnkudGFyZ2V0KSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hKGVudHJ5KTtcbn07XG52YXIgZmlyZUFsbE9ic2VydmVyQ2FsbGJhY2tzID0gZnVuY3Rpb24gKGVudHJpZXMpIHtcbiAgICBlbnRyaWVzLmZvckVhY2goZmlyZU9ic2VydmVyQ2FsbGJhY2spO1xufTtcbmZ1bmN0aW9uIGluaXRJbnRlcnNlY3Rpb25PYnNlcnZlcihfYSkge1xuICAgIHZhciByb290ID0gX2Eucm9vdCwgb3B0aW9ucyA9IF9fcmVzdChfYSwgW1wicm9vdFwiXSk7XG4gICAgdmFyIGxvb2t1cFJvb3QgPSByb290IHx8IGRvY3VtZW50O1xuICAgIC8qKlxuICAgICAqIElmIHdlIGRvbid0IGhhdmUgYW4gb2JzZXJ2ZXIgbG9va3VwIG1hcCBmb3IgdGhpcyByb290LCBjcmVhdGUgb25lLlxuICAgICAqL1xuICAgIGlmICghb2JzZXJ2ZXJzLmhhcyhsb29rdXBSb290KSkge1xuICAgICAgICBvYnNlcnZlcnMuc2V0KGxvb2t1cFJvb3QsIHt9KTtcbiAgICB9XG4gICAgdmFyIHJvb3RPYnNlcnZlcnMgPSBvYnNlcnZlcnMuZ2V0KGxvb2t1cFJvb3QpO1xuICAgIHZhciBrZXkgPSBKU09OLnN0cmluZ2lmeShvcHRpb25zKTtcbiAgICAvKipcbiAgICAgKiBJZiB3ZSBkb24ndCBoYXZlIGFuIG9ic2VydmVyIGZvciB0aGlzIGNvbWJpbmF0aW9uIG9mIHJvb3QgYW5kIHNldHRpbmdzLFxuICAgICAqIGNyZWF0ZSBvbmUuXG4gICAgICovXG4gICAgaWYgKCFyb290T2JzZXJ2ZXJzW2tleV0pIHtcbiAgICAgICAgcm9vdE9ic2VydmVyc1trZXldID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKGZpcmVBbGxPYnNlcnZlckNhbGxiYWNrcywgX19hc3NpZ24oeyByb290OiByb290IH0sIG9wdGlvbnMpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJvb3RPYnNlcnZlcnNba2V5XTtcbn1cbmZ1bmN0aW9uIG9ic2VydmVJbnRlcnNlY3Rpb24oZWxlbWVudCwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICB2YXIgcm9vdEludGVyZXNlY3Rpb25PYnNlcnZlciA9IGluaXRJbnRlcnNlY3Rpb25PYnNlcnZlcihvcHRpb25zKTtcbiAgICBvYnNlcnZlckNhbGxiYWNrcy5zZXQoZWxlbWVudCwgY2FsbGJhY2spO1xuICAgIHJvb3RJbnRlcmVzZWN0aW9uT2JzZXJ2ZXIub2JzZXJ2ZShlbGVtZW50KTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBvYnNlcnZlckNhbGxiYWNrcy5kZWxldGUoZWxlbWVudCk7XG4gICAgICAgIHJvb3RJbnRlcmVzZWN0aW9uT2JzZXJ2ZXIudW5vYnNlcnZlKGVsZW1lbnQpO1xuICAgIH07XG59XG5cbmV4cG9ydCB7IG9ic2VydmVJbnRlcnNlY3Rpb24gfTtcbiIsImltcG9ydCB7IGVudiB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL3Byb2Nlc3MubWpzJztcbmltcG9ydCB7IHVzZVJlZiwgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgQW5pbWF0aW9uVHlwZSB9IGZyb20gJy4uLy4uLy4uL3JlbmRlci91dGlscy90eXBlcy5tanMnO1xuaW1wb3J0IHsgd2Fybk9uY2UgfSBmcm9tICcuLi8uLi8uLi91dGlscy93YXJuLW9uY2UubWpzJztcbmltcG9ydCB7IG9ic2VydmVJbnRlcnNlY3Rpb24gfSBmcm9tICcuL29ic2VydmVycy5tanMnO1xuXG5mdW5jdGlvbiB1c2VWaWV3cG9ydChfYSkge1xuICAgIHZhciB2aXN1YWxFbGVtZW50ID0gX2EudmlzdWFsRWxlbWVudCwgd2hpbGVJblZpZXcgPSBfYS53aGlsZUluVmlldywgb25WaWV3cG9ydEVudGVyID0gX2Eub25WaWV3cG9ydEVudGVyLCBvblZpZXdwb3J0TGVhdmUgPSBfYS5vblZpZXdwb3J0TGVhdmUsIF9iID0gX2Eudmlld3BvcnQsIHZpZXdwb3J0ID0gX2IgPT09IHZvaWQgMCA/IHt9IDogX2I7XG4gICAgdmFyIHN0YXRlID0gdXNlUmVmKHtcbiAgICAgICAgaGFzRW50ZXJlZFZpZXc6IGZhbHNlLFxuICAgICAgICBpc0luVmlldzogZmFsc2UsXG4gICAgfSk7XG4gICAgdmFyIHNob3VsZE9ic2VydmUgPSBCb29sZWFuKHdoaWxlSW5WaWV3IHx8IG9uVmlld3BvcnRFbnRlciB8fCBvblZpZXdwb3J0TGVhdmUpO1xuICAgIGlmICh2aWV3cG9ydC5vbmNlICYmIHN0YXRlLmN1cnJlbnQuaGFzRW50ZXJlZFZpZXcpXG4gICAgICAgIHNob3VsZE9ic2VydmUgPSBmYWxzZTtcbiAgICB2YXIgdXNlT2JzZXJ2ZXIgPSB0eXBlb2YgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPT09IFwidW5kZWZpbmVkXCJcbiAgICAgICAgPyB1c2VNaXNzaW5nSW50ZXJzZWN0aW9uT2JzZXJ2ZXJcbiAgICAgICAgOiB1c2VJbnRlcnNlY3Rpb25PYnNlcnZlcjtcbiAgICB1c2VPYnNlcnZlcihzaG91bGRPYnNlcnZlLCBzdGF0ZS5jdXJyZW50LCB2aXN1YWxFbGVtZW50LCB2aWV3cG9ydCk7XG59XG52YXIgdGhyZXNob2xkTmFtZXMgPSB7XG4gICAgc29tZTogMCxcbiAgICBhbGw6IDEsXG59O1xuZnVuY3Rpb24gdXNlSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoc2hvdWxkT2JzZXJ2ZSwgc3RhdGUsIHZpc3VhbEVsZW1lbnQsIF9hKSB7XG4gICAgdmFyIHJvb3QgPSBfYS5yb290LCByb290TWFyZ2luID0gX2EubWFyZ2luLCBfYiA9IF9hLmFtb3VudCwgYW1vdW50ID0gX2IgPT09IHZvaWQgMCA/IFwic29tZVwiIDogX2IsIG9uY2UgPSBfYS5vbmNlO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghc2hvdWxkT2JzZXJ2ZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICByb290OiByb290ID09PSBudWxsIHx8IHJvb3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJvb3QuY3VycmVudCxcbiAgICAgICAgICAgIHJvb3RNYXJnaW46IHJvb3RNYXJnaW4sXG4gICAgICAgICAgICB0aHJlc2hvbGQ6IHR5cGVvZiBhbW91bnQgPT09IFwibnVtYmVyXCIgPyBhbW91bnQgOiB0aHJlc2hvbGROYW1lc1thbW91bnRdLFxuICAgICAgICB9O1xuICAgICAgICB2YXIgaW50ZXJzZWN0aW9uQ2FsbGJhY2sgPSBmdW5jdGlvbiAoZW50cnkpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHZhciBpc0ludGVyc2VjdGluZyA9IGVudHJ5LmlzSW50ZXJzZWN0aW5nO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJZiB0aGVyZSdzIGJlZW4gbm8gY2hhbmdlIGluIHRoZSB2aWV3cG9ydCBzdGF0ZSwgZWFybHkgcmV0dXJuLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoc3RhdGUuaXNJblZpZXcgPT09IGlzSW50ZXJzZWN0aW5nKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHN0YXRlLmlzSW5WaWV3ID0gaXNJbnRlcnNlY3Rpbmc7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEhhbmRsZSBoYXNFbnRlcmVkVmlldy4gSWYgdGhpcyBpcyBvbmx5IG1lYW50IHRvIHJ1biBvbmNlLCBhbmRcbiAgICAgICAgICAgICAqIGVsZW1lbnQgaXNuJ3QgdmlzaWJsZSwgZWFybHkgcmV0dXJuLiBPdGhlcndpc2Ugc2V0IGhhc0VudGVyZWRWaWV3IHRvIHRydWUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmIChvbmNlICYmICFpc0ludGVyc2VjdGluZyAmJiBzdGF0ZS5oYXNFbnRlcmVkVmlldykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzSW50ZXJzZWN0aW5nKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUuaGFzRW50ZXJlZFZpZXcgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKF9hID0gdmlzdWFsRWxlbWVudC5hbmltYXRpb25TdGF0ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNldEFjdGl2ZShBbmltYXRpb25UeXBlLkluVmlldywgaXNJbnRlcnNlY3RpbmcpO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBVc2UgdGhlIGxhdGVzdCBjb21taXR0ZWQgcHJvcHMgcmF0aGVyIHRoYW4gdGhlIG9uZXMgaW4gc2NvcGVcbiAgICAgICAgICAgICAqIHdoZW4gdGhpcyBvYnNlcnZlciBpcyBjcmVhdGVkXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZhciBwcm9wcyA9IHZpc3VhbEVsZW1lbnQuZ2V0UHJvcHMoKTtcbiAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IGlzSW50ZXJzZWN0aW5nXG4gICAgICAgICAgICAgICAgPyBwcm9wcy5vblZpZXdwb3J0RW50ZXJcbiAgICAgICAgICAgICAgICA6IHByb3BzLm9uVmlld3BvcnRMZWF2ZTtcbiAgICAgICAgICAgIGNhbGxiYWNrID09PSBudWxsIHx8IGNhbGxiYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYWxsYmFjayhlbnRyeSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBvYnNlcnZlSW50ZXJzZWN0aW9uKHZpc3VhbEVsZW1lbnQuZ2V0SW5zdGFuY2UoKSwgb3B0aW9ucywgaW50ZXJzZWN0aW9uQ2FsbGJhY2spO1xuICAgIH0sIFtzaG91bGRPYnNlcnZlLCByb290LCByb290TWFyZ2luLCBhbW91bnRdKTtcbn1cbi8qKlxuICogSWYgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgaXMgbWlzc2luZywgd2UgYWN0aXZhdGUgaW5WaWV3IGFuZCBmaXJlIG9uVmlld3BvcnRFbnRlclxuICogb24gbW91bnQuIFRoaXMgd2F5LCB0aGUgcGFnZSB3aWxsIGJlIGluIHRoZSBzdGF0ZSB0aGUgYXV0aG9yIGV4cGVjdHMgdXNlcnNcbiAqIHRvIHNlZSBpdCBpbiBmb3IgZXZlcnlvbmUuXG4gKi9cbmZ1bmN0aW9uIHVzZU1pc3NpbmdJbnRlcnNlY3Rpb25PYnNlcnZlcihzaG91bGRPYnNlcnZlLCBzdGF0ZSwgdmlzdWFsRWxlbWVudCwgX2EpIHtcbiAgICB2YXIgX2IgPSBfYS5mYWxsYmFjaywgZmFsbGJhY2sgPSBfYiA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9iO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghc2hvdWxkT2JzZXJ2ZSB8fCAhZmFsbGJhY2spXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChlbnYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICB3YXJuT25jZShmYWxzZSwgXCJJbnRlcnNlY3Rpb25PYnNlcnZlciBub3QgYXZhaWxhYmxlIG9uIHRoaXMgZGV2aWNlLiB3aGlsZUluVmlldyBhbmltYXRpb25zIHdpbGwgdHJpZ2dlciBvbiBtb3VudC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmUgdGhpcyBpbiBhbiByQUYgYmVjYXVzZSwgYXQgdGhpcyBwb2ludCwgdGhlIGFuaW1hdGlvbiBzdGF0ZVxuICAgICAgICAgKiB3b24ndCBoYXZlIGZsdXNoZWQgZm9yIHRoZSBmaXJzdCB0aW1lIGFuZCB0aGVyZSdzIGNlcnRhaW4gbG9naWMgaW5cbiAgICAgICAgICogdGhlcmUgdGhhdCBiZWhhdmVzIGRpZmZlcmVudGx5IG9uIHRoZSBpbml0aWFsIGFuaW1hdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBob29rIHNob3VsZCBiZSBxdWl0ZSByYXJlbHkgY2FsbGVkIHNvIHNldHRpbmcgdGhpcyBpbiBhbiByQUZcbiAgICAgICAgICogaXMgcHJlZmVycmVkIHRvIGNoYW5naW5nIHRoZSBiZWhhdmlvdXIgb2YgdGhlIGFuaW1hdGlvbiBzdGF0ZS5cbiAgICAgICAgICovXG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBzdGF0ZS5oYXNFbnRlcmVkVmlldyA9IHRydWU7XG4gICAgICAgICAgICB2YXIgb25WaWV3cG9ydEVudGVyID0gdmlzdWFsRWxlbWVudC5nZXRQcm9wcygpLm9uVmlld3BvcnRFbnRlcjtcbiAgICAgICAgICAgIG9uVmlld3BvcnRFbnRlciA9PT0gbnVsbCB8fCBvblZpZXdwb3J0RW50ZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uVmlld3BvcnRFbnRlcihudWxsKTtcbiAgICAgICAgICAgIChfYSA9IHZpc3VhbEVsZW1lbnQuYW5pbWF0aW9uU3RhdGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zZXRBY3RpdmUoQW5pbWF0aW9uVHlwZS5JblZpZXcsIHRydWUpO1xuICAgICAgICB9KTtcbiAgICB9LCBbc2hvdWxkT2JzZXJ2ZV0pO1xufVxuXG5leHBvcnQgeyB1c2VWaWV3cG9ydCB9O1xuIiwidmFyIG1ha2VSZW5kZXJsZXNzQ29tcG9uZW50ID0gZnVuY3Rpb24gKGhvb2spIHsgcmV0dXJuIGZ1bmN0aW9uIChwcm9wcykge1xuICAgIGhvb2socHJvcHMpO1xuICAgIHJldHVybiBudWxsO1xufTsgfTtcblxuZXhwb3J0IHsgbWFrZVJlbmRlcmxlc3NDb21wb25lbnQgfTtcbiIsImltcG9ydCB7IHVzZUZvY3VzR2VzdHVyZSB9IGZyb20gJy4uLy4uL2dlc3R1cmVzL3VzZS1mb2N1cy1nZXN0dXJlLm1qcyc7XG5pbXBvcnQgeyB1c2VIb3Zlckdlc3R1cmUgfSBmcm9tICcuLi8uLi9nZXN0dXJlcy91c2UtaG92ZXItZ2VzdHVyZS5tanMnO1xuaW1wb3J0IHsgdXNlVGFwR2VzdHVyZSB9IGZyb20gJy4uLy4uL2dlc3R1cmVzL3VzZS10YXAtZ2VzdHVyZS5tanMnO1xuaW1wb3J0IHsgdXNlVmlld3BvcnQgfSBmcm9tICcuL3ZpZXdwb3J0L3VzZS12aWV3cG9ydC5tanMnO1xuaW1wb3J0IHsgbWFrZVJlbmRlcmxlc3NDb21wb25lbnQgfSBmcm9tICcuLi91dGlscy9tYWtlLXJlbmRlcmxlc3MtY29tcG9uZW50Lm1qcyc7XG5cbnZhciBnZXN0dXJlQW5pbWF0aW9ucyA9IHtcbiAgICBpblZpZXc6IG1ha2VSZW5kZXJsZXNzQ29tcG9uZW50KHVzZVZpZXdwb3J0KSxcbiAgICB0YXA6IG1ha2VSZW5kZXJsZXNzQ29tcG9uZW50KHVzZVRhcEdlc3R1cmUpLFxuICAgIGZvY3VzOiBtYWtlUmVuZGVybGVzc0NvbXBvbmVudCh1c2VGb2N1c0dlc3R1cmUpLFxuICAgIGhvdmVyOiBtYWtlUmVuZGVybGVzc0NvbXBvbmVudCh1c2VIb3Zlckdlc3R1cmUpLFxufTtcblxuZXhwb3J0IHsgZ2VzdHVyZUFuaW1hdGlvbnMgfTtcbiIsImltcG9ydCB7IHVzZUNvbnN0YW50IH0gZnJvbSAnLi91c2UtY29uc3RhbnQubWpzJztcblxudmFyIGNvdW50ZXIgPSAwO1xudmFyIGluY3JlbWVudElkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gY291bnRlcisrOyB9O1xudmFyIHVzZUlkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdXNlQ29uc3RhbnQoaW5jcmVtZW50SWQpOyB9O1xuLyoqXG4gKiBJZGVhbGx5IHdlJ2QgdXNlIHRoZSBmb2xsb3dpbmcgY29kZSB0byBzdXBwb3J0IFJlYWN0IDE4IG9wdGlvbmFsbHkuXG4gKiBCdXQgdGhpcyBmYWlybHkgZmFpbHMgaW4gV2VicGFjayAob3RoZXJ3aXNlIHRyZWVzaGFraW5nIHdvdWxkbid0IHdvcmsgYXQgYWxsKS5cbiAqIE5lZWQgdG8gY29tZSB1cCB3aXRoIGEgZGlmZmVyZW50IHdheSBvZiBmaWd1cmluZyB0aGlzIG91dC5cbiAqL1xuLy8gZXhwb3J0IGNvbnN0IHVzZUlkID0gKFJlYWN0IGFzIGFueSkudXNlSWRcbi8vICAgICA/IChSZWFjdCBhcyBhbnkpLnVzZUlkXG4vLyAgICAgOiAoKSA9PiB1c2VDb25zdGFudChpbmNyZW1lbnRJZClcblxuZXhwb3J0IHsgdXNlSWQgfTtcbiIsImltcG9ydCB7IHVzZUNvbnRleHQsIHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IFByZXNlbmNlQ29udGV4dCB9IGZyb20gJy4uLy4uL2NvbnRleHQvUHJlc2VuY2VDb250ZXh0Lm1qcyc7XG5pbXBvcnQgeyB1c2VJZCB9IGZyb20gJy4uLy4uL3V0aWxzL3VzZS1pZC5tanMnO1xuXG4vKipcbiAqIFdoZW4gYSBjb21wb25lbnQgaXMgdGhlIGNoaWxkIG9mIGBBbmltYXRlUHJlc2VuY2VgLCBpdCBjYW4gdXNlIGB1c2VQcmVzZW5jZWBcbiAqIHRvIGFjY2VzcyBpbmZvcm1hdGlvbiBhYm91dCB3aGV0aGVyIGl0J3Mgc3RpbGwgcHJlc2VudCBpbiB0aGUgUmVhY3QgdHJlZS5cbiAqXG4gKiBgYGBqc3hcbiAqIGltcG9ydCB7IHVzZVByZXNlbmNlIH0gZnJvbSBcImZyYW1lci1tb3Rpb25cIlxuICpcbiAqIGV4cG9ydCBjb25zdCBDb21wb25lbnQgPSAoKSA9PiB7XG4gKiAgIGNvbnN0IFtpc1ByZXNlbnQsIHNhZmVUb1JlbW92ZV0gPSB1c2VQcmVzZW5jZSgpXG4gKlxuICogICB1c2VFZmZlY3QoKCkgPT4ge1xuICogICAgICFpc1ByZXNlbnQgJiYgc2V0VGltZW91dChzYWZlVG9SZW1vdmUsIDEwMDApXG4gKiAgIH0sIFtpc1ByZXNlbnRdKVxuICpcbiAqICAgcmV0dXJuIDxkaXYgLz5cbiAqIH1cbiAqIGBgYFxuICpcbiAqIElmIGBpc1ByZXNlbnRgIGlzIGBmYWxzZWAsIGl0IG1lYW5zIHRoYXQgYSBjb21wb25lbnQgaGFzIGJlZW4gcmVtb3ZlZCB0aGUgdHJlZSwgYnV0XG4gKiBgQW5pbWF0ZVByZXNlbmNlYCB3b24ndCByZWFsbHkgcmVtb3ZlIGl0IHVudGlsIGBzYWZlVG9SZW1vdmVgIGhhcyBiZWVuIGNhbGxlZC5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHVzZVByZXNlbmNlKCkge1xuICAgIHZhciBjb250ZXh0ID0gdXNlQ29udGV4dChQcmVzZW5jZUNvbnRleHQpO1xuICAgIGlmIChjb250ZXh0ID09PSBudWxsKVxuICAgICAgICByZXR1cm4gW3RydWUsIG51bGxdO1xuICAgIHZhciBpc1ByZXNlbnQgPSBjb250ZXh0LmlzUHJlc2VudCwgb25FeGl0Q29tcGxldGUgPSBjb250ZXh0Lm9uRXhpdENvbXBsZXRlLCByZWdpc3RlciA9IGNvbnRleHQucmVnaXN0ZXI7XG4gICAgLy8gSXQncyBzYWZlIHRvIGNhbGwgdGhlIGZvbGxvd2luZyBob29rcyBjb25kaXRpb25hbGx5IChhZnRlciBhbiBlYXJseSByZXR1cm4pIGJlY2F1c2UgdGhlIGNvbnRleHQgd2lsbCBhbHdheXNcbiAgICAvLyBlaXRoZXIgYmUgbnVsbCBvciBub24tbnVsbCBmb3IgdGhlIGxpZmVzcGFuIG9mIHRoZSBjb21wb25lbnQuXG4gICAgLy8gUmVwbGFjZSB3aXRoIHVzZUlkIHdoZW4gcmVsZWFzZWQgaW4gUmVhY3RcbiAgICB2YXIgaWQgPSB1c2VJZCgpO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7IHJldHVybiByZWdpc3RlcihpZCk7IH0sIFtdKTtcbiAgICB2YXIgc2FmZVRvUmVtb3ZlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gb25FeGl0Q29tcGxldGUgPT09IG51bGwgfHwgb25FeGl0Q29tcGxldGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uRXhpdENvbXBsZXRlKGlkKTsgfTtcbiAgICByZXR1cm4gIWlzUHJlc2VudCAmJiBvbkV4aXRDb21wbGV0ZSA/IFtmYWxzZSwgc2FmZVRvUmVtb3ZlXSA6IFt0cnVlXTtcbn1cbi8qKlxuICogU2ltaWxhciB0byBgdXNlUHJlc2VuY2VgLCBleGNlcHQgYHVzZUlzUHJlc2VudGAgc2ltcGx5IHJldHVybnMgd2hldGhlciBvciBub3QgdGhlIGNvbXBvbmVudCBpcyBwcmVzZW50LlxuICogVGhlcmUgaXMgbm8gYHNhZmVUb1JlbW92ZWAgZnVuY3Rpb24uXG4gKlxuICogYGBganN4XG4gKiBpbXBvcnQgeyB1c2VJc1ByZXNlbnQgfSBmcm9tIFwiZnJhbWVyLW1vdGlvblwiXG4gKlxuICogZXhwb3J0IGNvbnN0IENvbXBvbmVudCA9ICgpID0+IHtcbiAqICAgY29uc3QgaXNQcmVzZW50ID0gdXNlSXNQcmVzZW50KClcbiAqXG4gKiAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gKiAgICAgIWlzUHJlc2VudCAmJiBjb25zb2xlLmxvZyhcIkkndmUgYmVlbiByZW1vdmVkIVwiKVxuICogICB9LCBbaXNQcmVzZW50XSlcbiAqXG4gKiAgIHJldHVybiA8ZGl2IC8+XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHVzZUlzUHJlc2VudCgpIHtcbiAgICByZXR1cm4gaXNQcmVzZW50KHVzZUNvbnRleHQoUHJlc2VuY2VDb250ZXh0KSk7XG59XG5mdW5jdGlvbiBpc1ByZXNlbnQoY29udGV4dCkge1xuICAgIHJldHVybiBjb250ZXh0ID09PSBudWxsID8gdHJ1ZSA6IGNvbnRleHQuaXNQcmVzZW50O1xufVxuXG5leHBvcnQgeyBpc1ByZXNlbnQsIHVzZUlzUHJlc2VudCwgdXNlUHJlc2VuY2UgfTtcbiIsImZ1bmN0aW9uIHNoYWxsb3dDb21wYXJlKG5leHQsIHByZXYpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocHJldikpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB2YXIgcHJldkxlbmd0aCA9IHByZXYubGVuZ3RoO1xuICAgIGlmIChwcmV2TGVuZ3RoICE9PSBuZXh0Lmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJldkxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChwcmV2W2ldICE9PSBuZXh0W2ldKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuZXhwb3J0IHsgc2hhbGxvd0NvbXBhcmUgfTtcbiIsImNvbnN0IGNsYW1wID0gKG1pbiwgbWF4LCB2KSA9PiBNYXRoLm1pbihNYXRoLm1heCh2LCBtaW4pLCBtYXgpO1xuXG5leHBvcnQgeyBjbGFtcCB9O1xuIiwiaW1wb3J0IHsgd2FybmluZyB9IGZyb20gJ2hleS1saXN0ZW4nO1xuaW1wb3J0IHsgY2xhbXAgfSBmcm9tICcuLi8uLi91dGlscy9jbGFtcC5tanMnO1xuXG5jb25zdCBzYWZlTWluID0gMC4wMDE7XG5jb25zdCBtaW5EdXJhdGlvbiA9IDAuMDE7XG5jb25zdCBtYXhEdXJhdGlvbiA9IDEwLjA7XG5jb25zdCBtaW5EYW1waW5nID0gMC4wNTtcbmNvbnN0IG1heERhbXBpbmcgPSAxO1xuZnVuY3Rpb24gZmluZFNwcmluZyh7IGR1cmF0aW9uID0gODAwLCBib3VuY2UgPSAwLjI1LCB2ZWxvY2l0eSA9IDAsIG1hc3MgPSAxLCB9KSB7XG4gICAgbGV0IGVudmVsb3BlO1xuICAgIGxldCBkZXJpdmF0aXZlO1xuICAgIHdhcm5pbmcoZHVyYXRpb24gPD0gbWF4RHVyYXRpb24gKiAxMDAwLCBcIlNwcmluZyBkdXJhdGlvbiBtdXN0IGJlIDEwIHNlY29uZHMgb3IgbGVzc1wiKTtcbiAgICBsZXQgZGFtcGluZ1JhdGlvID0gMSAtIGJvdW5jZTtcbiAgICBkYW1waW5nUmF0aW8gPSBjbGFtcChtaW5EYW1waW5nLCBtYXhEYW1waW5nLCBkYW1waW5nUmF0aW8pO1xuICAgIGR1cmF0aW9uID0gY2xhbXAobWluRHVyYXRpb24sIG1heER1cmF0aW9uLCBkdXJhdGlvbiAvIDEwMDApO1xuICAgIGlmIChkYW1waW5nUmF0aW8gPCAxKSB7XG4gICAgICAgIGVudmVsb3BlID0gKHVuZGFtcGVkRnJlcSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZXhwb25lbnRpYWxEZWNheSA9IHVuZGFtcGVkRnJlcSAqIGRhbXBpbmdSYXRpbztcbiAgICAgICAgICAgIGNvbnN0IGRlbHRhID0gZXhwb25lbnRpYWxEZWNheSAqIGR1cmF0aW9uO1xuICAgICAgICAgICAgY29uc3QgYSA9IGV4cG9uZW50aWFsRGVjYXkgLSB2ZWxvY2l0eTtcbiAgICAgICAgICAgIGNvbnN0IGIgPSBjYWxjQW5ndWxhckZyZXEodW5kYW1wZWRGcmVxLCBkYW1waW5nUmF0aW8pO1xuICAgICAgICAgICAgY29uc3QgYyA9IE1hdGguZXhwKC1kZWx0YSk7XG4gICAgICAgICAgICByZXR1cm4gc2FmZU1pbiAtIChhIC8gYikgKiBjO1xuICAgICAgICB9O1xuICAgICAgICBkZXJpdmF0aXZlID0gKHVuZGFtcGVkRnJlcSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZXhwb25lbnRpYWxEZWNheSA9IHVuZGFtcGVkRnJlcSAqIGRhbXBpbmdSYXRpbztcbiAgICAgICAgICAgIGNvbnN0IGRlbHRhID0gZXhwb25lbnRpYWxEZWNheSAqIGR1cmF0aW9uO1xuICAgICAgICAgICAgY29uc3QgZCA9IGRlbHRhICogdmVsb2NpdHkgKyB2ZWxvY2l0eTtcbiAgICAgICAgICAgIGNvbnN0IGUgPSBNYXRoLnBvdyhkYW1waW5nUmF0aW8sIDIpICogTWF0aC5wb3codW5kYW1wZWRGcmVxLCAyKSAqIGR1cmF0aW9uO1xuICAgICAgICAgICAgY29uc3QgZiA9IE1hdGguZXhwKC1kZWx0YSk7XG4gICAgICAgICAgICBjb25zdCBnID0gY2FsY0FuZ3VsYXJGcmVxKE1hdGgucG93KHVuZGFtcGVkRnJlcSwgMiksIGRhbXBpbmdSYXRpbyk7XG4gICAgICAgICAgICBjb25zdCBmYWN0b3IgPSAtZW52ZWxvcGUodW5kYW1wZWRGcmVxKSArIHNhZmVNaW4gPiAwID8gLTEgOiAxO1xuICAgICAgICAgICAgcmV0dXJuIChmYWN0b3IgKiAoKGQgLSBlKSAqIGYpKSAvIGc7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBlbnZlbG9wZSA9ICh1bmRhbXBlZEZyZXEpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGEgPSBNYXRoLmV4cCgtdW5kYW1wZWRGcmVxICogZHVyYXRpb24pO1xuICAgICAgICAgICAgY29uc3QgYiA9ICh1bmRhbXBlZEZyZXEgLSB2ZWxvY2l0eSkgKiBkdXJhdGlvbiArIDE7XG4gICAgICAgICAgICByZXR1cm4gLXNhZmVNaW4gKyBhICogYjtcbiAgICAgICAgfTtcbiAgICAgICAgZGVyaXZhdGl2ZSA9ICh1bmRhbXBlZEZyZXEpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGEgPSBNYXRoLmV4cCgtdW5kYW1wZWRGcmVxICogZHVyYXRpb24pO1xuICAgICAgICAgICAgY29uc3QgYiA9ICh2ZWxvY2l0eSAtIHVuZGFtcGVkRnJlcSkgKiAoZHVyYXRpb24gKiBkdXJhdGlvbik7XG4gICAgICAgICAgICByZXR1cm4gYSAqIGI7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGluaXRpYWxHdWVzcyA9IDUgLyBkdXJhdGlvbjtcbiAgICBjb25zdCB1bmRhbXBlZEZyZXEgPSBhcHByb3hpbWF0ZVJvb3QoZW52ZWxvcGUsIGRlcml2YXRpdmUsIGluaXRpYWxHdWVzcyk7XG4gICAgZHVyYXRpb24gPSBkdXJhdGlvbiAqIDEwMDA7XG4gICAgaWYgKGlzTmFOKHVuZGFtcGVkRnJlcSkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0aWZmbmVzczogMTAwLFxuICAgICAgICAgICAgZGFtcGluZzogMTAsXG4gICAgICAgICAgICBkdXJhdGlvbixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHN0aWZmbmVzcyA9IE1hdGgucG93KHVuZGFtcGVkRnJlcSwgMikgKiBtYXNzO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RpZmZuZXNzLFxuICAgICAgICAgICAgZGFtcGluZzogZGFtcGluZ1JhdGlvICogMiAqIE1hdGguc3FydChtYXNzICogc3RpZmZuZXNzKSxcbiAgICAgICAgICAgIGR1cmF0aW9uLFxuICAgICAgICB9O1xuICAgIH1cbn1cbmNvbnN0IHJvb3RJdGVyYXRpb25zID0gMTI7XG5mdW5jdGlvbiBhcHByb3hpbWF0ZVJvb3QoZW52ZWxvcGUsIGRlcml2YXRpdmUsIGluaXRpYWxHdWVzcykge1xuICAgIGxldCByZXN1bHQgPSBpbml0aWFsR3Vlc3M7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCByb290SXRlcmF0aW9uczsgaSsrKSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdCAtIGVudmVsb3BlKHJlc3VsdCkgLyBkZXJpdmF0aXZlKHJlc3VsdCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBjYWxjQW5ndWxhckZyZXEodW5kYW1wZWRGcmVxLCBkYW1waW5nUmF0aW8pIHtcbiAgICByZXR1cm4gdW5kYW1wZWRGcmVxICogTWF0aC5zcXJ0KDEgLSBkYW1waW5nUmF0aW8gKiBkYW1waW5nUmF0aW8pO1xufVxuXG5leHBvcnQgeyBjYWxjQW5ndWxhckZyZXEsIGZpbmRTcHJpbmcsIG1heERhbXBpbmcsIG1heER1cmF0aW9uLCBtaW5EYW1waW5nLCBtaW5EdXJhdGlvbiB9O1xuIiwiaW1wb3J0IHsgX19yZXN0IH0gZnJvbSAndHNsaWInO1xuaW1wb3J0IHsgZmluZFNwcmluZywgY2FsY0FuZ3VsYXJGcmVxIH0gZnJvbSAnLi4vdXRpbHMvZmluZC1zcHJpbmcubWpzJztcblxuY29uc3QgZHVyYXRpb25LZXlzID0gW1wiZHVyYXRpb25cIiwgXCJib3VuY2VcIl07XG5jb25zdCBwaHlzaWNzS2V5cyA9IFtcInN0aWZmbmVzc1wiLCBcImRhbXBpbmdcIiwgXCJtYXNzXCJdO1xuZnVuY3Rpb24gaXNTcHJpbmdUeXBlKG9wdGlvbnMsIGtleXMpIHtcbiAgICByZXR1cm4ga2V5cy5zb21lKChrZXkpID0+IG9wdGlvbnNba2V5XSAhPT0gdW5kZWZpbmVkKTtcbn1cbmZ1bmN0aW9uIGdldFNwcmluZ09wdGlvbnMob3B0aW9ucykge1xuICAgIGxldCBzcHJpbmdPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7IHZlbG9jaXR5OiAwLjAsIHN0aWZmbmVzczogMTAwLCBkYW1waW5nOiAxMCwgbWFzczogMS4wLCBpc1Jlc29sdmVkRnJvbUR1cmF0aW9uOiBmYWxzZSB9LCBvcHRpb25zKTtcbiAgICBpZiAoIWlzU3ByaW5nVHlwZShvcHRpb25zLCBwaHlzaWNzS2V5cykgJiZcbiAgICAgICAgaXNTcHJpbmdUeXBlKG9wdGlvbnMsIGR1cmF0aW9uS2V5cykpIHtcbiAgICAgICAgY29uc3QgZGVyaXZlZCA9IGZpbmRTcHJpbmcob3B0aW9ucyk7XG4gICAgICAgIHNwcmluZ09wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc3ByaW5nT3B0aW9ucyksIGRlcml2ZWQpLCB7IHZlbG9jaXR5OiAwLjAsIG1hc3M6IDEuMCB9KTtcbiAgICAgICAgc3ByaW5nT3B0aW9ucy5pc1Jlc29sdmVkRnJvbUR1cmF0aW9uID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHNwcmluZ09wdGlvbnM7XG59XG5mdW5jdGlvbiBzcHJpbmcoX2EpIHtcbiAgICB2YXIgeyBmcm9tID0gMC4wLCB0byA9IDEuMCwgcmVzdFNwZWVkID0gMiwgcmVzdERlbHRhIH0gPSBfYSwgb3B0aW9ucyA9IF9fcmVzdChfYSwgW1wiZnJvbVwiLCBcInRvXCIsIFwicmVzdFNwZWVkXCIsIFwicmVzdERlbHRhXCJdKTtcbiAgICBjb25zdCBzdGF0ZSA9IHsgZG9uZTogZmFsc2UsIHZhbHVlOiBmcm9tIH07XG4gICAgbGV0IHsgc3RpZmZuZXNzLCBkYW1waW5nLCBtYXNzLCB2ZWxvY2l0eSwgZHVyYXRpb24sIGlzUmVzb2x2ZWRGcm9tRHVyYXRpb24sIH0gPSBnZXRTcHJpbmdPcHRpb25zKG9wdGlvbnMpO1xuICAgIGxldCByZXNvbHZlU3ByaW5nID0gemVybztcbiAgICBsZXQgcmVzb2x2ZVZlbG9jaXR5ID0gemVybztcbiAgICBmdW5jdGlvbiBjcmVhdGVTcHJpbmcoKSB7XG4gICAgICAgIGNvbnN0IGluaXRpYWxWZWxvY2l0eSA9IHZlbG9jaXR5ID8gLSh2ZWxvY2l0eSAvIDEwMDApIDogMC4wO1xuICAgICAgICBjb25zdCBpbml0aWFsRGVsdGEgPSB0byAtIGZyb207XG4gICAgICAgIGNvbnN0IGRhbXBpbmdSYXRpbyA9IGRhbXBpbmcgLyAoMiAqIE1hdGguc3FydChzdGlmZm5lc3MgKiBtYXNzKSk7XG4gICAgICAgIGNvbnN0IHVuZGFtcGVkQW5ndWxhckZyZXEgPSBNYXRoLnNxcnQoc3RpZmZuZXNzIC8gbWFzcykgLyAxMDAwO1xuICAgICAgICBpZiAocmVzdERlbHRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlc3REZWx0YSA9IE1hdGgubWluKE1hdGguYWJzKHRvIC0gZnJvbSkgLyAxMDAsIDAuNCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhbXBpbmdSYXRpbyA8IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IGFuZ3VsYXJGcmVxID0gY2FsY0FuZ3VsYXJGcmVxKHVuZGFtcGVkQW5ndWxhckZyZXEsIGRhbXBpbmdSYXRpbyk7XG4gICAgICAgICAgICByZXNvbHZlU3ByaW5nID0gKHQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbnZlbG9wZSA9IE1hdGguZXhwKC1kYW1waW5nUmF0aW8gKiB1bmRhbXBlZEFuZ3VsYXJGcmVxICogdCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh0byAtXG4gICAgICAgICAgICAgICAgICAgIGVudmVsb3BlICpcbiAgICAgICAgICAgICAgICAgICAgICAgICgoKGluaXRpYWxWZWxvY2l0eSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGFtcGluZ1JhdGlvICogdW5kYW1wZWRBbmd1bGFyRnJlcSAqIGluaXRpYWxEZWx0YSkgL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuZ3VsYXJGcmVxKSAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5zaW4oYW5ndWxhckZyZXEgKiB0KSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbERlbHRhICogTWF0aC5jb3MoYW5ndWxhckZyZXEgKiB0KSkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlc29sdmVWZWxvY2l0eSA9ICh0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZW52ZWxvcGUgPSBNYXRoLmV4cCgtZGFtcGluZ1JhdGlvICogdW5kYW1wZWRBbmd1bGFyRnJlcSAqIHQpO1xuICAgICAgICAgICAgICAgIHJldHVybiAoZGFtcGluZ1JhdGlvICpcbiAgICAgICAgICAgICAgICAgICAgdW5kYW1wZWRBbmd1bGFyRnJlcSAqXG4gICAgICAgICAgICAgICAgICAgIGVudmVsb3BlICpcbiAgICAgICAgICAgICAgICAgICAgKChNYXRoLnNpbihhbmd1bGFyRnJlcSAqIHQpICpcbiAgICAgICAgICAgICAgICAgICAgICAgIChpbml0aWFsVmVsb2NpdHkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhbXBpbmdSYXRpbyAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuZGFtcGVkQW5ndWxhckZyZXEgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbml0aWFsRGVsdGEpKSAvXG4gICAgICAgICAgICAgICAgICAgICAgICBhbmd1bGFyRnJlcSArXG4gICAgICAgICAgICAgICAgICAgICAgICBpbml0aWFsRGVsdGEgKiBNYXRoLmNvcyhhbmd1bGFyRnJlcSAqIHQpKSAtXG4gICAgICAgICAgICAgICAgICAgIGVudmVsb3BlICpcbiAgICAgICAgICAgICAgICAgICAgICAgIChNYXRoLmNvcyhhbmd1bGFyRnJlcSAqIHQpICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoaW5pdGlhbFZlbG9jaXR5ICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGFtcGluZ1JhdGlvICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuZGFtcGVkQW5ndWxhckZyZXEgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbERlbHRhKSAtXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5ndWxhckZyZXEgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbml0aWFsRGVsdGEgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLnNpbihhbmd1bGFyRnJlcSAqIHQpKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRhbXBpbmdSYXRpbyA9PT0gMSkge1xuICAgICAgICAgICAgcmVzb2x2ZVNwcmluZyA9ICh0KSA9PiB0byAtXG4gICAgICAgICAgICAgICAgTWF0aC5leHAoLXVuZGFtcGVkQW5ndWxhckZyZXEgKiB0KSAqXG4gICAgICAgICAgICAgICAgICAgIChpbml0aWFsRGVsdGEgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKGluaXRpYWxWZWxvY2l0eSArIHVuZGFtcGVkQW5ndWxhckZyZXEgKiBpbml0aWFsRGVsdGEpICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGRhbXBlZEFuZ3VsYXJGcmVxID0gdW5kYW1wZWRBbmd1bGFyRnJlcSAqIE1hdGguc3FydChkYW1waW5nUmF0aW8gKiBkYW1waW5nUmF0aW8gLSAxKTtcbiAgICAgICAgICAgIHJlc29sdmVTcHJpbmcgPSAodCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVudmVsb3BlID0gTWF0aC5leHAoLWRhbXBpbmdSYXRpbyAqIHVuZGFtcGVkQW5ndWxhckZyZXEgKiB0KTtcbiAgICAgICAgICAgICAgICBjb25zdCBmcmVxRm9yVCA9IE1hdGgubWluKGRhbXBlZEFuZ3VsYXJGcmVxICogdCwgMzAwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHRvIC1cbiAgICAgICAgICAgICAgICAgICAgKGVudmVsb3BlICpcbiAgICAgICAgICAgICAgICAgICAgICAgICgoaW5pdGlhbFZlbG9jaXR5ICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYW1waW5nUmF0aW8gKiB1bmRhbXBlZEFuZ3VsYXJGcmVxICogaW5pdGlhbERlbHRhKSAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5zaW5oKGZyZXFGb3JUKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGFtcGVkQW5ndWxhckZyZXEgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbml0aWFsRGVsdGEgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLmNvc2goZnJlcUZvclQpKSkgL1xuICAgICAgICAgICAgICAgICAgICAgICAgZGFtcGVkQW5ndWxhckZyZXEpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjcmVhdGVTcHJpbmcoKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBuZXh0OiAodCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudCA9IHJlc29sdmVTcHJpbmcodCk7XG4gICAgICAgICAgICBpZiAoIWlzUmVzb2x2ZWRGcm9tRHVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50VmVsb2NpdHkgPSByZXNvbHZlVmVsb2NpdHkodCkgKiAxMDAwO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzQmVsb3dWZWxvY2l0eVRocmVzaG9sZCA9IE1hdGguYWJzKGN1cnJlbnRWZWxvY2l0eSkgPD0gcmVzdFNwZWVkO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzQmVsb3dEaXNwbGFjZW1lbnRUaHJlc2hvbGQgPSBNYXRoLmFicyh0byAtIGN1cnJlbnQpIDw9IHJlc3REZWx0YTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5kb25lID1cbiAgICAgICAgICAgICAgICAgICAgaXNCZWxvd1ZlbG9jaXR5VGhyZXNob2xkICYmIGlzQmVsb3dEaXNwbGFjZW1lbnRUaHJlc2hvbGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5kb25lID0gdCA+PSBkdXJhdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YXRlLnZhbHVlID0gc3RhdGUuZG9uZSA/IHRvIDogY3VycmVudDtcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgICAgfSxcbiAgICAgICAgZmxpcFRhcmdldDogKCkgPT4ge1xuICAgICAgICAgICAgdmVsb2NpdHkgPSAtdmVsb2NpdHk7XG4gICAgICAgICAgICBbZnJvbSwgdG9dID0gW3RvLCBmcm9tXTtcbiAgICAgICAgICAgIGNyZWF0ZVNwcmluZygpO1xuICAgICAgICB9LFxuICAgIH07XG59XG5zcHJpbmcubmVlZHNJbnRlcnBvbGF0aW9uID0gKGEsIGIpID0+IHR5cGVvZiBhID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBiID09PSBcInN0cmluZ1wiO1xuY29uc3QgemVybyA9IChfdCkgPT4gMDtcblxuZXhwb3J0IHsgc3ByaW5nIH07XG4iLCJjb25zdCBwcm9ncmVzcyA9IChmcm9tLCB0bywgdmFsdWUpID0+IHtcbiAgICBjb25zdCB0b0Zyb21EaWZmZXJlbmNlID0gdG8gLSBmcm9tO1xuICAgIHJldHVybiB0b0Zyb21EaWZmZXJlbmNlID09PSAwID8gMSA6ICh2YWx1ZSAtIGZyb20pIC8gdG9Gcm9tRGlmZmVyZW5jZTtcbn07XG5cbmV4cG9ydCB7IHByb2dyZXNzIH07XG4iLCJjb25zdCBtaXggPSAoZnJvbSwgdG8sIHByb2dyZXNzKSA9PiAtcHJvZ3Jlc3MgKiBmcm9tICsgcHJvZ3Jlc3MgKiB0byArIGZyb207XG5cbmV4cG9ydCB7IG1peCB9O1xuIiwiaW1wb3J0IHsgaXNTdHJpbmcsIHNpbmdsZUNvbG9yUmVnZXgsIGZsb2F0UmVnZXggfSBmcm9tICcuLi91dGlscy5tanMnO1xuXG5jb25zdCBpc0NvbG9yU3RyaW5nID0gKHR5cGUsIHRlc3RQcm9wKSA9PiAodikgPT4ge1xuICAgIHJldHVybiBCb29sZWFuKChpc1N0cmluZyh2KSAmJiBzaW5nbGVDb2xvclJlZ2V4LnRlc3QodikgJiYgdi5zdGFydHNXaXRoKHR5cGUpKSB8fFxuICAgICAgICAodGVzdFByb3AgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHYsIHRlc3RQcm9wKSkpO1xufTtcbmNvbnN0IHNwbGl0Q29sb3IgPSAoYU5hbWUsIGJOYW1lLCBjTmFtZSkgPT4gKHYpID0+IHtcbiAgICBpZiAoIWlzU3RyaW5nKHYpKVxuICAgICAgICByZXR1cm4gdjtcbiAgICBjb25zdCBbYSwgYiwgYywgYWxwaGFdID0gdi5tYXRjaChmbG9hdFJlZ2V4KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBbYU5hbWVdOiBwYXJzZUZsb2F0KGEpLFxuICAgICAgICBbYk5hbWVdOiBwYXJzZUZsb2F0KGIpLFxuICAgICAgICBbY05hbWVdOiBwYXJzZUZsb2F0KGMpLFxuICAgICAgICBhbHBoYTogYWxwaGEgIT09IHVuZGVmaW5lZCA/IHBhcnNlRmxvYXQoYWxwaGEpIDogMSxcbiAgICB9O1xufTtcblxuZXhwb3J0IHsgaXNDb2xvclN0cmluZywgc3BsaXRDb2xvciB9O1xuIiwiaW1wb3J0IHsgbnVtYmVyLCBhbHBoYSB9IGZyb20gJy4uL251bWJlcnMvaW5kZXgubWpzJztcbmltcG9ydCB7IHNhbml0aXplLCBjbGFtcCB9IGZyb20gJy4uL3V0aWxzLm1qcyc7XG5pbXBvcnQgeyBpc0NvbG9yU3RyaW5nLCBzcGxpdENvbG9yIH0gZnJvbSAnLi91dGlscy5tanMnO1xuXG5jb25zdCBjbGFtcFJnYlVuaXQgPSBjbGFtcCgwLCAyNTUpO1xuY29uc3QgcmdiVW5pdCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbnVtYmVyKSwgeyB0cmFuc2Zvcm06ICh2KSA9PiBNYXRoLnJvdW5kKGNsYW1wUmdiVW5pdCh2KSkgfSk7XG5jb25zdCByZ2JhID0ge1xuICAgIHRlc3Q6IGlzQ29sb3JTdHJpbmcoJ3JnYicsICdyZWQnKSxcbiAgICBwYXJzZTogc3BsaXRDb2xvcigncmVkJywgJ2dyZWVuJywgJ2JsdWUnKSxcbiAgICB0cmFuc2Zvcm06ICh7IHJlZCwgZ3JlZW4sIGJsdWUsIGFscGhhOiBhbHBoYSQxID0gMSB9KSA9PiAncmdiYSgnICtcbiAgICAgICAgcmdiVW5pdC50cmFuc2Zvcm0ocmVkKSArXG4gICAgICAgICcsICcgK1xuICAgICAgICByZ2JVbml0LnRyYW5zZm9ybShncmVlbikgK1xuICAgICAgICAnLCAnICtcbiAgICAgICAgcmdiVW5pdC50cmFuc2Zvcm0oYmx1ZSkgK1xuICAgICAgICAnLCAnICtcbiAgICAgICAgc2FuaXRpemUoYWxwaGEudHJhbnNmb3JtKGFscGhhJDEpKSArXG4gICAgICAgICcpJyxcbn07XG5cbmV4cG9ydCB7IHJnYlVuaXQsIHJnYmEgfTtcbiIsImltcG9ydCB7IHJnYmEgfSBmcm9tICcuL3JnYmEubWpzJztcbmltcG9ydCB7IGlzQ29sb3JTdHJpbmcgfSBmcm9tICcuL3V0aWxzLm1qcyc7XG5cbmZ1bmN0aW9uIHBhcnNlSGV4KHYpIHtcbiAgICBsZXQgciA9ICcnO1xuICAgIGxldCBnID0gJyc7XG4gICAgbGV0IGIgPSAnJztcbiAgICBsZXQgYSA9ICcnO1xuICAgIGlmICh2Lmxlbmd0aCA+IDUpIHtcbiAgICAgICAgciA9IHYuc3Vic3RyKDEsIDIpO1xuICAgICAgICBnID0gdi5zdWJzdHIoMywgMik7XG4gICAgICAgIGIgPSB2LnN1YnN0cig1LCAyKTtcbiAgICAgICAgYSA9IHYuc3Vic3RyKDcsIDIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgciA9IHYuc3Vic3RyKDEsIDEpO1xuICAgICAgICBnID0gdi5zdWJzdHIoMiwgMSk7XG4gICAgICAgIGIgPSB2LnN1YnN0cigzLCAxKTtcbiAgICAgICAgYSA9IHYuc3Vic3RyKDQsIDEpO1xuICAgICAgICByICs9IHI7XG4gICAgICAgIGcgKz0gZztcbiAgICAgICAgYiArPSBiO1xuICAgICAgICBhICs9IGE7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHJlZDogcGFyc2VJbnQociwgMTYpLFxuICAgICAgICBncmVlbjogcGFyc2VJbnQoZywgMTYpLFxuICAgICAgICBibHVlOiBwYXJzZUludChiLCAxNiksXG4gICAgICAgIGFscGhhOiBhID8gcGFyc2VJbnQoYSwgMTYpIC8gMjU1IDogMSxcbiAgICB9O1xufVxuY29uc3QgaGV4ID0ge1xuICAgIHRlc3Q6IGlzQ29sb3JTdHJpbmcoJyMnKSxcbiAgICBwYXJzZTogcGFyc2VIZXgsXG4gICAgdHJhbnNmb3JtOiByZ2JhLnRyYW5zZm9ybSxcbn07XG5cbmV4cG9ydCB7IGhleCB9O1xuIiwiaW1wb3J0IHsgYWxwaGEgfSBmcm9tICcuLi9udW1iZXJzL2luZGV4Lm1qcyc7XG5pbXBvcnQgeyBwZXJjZW50IH0gZnJvbSAnLi4vbnVtYmVycy91bml0cy5tanMnO1xuaW1wb3J0IHsgc2FuaXRpemUgfSBmcm9tICcuLi91dGlscy5tanMnO1xuaW1wb3J0IHsgaXNDb2xvclN0cmluZywgc3BsaXRDb2xvciB9IGZyb20gJy4vdXRpbHMubWpzJztcblxuY29uc3QgaHNsYSA9IHtcbiAgICB0ZXN0OiBpc0NvbG9yU3RyaW5nKCdoc2wnLCAnaHVlJyksXG4gICAgcGFyc2U6IHNwbGl0Q29sb3IoJ2h1ZScsICdzYXR1cmF0aW9uJywgJ2xpZ2h0bmVzcycpLFxuICAgIHRyYW5zZm9ybTogKHsgaHVlLCBzYXR1cmF0aW9uLCBsaWdodG5lc3MsIGFscGhhOiBhbHBoYSQxID0gMSB9KSA9PiB7XG4gICAgICAgIHJldHVybiAoJ2hzbGEoJyArXG4gICAgICAgICAgICBNYXRoLnJvdW5kKGh1ZSkgK1xuICAgICAgICAgICAgJywgJyArXG4gICAgICAgICAgICBwZXJjZW50LnRyYW5zZm9ybShzYW5pdGl6ZShzYXR1cmF0aW9uKSkgK1xuICAgICAgICAgICAgJywgJyArXG4gICAgICAgICAgICBwZXJjZW50LnRyYW5zZm9ybShzYW5pdGl6ZShsaWdodG5lc3MpKSArXG4gICAgICAgICAgICAnLCAnICtcbiAgICAgICAgICAgIHNhbml0aXplKGFscGhhLnRyYW5zZm9ybShhbHBoYSQxKSkgK1xuICAgICAgICAgICAgJyknKTtcbiAgICB9LFxufTtcblxuZXhwb3J0IHsgaHNsYSB9O1xuIiwiZnVuY3Rpb24gaHVlVG9SZ2IocCwgcSwgdCkge1xuICAgIGlmICh0IDwgMClcbiAgICAgICAgdCArPSAxO1xuICAgIGlmICh0ID4gMSlcbiAgICAgICAgdCAtPSAxO1xuICAgIGlmICh0IDwgMSAvIDYpXG4gICAgICAgIHJldHVybiBwICsgKHEgLSBwKSAqIDYgKiB0O1xuICAgIGlmICh0IDwgMSAvIDIpXG4gICAgICAgIHJldHVybiBxO1xuICAgIGlmICh0IDwgMiAvIDMpXG4gICAgICAgIHJldHVybiBwICsgKHEgLSBwKSAqICgyIC8gMyAtIHQpICogNjtcbiAgICByZXR1cm4gcDtcbn1cbmZ1bmN0aW9uIGhzbGFUb1JnYmEoeyBodWUsIHNhdHVyYXRpb24sIGxpZ2h0bmVzcywgYWxwaGEgfSkge1xuICAgIGh1ZSAvPSAzNjA7XG4gICAgc2F0dXJhdGlvbiAvPSAxMDA7XG4gICAgbGlnaHRuZXNzIC89IDEwMDtcbiAgICBsZXQgcmVkID0gMDtcbiAgICBsZXQgZ3JlZW4gPSAwO1xuICAgIGxldCBibHVlID0gMDtcbiAgICBpZiAoIXNhdHVyYXRpb24pIHtcbiAgICAgICAgcmVkID0gZ3JlZW4gPSBibHVlID0gbGlnaHRuZXNzO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgcSA9IGxpZ2h0bmVzcyA8IDAuNVxuICAgICAgICAgICAgPyBsaWdodG5lc3MgKiAoMSArIHNhdHVyYXRpb24pXG4gICAgICAgICAgICA6IGxpZ2h0bmVzcyArIHNhdHVyYXRpb24gLSBsaWdodG5lc3MgKiBzYXR1cmF0aW9uO1xuICAgICAgICBjb25zdCBwID0gMiAqIGxpZ2h0bmVzcyAtIHE7XG4gICAgICAgIHJlZCA9IGh1ZVRvUmdiKHAsIHEsIGh1ZSArIDEgLyAzKTtcbiAgICAgICAgZ3JlZW4gPSBodWVUb1JnYihwLCBxLCBodWUpO1xuICAgICAgICBibHVlID0gaHVlVG9SZ2IocCwgcSwgaHVlIC0gMSAvIDMpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICByZWQ6IE1hdGgucm91bmQocmVkICogMjU1KSxcbiAgICAgICAgZ3JlZW46IE1hdGgucm91bmQoZ3JlZW4gKiAyNTUpLFxuICAgICAgICBibHVlOiBNYXRoLnJvdW5kKGJsdWUgKiAyNTUpLFxuICAgICAgICBhbHBoYSxcbiAgICB9O1xufVxuXG5leHBvcnQgeyBoc2xhVG9SZ2JhIH07XG4iLCJpbXBvcnQgeyBtaXggfSBmcm9tICcuL21peC5tanMnO1xuaW1wb3J0IHsgaHNsYSwgcmdiYSwgaGV4IH0gZnJvbSAnc3R5bGUtdmFsdWUtdHlwZXMnO1xuaW1wb3J0IHsgaW52YXJpYW50IH0gZnJvbSAnaGV5LWxpc3Rlbic7XG5pbXBvcnQgeyBoc2xhVG9SZ2JhIH0gZnJvbSAnLi9oc2xhLXRvLXJnYmEubWpzJztcblxuY29uc3QgbWl4TGluZWFyQ29sb3IgPSAoZnJvbSwgdG8sIHYpID0+IHtcbiAgICBjb25zdCBmcm9tRXhwbyA9IGZyb20gKiBmcm9tO1xuICAgIGNvbnN0IHRvRXhwbyA9IHRvICogdG87XG4gICAgcmV0dXJuIE1hdGguc3FydChNYXRoLm1heCgwLCB2ICogKHRvRXhwbyAtIGZyb21FeHBvKSArIGZyb21FeHBvKSk7XG59O1xuY29uc3QgY29sb3JUeXBlcyA9IFtoZXgsIHJnYmEsIGhzbGFdO1xuY29uc3QgZ2V0Q29sb3JUeXBlID0gKHYpID0+IGNvbG9yVHlwZXMuZmluZCgodHlwZSkgPT4gdHlwZS50ZXN0KHYpKTtcbmNvbnN0IG5vdEFuaW1hdGFibGUgPSAoY29sb3IpID0+IGAnJHtjb2xvcn0nIGlzIG5vdCBhbiBhbmltYXRhYmxlIGNvbG9yLiBVc2UgdGhlIGVxdWl2YWxlbnQgY29sb3IgY29kZSBpbnN0ZWFkLmA7XG5jb25zdCBtaXhDb2xvciA9IChmcm9tLCB0bykgPT4ge1xuICAgIGxldCBmcm9tQ29sb3JUeXBlID0gZ2V0Q29sb3JUeXBlKGZyb20pO1xuICAgIGxldCB0b0NvbG9yVHlwZSA9IGdldENvbG9yVHlwZSh0byk7XG4gICAgaW52YXJpYW50KCEhZnJvbUNvbG9yVHlwZSwgbm90QW5pbWF0YWJsZShmcm9tKSk7XG4gICAgaW52YXJpYW50KCEhdG9Db2xvclR5cGUsIG5vdEFuaW1hdGFibGUodG8pKTtcbiAgICBsZXQgZnJvbUNvbG9yID0gZnJvbUNvbG9yVHlwZS5wYXJzZShmcm9tKTtcbiAgICBsZXQgdG9Db2xvciA9IHRvQ29sb3JUeXBlLnBhcnNlKHRvKTtcbiAgICBpZiAoZnJvbUNvbG9yVHlwZSA9PT0gaHNsYSkge1xuICAgICAgICBmcm9tQ29sb3IgPSBoc2xhVG9SZ2JhKGZyb21Db2xvcik7XG4gICAgICAgIGZyb21Db2xvclR5cGUgPSByZ2JhO1xuICAgIH1cbiAgICBpZiAodG9Db2xvclR5cGUgPT09IGhzbGEpIHtcbiAgICAgICAgdG9Db2xvciA9IGhzbGFUb1JnYmEodG9Db2xvcik7XG4gICAgICAgIHRvQ29sb3JUeXBlID0gcmdiYTtcbiAgICB9XG4gICAgY29uc3QgYmxlbmRlZCA9IE9iamVjdC5hc3NpZ24oe30sIGZyb21Db2xvcik7XG4gICAgcmV0dXJuICh2KSA9PiB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGJsZW5kZWQpIHtcbiAgICAgICAgICAgIGlmIChrZXkgIT09IFwiYWxwaGFcIikge1xuICAgICAgICAgICAgICAgIGJsZW5kZWRba2V5XSA9IG1peExpbmVhckNvbG9yKGZyb21Db2xvcltrZXldLCB0b0NvbG9yW2tleV0sIHYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJsZW5kZWQuYWxwaGEgPSBtaXgoZnJvbUNvbG9yLmFscGhhLCB0b0NvbG9yLmFscGhhLCB2KTtcbiAgICAgICAgcmV0dXJuIGZyb21Db2xvclR5cGUudHJhbnNmb3JtKGJsZW5kZWQpO1xuICAgIH07XG59O1xuXG5leHBvcnQgeyBtaXhDb2xvciwgbWl4TGluZWFyQ29sb3IgfTtcbiIsImltcG9ydCB7IGlzU3RyaW5nIH0gZnJvbSAnLi4vdXRpbHMubWpzJztcbmltcG9ydCB7IGhleCB9IGZyb20gJy4vaGV4Lm1qcyc7XG5pbXBvcnQgeyBoc2xhIH0gZnJvbSAnLi9oc2xhLm1qcyc7XG5pbXBvcnQgeyByZ2JhIH0gZnJvbSAnLi9yZ2JhLm1qcyc7XG5cbmNvbnN0IGNvbG9yID0ge1xuICAgIHRlc3Q6ICh2KSA9PiByZ2JhLnRlc3QodikgfHwgaGV4LnRlc3QodikgfHwgaHNsYS50ZXN0KHYpLFxuICAgIHBhcnNlOiAodikgPT4ge1xuICAgICAgICBpZiAocmdiYS50ZXN0KHYpKSB7XG4gICAgICAgICAgICByZXR1cm4gcmdiYS5wYXJzZSh2KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChoc2xhLnRlc3QodikpIHtcbiAgICAgICAgICAgIHJldHVybiBoc2xhLnBhcnNlKHYpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGhleC5wYXJzZSh2KTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgdHJhbnNmb3JtOiAodikgPT4ge1xuICAgICAgICByZXR1cm4gaXNTdHJpbmcodilcbiAgICAgICAgICAgID8gdlxuICAgICAgICAgICAgOiB2Lmhhc093blByb3BlcnR5KCdyZWQnKVxuICAgICAgICAgICAgICAgID8gcmdiYS50cmFuc2Zvcm0odilcbiAgICAgICAgICAgICAgICA6IGhzbGEudHJhbnNmb3JtKHYpO1xuICAgIH0sXG59O1xuXG5leHBvcnQgeyBjb2xvciB9O1xuIiwiaW1wb3J0IHsgY29sb3IgfSBmcm9tICcuLi9jb2xvci9pbmRleC5tanMnO1xuaW1wb3J0IHsgbnVtYmVyIH0gZnJvbSAnLi4vbnVtYmVycy9pbmRleC5tanMnO1xuaW1wb3J0IHsgaXNTdHJpbmcsIGZsb2F0UmVnZXgsIGNvbG9yUmVnZXgsIHNhbml0aXplIH0gZnJvbSAnLi4vdXRpbHMubWpzJztcblxuY29uc3QgY29sb3JUb2tlbiA9ICcke2N9JztcbmNvbnN0IG51bWJlclRva2VuID0gJyR7bn0nO1xuZnVuY3Rpb24gdGVzdCh2KSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgIHJldHVybiAoaXNOYU4odikgJiZcbiAgICAgICAgaXNTdHJpbmcodikgJiZcbiAgICAgICAgKChfYiA9IChfYSA9IHYubWF0Y2goZmxvYXRSZWdleCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sZW5ndGgpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDApICsgKChfZCA9IChfYyA9IHYubWF0Y2goY29sb3JSZWdleCkpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5sZW5ndGgpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IDApID4gMCk7XG59XG5mdW5jdGlvbiBhbmFseXNlKHYpIHtcbiAgICBpZiAodHlwZW9mIHYgPT09ICdudW1iZXInKVxuICAgICAgICB2ID0gYCR7dn1gO1xuICAgIGNvbnN0IHZhbHVlcyA9IFtdO1xuICAgIGxldCBudW1Db2xvcnMgPSAwO1xuICAgIGNvbnN0IGNvbG9ycyA9IHYubWF0Y2goY29sb3JSZWdleCk7XG4gICAgaWYgKGNvbG9ycykge1xuICAgICAgICBudW1Db2xvcnMgPSBjb2xvcnMubGVuZ3RoO1xuICAgICAgICB2ID0gdi5yZXBsYWNlKGNvbG9yUmVnZXgsIGNvbG9yVG9rZW4pO1xuICAgICAgICB2YWx1ZXMucHVzaCguLi5jb2xvcnMubWFwKGNvbG9yLnBhcnNlKSk7XG4gICAgfVxuICAgIGNvbnN0IG51bWJlcnMgPSB2Lm1hdGNoKGZsb2F0UmVnZXgpO1xuICAgIGlmIChudW1iZXJzKSB7XG4gICAgICAgIHYgPSB2LnJlcGxhY2UoZmxvYXRSZWdleCwgbnVtYmVyVG9rZW4pO1xuICAgICAgICB2YWx1ZXMucHVzaCguLi5udW1iZXJzLm1hcChudW1iZXIucGFyc2UpKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdmFsdWVzLCBudW1Db2xvcnMsIHRva2VuaXNlZDogdiB9O1xufVxuZnVuY3Rpb24gcGFyc2Uodikge1xuICAgIHJldHVybiBhbmFseXNlKHYpLnZhbHVlcztcbn1cbmZ1bmN0aW9uIGNyZWF0ZVRyYW5zZm9ybWVyKHYpIHtcbiAgICBjb25zdCB7IHZhbHVlcywgbnVtQ29sb3JzLCB0b2tlbmlzZWQgfSA9IGFuYWx5c2Uodik7XG4gICAgY29uc3QgbnVtVmFsdWVzID0gdmFsdWVzLmxlbmd0aDtcbiAgICByZXR1cm4gKHYpID0+IHtcbiAgICAgICAgbGV0IG91dHB1dCA9IHRva2VuaXNlZDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1WYWx1ZXM7IGkrKykge1xuICAgICAgICAgICAgb3V0cHV0ID0gb3V0cHV0LnJlcGxhY2UoaSA8IG51bUNvbG9ycyA/IGNvbG9yVG9rZW4gOiBudW1iZXJUb2tlbiwgaSA8IG51bUNvbG9ycyA/IGNvbG9yLnRyYW5zZm9ybSh2W2ldKSA6IHNhbml0aXplKHZbaV0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH07XG59XG5jb25zdCBjb252ZXJ0TnVtYmVyc1RvWmVybyA9ICh2KSA9PiB0eXBlb2YgdiA9PT0gJ251bWJlcicgPyAwIDogdjtcbmZ1bmN0aW9uIGdldEFuaW1hdGFibGVOb25lKHYpIHtcbiAgICBjb25zdCBwYXJzZWQgPSBwYXJzZSh2KTtcbiAgICBjb25zdCB0cmFuc2Zvcm1lciA9IGNyZWF0ZVRyYW5zZm9ybWVyKHYpO1xuICAgIHJldHVybiB0cmFuc2Zvcm1lcihwYXJzZWQubWFwKGNvbnZlcnROdW1iZXJzVG9aZXJvKSk7XG59XG5jb25zdCBjb21wbGV4ID0geyB0ZXN0LCBwYXJzZSwgY3JlYXRlVHJhbnNmb3JtZXIsIGdldEFuaW1hdGFibGVOb25lIH07XG5cbmV4cG9ydCB7IGNvbXBsZXggfTtcbiIsImNvbnN0IHplcm9Qb2ludCA9IHtcbiAgICB4OiAwLFxuICAgIHk6IDAsXG4gICAgejogMFxufTtcbmNvbnN0IGlzTnVtID0gKHYpID0+IHR5cGVvZiB2ID09PSAnbnVtYmVyJztcblxuZXhwb3J0IHsgaXNOdW0sIHplcm9Qb2ludCB9O1xuIiwiaW1wb3J0IHsgY29tcGxleCwgY29sb3IgfSBmcm9tICdzdHlsZS12YWx1ZS10eXBlcyc7XG5pbXBvcnQgeyBtaXggfSBmcm9tICcuL21peC5tanMnO1xuaW1wb3J0IHsgbWl4Q29sb3IgfSBmcm9tICcuL21peC1jb2xvci5tanMnO1xuaW1wb3J0IHsgaXNOdW0gfSBmcm9tICcuL2luYy5tanMnO1xuaW1wb3J0IHsgcGlwZSB9IGZyb20gJy4vcGlwZS5tanMnO1xuaW1wb3J0IHsgd2FybmluZyB9IGZyb20gJ2hleS1saXN0ZW4nO1xuXG5mdW5jdGlvbiBnZXRNaXhlcihvcmlnaW4sIHRhcmdldCkge1xuICAgIGlmIChpc051bShvcmlnaW4pKSB7XG4gICAgICAgIHJldHVybiAodikgPT4gbWl4KG9yaWdpbiwgdGFyZ2V0LCB2KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY29sb3IudGVzdChvcmlnaW4pKSB7XG4gICAgICAgIHJldHVybiBtaXhDb2xvcihvcmlnaW4sIHRhcmdldCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbWl4Q29tcGxleChvcmlnaW4sIHRhcmdldCk7XG4gICAgfVxufVxuY29uc3QgbWl4QXJyYXkgPSAoZnJvbSwgdG8pID0+IHtcbiAgICBjb25zdCBvdXRwdXQgPSBbLi4uZnJvbV07XG4gICAgY29uc3QgbnVtVmFsdWVzID0gb3V0cHV0Lmxlbmd0aDtcbiAgICBjb25zdCBibGVuZFZhbHVlID0gZnJvbS5tYXAoKGZyb21UaGlzLCBpKSA9PiBnZXRNaXhlcihmcm9tVGhpcywgdG9baV0pKTtcbiAgICByZXR1cm4gKHYpID0+IHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1WYWx1ZXM7IGkrKykge1xuICAgICAgICAgICAgb3V0cHV0W2ldID0gYmxlbmRWYWx1ZVtpXSh2KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH07XG59O1xuY29uc3QgbWl4T2JqZWN0ID0gKG9yaWdpbiwgdGFyZ2V0KSA9PiB7XG4gICAgY29uc3Qgb3V0cHV0ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcmlnaW4pLCB0YXJnZXQpO1xuICAgIGNvbnN0IGJsZW5kVmFsdWUgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvdXRwdXQpIHtcbiAgICAgICAgaWYgKG9yaWdpbltrZXldICE9PSB1bmRlZmluZWQgJiYgdGFyZ2V0W2tleV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgYmxlbmRWYWx1ZVtrZXldID0gZ2V0TWl4ZXIob3JpZ2luW2tleV0sIHRhcmdldFtrZXldKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gKHYpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gYmxlbmRWYWx1ZSkge1xuICAgICAgICAgICAgb3V0cHV0W2tleV0gPSBibGVuZFZhbHVlW2tleV0odik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9O1xufTtcbmZ1bmN0aW9uIGFuYWx5c2UodmFsdWUpIHtcbiAgICBjb25zdCBwYXJzZWQgPSBjb21wbGV4LnBhcnNlKHZhbHVlKTtcbiAgICBjb25zdCBudW1WYWx1ZXMgPSBwYXJzZWQubGVuZ3RoO1xuICAgIGxldCBudW1OdW1iZXJzID0gMDtcbiAgICBsZXQgbnVtUkdCID0gMDtcbiAgICBsZXQgbnVtSFNMID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVZhbHVlczsgaSsrKSB7XG4gICAgICAgIGlmIChudW1OdW1iZXJzIHx8IHR5cGVvZiBwYXJzZWRbaV0gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIG51bU51bWJlcnMrKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChwYXJzZWRbaV0uaHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBudW1IU0wrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG51bVJHQisrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IHBhcnNlZCwgbnVtTnVtYmVycywgbnVtUkdCLCBudW1IU0wgfTtcbn1cbmNvbnN0IG1peENvbXBsZXggPSAob3JpZ2luLCB0YXJnZXQpID0+IHtcbiAgICBjb25zdCB0ZW1wbGF0ZSA9IGNvbXBsZXguY3JlYXRlVHJhbnNmb3JtZXIodGFyZ2V0KTtcbiAgICBjb25zdCBvcmlnaW5TdGF0cyA9IGFuYWx5c2Uob3JpZ2luKTtcbiAgICBjb25zdCB0YXJnZXRTdGF0cyA9IGFuYWx5c2UodGFyZ2V0KTtcbiAgICBjb25zdCBjYW5JbnRlcnBvbGF0ZSA9IG9yaWdpblN0YXRzLm51bUhTTCA9PT0gdGFyZ2V0U3RhdHMubnVtSFNMICYmXG4gICAgICAgIG9yaWdpblN0YXRzLm51bVJHQiA9PT0gdGFyZ2V0U3RhdHMubnVtUkdCICYmXG4gICAgICAgIG9yaWdpblN0YXRzLm51bU51bWJlcnMgPj0gdGFyZ2V0U3RhdHMubnVtTnVtYmVycztcbiAgICBpZiAoY2FuSW50ZXJwb2xhdGUpIHtcbiAgICAgICAgcmV0dXJuIHBpcGUobWl4QXJyYXkob3JpZ2luU3RhdHMucGFyc2VkLCB0YXJnZXRTdGF0cy5wYXJzZWQpLCB0ZW1wbGF0ZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB3YXJuaW5nKHRydWUsIGBDb21wbGV4IHZhbHVlcyAnJHtvcmlnaW59JyBhbmQgJyR7dGFyZ2V0fScgdG9vIGRpZmZlcmVudCB0byBtaXguIEVuc3VyZSBhbGwgY29sb3JzIGFyZSBvZiB0aGUgc2FtZSB0eXBlLCBhbmQgdGhhdCBlYWNoIGNvbnRhaW5zIHRoZSBzYW1lIHF1YW50aXR5IG9mIG51bWJlciBhbmQgY29sb3IgdmFsdWVzLiBGYWxsaW5nIGJhY2sgdG8gaW5zdGFudCB0cmFuc2l0aW9uLmApO1xuICAgICAgICByZXR1cm4gKHApID0+IGAke3AgPiAwID8gdGFyZ2V0IDogb3JpZ2lufWA7XG4gICAgfVxufTtcblxuZXhwb3J0IHsgbWl4QXJyYXksIG1peENvbXBsZXgsIG1peE9iamVjdCB9O1xuIiwiaW1wb3J0IHsgcHJvZ3Jlc3MgfSBmcm9tICcuL3Byb2dyZXNzLm1qcyc7XG5pbXBvcnQgeyBtaXggfSBmcm9tICcuL21peC5tanMnO1xuaW1wb3J0IHsgbWl4Q29sb3IgfSBmcm9tICcuL21peC1jb2xvci5tanMnO1xuaW1wb3J0IHsgbWl4Q29tcGxleCwgbWl4QXJyYXksIG1peE9iamVjdCB9IGZyb20gJy4vbWl4LWNvbXBsZXgubWpzJztcbmltcG9ydCB7IGNvbG9yIH0gZnJvbSAnc3R5bGUtdmFsdWUtdHlwZXMnO1xuaW1wb3J0IHsgY2xhbXAgfSBmcm9tICcuL2NsYW1wLm1qcyc7XG5pbXBvcnQgeyBwaXBlIH0gZnJvbSAnLi9waXBlLm1qcyc7XG5pbXBvcnQgeyBpbnZhcmlhbnQgfSBmcm9tICdoZXktbGlzdGVuJztcblxuY29uc3QgbWl4TnVtYmVyID0gKGZyb20sIHRvKSA9PiAocCkgPT4gbWl4KGZyb20sIHRvLCBwKTtcbmZ1bmN0aW9uIGRldGVjdE1peGVyRmFjdG9yeSh2KSB7XG4gICAgaWYgKHR5cGVvZiB2ID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gbWl4TnVtYmVyO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgdiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKGNvbG9yLnRlc3QodikpIHtcbiAgICAgICAgICAgIHJldHVybiBtaXhDb2xvcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBtaXhDb21wbGV4O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodikpIHtcbiAgICAgICAgcmV0dXJuIG1peEFycmF5O1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgdiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG1peE9iamVjdDtcbiAgICB9XG59XG5mdW5jdGlvbiBjcmVhdGVNaXhlcnMob3V0cHV0LCBlYXNlLCBjdXN0b21NaXhlcikge1xuICAgIGNvbnN0IG1peGVycyA9IFtdO1xuICAgIGNvbnN0IG1peGVyRmFjdG9yeSA9IGN1c3RvbU1peGVyIHx8IGRldGVjdE1peGVyRmFjdG9yeShvdXRwdXRbMF0pO1xuICAgIGNvbnN0IG51bU1peGVycyA9IG91dHB1dC5sZW5ndGggLSAxO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtTWl4ZXJzOyBpKyspIHtcbiAgICAgICAgbGV0IG1peGVyID0gbWl4ZXJGYWN0b3J5KG91dHB1dFtpXSwgb3V0cHV0W2kgKyAxXSk7XG4gICAgICAgIGlmIChlYXNlKSB7XG4gICAgICAgICAgICBjb25zdCBlYXNpbmdGdW5jdGlvbiA9IEFycmF5LmlzQXJyYXkoZWFzZSkgPyBlYXNlW2ldIDogZWFzZTtcbiAgICAgICAgICAgIG1peGVyID0gcGlwZShlYXNpbmdGdW5jdGlvbiwgbWl4ZXIpO1xuICAgICAgICB9XG4gICAgICAgIG1peGVycy5wdXNoKG1peGVyKTtcbiAgICB9XG4gICAgcmV0dXJuIG1peGVycztcbn1cbmZ1bmN0aW9uIGZhc3RJbnRlcnBvbGF0ZShbZnJvbSwgdG9dLCBbbWl4ZXJdKSB7XG4gICAgcmV0dXJuICh2KSA9PiBtaXhlcihwcm9ncmVzcyhmcm9tLCB0bywgdikpO1xufVxuZnVuY3Rpb24gc2xvd0ludGVycG9sYXRlKGlucHV0LCBtaXhlcnMpIHtcbiAgICBjb25zdCBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aDtcbiAgICBjb25zdCBsYXN0SW5wdXRJbmRleCA9IGlucHV0TGVuZ3RoIC0gMTtcbiAgICByZXR1cm4gKHYpID0+IHtcbiAgICAgICAgbGV0IG1peGVySW5kZXggPSAwO1xuICAgICAgICBsZXQgZm91bmRNaXhlckluZGV4ID0gZmFsc2U7XG4gICAgICAgIGlmICh2IDw9IGlucHV0WzBdKSB7XG4gICAgICAgICAgICBmb3VuZE1peGVySW5kZXggPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHYgPj0gaW5wdXRbbGFzdElucHV0SW5kZXhdKSB7XG4gICAgICAgICAgICBtaXhlckluZGV4ID0gbGFzdElucHV0SW5kZXggLSAxO1xuICAgICAgICAgICAgZm91bmRNaXhlckluZGV4ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWZvdW5kTWl4ZXJJbmRleCkge1xuICAgICAgICAgICAgbGV0IGkgPSAxO1xuICAgICAgICAgICAgZm9yICg7IGkgPCBpbnB1dExlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0W2ldID4gdiB8fCBpID09PSBsYXN0SW5wdXRJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtaXhlckluZGV4ID0gaSAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJvZ3Jlc3NJblJhbmdlID0gcHJvZ3Jlc3MoaW5wdXRbbWl4ZXJJbmRleF0sIGlucHV0W21peGVySW5kZXggKyAxXSwgdik7XG4gICAgICAgIHJldHVybiBtaXhlcnNbbWl4ZXJJbmRleF0ocHJvZ3Jlc3NJblJhbmdlKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gaW50ZXJwb2xhdGUoaW5wdXQsIG91dHB1dCwgeyBjbGFtcDogaXNDbGFtcCA9IHRydWUsIGVhc2UsIG1peGVyIH0gPSB7fSkge1xuICAgIGNvbnN0IGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuICAgIGludmFyaWFudChpbnB1dExlbmd0aCA9PT0gb3V0cHV0Lmxlbmd0aCwgJ0JvdGggaW5wdXQgYW5kIG91dHB1dCByYW5nZXMgbXVzdCBiZSB0aGUgc2FtZSBsZW5ndGgnKTtcbiAgICBpbnZhcmlhbnQoIWVhc2UgfHwgIUFycmF5LmlzQXJyYXkoZWFzZSkgfHwgZWFzZS5sZW5ndGggPT09IGlucHV0TGVuZ3RoIC0gMSwgJ0FycmF5IG9mIGVhc2luZyBmdW5jdGlvbnMgbXVzdCBiZSBvZiBsZW5ndGggYGlucHV0Lmxlbmd0aCAtIDFgLCBhcyBpdCBhcHBsaWVzIHRvIHRoZSB0cmFuc2l0aW9ucyAqKmJldHdlZW4qKiB0aGUgZGVmaW5lZCB2YWx1ZXMuJyk7XG4gICAgaWYgKGlucHV0WzBdID4gaW5wdXRbaW5wdXRMZW5ndGggLSAxXSkge1xuICAgICAgICBpbnB1dCA9IFtdLmNvbmNhdChpbnB1dCk7XG4gICAgICAgIG91dHB1dCA9IFtdLmNvbmNhdChvdXRwdXQpO1xuICAgICAgICBpbnB1dC5yZXZlcnNlKCk7XG4gICAgICAgIG91dHB1dC5yZXZlcnNlKCk7XG4gICAgfVxuICAgIGNvbnN0IG1peGVycyA9IGNyZWF0ZU1peGVycyhvdXRwdXQsIGVhc2UsIG1peGVyKTtcbiAgICBjb25zdCBpbnRlcnBvbGF0b3IgPSBpbnB1dExlbmd0aCA9PT0gMlxuICAgICAgICA/IGZhc3RJbnRlcnBvbGF0ZShpbnB1dCwgbWl4ZXJzKVxuICAgICAgICA6IHNsb3dJbnRlcnBvbGF0ZShpbnB1dCwgbWl4ZXJzKTtcbiAgICByZXR1cm4gaXNDbGFtcFxuICAgICAgICA/ICh2KSA9PiBpbnRlcnBvbGF0b3IoY2xhbXAoaW5wdXRbMF0sIGlucHV0W2lucHV0TGVuZ3RoIC0gMV0sIHYpKVxuICAgICAgICA6IGludGVycG9sYXRvcjtcbn1cblxuZXhwb3J0IHsgaW50ZXJwb2xhdGUgfTtcbiIsImNvbnN0IHJldmVyc2VFYXNpbmcgPSBlYXNpbmcgPT4gcCA9PiAxIC0gZWFzaW5nKDEgLSBwKTtcbmNvbnN0IG1pcnJvckVhc2luZyA9IGVhc2luZyA9PiBwID0+IHAgPD0gMC41ID8gZWFzaW5nKDIgKiBwKSAvIDIgOiAoMiAtIGVhc2luZygyICogKDEgLSBwKSkpIC8gMjtcbmNvbnN0IGNyZWF0ZUV4cG9JbiA9IChwb3dlcikgPT4gcCA9PiBNYXRoLnBvdyhwLCBwb3dlcik7XG5jb25zdCBjcmVhdGVCYWNrSW4gPSAocG93ZXIpID0+IHAgPT4gcCAqIHAgKiAoKHBvd2VyICsgMSkgKiBwIC0gcG93ZXIpO1xuY29uc3QgY3JlYXRlQW50aWNpcGF0ZSA9IChwb3dlcikgPT4ge1xuICAgIGNvbnN0IGJhY2tFYXNpbmcgPSBjcmVhdGVCYWNrSW4ocG93ZXIpO1xuICAgIHJldHVybiBwID0+IChwICo9IDIpIDwgMVxuICAgICAgICA/IDAuNSAqIGJhY2tFYXNpbmcocClcbiAgICAgICAgOiAwLjUgKiAoMiAtIE1hdGgucG93KDIsIC0xMCAqIChwIC0gMSkpKTtcbn07XG5cbmV4cG9ydCB7IGNyZWF0ZUFudGljaXBhdGUsIGNyZWF0ZUJhY2tJbiwgY3JlYXRlRXhwb0luLCBtaXJyb3JFYXNpbmcsIHJldmVyc2VFYXNpbmcgfTtcbiIsImltcG9ydCB7IGNyZWF0ZUV4cG9JbiwgcmV2ZXJzZUVhc2luZywgbWlycm9yRWFzaW5nLCBjcmVhdGVCYWNrSW4sIGNyZWF0ZUFudGljaXBhdGUgfSBmcm9tICcuL3V0aWxzLm1qcyc7XG5cbmNvbnN0IERFRkFVTFRfT1ZFUlNIT09UX1NUUkVOR1RIID0gMS41MjU7XG5jb25zdCBCT1VOQ0VfRklSU1RfVEhSRVNIT0xEID0gNC4wIC8gMTEuMDtcbmNvbnN0IEJPVU5DRV9TRUNPTkRfVEhSRVNIT0xEID0gOC4wIC8gMTEuMDtcbmNvbnN0IEJPVU5DRV9USElSRF9USFJFU0hPTEQgPSA5LjAgLyAxMC4wO1xuY29uc3QgbGluZWFyID0gcCA9PiBwO1xuY29uc3QgZWFzZUluID0gY3JlYXRlRXhwb0luKDIpO1xuY29uc3QgZWFzZU91dCA9IHJldmVyc2VFYXNpbmcoZWFzZUluKTtcbmNvbnN0IGVhc2VJbk91dCA9IG1pcnJvckVhc2luZyhlYXNlSW4pO1xuY29uc3QgY2lyY0luID0gcCA9PiAxIC0gTWF0aC5zaW4oTWF0aC5hY29zKHApKTtcbmNvbnN0IGNpcmNPdXQgPSByZXZlcnNlRWFzaW5nKGNpcmNJbik7XG5jb25zdCBjaXJjSW5PdXQgPSBtaXJyb3JFYXNpbmcoY2lyY091dCk7XG5jb25zdCBiYWNrSW4gPSBjcmVhdGVCYWNrSW4oREVGQVVMVF9PVkVSU0hPT1RfU1RSRU5HVEgpO1xuY29uc3QgYmFja091dCA9IHJldmVyc2VFYXNpbmcoYmFja0luKTtcbmNvbnN0IGJhY2tJbk91dCA9IG1pcnJvckVhc2luZyhiYWNrSW4pO1xuY29uc3QgYW50aWNpcGF0ZSA9IGNyZWF0ZUFudGljaXBhdGUoREVGQVVMVF9PVkVSU0hPT1RfU1RSRU5HVEgpO1xuY29uc3QgY2EgPSA0MzU2LjAgLyAzNjEuMDtcbmNvbnN0IGNiID0gMzU0NDIuMCAvIDE4MDUuMDtcbmNvbnN0IGNjID0gMTYwNjEuMCAvIDE4MDUuMDtcbmNvbnN0IGJvdW5jZU91dCA9IChwKSA9PiB7XG4gICAgaWYgKHAgPT09IDEgfHwgcCA9PT0gMClcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgY29uc3QgcDIgPSBwICogcDtcbiAgICByZXR1cm4gcCA8IEJPVU5DRV9GSVJTVF9USFJFU0hPTERcbiAgICAgICAgPyA3LjU2MjUgKiBwMlxuICAgICAgICA6IHAgPCBCT1VOQ0VfU0VDT05EX1RIUkVTSE9MRFxuICAgICAgICAgICAgPyA5LjA3NSAqIHAyIC0gOS45ICogcCArIDMuNFxuICAgICAgICAgICAgOiBwIDwgQk9VTkNFX1RISVJEX1RIUkVTSE9MRFxuICAgICAgICAgICAgICAgID8gY2EgKiBwMiAtIGNiICogcCArIGNjXG4gICAgICAgICAgICAgICAgOiAxMC44ICogcCAqIHAgLSAyMC41MiAqIHAgKyAxMC43Mjtcbn07XG5jb25zdCBib3VuY2VJbiA9IHJldmVyc2VFYXNpbmcoYm91bmNlT3V0KTtcbmNvbnN0IGJvdW5jZUluT3V0ID0gKHApID0+IHAgPCAwLjVcbiAgICA/IDAuNSAqICgxLjAgLSBib3VuY2VPdXQoMS4wIC0gcCAqIDIuMCkpXG4gICAgOiAwLjUgKiBib3VuY2VPdXQocCAqIDIuMCAtIDEuMCkgKyAwLjU7XG5cbmV4cG9ydCB7IGFudGljaXBhdGUsIGJhY2tJbiwgYmFja0luT3V0LCBiYWNrT3V0LCBib3VuY2VJbiwgYm91bmNlSW5PdXQsIGJvdW5jZU91dCwgY2lyY0luLCBjaXJjSW5PdXQsIGNpcmNPdXQsIGVhc2VJbiwgZWFzZUluT3V0LCBlYXNlT3V0LCBsaW5lYXIgfTtcbiIsImltcG9ydCB7IGludGVycG9sYXRlIH0gZnJvbSAnLi4vLi4vdXRpbHMvaW50ZXJwb2xhdGUubWpzJztcbmltcG9ydCB7IGVhc2VJbk91dCB9IGZyb20gJy4uLy4uL2Vhc2luZy9pbmRleC5tanMnO1xuXG5mdW5jdGlvbiBkZWZhdWx0RWFzaW5nKHZhbHVlcywgZWFzaW5nKSB7XG4gICAgcmV0dXJuIHZhbHVlcy5tYXAoKCkgPT4gZWFzaW5nIHx8IGVhc2VJbk91dCkuc3BsaWNlKDAsIHZhbHVlcy5sZW5ndGggLSAxKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRPZmZzZXQodmFsdWVzKSB7XG4gICAgY29uc3QgbnVtVmFsdWVzID0gdmFsdWVzLmxlbmd0aDtcbiAgICByZXR1cm4gdmFsdWVzLm1hcCgoX3ZhbHVlLCBpKSA9PiBpICE9PSAwID8gaSAvIChudW1WYWx1ZXMgLSAxKSA6IDApO1xufVxuZnVuY3Rpb24gY29udmVydE9mZnNldFRvVGltZXMob2Zmc2V0LCBkdXJhdGlvbikge1xuICAgIHJldHVybiBvZmZzZXQubWFwKChvKSA9PiBvICogZHVyYXRpb24pO1xufVxuZnVuY3Rpb24ga2V5ZnJhbWVzKHsgZnJvbSA9IDAsIHRvID0gMSwgZWFzZSwgb2Zmc2V0LCBkdXJhdGlvbiA9IDMwMCwgfSkge1xuICAgIGNvbnN0IHN0YXRlID0geyBkb25lOiBmYWxzZSwgdmFsdWU6IGZyb20gfTtcbiAgICBjb25zdCB2YWx1ZXMgPSBBcnJheS5pc0FycmF5KHRvKSA/IHRvIDogW2Zyb20sIHRvXTtcbiAgICBjb25zdCB0aW1lcyA9IGNvbnZlcnRPZmZzZXRUb1RpbWVzKG9mZnNldCAmJiBvZmZzZXQubGVuZ3RoID09PSB2YWx1ZXMubGVuZ3RoXG4gICAgICAgID8gb2Zmc2V0XG4gICAgICAgIDogZGVmYXVsdE9mZnNldCh2YWx1ZXMpLCBkdXJhdGlvbik7XG4gICAgZnVuY3Rpb24gY3JlYXRlSW50ZXJwb2xhdG9yKCkge1xuICAgICAgICByZXR1cm4gaW50ZXJwb2xhdGUodGltZXMsIHZhbHVlcywge1xuICAgICAgICAgICAgZWFzZTogQXJyYXkuaXNBcnJheShlYXNlKSA/IGVhc2UgOiBkZWZhdWx0RWFzaW5nKHZhbHVlcywgZWFzZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBsZXQgaW50ZXJwb2xhdG9yID0gY3JlYXRlSW50ZXJwb2xhdG9yKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbmV4dDogKHQpID0+IHtcbiAgICAgICAgICAgIHN0YXRlLnZhbHVlID0gaW50ZXJwb2xhdG9yKHQpO1xuICAgICAgICAgICAgc3RhdGUuZG9uZSA9IHQgPj0gZHVyYXRpb247XG4gICAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICAgIH0sXG4gICAgICAgIGZsaXBUYXJnZXQ6ICgpID0+IHtcbiAgICAgICAgICAgIHZhbHVlcy5yZXZlcnNlKCk7XG4gICAgICAgICAgICBpbnRlcnBvbGF0b3IgPSBjcmVhdGVJbnRlcnBvbGF0b3IoKTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuXG5leHBvcnQgeyBjb252ZXJ0T2Zmc2V0VG9UaW1lcywgZGVmYXVsdEVhc2luZywgZGVmYXVsdE9mZnNldCwga2V5ZnJhbWVzIH07XG4iLCJmdW5jdGlvbiBkZWNheSh7IHZlbG9jaXR5ID0gMCwgZnJvbSA9IDAsIHBvd2VyID0gMC44LCB0aW1lQ29uc3RhbnQgPSAzNTAsIHJlc3REZWx0YSA9IDAuNSwgbW9kaWZ5VGFyZ2V0LCB9KSB7XG4gICAgY29uc3Qgc3RhdGUgPSB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogZnJvbSB9O1xuICAgIGxldCBhbXBsaXR1ZGUgPSBwb3dlciAqIHZlbG9jaXR5O1xuICAgIGNvbnN0IGlkZWFsID0gZnJvbSArIGFtcGxpdHVkZTtcbiAgICBjb25zdCB0YXJnZXQgPSBtb2RpZnlUYXJnZXQgPT09IHVuZGVmaW5lZCA/IGlkZWFsIDogbW9kaWZ5VGFyZ2V0KGlkZWFsKTtcbiAgICBpZiAodGFyZ2V0ICE9PSBpZGVhbClcbiAgICAgICAgYW1wbGl0dWRlID0gdGFyZ2V0IC0gZnJvbTtcbiAgICByZXR1cm4ge1xuICAgICAgICBuZXh0OiAodCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZGVsdGEgPSAtYW1wbGl0dWRlICogTWF0aC5leHAoLXQgLyB0aW1lQ29uc3RhbnQpO1xuICAgICAgICAgICAgc3RhdGUuZG9uZSA9ICEoZGVsdGEgPiByZXN0RGVsdGEgfHwgZGVsdGEgPCAtcmVzdERlbHRhKTtcbiAgICAgICAgICAgIHN0YXRlLnZhbHVlID0gc3RhdGUuZG9uZSA/IHRhcmdldCA6IHRhcmdldCArIGRlbHRhO1xuICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgICB9LFxuICAgICAgICBmbGlwVGFyZ2V0OiAoKSA9PiB7IH0sXG4gICAgfTtcbn1cblxuZXhwb3J0IHsgZGVjYXkgfTtcbiIsImltcG9ydCB7IHNwcmluZyB9IGZyb20gJy4uL2dlbmVyYXRvcnMvc3ByaW5nLm1qcyc7XG5pbXBvcnQgeyBrZXlmcmFtZXMgfSBmcm9tICcuLi9nZW5lcmF0b3JzL2tleWZyYW1lcy5tanMnO1xuaW1wb3J0IHsgZGVjYXkgfSBmcm9tICcuLi9nZW5lcmF0b3JzL2RlY2F5Lm1qcyc7XG5cbmNvbnN0IHR5cGVzID0geyBrZXlmcmFtZXMsIHNwcmluZywgZGVjYXkgfTtcbmZ1bmN0aW9uIGRldGVjdEFuaW1hdGlvbkZyb21PcHRpb25zKGNvbmZpZykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGNvbmZpZy50bykpIHtcbiAgICAgICAgcmV0dXJuIGtleWZyYW1lcztcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZXNbY29uZmlnLnR5cGVdKSB7XG4gICAgICAgIHJldHVybiB0eXBlc1tjb25maWcudHlwZV07XG4gICAgfVxuICAgIGNvbnN0IGtleXMgPSBuZXcgU2V0KE9iamVjdC5rZXlzKGNvbmZpZykpO1xuICAgIGlmIChrZXlzLmhhcyhcImVhc2VcIikgfHxcbiAgICAgICAgKGtleXMuaGFzKFwiZHVyYXRpb25cIikgJiYgIWtleXMuaGFzKFwiZGFtcGluZ1JhdGlvXCIpKSkge1xuICAgICAgICByZXR1cm4ga2V5ZnJhbWVzO1xuICAgIH1cbiAgICBlbHNlIGlmIChrZXlzLmhhcyhcImRhbXBpbmdSYXRpb1wiKSB8fFxuICAgICAgICBrZXlzLmhhcyhcInN0aWZmbmVzc1wiKSB8fFxuICAgICAgICBrZXlzLmhhcyhcIm1hc3NcIikgfHxcbiAgICAgICAga2V5cy5oYXMoXCJkYW1waW5nXCIpIHx8XG4gICAgICAgIGtleXMuaGFzKFwicmVzdFNwZWVkXCIpIHx8XG4gICAgICAgIGtleXMuaGFzKFwicmVzdERlbHRhXCIpKSB7XG4gICAgICAgIHJldHVybiBzcHJpbmc7XG4gICAgfVxuICAgIHJldHVybiBrZXlmcmFtZXM7XG59XG5cbmV4cG9ydCB7IGRldGVjdEFuaW1hdGlvbkZyb21PcHRpb25zIH07XG4iLCJjb25zdCBkZWZhdWx0VGltZXN0ZXAgPSAoMSAvIDYwKSAqIDEwMDA7XG5jb25zdCBnZXRDdXJyZW50VGltZSA9IHR5cGVvZiBwZXJmb3JtYW5jZSAhPT0gXCJ1bmRlZmluZWRcIlxuICAgID8gKCkgPT4gcGVyZm9ybWFuY2Uubm93KClcbiAgICA6ICgpID0+IERhdGUubm93KCk7XG5jb25zdCBvbk5leHRGcmFtZSA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCJcbiAgICA/IChjYWxsYmFjaykgPT4gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShjYWxsYmFjaylcbiAgICA6IChjYWxsYmFjaykgPT4gc2V0VGltZW91dCgoKSA9PiBjYWxsYmFjayhnZXRDdXJyZW50VGltZSgpKSwgZGVmYXVsdFRpbWVzdGVwKTtcblxuZXhwb3J0IHsgZGVmYXVsdFRpbWVzdGVwLCBvbk5leHRGcmFtZSB9O1xuIiwiZnVuY3Rpb24gY3JlYXRlUmVuZGVyU3RlcChydW5OZXh0RnJhbWUpIHtcbiAgICBsZXQgdG9SdW4gPSBbXTtcbiAgICBsZXQgdG9SdW5OZXh0RnJhbWUgPSBbXTtcbiAgICBsZXQgbnVtVG9SdW4gPSAwO1xuICAgIGxldCBpc1Byb2Nlc3NpbmcgPSBmYWxzZTtcbiAgICBsZXQgZmx1c2hOZXh0RnJhbWUgPSBmYWxzZTtcbiAgICBjb25zdCB0b0tlZXBBbGl2ZSA9IG5ldyBXZWFrU2V0KCk7XG4gICAgY29uc3Qgc3RlcCA9IHtcbiAgICAgICAgc2NoZWR1bGU6IChjYWxsYmFjaywga2VlcEFsaXZlID0gZmFsc2UsIGltbWVkaWF0ZSA9IGZhbHNlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhZGRUb0N1cnJlbnRGcmFtZSA9IGltbWVkaWF0ZSAmJiBpc1Byb2Nlc3Npbmc7XG4gICAgICAgICAgICBjb25zdCBidWZmZXIgPSBhZGRUb0N1cnJlbnRGcmFtZSA/IHRvUnVuIDogdG9SdW5OZXh0RnJhbWU7XG4gICAgICAgICAgICBpZiAoa2VlcEFsaXZlKVxuICAgICAgICAgICAgICAgIHRvS2VlcEFsaXZlLmFkZChjYWxsYmFjayk7XG4gICAgICAgICAgICBpZiAoYnVmZmVyLmluZGV4T2YoY2FsbGJhY2spID09PSAtMSkge1xuICAgICAgICAgICAgICAgIGJ1ZmZlci5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICBpZiAoYWRkVG9DdXJyZW50RnJhbWUgJiYgaXNQcm9jZXNzaW5nKVxuICAgICAgICAgICAgICAgICAgICBudW1Ub1J1biA9IHRvUnVuLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjaztcbiAgICAgICAgfSxcbiAgICAgICAgY2FuY2VsOiAoY2FsbGJhY2spID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gdG9SdW5OZXh0RnJhbWUuaW5kZXhPZihjYWxsYmFjayk7XG4gICAgICAgICAgICBpZiAoaW5kZXggIT09IC0xKVxuICAgICAgICAgICAgICAgIHRvUnVuTmV4dEZyYW1lLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB0b0tlZXBBbGl2ZS5kZWxldGUoY2FsbGJhY2spO1xuICAgICAgICB9LFxuICAgICAgICBwcm9jZXNzOiAoZnJhbWVEYXRhKSA9PiB7XG4gICAgICAgICAgICBpZiAoaXNQcm9jZXNzaW5nKSB7XG4gICAgICAgICAgICAgICAgZmx1c2hOZXh0RnJhbWUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlzUHJvY2Vzc2luZyA9IHRydWU7XG4gICAgICAgICAgICBbdG9SdW4sIHRvUnVuTmV4dEZyYW1lXSA9IFt0b1J1bk5leHRGcmFtZSwgdG9SdW5dO1xuICAgICAgICAgICAgdG9SdW5OZXh0RnJhbWUubGVuZ3RoID0gMDtcbiAgICAgICAgICAgIG51bVRvUnVuID0gdG9SdW4ubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKG51bVRvUnVuKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1Ub1J1bjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrID0gdG9SdW5baV07XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGZyYW1lRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b0tlZXBBbGl2ZS5oYXMoY2FsbGJhY2spKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGVwLnNjaGVkdWxlKGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bk5leHRGcmFtZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXNQcm9jZXNzaW5nID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoZmx1c2hOZXh0RnJhbWUpIHtcbiAgICAgICAgICAgICAgICBmbHVzaE5leHRGcmFtZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHN0ZXAucHJvY2VzcyhmcmFtZURhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH07XG4gICAgcmV0dXJuIHN0ZXA7XG59XG5cbmV4cG9ydCB7IGNyZWF0ZVJlbmRlclN0ZXAgfTtcbiIsImltcG9ydCB7IG9uTmV4dEZyYW1lLCBkZWZhdWx0VGltZXN0ZXAgfSBmcm9tICcuL29uLW5leHQtZnJhbWUubWpzJztcbmltcG9ydCB7IGNyZWF0ZVJlbmRlclN0ZXAgfSBmcm9tICcuL2NyZWF0ZS1yZW5kZXItc3RlcC5tanMnO1xuXG5jb25zdCBtYXhFbGFwc2VkID0gNDA7XG5sZXQgdXNlRGVmYXVsdEVsYXBzZWQgPSB0cnVlO1xubGV0IHJ1bk5leHRGcmFtZSA9IGZhbHNlO1xubGV0IGlzUHJvY2Vzc2luZyA9IGZhbHNlO1xuY29uc3QgZnJhbWUgPSB7XG4gICAgZGVsdGE6IDAsXG4gICAgdGltZXN0YW1wOiAwLFxufTtcbmNvbnN0IHN0ZXBzT3JkZXIgPSBbXG4gICAgXCJyZWFkXCIsXG4gICAgXCJ1cGRhdGVcIixcbiAgICBcInByZVJlbmRlclwiLFxuICAgIFwicmVuZGVyXCIsXG4gICAgXCJwb3N0UmVuZGVyXCIsXG5dO1xuY29uc3Qgc3RlcHMgPSBzdGVwc09yZGVyLnJlZHVjZSgoYWNjLCBrZXkpID0+IHtcbiAgICBhY2Nba2V5XSA9IGNyZWF0ZVJlbmRlclN0ZXAoKCkgPT4gKHJ1bk5leHRGcmFtZSA9IHRydWUpKTtcbiAgICByZXR1cm4gYWNjO1xufSwge30pO1xuY29uc3Qgc3luYyA9IHN0ZXBzT3JkZXIucmVkdWNlKChhY2MsIGtleSkgPT4ge1xuICAgIGNvbnN0IHN0ZXAgPSBzdGVwc1trZXldO1xuICAgIGFjY1trZXldID0gKHByb2Nlc3MsIGtlZXBBbGl2ZSA9IGZhbHNlLCBpbW1lZGlhdGUgPSBmYWxzZSkgPT4ge1xuICAgICAgICBpZiAoIXJ1bk5leHRGcmFtZSlcbiAgICAgICAgICAgIHN0YXJ0TG9vcCgpO1xuICAgICAgICByZXR1cm4gc3RlcC5zY2hlZHVsZShwcm9jZXNzLCBrZWVwQWxpdmUsIGltbWVkaWF0ZSk7XG4gICAgfTtcbiAgICByZXR1cm4gYWNjO1xufSwge30pO1xuY29uc3QgY2FuY2VsU3luYyA9IHN0ZXBzT3JkZXIucmVkdWNlKChhY2MsIGtleSkgPT4ge1xuICAgIGFjY1trZXldID0gc3RlcHNba2V5XS5jYW5jZWw7XG4gICAgcmV0dXJuIGFjYztcbn0sIHt9KTtcbmNvbnN0IGZsdXNoU3luYyA9IHN0ZXBzT3JkZXIucmVkdWNlKChhY2MsIGtleSkgPT4ge1xuICAgIGFjY1trZXldID0gKCkgPT4gc3RlcHNba2V5XS5wcm9jZXNzKGZyYW1lKTtcbiAgICByZXR1cm4gYWNjO1xufSwge30pO1xuY29uc3QgcHJvY2Vzc1N0ZXAgPSAoc3RlcElkKSA9PiBzdGVwc1tzdGVwSWRdLnByb2Nlc3MoZnJhbWUpO1xuY29uc3QgcHJvY2Vzc0ZyYW1lID0gKHRpbWVzdGFtcCkgPT4ge1xuICAgIHJ1bk5leHRGcmFtZSA9IGZhbHNlO1xuICAgIGZyYW1lLmRlbHRhID0gdXNlRGVmYXVsdEVsYXBzZWRcbiAgICAgICAgPyBkZWZhdWx0VGltZXN0ZXBcbiAgICAgICAgOiBNYXRoLm1heChNYXRoLm1pbih0aW1lc3RhbXAgLSBmcmFtZS50aW1lc3RhbXAsIG1heEVsYXBzZWQpLCAxKTtcbiAgICBmcmFtZS50aW1lc3RhbXAgPSB0aW1lc3RhbXA7XG4gICAgaXNQcm9jZXNzaW5nID0gdHJ1ZTtcbiAgICBzdGVwc09yZGVyLmZvckVhY2gocHJvY2Vzc1N0ZXApO1xuICAgIGlzUHJvY2Vzc2luZyA9IGZhbHNlO1xuICAgIGlmIChydW5OZXh0RnJhbWUpIHtcbiAgICAgICAgdXNlRGVmYXVsdEVsYXBzZWQgPSBmYWxzZTtcbiAgICAgICAgb25OZXh0RnJhbWUocHJvY2Vzc0ZyYW1lKTtcbiAgICB9XG59O1xuY29uc3Qgc3RhcnRMb29wID0gKCkgPT4ge1xuICAgIHJ1bk5leHRGcmFtZSA9IHRydWU7XG4gICAgdXNlRGVmYXVsdEVsYXBzZWQgPSB0cnVlO1xuICAgIGlmICghaXNQcm9jZXNzaW5nKVxuICAgICAgICBvbk5leHRGcmFtZShwcm9jZXNzRnJhbWUpO1xufTtcbmNvbnN0IGdldEZyYW1lRGF0YSA9ICgpID0+IGZyYW1lO1xuXG5leHBvcnQgZGVmYXVsdCBzeW5jO1xuZXhwb3J0IHsgY2FuY2VsU3luYywgZmx1c2hTeW5jLCBnZXRGcmFtZURhdGEgfTtcbiIsImZ1bmN0aW9uIGxvb3BFbGFwc2VkKGVsYXBzZWQsIGR1cmF0aW9uLCBkZWxheSA9IDApIHtcbiAgICByZXR1cm4gZWxhcHNlZCAtIGR1cmF0aW9uIC0gZGVsYXk7XG59XG5mdW5jdGlvbiByZXZlcnNlRWxhcHNlZChlbGFwc2VkLCBkdXJhdGlvbiwgZGVsYXkgPSAwLCBpc0ZvcndhcmRQbGF5YmFjayA9IHRydWUpIHtcbiAgICByZXR1cm4gaXNGb3J3YXJkUGxheWJhY2tcbiAgICAgICAgPyBsb29wRWxhcHNlZChkdXJhdGlvbiArIC1lbGFwc2VkLCBkdXJhdGlvbiwgZGVsYXkpXG4gICAgICAgIDogZHVyYXRpb24gLSAoZWxhcHNlZCAtIGR1cmF0aW9uKSArIGRlbGF5O1xufVxuZnVuY3Rpb24gaGFzUmVwZWF0RGVsYXlFbGFwc2VkKGVsYXBzZWQsIGR1cmF0aW9uLCBkZWxheSwgaXNGb3J3YXJkUGxheWJhY2spIHtcbiAgICByZXR1cm4gaXNGb3J3YXJkUGxheWJhY2sgPyBlbGFwc2VkID49IGR1cmF0aW9uICsgZGVsYXkgOiBlbGFwc2VkIDw9IC1kZWxheTtcbn1cblxuZXhwb3J0IHsgaGFzUmVwZWF0RGVsYXlFbGFwc2VkLCBsb29wRWxhcHNlZCwgcmV2ZXJzZUVsYXBzZWQgfTtcbiIsImltcG9ydCB7IF9fcmVzdCB9IGZyb20gJ3RzbGliJztcbmltcG9ydCB7IGRldGVjdEFuaW1hdGlvbkZyb21PcHRpb25zIH0gZnJvbSAnLi91dGlscy9kZXRlY3QtYW5pbWF0aW9uLWZyb20tb3B0aW9ucy5tanMnO1xuaW1wb3J0IHN5bmMsIHsgY2FuY2VsU3luYyB9IGZyb20gJ2ZyYW1lc3luYyc7XG5pbXBvcnQgeyBpbnRlcnBvbGF0ZSB9IGZyb20gJy4uL3V0aWxzL2ludGVycG9sYXRlLm1qcyc7XG5pbXBvcnQgeyBoYXNSZXBlYXREZWxheUVsYXBzZWQsIHJldmVyc2VFbGFwc2VkLCBsb29wRWxhcHNlZCB9IGZyb20gJy4vdXRpbHMvZWxhcHNlZC5tanMnO1xuXG5jb25zdCBmcmFtZXN5bmMgPSAodXBkYXRlKSA9PiB7XG4gICAgY29uc3QgcGFzc1RpbWVzdGFtcCA9ICh7IGRlbHRhIH0pID0+IHVwZGF0ZShkZWx0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RhcnQ6ICgpID0+IHN5bmMudXBkYXRlKHBhc3NUaW1lc3RhbXAsIHRydWUpLFxuICAgICAgICBzdG9wOiAoKSA9PiBjYW5jZWxTeW5jLnVwZGF0ZShwYXNzVGltZXN0YW1wKSxcbiAgICB9O1xufTtcbmZ1bmN0aW9uIGFuaW1hdGUoX2EpIHtcbiAgICB2YXIgX2IsIF9jO1xuICAgIHZhciB7IGZyb20sIGF1dG9wbGF5ID0gdHJ1ZSwgZHJpdmVyID0gZnJhbWVzeW5jLCBlbGFwc2VkID0gMCwgcmVwZWF0OiByZXBlYXRNYXggPSAwLCByZXBlYXRUeXBlID0gXCJsb29wXCIsIHJlcGVhdERlbGF5ID0gMCwgb25QbGF5LCBvblN0b3AsIG9uQ29tcGxldGUsIG9uUmVwZWF0LCBvblVwZGF0ZSB9ID0gX2EsIG9wdGlvbnMgPSBfX3Jlc3QoX2EsIFtcImZyb21cIiwgXCJhdXRvcGxheVwiLCBcImRyaXZlclwiLCBcImVsYXBzZWRcIiwgXCJyZXBlYXRcIiwgXCJyZXBlYXRUeXBlXCIsIFwicmVwZWF0RGVsYXlcIiwgXCJvblBsYXlcIiwgXCJvblN0b3BcIiwgXCJvbkNvbXBsZXRlXCIsIFwib25SZXBlYXRcIiwgXCJvblVwZGF0ZVwiXSk7XG4gICAgbGV0IHsgdG8gfSA9IG9wdGlvbnM7XG4gICAgbGV0IGRyaXZlckNvbnRyb2xzO1xuICAgIGxldCByZXBlYXRDb3VudCA9IDA7XG4gICAgbGV0IGNvbXB1dGVkRHVyYXRpb24gPSBvcHRpb25zLmR1cmF0aW9uO1xuICAgIGxldCBsYXRlc3Q7XG4gICAgbGV0IGlzQ29tcGxldGUgPSBmYWxzZTtcbiAgICBsZXQgaXNGb3J3YXJkUGxheWJhY2sgPSB0cnVlO1xuICAgIGxldCBpbnRlcnBvbGF0ZUZyb21OdW1iZXI7XG4gICAgY29uc3QgYW5pbWF0b3IgPSBkZXRlY3RBbmltYXRpb25Gcm9tT3B0aW9ucyhvcHRpb25zKTtcbiAgICBpZiAoKF9jID0gKF9iID0gYW5pbWF0b3IpLm5lZWRzSW50ZXJwb2xhdGlvbikgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmNhbGwoX2IsIGZyb20sIHRvKSkge1xuICAgICAgICBpbnRlcnBvbGF0ZUZyb21OdW1iZXIgPSBpbnRlcnBvbGF0ZShbMCwgMTAwXSwgW2Zyb20sIHRvXSwge1xuICAgICAgICAgICAgY2xhbXA6IGZhbHNlLFxuICAgICAgICB9KTtcbiAgICAgICAgZnJvbSA9IDA7XG4gICAgICAgIHRvID0gMTAwO1xuICAgIH1cbiAgICBjb25zdCBhbmltYXRpb24gPSBhbmltYXRvcihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpLCB7IGZyb20sIHRvIH0pKTtcbiAgICBmdW5jdGlvbiByZXBlYXQoKSB7XG4gICAgICAgIHJlcGVhdENvdW50Kys7XG4gICAgICAgIGlmIChyZXBlYXRUeXBlID09PSBcInJldmVyc2VcIikge1xuICAgICAgICAgICAgaXNGb3J3YXJkUGxheWJhY2sgPSByZXBlYXRDb3VudCAlIDIgPT09IDA7XG4gICAgICAgICAgICBlbGFwc2VkID0gcmV2ZXJzZUVsYXBzZWQoZWxhcHNlZCwgY29tcHV0ZWREdXJhdGlvbiwgcmVwZWF0RGVsYXksIGlzRm9yd2FyZFBsYXliYWNrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVsYXBzZWQgPSBsb29wRWxhcHNlZChlbGFwc2VkLCBjb21wdXRlZER1cmF0aW9uLCByZXBlYXREZWxheSk7XG4gICAgICAgICAgICBpZiAocmVwZWF0VHlwZSA9PT0gXCJtaXJyb3JcIilcbiAgICAgICAgICAgICAgICBhbmltYXRpb24uZmxpcFRhcmdldCgpO1xuICAgICAgICB9XG4gICAgICAgIGlzQ29tcGxldGUgPSBmYWxzZTtcbiAgICAgICAgb25SZXBlYXQgJiYgb25SZXBlYXQoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29tcGxldGUoKSB7XG4gICAgICAgIGRyaXZlckNvbnRyb2xzLnN0b3AoKTtcbiAgICAgICAgb25Db21wbGV0ZSAmJiBvbkNvbXBsZXRlKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZShkZWx0YSkge1xuICAgICAgICBpZiAoIWlzRm9yd2FyZFBsYXliYWNrKVxuICAgICAgICAgICAgZGVsdGEgPSAtZGVsdGE7XG4gICAgICAgIGVsYXBzZWQgKz0gZGVsdGE7XG4gICAgICAgIGlmICghaXNDb21wbGV0ZSkge1xuICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSBhbmltYXRpb24ubmV4dChNYXRoLm1heCgwLCBlbGFwc2VkKSk7XG4gICAgICAgICAgICBsYXRlc3QgPSBzdGF0ZS52YWx1ZTtcbiAgICAgICAgICAgIGlmIChpbnRlcnBvbGF0ZUZyb21OdW1iZXIpXG4gICAgICAgICAgICAgICAgbGF0ZXN0ID0gaW50ZXJwb2xhdGVGcm9tTnVtYmVyKGxhdGVzdCk7XG4gICAgICAgICAgICBpc0NvbXBsZXRlID0gaXNGb3J3YXJkUGxheWJhY2sgPyBzdGF0ZS5kb25lIDogZWxhcHNlZCA8PSAwO1xuICAgICAgICB9XG4gICAgICAgIG9uVXBkYXRlID09PSBudWxsIHx8IG9uVXBkYXRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvblVwZGF0ZShsYXRlc3QpO1xuICAgICAgICBpZiAoaXNDb21wbGV0ZSkge1xuICAgICAgICAgICAgaWYgKHJlcGVhdENvdW50ID09PSAwKVxuICAgICAgICAgICAgICAgIGNvbXB1dGVkRHVyYXRpb24gIT09IG51bGwgJiYgY29tcHV0ZWREdXJhdGlvbiAhPT0gdm9pZCAwID8gY29tcHV0ZWREdXJhdGlvbiA6IChjb21wdXRlZER1cmF0aW9uID0gZWxhcHNlZCk7XG4gICAgICAgICAgICBpZiAocmVwZWF0Q291bnQgPCByZXBlYXRNYXgpIHtcbiAgICAgICAgICAgICAgICBoYXNSZXBlYXREZWxheUVsYXBzZWQoZWxhcHNlZCwgY29tcHV0ZWREdXJhdGlvbiwgcmVwZWF0RGVsYXksIGlzRm9yd2FyZFBsYXliYWNrKSAmJiByZXBlYXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbXBsZXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcGxheSgpIHtcbiAgICAgICAgb25QbGF5ID09PSBudWxsIHx8IG9uUGxheSA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25QbGF5KCk7XG4gICAgICAgIGRyaXZlckNvbnRyb2xzID0gZHJpdmVyKHVwZGF0ZSk7XG4gICAgICAgIGRyaXZlckNvbnRyb2xzLnN0YXJ0KCk7XG4gICAgfVxuICAgIGF1dG9wbGF5ICYmIHBsYXkoKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdG9wOiAoKSA9PiB7XG4gICAgICAgICAgICBvblN0b3AgPT09IG51bGwgfHwgb25TdG9wID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvblN0b3AoKTtcbiAgICAgICAgICAgIGRyaXZlckNvbnRyb2xzLnN0b3AoKTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuXG5leHBvcnQgeyBhbmltYXRlIH07XG4iLCJmdW5jdGlvbiB2ZWxvY2l0eVBlclNlY29uZCh2ZWxvY2l0eSwgZnJhbWVEdXJhdGlvbikge1xuICAgIHJldHVybiBmcmFtZUR1cmF0aW9uID8gdmVsb2NpdHkgKiAoMTAwMCAvIGZyYW1lRHVyYXRpb24pIDogMDtcbn1cblxuZXhwb3J0IHsgdmVsb2NpdHlQZXJTZWNvbmQgfTtcbiIsImltcG9ydCB7IGFuaW1hdGUgfSBmcm9tICcuL2luZGV4Lm1qcyc7XG5pbXBvcnQgeyB2ZWxvY2l0eVBlclNlY29uZCB9IGZyb20gJy4uL3V0aWxzL3ZlbG9jaXR5LXBlci1zZWNvbmQubWpzJztcbmltcG9ydCB7IGdldEZyYW1lRGF0YSB9IGZyb20gJ2ZyYW1lc3luYyc7XG5cbmZ1bmN0aW9uIGluZXJ0aWEoeyBmcm9tID0gMCwgdmVsb2NpdHkgPSAwLCBtaW4sIG1heCwgcG93ZXIgPSAwLjgsIHRpbWVDb25zdGFudCA9IDc1MCwgYm91bmNlU3RpZmZuZXNzID0gNTAwLCBib3VuY2VEYW1waW5nID0gMTAsIHJlc3REZWx0YSA9IDEsIG1vZGlmeVRhcmdldCwgZHJpdmVyLCBvblVwZGF0ZSwgb25Db21wbGV0ZSwgb25TdG9wLCB9KSB7XG4gICAgbGV0IGN1cnJlbnRBbmltYXRpb247XG4gICAgZnVuY3Rpb24gaXNPdXRPZkJvdW5kcyh2KSB7XG4gICAgICAgIHJldHVybiAobWluICE9PSB1bmRlZmluZWQgJiYgdiA8IG1pbikgfHwgKG1heCAhPT0gdW5kZWZpbmVkICYmIHYgPiBtYXgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBib3VuZGFyeU5lYXJlc3Qodikge1xuICAgICAgICBpZiAobWluID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gbWF4O1xuICAgICAgICBpZiAobWF4ID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gbWluO1xuICAgICAgICByZXR1cm4gTWF0aC5hYnMobWluIC0gdikgPCBNYXRoLmFicyhtYXggLSB2KSA/IG1pbiA6IG1heDtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3RhcnRBbmltYXRpb24ob3B0aW9ucykge1xuICAgICAgICBjdXJyZW50QW5pbWF0aW9uID09PSBudWxsIHx8IGN1cnJlbnRBbmltYXRpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN1cnJlbnRBbmltYXRpb24uc3RvcCgpO1xuICAgICAgICBjdXJyZW50QW5pbWF0aW9uID0gYW5pbWF0ZShPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpLCB7IGRyaXZlciwgb25VcGRhdGU6ICh2KSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIG9uVXBkYXRlID09PSBudWxsIHx8IG9uVXBkYXRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvblVwZGF0ZSh2KTtcbiAgICAgICAgICAgICAgICAoX2EgPSBvcHRpb25zLm9uVXBkYXRlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChvcHRpb25zLCB2KTtcbiAgICAgICAgICAgIH0sIG9uQ29tcGxldGUsXG4gICAgICAgICAgICBvblN0b3AgfSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzdGFydFNwcmluZyhvcHRpb25zKSB7XG4gICAgICAgIHN0YXJ0QW5pbWF0aW9uKE9iamVjdC5hc3NpZ24oeyB0eXBlOiBcInNwcmluZ1wiLCBzdGlmZm5lc3M6IGJvdW5jZVN0aWZmbmVzcywgZGFtcGluZzogYm91bmNlRGFtcGluZywgcmVzdERlbHRhIH0sIG9wdGlvbnMpKTtcbiAgICB9XG4gICAgaWYgKGlzT3V0T2ZCb3VuZHMoZnJvbSkpIHtcbiAgICAgICAgc3RhcnRTcHJpbmcoeyBmcm9tLCB2ZWxvY2l0eSwgdG86IGJvdW5kYXJ5TmVhcmVzdChmcm9tKSB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxldCB0YXJnZXQgPSBwb3dlciAqIHZlbG9jaXR5ICsgZnJvbTtcbiAgICAgICAgaWYgKHR5cGVvZiBtb2RpZnlUYXJnZXQgIT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgICAgICB0YXJnZXQgPSBtb2RpZnlUYXJnZXQodGFyZ2V0KTtcbiAgICAgICAgY29uc3QgYm91bmRhcnkgPSBib3VuZGFyeU5lYXJlc3QodGFyZ2V0KTtcbiAgICAgICAgY29uc3QgaGVhZGluZyA9IGJvdW5kYXJ5ID09PSBtaW4gPyAtMSA6IDE7XG4gICAgICAgIGxldCBwcmV2O1xuICAgICAgICBsZXQgY3VycmVudDtcbiAgICAgICAgY29uc3QgY2hlY2tCb3VuZGFyeSA9ICh2KSA9PiB7XG4gICAgICAgICAgICBwcmV2ID0gY3VycmVudDtcbiAgICAgICAgICAgIGN1cnJlbnQgPSB2O1xuICAgICAgICAgICAgdmVsb2NpdHkgPSB2ZWxvY2l0eVBlclNlY29uZCh2IC0gcHJldiwgZ2V0RnJhbWVEYXRhKCkuZGVsdGEpO1xuICAgICAgICAgICAgaWYgKChoZWFkaW5nID09PSAxICYmIHYgPiBib3VuZGFyeSkgfHxcbiAgICAgICAgICAgICAgICAoaGVhZGluZyA9PT0gLTEgJiYgdiA8IGJvdW5kYXJ5KSkge1xuICAgICAgICAgICAgICAgIHN0YXJ0U3ByaW5nKHsgZnJvbTogdiwgdG86IGJvdW5kYXJ5LCB2ZWxvY2l0eSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgc3RhcnRBbmltYXRpb24oe1xuICAgICAgICAgICAgdHlwZTogXCJkZWNheVwiLFxuICAgICAgICAgICAgZnJvbSxcbiAgICAgICAgICAgIHZlbG9jaXR5LFxuICAgICAgICAgICAgdGltZUNvbnN0YW50LFxuICAgICAgICAgICAgcG93ZXIsXG4gICAgICAgICAgICByZXN0RGVsdGEsXG4gICAgICAgICAgICBtb2RpZnlUYXJnZXQsXG4gICAgICAgICAgICBvblVwZGF0ZTogaXNPdXRPZkJvdW5kcyh0YXJnZXQpID8gY2hlY2tCb3VuZGFyeSA6IHVuZGVmaW5lZCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHN0b3A6ICgpID0+IGN1cnJlbnRBbmltYXRpb24gPT09IG51bGwgfHwgY3VycmVudEFuaW1hdGlvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3VycmVudEFuaW1hdGlvbi5zdG9wKCksXG4gICAgfTtcbn1cblxuZXhwb3J0IHsgaW5lcnRpYSB9O1xuIiwiLyoqXG4gKiBDb252ZXJ0cyBzZWNvbmRzIHRvIG1pbGxpc2Vjb25kc1xuICpcbiAqIEBwYXJhbSBzZWNvbmRzIC0gVGltZSBpbiBzZWNvbmRzLlxuICogQHJldHVybiBtaWxsaXNlY29uZHMgLSBDb252ZXJ0ZWQgdGltZSBpbiBtaWxsaXNlY29uZHMuXG4gKi9cbnZhciBzZWNvbmRzVG9NaWxsaXNlY29uZHMgPSBmdW5jdGlvbiAoc2Vjb25kcykgeyByZXR1cm4gc2Vjb25kcyAqIDEwMDA7IH07XG5cbmV4cG9ydCB7IHNlY29uZHNUb01pbGxpc2Vjb25kcyB9O1xuIiwiaW1wb3J0IHsgbGluZWFyIH0gZnJvbSAnLi9pbmRleC5tanMnO1xuXG5jb25zdCBhID0gKGExLCBhMikgPT4gMS4wIC0gMy4wICogYTIgKyAzLjAgKiBhMTtcbmNvbnN0IGIgPSAoYTEsIGEyKSA9PiAzLjAgKiBhMiAtIDYuMCAqIGExO1xuY29uc3QgYyA9IChhMSkgPT4gMy4wICogYTE7XG5jb25zdCBjYWxjQmV6aWVyID0gKHQsIGExLCBhMikgPT4gKChhKGExLCBhMikgKiB0ICsgYihhMSwgYTIpKSAqIHQgKyBjKGExKSkgKiB0O1xuY29uc3QgZ2V0U2xvcGUgPSAodCwgYTEsIGEyKSA9PiAzLjAgKiBhKGExLCBhMikgKiB0ICogdCArIDIuMCAqIGIoYTEsIGEyKSAqIHQgKyBjKGExKTtcbmNvbnN0IHN1YmRpdmlzaW9uUHJlY2lzaW9uID0gMC4wMDAwMDAxO1xuY29uc3Qgc3ViZGl2aXNpb25NYXhJdGVyYXRpb25zID0gMTA7XG5mdW5jdGlvbiBiaW5hcnlTdWJkaXZpZGUoYVgsIGFBLCBhQiwgbVgxLCBtWDIpIHtcbiAgICBsZXQgY3VycmVudFg7XG4gICAgbGV0IGN1cnJlbnRUO1xuICAgIGxldCBpID0gMDtcbiAgICBkbyB7XG4gICAgICAgIGN1cnJlbnRUID0gYUEgKyAoYUIgLSBhQSkgLyAyLjA7XG4gICAgICAgIGN1cnJlbnRYID0gY2FsY0JlemllcihjdXJyZW50VCwgbVgxLCBtWDIpIC0gYVg7XG4gICAgICAgIGlmIChjdXJyZW50WCA+IDAuMCkge1xuICAgICAgICAgICAgYUIgPSBjdXJyZW50VDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFBID0gY3VycmVudFQ7XG4gICAgICAgIH1cbiAgICB9IHdoaWxlIChNYXRoLmFicyhjdXJyZW50WCkgPiBzdWJkaXZpc2lvblByZWNpc2lvbiAmJlxuICAgICAgICArK2kgPCBzdWJkaXZpc2lvbk1heEl0ZXJhdGlvbnMpO1xuICAgIHJldHVybiBjdXJyZW50VDtcbn1cbmNvbnN0IG5ld3Rvbkl0ZXJhdGlvbnMgPSA4O1xuY29uc3QgbmV3dG9uTWluU2xvcGUgPSAwLjAwMTtcbmZ1bmN0aW9uIG5ld3RvblJhcGhzb25JdGVyYXRlKGFYLCBhR3Vlc3NULCBtWDEsIG1YMikge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmV3dG9uSXRlcmF0aW9uczsgKytpKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRTbG9wZSA9IGdldFNsb3BlKGFHdWVzc1QsIG1YMSwgbVgyKTtcbiAgICAgICAgaWYgKGN1cnJlbnRTbG9wZSA9PT0gMC4wKSB7XG4gICAgICAgICAgICByZXR1cm4gYUd1ZXNzVDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjdXJyZW50WCA9IGNhbGNCZXppZXIoYUd1ZXNzVCwgbVgxLCBtWDIpIC0gYVg7XG4gICAgICAgIGFHdWVzc1QgLT0gY3VycmVudFggLyBjdXJyZW50U2xvcGU7XG4gICAgfVxuICAgIHJldHVybiBhR3Vlc3NUO1xufVxuY29uc3Qga1NwbGluZVRhYmxlU2l6ZSA9IDExO1xuY29uc3Qga1NhbXBsZVN0ZXBTaXplID0gMS4wIC8gKGtTcGxpbmVUYWJsZVNpemUgLSAxLjApO1xuZnVuY3Rpb24gY3ViaWNCZXppZXIobVgxLCBtWTEsIG1YMiwgbVkyKSB7XG4gICAgaWYgKG1YMSA9PT0gbVkxICYmIG1YMiA9PT0gbVkyKVxuICAgICAgICByZXR1cm4gbGluZWFyO1xuICAgIGNvbnN0IHNhbXBsZVZhbHVlcyA9IG5ldyBGbG9hdDMyQXJyYXkoa1NwbGluZVRhYmxlU2l6ZSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrU3BsaW5lVGFibGVTaXplOyArK2kpIHtcbiAgICAgICAgc2FtcGxlVmFsdWVzW2ldID0gY2FsY0JlemllcihpICoga1NhbXBsZVN0ZXBTaXplLCBtWDEsIG1YMik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFRGb3JYKGFYKSB7XG4gICAgICAgIGxldCBpbnRlcnZhbFN0YXJ0ID0gMC4wO1xuICAgICAgICBsZXQgY3VycmVudFNhbXBsZSA9IDE7XG4gICAgICAgIGNvbnN0IGxhc3RTYW1wbGUgPSBrU3BsaW5lVGFibGVTaXplIC0gMTtcbiAgICAgICAgZm9yICg7IGN1cnJlbnRTYW1wbGUgIT09IGxhc3RTYW1wbGUgJiYgc2FtcGxlVmFsdWVzW2N1cnJlbnRTYW1wbGVdIDw9IGFYOyArK2N1cnJlbnRTYW1wbGUpIHtcbiAgICAgICAgICAgIGludGVydmFsU3RhcnQgKz0ga1NhbXBsZVN0ZXBTaXplO1xuICAgICAgICB9XG4gICAgICAgIC0tY3VycmVudFNhbXBsZTtcbiAgICAgICAgY29uc3QgZGlzdCA9IChhWCAtIHNhbXBsZVZhbHVlc1tjdXJyZW50U2FtcGxlXSkgL1xuICAgICAgICAgICAgKHNhbXBsZVZhbHVlc1tjdXJyZW50U2FtcGxlICsgMV0gLSBzYW1wbGVWYWx1ZXNbY3VycmVudFNhbXBsZV0pO1xuICAgICAgICBjb25zdCBndWVzc0ZvclQgPSBpbnRlcnZhbFN0YXJ0ICsgZGlzdCAqIGtTYW1wbGVTdGVwU2l6ZTtcbiAgICAgICAgY29uc3QgaW5pdGlhbFNsb3BlID0gZ2V0U2xvcGUoZ3Vlc3NGb3JULCBtWDEsIG1YMik7XG4gICAgICAgIGlmIChpbml0aWFsU2xvcGUgPj0gbmV3dG9uTWluU2xvcGUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXd0b25SYXBoc29uSXRlcmF0ZShhWCwgZ3Vlc3NGb3JULCBtWDEsIG1YMik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW5pdGlhbFNsb3BlID09PSAwLjApIHtcbiAgICAgICAgICAgIHJldHVybiBndWVzc0ZvclQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gYmluYXJ5U3ViZGl2aWRlKGFYLCBpbnRlcnZhbFN0YXJ0LCBpbnRlcnZhbFN0YXJ0ICsga1NhbXBsZVN0ZXBTaXplLCBtWDEsIG1YMik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICh0KSA9PiB0ID09PSAwIHx8IHQgPT09IDEgPyB0IDogY2FsY0JlemllcihnZXRURm9yWCh0KSwgbVkxLCBtWTIpO1xufVxuXG5leHBvcnQgeyBjdWJpY0JlemllciB9O1xuIiwiaW1wb3J0IHsgX19yZWFkIH0gZnJvbSAndHNsaWInO1xuaW1wb3J0IHsgaW52YXJpYW50IH0gZnJvbSAnaGV5LWxpc3Rlbic7XG5pbXBvcnQgeyBjdWJpY0JlemllciwgbGluZWFyLCBlYXNlSW4sIGVhc2VJbk91dCwgZWFzZU91dCwgY2lyY0luLCBjaXJjSW5PdXQsIGNpcmNPdXQsIGJhY2tJbiwgYmFja0luT3V0LCBiYWNrT3V0LCBhbnRpY2lwYXRlLCBib3VuY2VJbiwgYm91bmNlSW5PdXQsIGJvdW5jZU91dCB9IGZyb20gJ3BvcG1vdGlvbic7XG5cbnZhciBlYXNpbmdMb29rdXAgPSB7XG4gICAgbGluZWFyOiBsaW5lYXIsXG4gICAgZWFzZUluOiBlYXNlSW4sXG4gICAgZWFzZUluT3V0OiBlYXNlSW5PdXQsXG4gICAgZWFzZU91dDogZWFzZU91dCxcbiAgICBjaXJjSW46IGNpcmNJbixcbiAgICBjaXJjSW5PdXQ6IGNpcmNJbk91dCxcbiAgICBjaXJjT3V0OiBjaXJjT3V0LFxuICAgIGJhY2tJbjogYmFja0luLFxuICAgIGJhY2tJbk91dDogYmFja0luT3V0LFxuICAgIGJhY2tPdXQ6IGJhY2tPdXQsXG4gICAgYW50aWNpcGF0ZTogYW50aWNpcGF0ZSxcbiAgICBib3VuY2VJbjogYm91bmNlSW4sXG4gICAgYm91bmNlSW5PdXQ6IGJvdW5jZUluT3V0LFxuICAgIGJvdW5jZU91dDogYm91bmNlT3V0LFxufTtcbnZhciBlYXNpbmdEZWZpbml0aW9uVG9GdW5jdGlvbiA9IGZ1bmN0aW9uIChkZWZpbml0aW9uKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZGVmaW5pdGlvbikpIHtcbiAgICAgICAgLy8gSWYgY3ViaWMgYmV6aWVyIGRlZmluaXRpb24sIGNyZWF0ZSBiZXppZXIgY3VydmVcbiAgICAgICAgaW52YXJpYW50KGRlZmluaXRpb24ubGVuZ3RoID09PSA0LCBcIkN1YmljIGJlemllciBhcnJheXMgbXVzdCBjb250YWluIGZvdXIgbnVtZXJpY2FsIHZhbHVlcy5cIik7XG4gICAgICAgIHZhciBfYSA9IF9fcmVhZChkZWZpbml0aW9uLCA0KSwgeDEgPSBfYVswXSwgeTEgPSBfYVsxXSwgeDIgPSBfYVsyXSwgeTIgPSBfYVszXTtcbiAgICAgICAgcmV0dXJuIGN1YmljQmV6aWVyKHgxLCB5MSwgeDIsIHkyKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGRlZmluaXRpb24gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgLy8gRWxzZSBsb29rdXAgZnJvbSB0YWJsZVxuICAgICAgICBpbnZhcmlhbnQoZWFzaW5nTG9va3VwW2RlZmluaXRpb25dICE9PSB1bmRlZmluZWQsIFwiSW52YWxpZCBlYXNpbmcgdHlwZSAnXCIuY29uY2F0KGRlZmluaXRpb24sIFwiJ1wiKSk7XG4gICAgICAgIHJldHVybiBlYXNpbmdMb29rdXBbZGVmaW5pdGlvbl07XG4gICAgfVxuICAgIHJldHVybiBkZWZpbml0aW9uO1xufTtcbnZhciBpc0Vhc2luZ0FycmF5ID0gZnVuY3Rpb24gKGVhc2UpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShlYXNlKSAmJiB0eXBlb2YgZWFzZVswXSAhPT0gXCJudW1iZXJcIjtcbn07XG5cbmV4cG9ydCB7IGVhc2luZ0RlZmluaXRpb25Ub0Z1bmN0aW9uLCBpc0Vhc2luZ0FycmF5IH07XG4iLCJpbXBvcnQgeyBjb21wbGV4IH0gZnJvbSAnc3R5bGUtdmFsdWUtdHlwZXMnO1xuXG4vKipcbiAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYW5pbWF0YWJsZS4gRXhhbXBsZXM6XG4gKlxuICog4pyFOiAxMDAsIFwiMTAwcHhcIiwgXCIjZmZmXCJcbiAqIOKdjDogXCJibG9ja1wiLCBcInVybCgyLmpwZylcIlxuICogQHBhcmFtIHZhbHVlXG4gKlxuICogQGludGVybmFsXG4gKi9cbnZhciBpc0FuaW1hdGFibGUgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgIC8vIElmIHRoZSBsaXN0IG9mIGtleXMgdGF0IG1pZ2h0IGJlIG5vbi1hbmltYXRhYmxlIGdyb3dzLCByZXBsYWNlIHdpdGggU2V0XG4gICAgaWYgKGtleSA9PT0gXCJ6SW5kZXhcIilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIC8vIElmIGl0J3MgYSBudW1iZXIgb3IgYSBrZXlmcmFtZXMgYXJyYXksIHdlIGNhbiBhbmltYXRlIGl0LiBXZSBtaWdodCBhdCBzb21lIHBvaW50XG4gICAgLy8gbmVlZCB0byBkbyBhIGRlZXAgaXNBbmltYXRhYmxlIGNoZWNrIG9mIGtleWZyYW1lcywgb3IgbGV0IFBvcG1vdGlvbiBoYW5kbGUgdGhpcyxcbiAgICAvLyBidXQgZm9yIG5vdyBsZXRzIGxlYXZlIGl0IGxpa2UgdGhpcyBmb3IgcGVyZm9ybWFuY2UgcmVhc29uc1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgfHwgQXJyYXkuaXNBcnJheSh2YWx1ZSkpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgLy8gSXQncyBhbmltYXRhYmxlIGlmIHdlIGhhdmUgYSBzdHJpbmdcbiAgICAgICAgY29tcGxleC50ZXN0KHZhbHVlKSAmJiAvLyBBbmQgaXQgY29udGFpbnMgbnVtYmVycyBhbmQvb3IgY29sb3JzXG4gICAgICAgICF2YWx1ZS5zdGFydHNXaXRoKFwidXJsKFwiKSAvLyBVbmxlc3MgaXQgc3RhcnRzIHdpdGggXCJ1cmwoXCJcbiAgICApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbmV4cG9ydCB7IGlzQW5pbWF0YWJsZSB9O1xuIiwiaW1wb3J0IHsgX19hc3NpZ24gfSBmcm9tICd0c2xpYic7XG5pbXBvcnQgeyBpc0tleWZyYW1lc1RhcmdldCB9IGZyb20gJy4vaXMta2V5ZnJhbWVzLXRhcmdldC5tanMnO1xuXG52YXIgdW5kZXJEYW1wZWRTcHJpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAoe1xuICAgIHR5cGU6IFwic3ByaW5nXCIsXG4gICAgc3RpZmZuZXNzOiA1MDAsXG4gICAgZGFtcGluZzogMjUsXG4gICAgcmVzdFNwZWVkOiAxMCxcbn0pOyB9O1xudmFyIGNyaXRpY2FsbHlEYW1wZWRTcHJpbmcgPSBmdW5jdGlvbiAodG8pIHsgcmV0dXJuICh7XG4gICAgdHlwZTogXCJzcHJpbmdcIixcbiAgICBzdGlmZm5lc3M6IDU1MCxcbiAgICBkYW1waW5nOiB0byA9PT0gMCA/IDIgKiBNYXRoLnNxcnQoNTUwKSA6IDMwLFxuICAgIHJlc3RTcGVlZDogMTAsXG59KTsgfTtcbnZhciBsaW5lYXJUd2VlbiA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7XG4gICAgdHlwZTogXCJrZXlmcmFtZXNcIixcbiAgICBlYXNlOiBcImxpbmVhclwiLFxuICAgIGR1cmF0aW9uOiAwLjMsXG59KTsgfTtcbnZhciBrZXlmcmFtZXMgPSBmdW5jdGlvbiAodmFsdWVzKSB7IHJldHVybiAoe1xuICAgIHR5cGU6IFwia2V5ZnJhbWVzXCIsXG4gICAgZHVyYXRpb246IDAuOCxcbiAgICB2YWx1ZXM6IHZhbHVlcyxcbn0pOyB9O1xudmFyIGRlZmF1bHRUcmFuc2l0aW9ucyA9IHtcbiAgICB4OiB1bmRlckRhbXBlZFNwcmluZyxcbiAgICB5OiB1bmRlckRhbXBlZFNwcmluZyxcbiAgICB6OiB1bmRlckRhbXBlZFNwcmluZyxcbiAgICByb3RhdGU6IHVuZGVyRGFtcGVkU3ByaW5nLFxuICAgIHJvdGF0ZVg6IHVuZGVyRGFtcGVkU3ByaW5nLFxuICAgIHJvdGF0ZVk6IHVuZGVyRGFtcGVkU3ByaW5nLFxuICAgIHJvdGF0ZVo6IHVuZGVyRGFtcGVkU3ByaW5nLFxuICAgIHNjYWxlWDogY3JpdGljYWxseURhbXBlZFNwcmluZyxcbiAgICBzY2FsZVk6IGNyaXRpY2FsbHlEYW1wZWRTcHJpbmcsXG4gICAgc2NhbGU6IGNyaXRpY2FsbHlEYW1wZWRTcHJpbmcsXG4gICAgb3BhY2l0eTogbGluZWFyVHdlZW4sXG4gICAgYmFja2dyb3VuZENvbG9yOiBsaW5lYXJUd2VlbixcbiAgICBjb2xvcjogbGluZWFyVHdlZW4sXG4gICAgZGVmYXVsdDogY3JpdGljYWxseURhbXBlZFNwcmluZyxcbn07XG52YXIgZ2V0RGVmYXVsdFRyYW5zaXRpb24gPSBmdW5jdGlvbiAodmFsdWVLZXksIHRvKSB7XG4gICAgdmFyIHRyYW5zaXRpb25GYWN0b3J5O1xuICAgIGlmIChpc0tleWZyYW1lc1RhcmdldCh0bykpIHtcbiAgICAgICAgdHJhbnNpdGlvbkZhY3RvcnkgPSBrZXlmcmFtZXM7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0cmFuc2l0aW9uRmFjdG9yeSA9XG4gICAgICAgICAgICBkZWZhdWx0VHJhbnNpdGlvbnNbdmFsdWVLZXldIHx8IGRlZmF1bHRUcmFuc2l0aW9ucy5kZWZhdWx0O1xuICAgIH1cbiAgICByZXR1cm4gX19hc3NpZ24oeyB0bzogdG8gfSwgdHJhbnNpdGlvbkZhY3RvcnkodG8pKTtcbn07XG5cbmV4cG9ydCB7IGNyaXRpY2FsbHlEYW1wZWRTcHJpbmcsIGdldERlZmF1bHRUcmFuc2l0aW9uLCBsaW5lYXJUd2VlbiwgdW5kZXJEYW1wZWRTcHJpbmcgfTtcbiIsImltcG9ydCB7IGNvbXBsZXggfSBmcm9tICcuL2luZGV4Lm1qcyc7XG5pbXBvcnQgeyBmbG9hdFJlZ2V4IH0gZnJvbSAnLi4vdXRpbHMubWpzJztcblxuY29uc3QgbWF4RGVmYXVsdHMgPSBuZXcgU2V0KFsnYnJpZ2h0bmVzcycsICdjb250cmFzdCcsICdzYXR1cmF0ZScsICdvcGFjaXR5J10pO1xuZnVuY3Rpb24gYXBwbHlEZWZhdWx0RmlsdGVyKHYpIHtcbiAgICBsZXQgW25hbWUsIHZhbHVlXSA9IHYuc2xpY2UoMCwgLTEpLnNwbGl0KCcoJyk7XG4gICAgaWYgKG5hbWUgPT09ICdkcm9wLXNoYWRvdycpXG4gICAgICAgIHJldHVybiB2O1xuICAgIGNvbnN0IFtudW1iZXJdID0gdmFsdWUubWF0Y2goZmxvYXRSZWdleCkgfHwgW107XG4gICAgaWYgKCFudW1iZXIpXG4gICAgICAgIHJldHVybiB2O1xuICAgIGNvbnN0IHVuaXQgPSB2YWx1ZS5yZXBsYWNlKG51bWJlciwgJycpO1xuICAgIGxldCBkZWZhdWx0VmFsdWUgPSBtYXhEZWZhdWx0cy5oYXMobmFtZSkgPyAxIDogMDtcbiAgICBpZiAobnVtYmVyICE9PSB2YWx1ZSlcbiAgICAgICAgZGVmYXVsdFZhbHVlICo9IDEwMDtcbiAgICByZXR1cm4gbmFtZSArICcoJyArIGRlZmF1bHRWYWx1ZSArIHVuaXQgKyAnKSc7XG59XG5jb25zdCBmdW5jdGlvblJlZ2V4ID0gLyhbYS16LV0qKVxcKC4qP1xcKS9nO1xuY29uc3QgZmlsdGVyID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjb21wbGV4KSwgeyBnZXRBbmltYXRhYmxlTm9uZTogKHYpID0+IHtcbiAgICAgICAgY29uc3QgZnVuY3Rpb25zID0gdi5tYXRjaChmdW5jdGlvblJlZ2V4KTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9ucyA/IGZ1bmN0aW9ucy5tYXAoYXBwbHlEZWZhdWx0RmlsdGVyKS5qb2luKCcgJykgOiB2O1xuICAgIH0gfSk7XG5cbmV4cG9ydCB7IGZpbHRlciB9O1xuIiwiaW1wb3J0IHsgX19hc3NpZ24gfSBmcm9tICd0c2xpYic7XG5pbXBvcnQgeyBjb2xvciwgZmlsdGVyIH0gZnJvbSAnc3R5bGUtdmFsdWUtdHlwZXMnO1xuaW1wb3J0IHsgbnVtYmVyVmFsdWVUeXBlcyB9IGZyb20gJy4vbnVtYmVyLm1qcyc7XG5cbi8qKlxuICogQSBtYXAgb2YgZGVmYXVsdCB2YWx1ZSB0eXBlcyBmb3IgY29tbW9uIHZhbHVlc1xuICovXG52YXIgZGVmYXVsdFZhbHVlVHlwZXMgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgbnVtYmVyVmFsdWVUeXBlcyksIHsgXG4gICAgLy8gQ29sb3IgcHJvcHNcbiAgICBjb2xvcjogY29sb3IsIGJhY2tncm91bmRDb2xvcjogY29sb3IsIG91dGxpbmVDb2xvcjogY29sb3IsIGZpbGw6IGNvbG9yLCBzdHJva2U6IGNvbG9yLCBcbiAgICAvLyBCb3JkZXIgcHJvcHNcbiAgICBib3JkZXJDb2xvcjogY29sb3IsIGJvcmRlclRvcENvbG9yOiBjb2xvciwgYm9yZGVyUmlnaHRDb2xvcjogY29sb3IsIGJvcmRlckJvdHRvbUNvbG9yOiBjb2xvciwgYm9yZGVyTGVmdENvbG9yOiBjb2xvciwgZmlsdGVyOiBmaWx0ZXIsIFdlYmtpdEZpbHRlcjogZmlsdGVyIH0pO1xuLyoqXG4gKiBHZXRzIHRoZSBkZWZhdWx0IFZhbHVlVHlwZSBmb3IgdGhlIHByb3ZpZGVkIHZhbHVlIGtleVxuICovXG52YXIgZ2V0RGVmYXVsdFZhbHVlVHlwZSA9IGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIGRlZmF1bHRWYWx1ZVR5cGVzW2tleV07IH07XG5cbmV4cG9ydCB7IGRlZmF1bHRWYWx1ZVR5cGVzLCBnZXREZWZhdWx0VmFsdWVUeXBlIH07XG4iLCJpbXBvcnQgeyBmaWx0ZXIsIGNvbXBsZXggfSBmcm9tICdzdHlsZS12YWx1ZS10eXBlcyc7XG5pbXBvcnQgeyBnZXREZWZhdWx0VmFsdWVUeXBlIH0gZnJvbSAnLi9kZWZhdWx0cy5tanMnO1xuXG5mdW5jdGlvbiBnZXRBbmltYXRhYmxlTm9uZShrZXksIHZhbHVlKSB7XG4gICAgdmFyIF9hO1xuICAgIHZhciBkZWZhdWx0VmFsdWVUeXBlID0gZ2V0RGVmYXVsdFZhbHVlVHlwZShrZXkpO1xuICAgIGlmIChkZWZhdWx0VmFsdWVUeXBlICE9PSBmaWx0ZXIpXG4gICAgICAgIGRlZmF1bHRWYWx1ZVR5cGUgPSBjb21wbGV4O1xuICAgIC8vIElmIHZhbHVlIGlzIG5vdCByZWNvZ25pc2VkIGFzIGFuaW1hdGFibGUsIGllIFwibm9uZVwiLCBjcmVhdGUgYW4gYW5pbWF0YWJsZSB2ZXJzaW9uIG9yaWdpbiBiYXNlZCBvbiB0aGUgdGFyZ2V0XG4gICAgcmV0dXJuIChfYSA9IGRlZmF1bHRWYWx1ZVR5cGUuZ2V0QW5pbWF0YWJsZU5vbmUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKGRlZmF1bHRWYWx1ZVR5cGUsIHZhbHVlKTtcbn1cblxuZXhwb3J0IHsgZ2V0QW5pbWF0YWJsZU5vbmUgfTtcbiIsInZhciBpbnN0YW50QW5pbWF0aW9uU3RhdGUgPSB7XG4gICAgY3VycmVudDogZmFsc2UsXG59O1xuXG5leHBvcnQgeyBpbnN0YW50QW5pbWF0aW9uU3RhdGUgfTtcbiIsImltcG9ydCB7IF9fYXNzaWduLCBfX3Jlc3QsIF9fc3ByZWFkQXJyYXksIF9fcmVhZCB9IGZyb20gJ3RzbGliJztcbmltcG9ydCB7IGluZXJ0aWEsIGFuaW1hdGUgfSBmcm9tICdwb3Btb3Rpb24nO1xuaW1wb3J0IHsgc2Vjb25kc1RvTWlsbGlzZWNvbmRzIH0gZnJvbSAnLi4vLi4vdXRpbHMvdGltZS1jb252ZXJzaW9uLm1qcyc7XG5pbXBvcnQgeyBpc0Vhc2luZ0FycmF5LCBlYXNpbmdEZWZpbml0aW9uVG9GdW5jdGlvbiB9IGZyb20gJy4vZWFzaW5nLm1qcyc7XG5pbXBvcnQgeyBpc0FuaW1hdGFibGUgfSBmcm9tICcuL2lzLWFuaW1hdGFibGUubWpzJztcbmltcG9ydCB7IGdldERlZmF1bHRUcmFuc2l0aW9uIH0gZnJvbSAnLi9kZWZhdWx0LXRyYW5zaXRpb25zLm1qcyc7XG5pbXBvcnQgeyB3YXJuaW5nIH0gZnJvbSAnaGV5LWxpc3Rlbic7XG5pbXBvcnQgeyBnZXRBbmltYXRhYmxlTm9uZSB9IGZyb20gJy4uLy4uL3JlbmRlci9kb20vdmFsdWUtdHlwZXMvYW5pbWF0YWJsZS1ub25lLm1qcyc7XG5pbXBvcnQgeyBpbnN0YW50QW5pbWF0aW9uU3RhdGUgfSBmcm9tICcuLi8uLi91dGlscy91c2UtaW5zdGFudC10cmFuc2l0aW9uLXN0YXRlLm1qcyc7XG5pbXBvcnQgeyByZXNvbHZlRmluYWxWYWx1ZUluS2V5ZnJhbWVzIH0gZnJvbSAnLi4vLi4vdXRpbHMvcmVzb2x2ZS12YWx1ZS5tanMnO1xuXG4vKipcbiAqIERlY2lkZSB3aGV0aGVyIGEgdHJhbnNpdGlvbiBpcyBkZWZpbmVkIG9uIGEgZ2l2ZW4gVHJhbnNpdGlvbi5cbiAqIFRoaXMgZmlsdGVycyBvdXQgb3JjaGVzdHJhdGlvbiBvcHRpb25zIGFuZCByZXR1cm5zIHRydWVcbiAqIGlmIGFueSBvcHRpb25zIGFyZSBsZWZ0LlxuICovXG5mdW5jdGlvbiBpc1RyYW5zaXRpb25EZWZpbmVkKF9hKSB7XG4gICAgX2Eud2hlbjsgX2EuZGVsYXk7IF9hLmRlbGF5Q2hpbGRyZW47IF9hLnN0YWdnZXJDaGlsZHJlbjsgX2Euc3RhZ2dlckRpcmVjdGlvbjsgX2EucmVwZWF0OyBfYS5yZXBlYXRUeXBlOyBfYS5yZXBlYXREZWxheTsgX2EuZnJvbTsgdmFyIHRyYW5zaXRpb24gPSBfX3Jlc3QoX2EsIFtcIndoZW5cIiwgXCJkZWxheVwiLCBcImRlbGF5Q2hpbGRyZW5cIiwgXCJzdGFnZ2VyQ2hpbGRyZW5cIiwgXCJzdGFnZ2VyRGlyZWN0aW9uXCIsIFwicmVwZWF0XCIsIFwicmVwZWF0VHlwZVwiLCBcInJlcGVhdERlbGF5XCIsIFwiZnJvbVwiXSk7XG4gICAgcmV0dXJuICEhT2JqZWN0LmtleXModHJhbnNpdGlvbikubGVuZ3RoO1xufVxudmFyIGxlZ2FjeVJlcGVhdFdhcm5pbmcgPSBmYWxzZTtcbi8qKlxuICogQ29udmVydCBGcmFtZXIgTW90aW9uJ3MgVHJhbnNpdGlvbiB0eXBlIGludG8gUG9wbW90aW9uLWNvbXBhdGlibGUgb3B0aW9ucy5cbiAqL1xuZnVuY3Rpb24gY29udmVydFRyYW5zaXRpb25Ub0FuaW1hdGlvbk9wdGlvbnMoX2EpIHtcbiAgICB2YXIgZWFzZSA9IF9hLmVhc2UsIHRpbWVzID0gX2EudGltZXMsIHlveW8gPSBfYS55b3lvLCBmbGlwID0gX2EuZmxpcCwgbG9vcCA9IF9hLmxvb3AsIHRyYW5zaXRpb24gPSBfX3Jlc3QoX2EsIFtcImVhc2VcIiwgXCJ0aW1lc1wiLCBcInlveW9cIiwgXCJmbGlwXCIsIFwibG9vcFwiXSk7XG4gICAgdmFyIG9wdGlvbnMgPSBfX2Fzc2lnbih7fSwgdHJhbnNpdGlvbik7XG4gICAgaWYgKHRpbWVzKVxuICAgICAgICBvcHRpb25zW1wib2Zmc2V0XCJdID0gdGltZXM7XG4gICAgLyoqXG4gICAgICogQ29udmVydCBhbnkgZXhpc3RpbmcgZHVyYXRpb25zIGZyb20gc2Vjb25kcyB0byBtaWxsaXNlY29uZHNcbiAgICAgKi9cbiAgICBpZiAodHJhbnNpdGlvbi5kdXJhdGlvbilcbiAgICAgICAgb3B0aW9uc1tcImR1cmF0aW9uXCJdID0gc2Vjb25kc1RvTWlsbGlzZWNvbmRzKHRyYW5zaXRpb24uZHVyYXRpb24pO1xuICAgIGlmICh0cmFuc2l0aW9uLnJlcGVhdERlbGF5KVxuICAgICAgICBvcHRpb25zLnJlcGVhdERlbGF5ID0gc2Vjb25kc1RvTWlsbGlzZWNvbmRzKHRyYW5zaXRpb24ucmVwZWF0RGVsYXkpO1xuICAgIC8qKlxuICAgICAqIE1hcCBlYXNpbmcgbmFtZXMgdG8gUG9wbW90aW9uJ3MgZWFzaW5nIGZ1bmN0aW9uc1xuICAgICAqL1xuICAgIGlmIChlYXNlKSB7XG4gICAgICAgIG9wdGlvbnNbXCJlYXNlXCJdID0gaXNFYXNpbmdBcnJheShlYXNlKVxuICAgICAgICAgICAgPyBlYXNlLm1hcChlYXNpbmdEZWZpbml0aW9uVG9GdW5jdGlvbilcbiAgICAgICAgICAgIDogZWFzaW5nRGVmaW5pdGlvblRvRnVuY3Rpb24oZWFzZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN1cHBvcnQgbGVnYWN5IHRyYW5zaXRpb24gQVBJXG4gICAgICovXG4gICAgaWYgKHRyYW5zaXRpb24udHlwZSA9PT0gXCJ0d2VlblwiKVxuICAgICAgICBvcHRpb25zLnR5cGUgPSBcImtleWZyYW1lc1wiO1xuICAgIC8qKlxuICAgICAqIFRPRE86IFRoZXNlIG9wdGlvbnMgYXJlIG9mZmljaWFsbHkgcmVtb3ZlZCBmcm9tIHRoZSBBUEkuXG4gICAgICovXG4gICAgaWYgKHlveW8gfHwgbG9vcCB8fCBmbGlwKSB7XG4gICAgICAgIHdhcm5pbmcoIWxlZ2FjeVJlcGVhdFdhcm5pbmcsIFwieW95bywgbG9vcCBhbmQgZmxpcCBoYXZlIGJlZW4gcmVtb3ZlZCBmcm9tIHRoZSBBUEkuIFJlcGxhY2Ugd2l0aCByZXBlYXQgYW5kIHJlcGVhdFR5cGUgb3B0aW9ucy5cIik7XG4gICAgICAgIGxlZ2FjeVJlcGVhdFdhcm5pbmcgPSB0cnVlO1xuICAgICAgICBpZiAoeW95bykge1xuICAgICAgICAgICAgb3B0aW9ucy5yZXBlYXRUeXBlID0gXCJyZXZlcnNlXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobG9vcCkge1xuICAgICAgICAgICAgb3B0aW9ucy5yZXBlYXRUeXBlID0gXCJsb29wXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZmxpcCkge1xuICAgICAgICAgICAgb3B0aW9ucy5yZXBlYXRUeXBlID0gXCJtaXJyb3JcIjtcbiAgICAgICAgfVxuICAgICAgICBvcHRpb25zLnJlcGVhdCA9IGxvb3AgfHwgeW95byB8fCBmbGlwIHx8IHRyYW5zaXRpb24ucmVwZWF0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUT0RPOiBQb3Btb3Rpb24gOSBoYXMgdGhlIGFiaWxpdHkgdG8gYXV0b21hdGljYWxseSBkZXRlY3Qgd2hldGhlciB0byB1c2VcbiAgICAgKiBhIGtleWZyYW1lcyBvciBzcHJpbmcgYW5pbWF0aW9uLCBidXQgZG9lcyBzbyBieSBkZXRlY3RpbmcgdmVsb2NpdHkgYW5kIG90aGVyIHNwcmluZyBvcHRpb25zLlxuICAgICAqIEl0J2QgYmUgZ29vZCB0byBpbnRyb2R1Y2UgYSBzaW1pbGFyIHRoaW5nIGhlcmUuXG4gICAgICovXG4gICAgaWYgKHRyYW5zaXRpb24udHlwZSAhPT0gXCJzcHJpbmdcIilcbiAgICAgICAgb3B0aW9ucy50eXBlID0gXCJrZXlmcmFtZXNcIjtcbiAgICByZXR1cm4gb3B0aW9ucztcbn1cbi8qKlxuICogR2V0IHRoZSBkZWxheSBmb3IgYSB2YWx1ZSBieSBjaGVja2luZyBUcmFuc2l0aW9uIHdpdGggZGVjcmVhc2luZyBzcGVjaWZpY2l0eS5cbiAqL1xuZnVuY3Rpb24gZ2V0RGVsYXlGcm9tVHJhbnNpdGlvbih0cmFuc2l0aW9uLCBrZXkpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHZhciB2YWx1ZVRyYW5zaXRpb24gPSBnZXRWYWx1ZVRyYW5zaXRpb24odHJhbnNpdGlvbiwga2V5KSB8fCB7fTtcbiAgICByZXR1cm4gKF9iID0gKF9hID0gdmFsdWVUcmFuc2l0aW9uLmRlbGF5KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0cmFuc2l0aW9uLmRlbGF5KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAwO1xufVxuZnVuY3Rpb24gaHlkcmF0ZUtleWZyYW1lcyhvcHRpb25zKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucy50bykgJiYgb3B0aW9ucy50b1swXSA9PT0gbnVsbCkge1xuICAgICAgICBvcHRpb25zLnRvID0gX19zcHJlYWRBcnJheShbXSwgX19yZWFkKG9wdGlvbnMudG8pLCBmYWxzZSk7XG4gICAgICAgIG9wdGlvbnMudG9bMF0gPSBvcHRpb25zLmZyb207XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25zO1xufVxuZnVuY3Rpb24gZ2V0UG9wbW90aW9uQW5pbWF0aW9uT3B0aW9ucyh0cmFuc2l0aW9uLCBvcHRpb25zLCBrZXkpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucy50bykpIHtcbiAgICAgICAgKF9hID0gdHJhbnNpdGlvbi5kdXJhdGlvbikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKHRyYW5zaXRpb24uZHVyYXRpb24gPSAwLjgpO1xuICAgIH1cbiAgICBoeWRyYXRlS2V5ZnJhbWVzKG9wdGlvbnMpO1xuICAgIC8qKlxuICAgICAqIEdldCBhIGRlZmF1bHQgdHJhbnNpdGlvbiBpZiBub25lIGlzIGRldGVybWluZWQgdG8gYmUgZGVmaW5lZC5cbiAgICAgKi9cbiAgICBpZiAoIWlzVHJhbnNpdGlvbkRlZmluZWQodHJhbnNpdGlvbikpIHtcbiAgICAgICAgdHJhbnNpdGlvbiA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCB0cmFuc2l0aW9uKSwgZ2V0RGVmYXVsdFRyYW5zaXRpb24oa2V5LCBvcHRpb25zLnRvKSk7XG4gICAgfVxuICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgb3B0aW9ucyksIGNvbnZlcnRUcmFuc2l0aW9uVG9BbmltYXRpb25PcHRpb25zKHRyYW5zaXRpb24pKTtcbn1cbi8qKlxuICpcbiAqL1xuZnVuY3Rpb24gZ2V0QW5pbWF0aW9uKGtleSwgdmFsdWUsIHRhcmdldCwgdHJhbnNpdGlvbiwgb25Db21wbGV0ZSkge1xuICAgIHZhciBfYTtcbiAgICB2YXIgdmFsdWVUcmFuc2l0aW9uID0gZ2V0VmFsdWVUcmFuc2l0aW9uKHRyYW5zaXRpb24sIGtleSk7XG4gICAgdmFyIG9yaWdpbiA9IChfYSA9IHZhbHVlVHJhbnNpdGlvbi5mcm9tKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB2YWx1ZS5nZXQoKTtcbiAgICB2YXIgaXNUYXJnZXRBbmltYXRhYmxlID0gaXNBbmltYXRhYmxlKGtleSwgdGFyZ2V0KTtcbiAgICBpZiAob3JpZ2luID09PSBcIm5vbmVcIiAmJiBpc1RhcmdldEFuaW1hdGFibGUgJiYgdHlwZW9mIHRhcmdldCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgd2UncmUgdHJ5aW5nIHRvIGFuaW1hdGUgZnJvbSBcIm5vbmVcIiwgdHJ5IGFuZCBnZXQgYW4gYW5pbWF0YWJsZSB2ZXJzaW9uXG4gICAgICAgICAqIG9mIHRoZSB0YXJnZXQuIFRoaXMgY291bGQgYmUgaW1wcm92ZWQgdG8gd29yayBib3RoIHdheXMuXG4gICAgICAgICAqL1xuICAgICAgICBvcmlnaW4gPSBnZXRBbmltYXRhYmxlTm9uZShrZXksIHRhcmdldCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzWmVybyhvcmlnaW4pICYmIHR5cGVvZiB0YXJnZXQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgb3JpZ2luID0gZ2V0WmVyb1VuaXQodGFyZ2V0KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkodGFyZ2V0KSAmJlxuICAgICAgICBpc1plcm8odGFyZ2V0KSAmJlxuICAgICAgICB0eXBlb2Ygb3JpZ2luID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRhcmdldCA9IGdldFplcm9Vbml0KG9yaWdpbik7XG4gICAgfVxuICAgIHZhciBpc09yaWdpbkFuaW1hdGFibGUgPSBpc0FuaW1hdGFibGUoa2V5LCBvcmlnaW4pO1xuICAgIHdhcm5pbmcoaXNPcmlnaW5BbmltYXRhYmxlID09PSBpc1RhcmdldEFuaW1hdGFibGUsIFwiWW91IGFyZSB0cnlpbmcgdG8gYW5pbWF0ZSBcIi5jb25jYXQoa2V5LCBcIiBmcm9tIFxcXCJcIikuY29uY2F0KG9yaWdpbiwgXCJcXFwiIHRvIFxcXCJcIikuY29uY2F0KHRhcmdldCwgXCJcXFwiLiBcIikuY29uY2F0KG9yaWdpbiwgXCIgaXMgbm90IGFuIGFuaW1hdGFibGUgdmFsdWUgLSB0byBlbmFibGUgdGhpcyBhbmltYXRpb24gc2V0IFwiKS5jb25jYXQob3JpZ2luLCBcIiB0byBhIHZhbHVlIGFuaW1hdGFibGUgdG8gXCIpLmNvbmNhdCh0YXJnZXQsIFwiIHZpYSB0aGUgYHN0eWxlYCBwcm9wZXJ0eS5cIikpO1xuICAgIGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGZyb206IG9yaWdpbixcbiAgICAgICAgICAgIHRvOiB0YXJnZXQsXG4gICAgICAgICAgICB2ZWxvY2l0eTogdmFsdWUuZ2V0VmVsb2NpdHkoKSxcbiAgICAgICAgICAgIG9uQ29tcGxldGU6IG9uQ29tcGxldGUsXG4gICAgICAgICAgICBvblVwZGF0ZTogZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHZhbHVlLnNldCh2KTsgfSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHZhbHVlVHJhbnNpdGlvbi50eXBlID09PSBcImluZXJ0aWFcIiB8fFxuICAgICAgICAgICAgdmFsdWVUcmFuc2l0aW9uLnR5cGUgPT09IFwiZGVjYXlcIlxuICAgICAgICAgICAgPyBpbmVydGlhKF9fYXNzaWduKF9fYXNzaWduKHt9LCBvcHRpb25zKSwgdmFsdWVUcmFuc2l0aW9uKSlcbiAgICAgICAgICAgIDogYW5pbWF0ZShfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZ2V0UG9wbW90aW9uQW5pbWF0aW9uT3B0aW9ucyh2YWx1ZVRyYW5zaXRpb24sIG9wdGlvbnMsIGtleSkpLCB7IG9uVXBkYXRlOiBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMub25VcGRhdGUodik7XG4gICAgICAgICAgICAgICAgICAgIChfYSA9IHZhbHVlVHJhbnNpdGlvbi5vblVwZGF0ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodmFsdWVUcmFuc2l0aW9uLCB2KTtcbiAgICAgICAgICAgICAgICB9LCBvbkNvbXBsZXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5vbkNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIChfYSA9IHZhbHVlVHJhbnNpdGlvbi5vbkNvbXBsZXRlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh2YWx1ZVRyYW5zaXRpb24pO1xuICAgICAgICAgICAgICAgIH0gfSkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzZXQoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHZhciBmaW5hbFRhcmdldCA9IHJlc29sdmVGaW5hbFZhbHVlSW5LZXlmcmFtZXModGFyZ2V0KTtcbiAgICAgICAgdmFsdWUuc2V0KGZpbmFsVGFyZ2V0KTtcbiAgICAgICAgb25Db21wbGV0ZSgpO1xuICAgICAgICAoX2EgPSB2YWx1ZVRyYW5zaXRpb24gPT09IG51bGwgfHwgdmFsdWVUcmFuc2l0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2YWx1ZVRyYW5zaXRpb24ub25VcGRhdGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHZhbHVlVHJhbnNpdGlvbiwgZmluYWxUYXJnZXQpO1xuICAgICAgICAoX2IgPSB2YWx1ZVRyYW5zaXRpb24gPT09IG51bGwgfHwgdmFsdWVUcmFuc2l0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2YWx1ZVRyYW5zaXRpb24ub25Db21wbGV0ZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwodmFsdWVUcmFuc2l0aW9uKTtcbiAgICAgICAgcmV0dXJuIHsgc3RvcDogZnVuY3Rpb24gKCkgeyB9IH07XG4gICAgfVxuICAgIHJldHVybiAhaXNPcmlnaW5BbmltYXRhYmxlIHx8XG4gICAgICAgICFpc1RhcmdldEFuaW1hdGFibGUgfHxcbiAgICAgICAgdmFsdWVUcmFuc2l0aW9uLnR5cGUgPT09IGZhbHNlXG4gICAgICAgID8gc2V0XG4gICAgICAgIDogc3RhcnQ7XG59XG5mdW5jdGlvbiBpc1plcm8odmFsdWUpIHtcbiAgICByZXR1cm4gKHZhbHVlID09PSAwIHx8XG4gICAgICAgICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgIHBhcnNlRmxvYXQodmFsdWUpID09PSAwICYmXG4gICAgICAgICAgICB2YWx1ZS5pbmRleE9mKFwiIFwiKSA9PT0gLTEpKTtcbn1cbmZ1bmN0aW9uIGdldFplcm9Vbml0KHBvdGVudGlhbFVuaXRUeXBlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBwb3RlbnRpYWxVbml0VHlwZSA9PT0gXCJudW1iZXJcIlxuICAgICAgICA/IDBcbiAgICAgICAgOiBnZXRBbmltYXRhYmxlTm9uZShcIlwiLCBwb3RlbnRpYWxVbml0VHlwZSk7XG59XG5mdW5jdGlvbiBnZXRWYWx1ZVRyYW5zaXRpb24odHJhbnNpdGlvbiwga2V5KSB7XG4gICAgcmV0dXJuIHRyYW5zaXRpb25ba2V5XSB8fCB0cmFuc2l0aW9uW1wiZGVmYXVsdFwiXSB8fCB0cmFuc2l0aW9uO1xufVxuLyoqXG4gKiBTdGFydCBhbmltYXRpb24gb24gYSBNb3Rpb25WYWx1ZS4gVGhpcyBmdW5jdGlvbiBpcyBhbiBpbnRlcmZhY2UgYmV0d2VlblxuICogRnJhbWVyIE1vdGlvbiBhbmQgUG9wbW90aW9uXG4gKi9cbmZ1bmN0aW9uIHN0YXJ0QW5pbWF0aW9uKGtleSwgdmFsdWUsIHRhcmdldCwgdHJhbnNpdGlvbikge1xuICAgIGlmICh0cmFuc2l0aW9uID09PSB2b2lkIDApIHsgdHJhbnNpdGlvbiA9IHt9OyB9XG4gICAgaWYgKGluc3RhbnRBbmltYXRpb25TdGF0ZS5jdXJyZW50KSB7XG4gICAgICAgIHRyYW5zaXRpb24gPSB7IHR5cGU6IGZhbHNlIH07XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZS5zdGFydChmdW5jdGlvbiAob25Db21wbGV0ZSkge1xuICAgICAgICB2YXIgZGVsYXlUaW1lcjtcbiAgICAgICAgdmFyIGNvbnRyb2xzO1xuICAgICAgICB2YXIgYW5pbWF0aW9uID0gZ2V0QW5pbWF0aW9uKGtleSwgdmFsdWUsIHRhcmdldCwgdHJhbnNpdGlvbiwgb25Db21wbGV0ZSk7XG4gICAgICAgIHZhciBkZWxheSA9IGdldERlbGF5RnJvbVRyYW5zaXRpb24odHJhbnNpdGlvbiwga2V5KTtcbiAgICAgICAgdmFyIHN0YXJ0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKGNvbnRyb2xzID0gYW5pbWF0aW9uKCkpOyB9O1xuICAgICAgICBpZiAoZGVsYXkpIHtcbiAgICAgICAgICAgIGRlbGF5VGltZXIgPSB3aW5kb3cuc2V0VGltZW91dChzdGFydCwgc2Vjb25kc1RvTWlsbGlzZWNvbmRzKGRlbGF5KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGFydCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoZGVsYXlUaW1lcik7XG4gICAgICAgICAgICBjb250cm9scyA9PT0gbnVsbCB8fCBjb250cm9scyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29udHJvbHMuc3RvcCgpO1xuICAgICAgICB9O1xuICAgIH0pO1xufVxuXG5leHBvcnQgeyBjb252ZXJ0VHJhbnNpdGlvblRvQW5pbWF0aW9uT3B0aW9ucywgZ2V0RGVsYXlGcm9tVHJhbnNpdGlvbiwgZ2V0UG9wbW90aW9uQW5pbWF0aW9uT3B0aW9ucywgZ2V0VmFsdWVUcmFuc2l0aW9uLCBnZXRaZXJvVW5pdCwgaHlkcmF0ZUtleWZyYW1lcywgaXNUcmFuc2l0aW9uRGVmaW5lZCwgaXNaZXJvLCBzdGFydEFuaW1hdGlvbiB9O1xuIiwiLyoqXG4gKiBDaGVjayBpZiB2YWx1ZSBpcyBhIG51bWVyaWNhbCBzdHJpbmcsIGllIGEgc3RyaW5nIHRoYXQgaXMgcHVyZWx5IGEgbnVtYmVyIGVnIFwiMTAwXCIgb3IgXCItMTAwLjFcIlxuICovXG52YXIgaXNOdW1lcmljYWxTdHJpbmcgPSBmdW5jdGlvbiAodikgeyByZXR1cm4gL15cXC0/XFxkKlxcLj9cXGQrJC8udGVzdCh2KTsgfTtcblxuZXhwb3J0IHsgaXNOdW1lcmljYWxTdHJpbmcgfTtcbiIsIi8qKlxuICogQ2hlY2sgaWYgdGhlIHZhbHVlIGlzIGEgemVybyB2YWx1ZSBzdHJpbmcgbGlrZSBcIjBweFwiIG9yIFwiMCVcIlxuICovXG52YXIgaXNaZXJvVmFsdWVTdHJpbmcgPSBmdW5jdGlvbiAodikgeyByZXR1cm4gL14wW14uXFxzXSskLy50ZXN0KHYpOyB9O1xuXG5leHBvcnQgeyBpc1plcm9WYWx1ZVN0cmluZyB9O1xuIiwiaW1wb3J0IHsgX19yZWFkIH0gZnJvbSAndHNsaWInO1xuXG5mdW5jdGlvbiBhZGRVbmlxdWVJdGVtKGFyciwgaXRlbSkge1xuICAgIGFyci5pbmRleE9mKGl0ZW0pID09PSAtMSAmJiBhcnIucHVzaChpdGVtKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZUl0ZW0oYXJyLCBpdGVtKSB7XG4gICAgdmFyIGluZGV4ID0gYXJyLmluZGV4T2YoaXRlbSk7XG4gICAgaW5kZXggPiAtMSAmJiBhcnIuc3BsaWNlKGluZGV4LCAxKTtcbn1cbi8vIEFkYXB0ZWQgZnJvbSBhcnJheS1tb3ZlXG5mdW5jdGlvbiBtb3ZlSXRlbShfYSwgZnJvbUluZGV4LCB0b0luZGV4KSB7XG4gICAgdmFyIF9iID0gX19yZWFkKF9hKSwgYXJyID0gX2Iuc2xpY2UoMCk7XG4gICAgdmFyIHN0YXJ0SW5kZXggPSBmcm9tSW5kZXggPCAwID8gYXJyLmxlbmd0aCArIGZyb21JbmRleCA6IGZyb21JbmRleDtcbiAgICBpZiAoc3RhcnRJbmRleCA+PSAwICYmIHN0YXJ0SW5kZXggPCBhcnIubGVuZ3RoKSB7XG4gICAgICAgIHZhciBlbmRJbmRleCA9IHRvSW5kZXggPCAwID8gYXJyLmxlbmd0aCArIHRvSW5kZXggOiB0b0luZGV4O1xuICAgICAgICB2YXIgX2MgPSBfX3JlYWQoYXJyLnNwbGljZShmcm9tSW5kZXgsIDEpLCAxKSwgaXRlbSA9IF9jWzBdO1xuICAgICAgICBhcnIuc3BsaWNlKGVuZEluZGV4LCAwLCBpdGVtKTtcbiAgICB9XG4gICAgcmV0dXJuIGFycjtcbn1cblxuZXhwb3J0IHsgYWRkVW5pcXVlSXRlbSwgbW92ZUl0ZW0sIHJlbW92ZUl0ZW0gfTtcbiIsImltcG9ydCB7IGFkZFVuaXF1ZUl0ZW0sIHJlbW92ZUl0ZW0gfSBmcm9tICcuL2FycmF5Lm1qcyc7XG5cbnZhciBTdWJzY3JpcHRpb25NYW5hZ2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFN1YnNjcmlwdGlvbk1hbmFnZXIoKSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucyA9IFtdO1xuICAgIH1cbiAgICBTdWJzY3JpcHRpb25NYW5hZ2VyLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoaGFuZGxlcikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBhZGRVbmlxdWVJdGVtKHRoaXMuc3Vic2NyaXB0aW9ucywgaGFuZGxlcik7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiByZW1vdmVJdGVtKF90aGlzLnN1YnNjcmlwdGlvbnMsIGhhbmRsZXIpOyB9O1xuICAgIH07XG4gICAgU3Vic2NyaXB0aW9uTWFuYWdlci5wcm90b3R5cGUubm90aWZ5ID0gZnVuY3Rpb24gKGEsIGIsIGMpIHtcbiAgICAgICAgdmFyIG51bVN1YnNjcmlwdGlvbnMgPSB0aGlzLnN1YnNjcmlwdGlvbnMubGVuZ3RoO1xuICAgICAgICBpZiAoIW51bVN1YnNjcmlwdGlvbnMpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChudW1TdWJzY3JpcHRpb25zID09PSAxKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElmIHRoZXJlJ3Mgb25seSBhIHNpbmdsZSBoYW5kbGVyIHdlIGNhbiBqdXN0IGNhbGwgaXQgd2l0aG91dCBpbnZva2luZyBhIGxvb3AuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uc1swXShhLCBiLCBjKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtU3Vic2NyaXB0aW9uczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQ2hlY2sgd2hldGhlciB0aGUgaGFuZGxlciBleGlzdHMgYmVmb3JlIGZpcmluZyBhcyBpdCdzIHBvc3NpYmxlXG4gICAgICAgICAgICAgICAgICogdGhlIHN1YnNjcmlwdGlvbnMgd2VyZSBtb2RpZmllZCBkdXJpbmcgdGhpcyBsb29wIHJ1bm5pbmcuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdmFyIGhhbmRsZXIgPSB0aGlzLnN1YnNjcmlwdGlvbnNbaV07XG4gICAgICAgICAgICAgICAgaGFuZGxlciAmJiBoYW5kbGVyKGEsIGIsIGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBTdWJzY3JpcHRpb25NYW5hZ2VyLnByb3RvdHlwZS5nZXRTaXplID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWJzY3JpcHRpb25zLmxlbmd0aDtcbiAgICB9O1xuICAgIFN1YnNjcmlwdGlvbk1hbmFnZXIucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMubGVuZ3RoID0gMDtcbiAgICB9O1xuICAgIHJldHVybiBTdWJzY3JpcHRpb25NYW5hZ2VyO1xufSgpKTtcblxuZXhwb3J0IHsgU3Vic2NyaXB0aW9uTWFuYWdlciB9O1xuIiwiaW1wb3J0IHN5bmMsIHsgZ2V0RnJhbWVEYXRhIH0gZnJvbSAnZnJhbWVzeW5jJztcbmltcG9ydCB7IHZlbG9jaXR5UGVyU2Vjb25kIH0gZnJvbSAncG9wbW90aW9uJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbk1hbmFnZXIgfSBmcm9tICcuLi91dGlscy9zdWJzY3JpcHRpb24tbWFuYWdlci5tanMnO1xuXG52YXIgaXNGbG9hdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiAhaXNOYU4ocGFyc2VGbG9hdCh2YWx1ZSkpO1xufTtcbi8qKlxuICogYE1vdGlvblZhbHVlYCBpcyB1c2VkIHRvIHRyYWNrIHRoZSBzdGF0ZSBhbmQgdmVsb2NpdHkgb2YgbW90aW9uIHZhbHVlcy5cbiAqXG4gKiBAcHVibGljXG4gKi9cbnZhciBNb3Rpb25WYWx1ZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gaW5pdCAtIFRoZSBpbml0aWF0aW5nIHZhbHVlXG4gICAgICogQHBhcmFtIGNvbmZpZyAtIE9wdGlvbmFsIGNvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICAgICAqXG4gICAgICogLSAgYHRyYW5zZm9ybWVyYDogQSBmdW5jdGlvbiB0byB0cmFuc2Zvcm0gaW5jb21pbmcgdmFsdWVzIHdpdGguXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBNb3Rpb25WYWx1ZShpbml0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIHdpbGwgYmUgcmVwbGFjZWQgYnkgdGhlIGJ1aWxkIHN0ZXAgd2l0aCB0aGUgbGF0ZXN0IHZlcnNpb24gbnVtYmVyLlxuICAgICAgICAgKiBXaGVuIE1vdGlvblZhbHVlcyBhcmUgcHJvdmlkZWQgdG8gbW90aW9uIGNvbXBvbmVudHMsIHdhcm4gaWYgdmVyc2lvbnMgYXJlIG1peGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy52ZXJzaW9uID0gXCI2LjUuMVwiO1xuICAgICAgICAvKipcbiAgICAgICAgICogRHVyYXRpb24sIGluIG1pbGxpc2Vjb25kcywgc2luY2UgbGFzdCB1cGRhdGluZyBmcmFtZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRpbWVEZWx0YSA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaW1lc3RhbXAgb2YgdGhlIGxhc3QgdGltZSB0aGlzIGBNb3Rpb25WYWx1ZWAgd2FzIHVwZGF0ZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5sYXN0VXBkYXRlZCA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGdW5jdGlvbnMgdG8gbm90aWZ5IHdoZW4gdGhlIGBNb3Rpb25WYWx1ZWAgdXBkYXRlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnVwZGF0ZVN1YnNjcmliZXJzID0gbmV3IFN1YnNjcmlwdGlvbk1hbmFnZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZ1bmN0aW9ucyB0byBub3RpZnkgd2hlbiB0aGUgdmVsb2NpdHkgdXBkYXRlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnZlbG9jaXR5VXBkYXRlU3Vic2NyaWJlcnMgPSBuZXcgU3Vic2NyaXB0aW9uTWFuYWdlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRnVuY3Rpb25zIHRvIG5vdGlmeSB3aGVuIHRoZSBgTW90aW9uVmFsdWVgIHVwZGF0ZXMgYW5kIGByZW5kZXJgIGlzIHNldCB0byBgdHJ1ZWAuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZW5kZXJTdWJzY3JpYmVycyA9IG5ldyBTdWJzY3JpcHRpb25NYW5hZ2VyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcmFja3Mgd2hldGhlciB0aGlzIHZhbHVlIGNhbiBvdXRwdXQgYSB2ZWxvY2l0eS4gQ3VycmVudGx5IHRoaXMgaXMgb25seSB0cnVlXG4gICAgICAgICAqIGlmIHRoZSB2YWx1ZSBpcyBudW1lcmljYWwsIGJ1dCB3ZSBtaWdodCBiZSBhYmxlIHRvIHdpZGVuIHRoZSBzY29wZSBoZXJlIGFuZCBzdXBwb3J0XG4gICAgICAgICAqIG90aGVyIHZhbHVlIHR5cGVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2FuVHJhY2tWZWxvY2l0eSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnVwZGF0ZUFuZE5vdGlmeSA9IGZ1bmN0aW9uICh2LCByZW5kZXIpIHtcbiAgICAgICAgICAgIGlmIChyZW5kZXIgPT09IHZvaWQgMCkgeyByZW5kZXIgPSB0cnVlOyB9XG4gICAgICAgICAgICBfdGhpcy5wcmV2ID0gX3RoaXMuY3VycmVudDtcbiAgICAgICAgICAgIF90aGlzLmN1cnJlbnQgPSB2O1xuICAgICAgICAgICAgLy8gVXBkYXRlIHRpbWVzdGFtcFxuICAgICAgICAgICAgdmFyIF9hID0gZ2V0RnJhbWVEYXRhKCksIGRlbHRhID0gX2EuZGVsdGEsIHRpbWVzdGFtcCA9IF9hLnRpbWVzdGFtcDtcbiAgICAgICAgICAgIGlmIChfdGhpcy5sYXN0VXBkYXRlZCAhPT0gdGltZXN0YW1wKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMudGltZURlbHRhID0gZGVsdGE7XG4gICAgICAgICAgICAgICAgX3RoaXMubGFzdFVwZGF0ZWQgPSB0aW1lc3RhbXA7XG4gICAgICAgICAgICAgICAgc3luYy5wb3N0UmVuZGVyKF90aGlzLnNjaGVkdWxlVmVsb2NpdHlDaGVjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBVcGRhdGUgdXBkYXRlIHN1YnNjcmliZXJzXG4gICAgICAgICAgICBpZiAoX3RoaXMucHJldiAhPT0gX3RoaXMuY3VycmVudCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnVwZGF0ZVN1YnNjcmliZXJzLm5vdGlmeShfdGhpcy5jdXJyZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFVwZGF0ZSB2ZWxvY2l0eSBzdWJzY3JpYmVyc1xuICAgICAgICAgICAgaWYgKF90aGlzLnZlbG9jaXR5VXBkYXRlU3Vic2NyaWJlcnMuZ2V0U2l6ZSgpKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMudmVsb2NpdHlVcGRhdGVTdWJzY3JpYmVycy5ub3RpZnkoX3RoaXMuZ2V0VmVsb2NpdHkoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBVcGRhdGUgcmVuZGVyIHN1YnNjcmliZXJzXG4gICAgICAgICAgICBpZiAocmVuZGVyKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucmVuZGVyU3Vic2NyaWJlcnMubm90aWZ5KF90aGlzLmN1cnJlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU2NoZWR1bGUgYSB2ZWxvY2l0eSBjaGVjayBmb3IgdGhlIG5leHQgZnJhbWUuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgaXMgYW4gaW5zdGFuY2VkIGFuZCBib3VuZCBmdW5jdGlvbiB0byBwcmV2ZW50IGdlbmVyYXRpbmcgYSBuZXdcbiAgICAgICAgICogZnVuY3Rpb24gb25jZSBwZXIgZnJhbWUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zY2hlZHVsZVZlbG9jaXR5Q2hlY2sgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBzeW5jLnBvc3RSZW5kZXIoX3RoaXMudmVsb2NpdHlDaGVjayk7IH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBVcGRhdGVzIGBwcmV2YCB3aXRoIGBjdXJyZW50YCBpZiB0aGUgdmFsdWUgaGFzbid0IGJlZW4gdXBkYXRlZCB0aGlzIGZyYW1lLlxuICAgICAgICAgKiBUaGlzIGVuc3VyZXMgdmVsb2NpdHkgY2FsY3VsYXRpb25zIHJldHVybiBgMGAuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgaXMgYW4gaW5zdGFuY2VkIGFuZCBib3VuZCBmdW5jdGlvbiB0byBwcmV2ZW50IGdlbmVyYXRpbmcgYSBuZXdcbiAgICAgICAgICogZnVuY3Rpb24gb25jZSBwZXIgZnJhbWUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy52ZWxvY2l0eUNoZWNrID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgdGltZXN0YW1wID0gX2EudGltZXN0YW1wO1xuICAgICAgICAgICAgaWYgKHRpbWVzdGFtcCAhPT0gX3RoaXMubGFzdFVwZGF0ZWQpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5wcmV2ID0gX3RoaXMuY3VycmVudDtcbiAgICAgICAgICAgICAgICBfdGhpcy52ZWxvY2l0eVVwZGF0ZVN1YnNjcmliZXJzLm5vdGlmeShfdGhpcy5nZXRWZWxvY2l0eSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYXNBbmltYXRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnByZXYgPSB0aGlzLmN1cnJlbnQgPSBpbml0O1xuICAgICAgICB0aGlzLmNhblRyYWNrVmVsb2NpdHkgPSBpc0Zsb2F0KHRoaXMuY3VycmVudCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgbm90aWZpZWQgd2hlbiB0aGUgYE1vdGlvblZhbHVlYCBpcyB1cGRhdGVkLlxuICAgICAqXG4gICAgICogSXQgcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQsIHdoZW4gY2FsbGVkLCB3aWxsIGNhbmNlbCB0aGUgc3Vic2NyaXB0aW9uLlxuICAgICAqXG4gICAgICogV2hlbiBjYWxsaW5nIGBvbkNoYW5nZWAgaW5zaWRlIGEgUmVhY3QgY29tcG9uZW50LCBpdCBzaG91bGQgYmUgd3JhcHBlZCB3aXRoIHRoZVxuICAgICAqIGB1c2VFZmZlY3RgIGhvb2suIEFzIGl0IHJldHVybnMgYW4gdW5zdWJzY3JpYmUgZnVuY3Rpb24sIHRoaXMgc2hvdWxkIGJlIHJldHVybmVkXG4gICAgICogZnJvbSB0aGUgYHVzZUVmZmVjdGAgZnVuY3Rpb24gdG8gZW5zdXJlIHlvdSBkb24ndCBhZGQgZHVwbGljYXRlIHN1YnNjcmliZXJzLi5cbiAgICAgKlxuICAgICAqIGBgYGpzeFxuICAgICAqIGV4cG9ydCBjb25zdCBNeUNvbXBvbmVudCA9ICgpID0+IHtcbiAgICAgKiAgIGNvbnN0IHggPSB1c2VNb3Rpb25WYWx1ZSgwKVxuICAgICAqICAgY29uc3QgeSA9IHVzZU1vdGlvblZhbHVlKDApXG4gICAgICogICBjb25zdCBvcGFjaXR5ID0gdXNlTW90aW9uVmFsdWUoMSlcbiAgICAgKlxuICAgICAqICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgKiAgICAgZnVuY3Rpb24gdXBkYXRlT3BhY2l0eSgpIHtcbiAgICAgKiAgICAgICBjb25zdCBtYXhYWSA9IE1hdGgubWF4KHguZ2V0KCksIHkuZ2V0KCkpXG4gICAgICogICAgICAgY29uc3QgbmV3T3BhY2l0eSA9IHRyYW5zZm9ybShtYXhYWSwgWzAsIDEwMF0sIFsxLCAwXSlcbiAgICAgKiAgICAgICBvcGFjaXR5LnNldChuZXdPcGFjaXR5KVxuICAgICAqICAgICB9XG4gICAgICpcbiAgICAgKiAgICAgY29uc3QgdW5zdWJzY3JpYmVYID0geC5vbkNoYW5nZSh1cGRhdGVPcGFjaXR5KVxuICAgICAqICAgICBjb25zdCB1bnN1YnNjcmliZVkgPSB5Lm9uQ2hhbmdlKHVwZGF0ZU9wYWNpdHkpXG4gICAgICpcbiAgICAgKiAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgKiAgICAgICB1bnN1YnNjcmliZVgoKVxuICAgICAqICAgICAgIHVuc3Vic2NyaWJlWSgpXG4gICAgICogICAgIH1cbiAgICAgKiAgIH0sIFtdKVxuICAgICAqXG4gICAgICogICByZXR1cm4gPG1vdGlvbi5kaXYgc3R5bGU9e3sgeCB9fSAvPlxuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwcml2YXRlUmVtYXJrc1xuICAgICAqXG4gICAgICogV2UgY291bGQgbG9vayBpbnRvIGEgYHVzZU9uQ2hhbmdlYCBob29rIGlmIHRoZSBhYm92ZSBsaWZlY3ljbGUgbWFuYWdlbWVudCBwcm92ZXMgY29uZnVzaW5nLlxuICAgICAqXG4gICAgICogYGBganN4XG4gICAgICogdXNlT25DaGFuZ2UoeCwgKCkgPT4ge30pXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3Vic2NyaWJlciAtIEEgZnVuY3Rpb24gdGhhdCByZWNlaXZlcyB0aGUgbGF0ZXN0IHZhbHVlLlxuICAgICAqIEByZXR1cm5zIEEgZnVuY3Rpb24gdGhhdCwgd2hlbiBjYWxsZWQsIHdpbGwgY2FuY2VsIHRoaXMgc3Vic2NyaXB0aW9uLlxuICAgICAqXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIE1vdGlvblZhbHVlLnByb3RvdHlwZS5vbkNoYW5nZSA9IGZ1bmN0aW9uIChzdWJzY3JpcHRpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlU3Vic2NyaWJlcnMuYWRkKHN1YnNjcmlwdGlvbik7XG4gICAgfTtcbiAgICBNb3Rpb25WYWx1ZS5wcm90b3R5cGUuY2xlYXJMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlU3Vic2NyaWJlcnMuY2xlYXIoKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFkZHMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgbm90aWZpZWQgd2hlbiB0aGUgYE1vdGlvblZhbHVlYCByZXF1ZXN0cyBhIHJlbmRlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdWJzY3JpYmVyIC0gQSBmdW5jdGlvbiB0aGF0J3MgcHJvdmlkZWQgdGhlIGxhdGVzdCB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyBBIGZ1bmN0aW9uIHRoYXQsIHdoZW4gY2FsbGVkLCB3aWxsIGNhbmNlbCB0aGlzIHN1YnNjcmlwdGlvbi5cbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIE1vdGlvblZhbHVlLnByb3RvdHlwZS5vblJlbmRlclJlcXVlc3QgPSBmdW5jdGlvbiAoc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgIC8vIFJlbmRlciBpbW1lZGlhdGVseVxuICAgICAgICBzdWJzY3JpcHRpb24odGhpcy5nZXQoKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlclN1YnNjcmliZXJzLmFkZChzdWJzY3JpcHRpb24pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQXR0YWNoZXMgYSBwYXNzaXZlIGVmZmVjdCB0byB0aGUgYE1vdGlvblZhbHVlYC5cbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIE1vdGlvblZhbHVlLnByb3RvdHlwZS5hdHRhY2ggPSBmdW5jdGlvbiAocGFzc2l2ZUVmZmVjdCkge1xuICAgICAgICB0aGlzLnBhc3NpdmVFZmZlY3QgPSBwYXNzaXZlRWZmZWN0O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgc3RhdGUgb2YgdGhlIGBNb3Rpb25WYWx1ZWAuXG4gICAgICpcbiAgICAgKiBAcmVtYXJrc1xuICAgICAqXG4gICAgICogYGBganN4XG4gICAgICogY29uc3QgeCA9IHVzZU1vdGlvblZhbHVlKDApXG4gICAgICogeC5zZXQoMTApXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbGF0ZXN0IC0gTGF0ZXN0IHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcGFyYW0gcmVuZGVyIC0gV2hldGhlciB0byBub3RpZnkgcmVuZGVyIHN1YnNjcmliZXJzLiBEZWZhdWx0cyB0byBgdHJ1ZWBcbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBNb3Rpb25WYWx1ZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHYsIHJlbmRlcikge1xuICAgICAgICBpZiAocmVuZGVyID09PSB2b2lkIDApIHsgcmVuZGVyID0gdHJ1ZTsgfVxuICAgICAgICBpZiAoIXJlbmRlciB8fCAhdGhpcy5wYXNzaXZlRWZmZWN0KSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUFuZE5vdGlmeSh2LCByZW5kZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wYXNzaXZlRWZmZWN0KHYsIHRoaXMudXBkYXRlQW5kTm90aWZ5KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbGF0ZXN0IHN0YXRlIG9mIGBNb3Rpb25WYWx1ZWBcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIC0gVGhlIGxhdGVzdCBzdGF0ZSBvZiBgTW90aW9uVmFsdWVgXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgTW90aW9uVmFsdWUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBNb3Rpb25WYWx1ZS5wcm90b3R5cGUuZ2V0UHJldmlvdXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByZXY7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBsYXRlc3QgdmVsb2NpdHkgb2YgYE1vdGlvblZhbHVlYFxuICAgICAqXG4gICAgICogQHJldHVybnMgLSBUaGUgbGF0ZXN0IHZlbG9jaXR5IG9mIGBNb3Rpb25WYWx1ZWAuIFJldHVybnMgYDBgIGlmIHRoZSBzdGF0ZSBpcyBub24tbnVtZXJpY2FsLlxuICAgICAqXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIE1vdGlvblZhbHVlLnByb3RvdHlwZS5nZXRWZWxvY2l0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gVGhpcyBjb3VsZCBiZSBpc0Zsb2F0KHRoaXMucHJldikgJiYgaXNGbG9hdCh0aGlzLmN1cnJlbnQpLCBidXQgdGhhdCB3b3VsZCBiZSB3YXN0ZWZ1bFxuICAgICAgICByZXR1cm4gdGhpcy5jYW5UcmFja1ZlbG9jaXR5XG4gICAgICAgICAgICA/IC8vIFRoZXNlIGNhc3RzIGNvdWxkIGJlIGF2b2lkZWQgaWYgcGFyc2VGbG9hdCB3b3VsZCBiZSB0eXBlZCBiZXR0ZXJcbiAgICAgICAgICAgICAgICB2ZWxvY2l0eVBlclNlY29uZChwYXJzZUZsb2F0KHRoaXMuY3VycmVudCkgLVxuICAgICAgICAgICAgICAgICAgICBwYXJzZUZsb2F0KHRoaXMucHJldiksIHRoaXMudGltZURlbHRhKVxuICAgICAgICAgICAgOiAwO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXJzIGEgbmV3IGFuaW1hdGlvbiB0byBjb250cm9sIHRoaXMgYE1vdGlvblZhbHVlYC4gT25seSBvbmVcbiAgICAgKiBhbmltYXRpb24gY2FuIGRyaXZlIGEgYE1vdGlvblZhbHVlYCBhdCBvbmUgdGltZS5cbiAgICAgKlxuICAgICAqIGBgYGpzeFxuICAgICAqIHZhbHVlLnN0YXJ0KClcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSBhbmltYXRpb24gLSBBIGZ1bmN0aW9uIHRoYXQgc3RhcnRzIHRoZSBwcm92aWRlZCBhbmltYXRpb25cbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIE1vdGlvblZhbHVlLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uIChhbmltYXRpb24pIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgX3RoaXMuaGFzQW5pbWF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgX3RoaXMuc3RvcEFuaW1hdGlvbiA9IGFuaW1hdGlvbihyZXNvbHZlKTtcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5jbGVhckFuaW1hdGlvbigpOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFN0b3AgdGhlIGN1cnJlbnRseSBhY3RpdmUgYW5pbWF0aW9uLlxuICAgICAqXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIE1vdGlvblZhbHVlLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5zdG9wQW5pbWF0aW9uKVxuICAgICAgICAgICAgdGhpcy5zdG9wQW5pbWF0aW9uKCk7XG4gICAgICAgIHRoaXMuY2xlYXJBbmltYXRpb24oKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIHRoaXMgdmFsdWUgaXMgY3VycmVudGx5IGFuaW1hdGluZy5cbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBNb3Rpb25WYWx1ZS5wcm90b3R5cGUuaXNBbmltYXRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuc3RvcEFuaW1hdGlvbjtcbiAgICB9O1xuICAgIE1vdGlvblZhbHVlLnByb3RvdHlwZS5jbGVhckFuaW1hdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zdG9wQW5pbWF0aW9uID0gbnVsbDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERlc3Ryb3kgYW5kIGNsZWFuIHVwIHN1YnNjcmliZXJzIHRvIHRoaXMgYE1vdGlvblZhbHVlYC5cbiAgICAgKlxuICAgICAqIFRoZSBgTW90aW9uVmFsdWVgIGhvb2tzIGxpa2UgYHVzZU1vdGlvblZhbHVlYCBhbmQgYHVzZVRyYW5zZm9ybWAgYXV0b21hdGljYWxseVxuICAgICAqIGhhbmRsZSB0aGUgbGlmZWN5Y2xlIG9mIHRoZSByZXR1cm5lZCBgTW90aW9uVmFsdWVgLCBzbyB0aGlzIG1ldGhvZCBpcyBvbmx5IG5lY2Vzc2FyeSBpZiB5b3UndmUgbWFudWFsbHlcbiAgICAgKiBjcmVhdGVkIGEgYE1vdGlvblZhbHVlYCB2aWEgdGhlIGBtb3Rpb25WYWx1ZWAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgTW90aW9uVmFsdWUucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlU3Vic2NyaWJlcnMuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5yZW5kZXJTdWJzY3JpYmVycy5jbGVhcigpO1xuICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICB9O1xuICAgIHJldHVybiBNb3Rpb25WYWx1ZTtcbn0oKSk7XG5mdW5jdGlvbiBtb3Rpb25WYWx1ZShpbml0KSB7XG4gICAgcmV0dXJuIG5ldyBNb3Rpb25WYWx1ZShpbml0KTtcbn1cblxuZXhwb3J0IHsgTW90aW9uVmFsdWUsIG1vdGlvblZhbHVlIH07XG4iLCIvKipcbiAqIFRlc3RzIGEgcHJvdmlkZWQgdmFsdWUgYWdhaW5zdCBhIFZhbHVlVHlwZVxuICovXG52YXIgdGVzdFZhbHVlVHlwZSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiBmdW5jdGlvbiAodHlwZSkgeyByZXR1cm4gdHlwZS50ZXN0KHYpOyB9OyB9O1xuXG5leHBvcnQgeyB0ZXN0VmFsdWVUeXBlIH07XG4iLCIvKipcbiAqIFZhbHVlVHlwZSBmb3IgXCJhdXRvXCJcbiAqL1xudmFyIGF1dG8gPSB7XG4gICAgdGVzdDogZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHYgPT09IFwiYXV0b1wiOyB9LFxuICAgIHBhcnNlOiBmdW5jdGlvbiAodikgeyByZXR1cm4gdjsgfSxcbn07XG5cbmV4cG9ydCB7IGF1dG8gfTtcbiIsImltcG9ydCB7IG51bWJlciwgcHgsIHBlcmNlbnQsIGRlZ3JlZXMsIHZ3LCB2aCB9IGZyb20gJ3N0eWxlLXZhbHVlLXR5cGVzJztcbmltcG9ydCB7IHRlc3RWYWx1ZVR5cGUgfSBmcm9tICcuL3Rlc3QubWpzJztcbmltcG9ydCB7IGF1dG8gfSBmcm9tICcuL3R5cGUtYXV0by5tanMnO1xuXG4vKipcbiAqIEEgbGlzdCBvZiB2YWx1ZSB0eXBlcyBjb21tb25seSB1c2VkIGZvciBkaW1lbnNpb25zXG4gKi9cbnZhciBkaW1lbnNpb25WYWx1ZVR5cGVzID0gW251bWJlciwgcHgsIHBlcmNlbnQsIGRlZ3JlZXMsIHZ3LCB2aCwgYXV0b107XG4vKipcbiAqIFRlc3RzIGEgZGltZW5zaW9uYWwgdmFsdWUgYWdhaW5zdCB0aGUgbGlzdCBvZiBkaW1lbnNpb24gVmFsdWVUeXBlc1xuICovXG52YXIgZmluZERpbWVuc2lvblZhbHVlVHlwZSA9IGZ1bmN0aW9uICh2KSB7XG4gICAgcmV0dXJuIGRpbWVuc2lvblZhbHVlVHlwZXMuZmluZCh0ZXN0VmFsdWVUeXBlKHYpKTtcbn07XG5cbmV4cG9ydCB7IGRpbWVuc2lvblZhbHVlVHlwZXMsIGZpbmREaW1lbnNpb25WYWx1ZVR5cGUgfTtcbiIsImltcG9ydCB7IF9fc3ByZWFkQXJyYXksIF9fcmVhZCB9IGZyb20gJ3RzbGliJztcbmltcG9ydCB7IGNvbG9yLCBjb21wbGV4IH0gZnJvbSAnc3R5bGUtdmFsdWUtdHlwZXMnO1xuaW1wb3J0IHsgZGltZW5zaW9uVmFsdWVUeXBlcyB9IGZyb20gJy4vZGltZW5zaW9ucy5tanMnO1xuaW1wb3J0IHsgdGVzdFZhbHVlVHlwZSB9IGZyb20gJy4vdGVzdC5tanMnO1xuXG4vKipcbiAqIEEgbGlzdCBvZiBhbGwgVmFsdWVUeXBlc1xuICovXG52YXIgdmFsdWVUeXBlcyA9IF9fc3ByZWFkQXJyYXkoX19zcHJlYWRBcnJheShbXSwgX19yZWFkKGRpbWVuc2lvblZhbHVlVHlwZXMpLCBmYWxzZSksIFtjb2xvciwgY29tcGxleF0sIGZhbHNlKTtcbi8qKlxuICogVGVzdHMgYSB2YWx1ZSBhZ2FpbnN0IHRoZSBsaXN0IG9mIFZhbHVlVHlwZXNcbiAqL1xudmFyIGZpbmRWYWx1ZVR5cGUgPSBmdW5jdGlvbiAodikgeyByZXR1cm4gdmFsdWVUeXBlcy5maW5kKHRlc3RWYWx1ZVR5cGUodikpOyB9O1xuXG5leHBvcnQgeyBmaW5kVmFsdWVUeXBlIH07XG4iLCJpbXBvcnQgeyBfX3Jlc3QsIF9fYXNzaWduLCBfX3NwcmVhZEFycmF5LCBfX3JlYWQgfSBmcm9tICd0c2xpYic7XG5pbXBvcnQgeyBjb21wbGV4IH0gZnJvbSAnc3R5bGUtdmFsdWUtdHlwZXMnO1xuaW1wb3J0IHsgaXNOdW1lcmljYWxTdHJpbmcgfSBmcm9tICcuLi8uLi91dGlscy9pcy1udW1lcmljYWwtc3RyaW5nLm1qcyc7XG5pbXBvcnQgeyBpc1plcm9WYWx1ZVN0cmluZyB9IGZyb20gJy4uLy4uL3V0aWxzL2lzLXplcm8tdmFsdWUtc3RyaW5nLm1qcyc7XG5pbXBvcnQgeyByZXNvbHZlRmluYWxWYWx1ZUluS2V5ZnJhbWVzIH0gZnJvbSAnLi4vLi4vdXRpbHMvcmVzb2x2ZS12YWx1ZS5tanMnO1xuaW1wb3J0IHsgbW90aW9uVmFsdWUgfSBmcm9tICcuLi8uLi92YWx1ZS9pbmRleC5tanMnO1xuaW1wb3J0IHsgZ2V0QW5pbWF0YWJsZU5vbmUgfSBmcm9tICcuLi9kb20vdmFsdWUtdHlwZXMvYW5pbWF0YWJsZS1ub25lLm1qcyc7XG5pbXBvcnQgeyBmaW5kVmFsdWVUeXBlIH0gZnJvbSAnLi4vZG9tL3ZhbHVlLXR5cGVzL2ZpbmQubWpzJztcbmltcG9ydCB7IHJlc29sdmVWYXJpYW50IH0gZnJvbSAnLi92YXJpYW50cy5tanMnO1xuXG4vKipcbiAqIFNldCBWaXN1YWxFbGVtZW50J3MgTW90aW9uVmFsdWUsIGNyZWF0aW5nIGEgbmV3IE1vdGlvblZhbHVlIGZvciBpdCBpZlxuICogaXQgZG9lc24ndCBleGlzdC5cbiAqL1xuZnVuY3Rpb24gc2V0TW90aW9uVmFsdWUodmlzdWFsRWxlbWVudCwga2V5LCB2YWx1ZSkge1xuICAgIGlmICh2aXN1YWxFbGVtZW50Lmhhc1ZhbHVlKGtleSkpIHtcbiAgICAgICAgdmlzdWFsRWxlbWVudC5nZXRWYWx1ZShrZXkpLnNldCh2YWx1ZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2aXN1YWxFbGVtZW50LmFkZFZhbHVlKGtleSwgbW90aW9uVmFsdWUodmFsdWUpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzZXRUYXJnZXQodmlzdWFsRWxlbWVudCwgZGVmaW5pdGlvbikge1xuICAgIHZhciByZXNvbHZlZCA9IHJlc29sdmVWYXJpYW50KHZpc3VhbEVsZW1lbnQsIGRlZmluaXRpb24pO1xuICAgIHZhciBfYSA9IHJlc29sdmVkID8gdmlzdWFsRWxlbWVudC5tYWtlVGFyZ2V0QW5pbWF0YWJsZShyZXNvbHZlZCwgZmFsc2UpIDoge30sIF9iID0gX2EudHJhbnNpdGlvbkVuZCwgdHJhbnNpdGlvbkVuZCA9IF9iID09PSB2b2lkIDAgPyB7fSA6IF9iOyBfYS50cmFuc2l0aW9uOyB2YXIgdGFyZ2V0ID0gX19yZXN0KF9hLCBbXCJ0cmFuc2l0aW9uRW5kXCIsIFwidHJhbnNpdGlvblwiXSk7XG4gICAgdGFyZ2V0ID0gX19hc3NpZ24oX19hc3NpZ24oe30sIHRhcmdldCksIHRyYW5zaXRpb25FbmQpO1xuICAgIGZvciAodmFyIGtleSBpbiB0YXJnZXQpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gcmVzb2x2ZUZpbmFsVmFsdWVJbktleWZyYW1lcyh0YXJnZXRba2V5XSk7XG4gICAgICAgIHNldE1vdGlvblZhbHVlKHZpc3VhbEVsZW1lbnQsIGtleSwgdmFsdWUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNldFZhcmlhbnRzKHZpc3VhbEVsZW1lbnQsIHZhcmlhbnRMYWJlbHMpIHtcbiAgICB2YXIgcmV2ZXJzZWRMYWJlbHMgPSBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQodmFyaWFudExhYmVscyksIGZhbHNlKS5yZXZlcnNlKCk7XG4gICAgcmV2ZXJzZWRMYWJlbHMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmFyIHZhcmlhbnQgPSB2aXN1YWxFbGVtZW50LmdldFZhcmlhbnQoa2V5KTtcbiAgICAgICAgdmFyaWFudCAmJiBzZXRUYXJnZXQodmlzdWFsRWxlbWVudCwgdmFyaWFudCk7XG4gICAgICAgIChfYSA9IHZpc3VhbEVsZW1lbnQudmFyaWFudENoaWxkcmVuKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgIHNldFZhcmlhbnRzKGNoaWxkLCB2YXJpYW50TGFiZWxzKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBzZXRWYWx1ZXModmlzdWFsRWxlbWVudCwgZGVmaW5pdGlvbikge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGRlZmluaXRpb24pKSB7XG4gICAgICAgIHJldHVybiBzZXRWYXJpYW50cyh2aXN1YWxFbGVtZW50LCBkZWZpbml0aW9uKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGRlZmluaXRpb24gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIHNldFZhcmlhbnRzKHZpc3VhbEVsZW1lbnQsIFtkZWZpbml0aW9uXSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzZXRUYXJnZXQodmlzdWFsRWxlbWVudCwgZGVmaW5pdGlvbik7XG4gICAgfVxufVxuZnVuY3Rpb24gY2hlY2tUYXJnZXRGb3JOZXdWYWx1ZXModmlzdWFsRWxlbWVudCwgdGFyZ2V0LCBvcmlnaW4pIHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICB2YXIgX2Q7XG4gICAgdmFyIG5ld1ZhbHVlS2V5cyA9IE9iamVjdC5rZXlzKHRhcmdldCkuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuICF2aXN1YWxFbGVtZW50Lmhhc1ZhbHVlKGtleSk7IH0pO1xuICAgIHZhciBudW1OZXdWYWx1ZXMgPSBuZXdWYWx1ZUtleXMubGVuZ3RoO1xuICAgIGlmICghbnVtTmV3VmFsdWVzKVxuICAgICAgICByZXR1cm47XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1OZXdWYWx1ZXM7IGkrKykge1xuICAgICAgICB2YXIga2V5ID0gbmV3VmFsdWVLZXlzW2ldO1xuICAgICAgICB2YXIgdGFyZ2V0VmFsdWUgPSB0YXJnZXRba2V5XTtcbiAgICAgICAgdmFyIHZhbHVlID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRoZSB0YXJnZXQgaXMgYSBzZXJpZXMgb2Yga2V5ZnJhbWVzLCB3ZSBjYW4gdXNlIHRoZSBmaXJzdCB2YWx1ZVxuICAgICAgICAgKiBpbiB0aGUgYXJyYXkuIElmIHRoaXMgZmlyc3QgdmFsdWUgaXMgbnVsbCwgd2UnbGwgc3RpbGwgbmVlZCB0byByZWFkIGZyb20gdGhlIERPTS5cbiAgICAgICAgICovXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRhcmdldFZhbHVlKSkge1xuICAgICAgICAgICAgdmFsdWUgPSB0YXJnZXRWYWx1ZVswXTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdGhlIHRhcmdldCBpc24ndCBrZXlmcmFtZXMsIG9yIHRoZSBmaXJzdCBrZXlmcmFtZSB3YXMgbnVsbCwgd2UgbmVlZCB0b1xuICAgICAgICAgKiBmaXJzdCBjaGVjayBpZiBhbiBvcmlnaW4gdmFsdWUgd2FzIGV4cGxpY2l0bHkgZGVmaW5lZCBpbiB0aGUgdHJhbnNpdGlvbiBhcyBcImZyb21cIixcbiAgICAgICAgICogaWYgbm90IHJlYWQgdGhlIHZhbHVlIGZyb20gdGhlIERPTS4gQXMgYW4gYWJzb2x1dGUgZmFsbGJhY2ssIHRha2UgdGhlIGRlZmluZWQgdGFyZ2V0IHZhbHVlLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IChfYiA9IChfYSA9IG9yaWdpbltrZXldKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB2aXN1YWxFbGVtZW50LnJlYWRWYWx1ZShrZXkpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB0YXJnZXRba2V5XTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdmFsdWUgaXMgc3RpbGwgdW5kZWZpbmVkIG9yIG51bGwsIGlnbm9yZSBpdC4gUHJlZmVyYWJseSB0aGlzIHdvdWxkIHRocm93LFxuICAgICAgICAgKiBidXQgdGhpcyB3YXMgY2F1c2luZyBpc3N1ZXMgaW4gRnJhbWVyLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IG51bGwpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICAgKGlzTnVtZXJpY2FsU3RyaW5nKHZhbHVlKSB8fCBpc1plcm9WYWx1ZVN0cmluZyh2YWx1ZSkpKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGlzIGlzIGEgbnVtYmVyIHJlYWQgYXMgYSBzdHJpbmcsIGllIFwiMFwiIG9yIFwiMjAwXCIsIGNvbnZlcnQgaXQgdG8gYSBudW1iZXJcbiAgICAgICAgICAgIHZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWZpbmRWYWx1ZVR5cGUodmFsdWUpICYmIGNvbXBsZXgudGVzdCh0YXJnZXRWYWx1ZSkpIHtcbiAgICAgICAgICAgIHZhbHVlID0gZ2V0QW5pbWF0YWJsZU5vbmUoa2V5LCB0YXJnZXRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdmlzdWFsRWxlbWVudC5hZGRWYWx1ZShrZXksIG1vdGlvblZhbHVlKHZhbHVlKSk7XG4gICAgICAgIChfYyA9IChfZCA9IG9yaWdpbilba2V5XSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogKF9kW2tleV0gPSB2YWx1ZSk7XG4gICAgICAgIHZpc3VhbEVsZW1lbnQuc2V0QmFzZVRhcmdldChrZXksIHZhbHVlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRPcmlnaW5Gcm9tVHJhbnNpdGlvbihrZXksIHRyYW5zaXRpb24pIHtcbiAgICBpZiAoIXRyYW5zaXRpb24pXG4gICAgICAgIHJldHVybjtcbiAgICB2YXIgdmFsdWVUcmFuc2l0aW9uID0gdHJhbnNpdGlvbltrZXldIHx8IHRyYW5zaXRpb25bXCJkZWZhdWx0XCJdIHx8IHRyYW5zaXRpb247XG4gICAgcmV0dXJuIHZhbHVlVHJhbnNpdGlvbi5mcm9tO1xufVxuZnVuY3Rpb24gZ2V0T3JpZ2luKHRhcmdldCwgdHJhbnNpdGlvbiwgdmlzdWFsRWxlbWVudCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgdmFyIG9yaWdpbiA9IHt9O1xuICAgIGZvciAodmFyIGtleSBpbiB0YXJnZXQpIHtcbiAgICAgICAgb3JpZ2luW2tleV0gPVxuICAgICAgICAgICAgKF9hID0gZ2V0T3JpZ2luRnJvbVRyYW5zaXRpb24oa2V5LCB0cmFuc2l0aW9uKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKF9iID0gdmlzdWFsRWxlbWVudC5nZXRWYWx1ZShrZXkpKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZ2V0KCk7XG4gICAgfVxuICAgIHJldHVybiBvcmlnaW47XG59XG5cbmV4cG9ydCB7IGNoZWNrVGFyZ2V0Rm9yTmV3VmFsdWVzLCBnZXRPcmlnaW4sIGdldE9yaWdpbkZyb21UcmFuc2l0aW9uLCBzZXRUYXJnZXQsIHNldFZhbHVlcyB9O1xuIiwiaW1wb3J0IHsgX19yZWFkLCBfX3Jlc3QsIF9fYXNzaWduIH0gZnJvbSAndHNsaWInO1xuaW1wb3J0IHsgc3RhcnRBbmltYXRpb24gfSBmcm9tICcuLi8uLi9hbmltYXRpb24vdXRpbHMvdHJhbnNpdGlvbnMubWpzJztcbmltcG9ydCB7IHNldFRhcmdldCB9IGZyb20gJy4vc2V0dGVycy5tanMnO1xuaW1wb3J0IHsgcmVzb2x2ZVZhcmlhbnQgfSBmcm9tICcuL3ZhcmlhbnRzLm1qcyc7XG5pbXBvcnQgeyBpc1RyYW5zZm9ybVByb3AgfSBmcm9tICcuLi9odG1sL3V0aWxzL3RyYW5zZm9ybS5tanMnO1xuXG5mdW5jdGlvbiBhbmltYXRlVmlzdWFsRWxlbWVudCh2aXN1YWxFbGVtZW50LCBkZWZpbml0aW9uLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICB2aXN1YWxFbGVtZW50Lm5vdGlmeUFuaW1hdGlvblN0YXJ0KGRlZmluaXRpb24pO1xuICAgIHZhciBhbmltYXRpb247XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZGVmaW5pdGlvbikpIHtcbiAgICAgICAgdmFyIGFuaW1hdGlvbnMgPSBkZWZpbml0aW9uLm1hcChmdW5jdGlvbiAodmFyaWFudCkge1xuICAgICAgICAgICAgcmV0dXJuIGFuaW1hdGVWYXJpYW50KHZpc3VhbEVsZW1lbnQsIHZhcmlhbnQsIG9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICAgICAgYW5pbWF0aW9uID0gUHJvbWlzZS5hbGwoYW5pbWF0aW9ucyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBkZWZpbml0aW9uID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGFuaW1hdGlvbiA9IGFuaW1hdGVWYXJpYW50KHZpc3VhbEVsZW1lbnQsIGRlZmluaXRpb24sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIHJlc29sdmVkRGVmaW5pdGlvbiA9IHR5cGVvZiBkZWZpbml0aW9uID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICAgID8gcmVzb2x2ZVZhcmlhbnQodmlzdWFsRWxlbWVudCwgZGVmaW5pdGlvbiwgb3B0aW9ucy5jdXN0b20pXG4gICAgICAgICAgICA6IGRlZmluaXRpb247XG4gICAgICAgIGFuaW1hdGlvbiA9IGFuaW1hdGVUYXJnZXQodmlzdWFsRWxlbWVudCwgcmVzb2x2ZWREZWZpbml0aW9uLCBvcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIGFuaW1hdGlvbi50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHZpc3VhbEVsZW1lbnQubm90aWZ5QW5pbWF0aW9uQ29tcGxldGUoZGVmaW5pdGlvbik7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBhbmltYXRlVmFyaWFudCh2aXN1YWxFbGVtZW50LCB2YXJpYW50LCBvcHRpb25zKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgdmFyIHJlc29sdmVkID0gcmVzb2x2ZVZhcmlhbnQodmlzdWFsRWxlbWVudCwgdmFyaWFudCwgb3B0aW9ucy5jdXN0b20pO1xuICAgIHZhciBfYiA9IChyZXNvbHZlZCB8fCB7fSkudHJhbnNpdGlvbiwgdHJhbnNpdGlvbiA9IF9iID09PSB2b2lkIDAgPyB2aXN1YWxFbGVtZW50LmdldERlZmF1bHRUcmFuc2l0aW9uKCkgfHwge30gOiBfYjtcbiAgICBpZiAob3B0aW9ucy50cmFuc2l0aW9uT3ZlcnJpZGUpIHtcbiAgICAgICAgdHJhbnNpdGlvbiA9IG9wdGlvbnMudHJhbnNpdGlvbk92ZXJyaWRlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJZiB3ZSBoYXZlIGEgdmFyaWFudCwgY3JlYXRlIGEgY2FsbGJhY2sgdGhhdCBydW5zIGl0IGFzIGFuIGFuaW1hdGlvbi5cbiAgICAgKiBPdGhlcndpc2UsIHdlIHJlc29sdmUgYSBQcm9taXNlIGltbWVkaWF0ZWx5IGZvciBhIGNvbXBvc2FibGUgbm8tb3AuXG4gICAgICovXG4gICAgdmFyIGdldEFuaW1hdGlvbiA9IHJlc29sdmVkXG4gICAgICAgID8gZnVuY3Rpb24gKCkgeyByZXR1cm4gYW5pbWF0ZVRhcmdldCh2aXN1YWxFbGVtZW50LCByZXNvbHZlZCwgb3B0aW9ucyk7IH1cbiAgICAgICAgOiBmdW5jdGlvbiAoKSB7IHJldHVybiBQcm9taXNlLnJlc29sdmUoKTsgfTtcbiAgICAvKipcbiAgICAgKiBJZiB3ZSBoYXZlIGNoaWxkcmVuLCBjcmVhdGUgYSBjYWxsYmFjayB0aGF0IHJ1bnMgYWxsIHRoZWlyIGFuaW1hdGlvbnMuXG4gICAgICogT3RoZXJ3aXNlLCB3ZSByZXNvbHZlIGEgUHJvbWlzZSBpbW1lZGlhdGVseSBmb3IgYSBjb21wb3NhYmxlIG5vLW9wLlxuICAgICAqL1xuICAgIHZhciBnZXRDaGlsZEFuaW1hdGlvbnMgPSAoKF9hID0gdmlzdWFsRWxlbWVudC52YXJpYW50Q2hpbGRyZW4pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zaXplKVxuICAgICAgICA/IGZ1bmN0aW9uIChmb3J3YXJkRGVsYXkpIHtcbiAgICAgICAgICAgIGlmIChmb3J3YXJkRGVsYXkgPT09IHZvaWQgMCkgeyBmb3J3YXJkRGVsYXkgPSAwOyB9XG4gICAgICAgICAgICB2YXIgX2EgPSB0cmFuc2l0aW9uLmRlbGF5Q2hpbGRyZW4sIGRlbGF5Q2hpbGRyZW4gPSBfYSA9PT0gdm9pZCAwID8gMCA6IF9hLCBzdGFnZ2VyQ2hpbGRyZW4gPSB0cmFuc2l0aW9uLnN0YWdnZXJDaGlsZHJlbiwgc3RhZ2dlckRpcmVjdGlvbiA9IHRyYW5zaXRpb24uc3RhZ2dlckRpcmVjdGlvbjtcbiAgICAgICAgICAgIHJldHVybiBhbmltYXRlQ2hpbGRyZW4odmlzdWFsRWxlbWVudCwgdmFyaWFudCwgZGVsYXlDaGlsZHJlbiArIGZvcndhcmREZWxheSwgc3RhZ2dlckNoaWxkcmVuLCBzdGFnZ2VyRGlyZWN0aW9uLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICA6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpOyB9O1xuICAgIC8qKlxuICAgICAqIElmIHRoZSB0cmFuc2l0aW9uIGV4cGxpY2l0bHkgZGVmaW5lcyBhIFwid2hlblwiIG9wdGlvbiwgd2UgbmVlZCB0byByZXNvbHZlIGVpdGhlclxuICAgICAqIHRoaXMgYW5pbWF0aW9uIG9yIGFsbCBjaGlsZHJlbiBhbmltYXRpb25zIGJlZm9yZSBwbGF5aW5nIHRoZSBvdGhlci5cbiAgICAgKi9cbiAgICB2YXIgd2hlbiA9IHRyYW5zaXRpb24ud2hlbjtcbiAgICBpZiAod2hlbikge1xuICAgICAgICB2YXIgX2MgPSBfX3JlYWQod2hlbiA9PT0gXCJiZWZvcmVDaGlsZHJlblwiXG4gICAgICAgICAgICA/IFtnZXRBbmltYXRpb24sIGdldENoaWxkQW5pbWF0aW9uc11cbiAgICAgICAgICAgIDogW2dldENoaWxkQW5pbWF0aW9ucywgZ2V0QW5pbWF0aW9uXSwgMiksIGZpcnN0ID0gX2NbMF0sIGxhc3QgPSBfY1sxXTtcbiAgICAgICAgcmV0dXJuIGZpcnN0KCkudGhlbihsYXN0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbZ2V0QW5pbWF0aW9uKCksIGdldENoaWxkQW5pbWF0aW9ucyhvcHRpb25zLmRlbGF5KV0pO1xuICAgIH1cbn1cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGFuaW1hdGVUYXJnZXQodmlzdWFsRWxlbWVudCwgZGVmaW5pdGlvbiwgX2EpIHtcbiAgICB2YXIgX2I7XG4gICAgdmFyIF9jID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIF9kID0gX2MuZGVsYXksIGRlbGF5ID0gX2QgPT09IHZvaWQgMCA/IDAgOiBfZCwgdHJhbnNpdGlvbk92ZXJyaWRlID0gX2MudHJhbnNpdGlvbk92ZXJyaWRlLCB0eXBlID0gX2MudHlwZTtcbiAgICB2YXIgX2UgPSB2aXN1YWxFbGVtZW50Lm1ha2VUYXJnZXRBbmltYXRhYmxlKGRlZmluaXRpb24pLCBfZiA9IF9lLnRyYW5zaXRpb24sIHRyYW5zaXRpb24gPSBfZiA9PT0gdm9pZCAwID8gdmlzdWFsRWxlbWVudC5nZXREZWZhdWx0VHJhbnNpdGlvbigpIDogX2YsIHRyYW5zaXRpb25FbmQgPSBfZS50cmFuc2l0aW9uRW5kLCB0YXJnZXQgPSBfX3Jlc3QoX2UsIFtcInRyYW5zaXRpb25cIiwgXCJ0cmFuc2l0aW9uRW5kXCJdKTtcbiAgICBpZiAodHJhbnNpdGlvbk92ZXJyaWRlKVxuICAgICAgICB0cmFuc2l0aW9uID0gdHJhbnNpdGlvbk92ZXJyaWRlO1xuICAgIHZhciBhbmltYXRpb25zID0gW107XG4gICAgdmFyIGFuaW1hdGlvblR5cGVTdGF0ZSA9IHR5cGUgJiYgKChfYiA9IHZpc3VhbEVsZW1lbnQuYW5pbWF0aW9uU3RhdGUpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5nZXRTdGF0ZSgpW3R5cGVdKTtcbiAgICBmb3IgKHZhciBrZXkgaW4gdGFyZ2V0KSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHZpc3VhbEVsZW1lbnQuZ2V0VmFsdWUoa2V5KTtcbiAgICAgICAgdmFyIHZhbHVlVGFyZ2V0ID0gdGFyZ2V0W2tleV07XG4gICAgICAgIGlmICghdmFsdWUgfHxcbiAgICAgICAgICAgIHZhbHVlVGFyZ2V0ID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgIChhbmltYXRpb25UeXBlU3RhdGUgJiZcbiAgICAgICAgICAgICAgICBzaG91bGRCbG9ja0FuaW1hdGlvbihhbmltYXRpb25UeXBlU3RhdGUsIGtleSkpKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdmFsdWVUcmFuc2l0aW9uID0gX19hc3NpZ24oeyBkZWxheTogZGVsYXkgfSwgdHJhbnNpdGlvbik7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYWtlIGFuaW1hdGlvbiBpbnN0YW50IGlmIHRoaXMgaXMgYSB0cmFuc2Zvcm0gcHJvcCBhbmQgd2Ugc2hvdWxkIHJlZHVjZSBtb3Rpb24uXG4gICAgICAgICAqL1xuICAgICAgICBpZiAodmlzdWFsRWxlbWVudC5zaG91bGRSZWR1Y2VNb3Rpb24gJiYgaXNUcmFuc2Zvcm1Qcm9wKGtleSkpIHtcbiAgICAgICAgICAgIHZhbHVlVHJhbnNpdGlvbiA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCB2YWx1ZVRyYW5zaXRpb24pLCB7IHR5cGU6IGZhbHNlLCBkZWxheTogMCB9KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYW5pbWF0aW9uID0gc3RhcnRBbmltYXRpb24oa2V5LCB2YWx1ZSwgdmFsdWVUYXJnZXQsIHZhbHVlVHJhbnNpdGlvbik7XG4gICAgICAgIGFuaW1hdGlvbnMucHVzaChhbmltYXRpb24pO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoYW5pbWF0aW9ucykudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRyYW5zaXRpb25FbmQgJiYgc2V0VGFyZ2V0KHZpc3VhbEVsZW1lbnQsIHRyYW5zaXRpb25FbmQpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gYW5pbWF0ZUNoaWxkcmVuKHZpc3VhbEVsZW1lbnQsIHZhcmlhbnQsIGRlbGF5Q2hpbGRyZW4sIHN0YWdnZXJDaGlsZHJlbiwgc3RhZ2dlckRpcmVjdGlvbiwgb3B0aW9ucykge1xuICAgIGlmIChkZWxheUNoaWxkcmVuID09PSB2b2lkIDApIHsgZGVsYXlDaGlsZHJlbiA9IDA7IH1cbiAgICBpZiAoc3RhZ2dlckNoaWxkcmVuID09PSB2b2lkIDApIHsgc3RhZ2dlckNoaWxkcmVuID0gMDsgfVxuICAgIGlmIChzdGFnZ2VyRGlyZWN0aW9uID09PSB2b2lkIDApIHsgc3RhZ2dlckRpcmVjdGlvbiA9IDE7IH1cbiAgICB2YXIgYW5pbWF0aW9ucyA9IFtdO1xuICAgIHZhciBtYXhTdGFnZ2VyRHVyYXRpb24gPSAodmlzdWFsRWxlbWVudC52YXJpYW50Q2hpbGRyZW4uc2l6ZSAtIDEpICogc3RhZ2dlckNoaWxkcmVuO1xuICAgIHZhciBnZW5lcmF0ZVN0YWdnZXJEdXJhdGlvbiA9IHN0YWdnZXJEaXJlY3Rpb24gPT09IDFcbiAgICAgICAgPyBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgaWYgKGkgPT09IHZvaWQgMCkgeyBpID0gMDsgfVxuICAgICAgICAgICAgcmV0dXJuIGkgKiBzdGFnZ2VyQ2hpbGRyZW47XG4gICAgICAgIH1cbiAgICAgICAgOiBmdW5jdGlvbiAoaSkge1xuICAgICAgICAgICAgaWYgKGkgPT09IHZvaWQgMCkgeyBpID0gMDsgfVxuICAgICAgICAgICAgcmV0dXJuIG1heFN0YWdnZXJEdXJhdGlvbiAtIGkgKiBzdGFnZ2VyQ2hpbGRyZW47XG4gICAgICAgIH07XG4gICAgQXJyYXkuZnJvbSh2aXN1YWxFbGVtZW50LnZhcmlhbnRDaGlsZHJlbilcbiAgICAgICAgLnNvcnQoc29ydEJ5VHJlZU9yZGVyKVxuICAgICAgICAuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQsIGkpIHtcbiAgICAgICAgYW5pbWF0aW9ucy5wdXNoKGFuaW1hdGVWYXJpYW50KGNoaWxkLCB2YXJpYW50LCBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgb3B0aW9ucyksIHsgZGVsYXk6IGRlbGF5Q2hpbGRyZW4gKyBnZW5lcmF0ZVN0YWdnZXJEdXJhdGlvbihpKSB9KSkudGhlbihmdW5jdGlvbiAoKSB7IHJldHVybiBjaGlsZC5ub3RpZnlBbmltYXRpb25Db21wbGV0ZSh2YXJpYW50KTsgfSkpO1xuICAgIH0pO1xuICAgIHJldHVybiBQcm9taXNlLmFsbChhbmltYXRpb25zKTtcbn1cbmZ1bmN0aW9uIHN0b3BBbmltYXRpb24odmlzdWFsRWxlbWVudCkge1xuICAgIHZpc3VhbEVsZW1lbnQuZm9yRWFjaFZhbHVlKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gdmFsdWUuc3RvcCgpOyB9KTtcbn1cbmZ1bmN0aW9uIHNvcnRCeVRyZWVPcmRlcihhLCBiKSB7XG4gICAgcmV0dXJuIGEuc29ydE5vZGVQb3NpdGlvbihiKTtcbn1cbi8qKlxuICogRGVjaWRlIHdoZXRoZXIgd2Ugc2hvdWxkIGJsb2NrIHRoaXMgYW5pbWF0aW9uLiBQcmV2aW91c2x5LCB3ZSBhY2hpZXZlZCB0aGlzXG4gKiBqdXN0IGJ5IGNoZWNraW5nIHdoZXRoZXIgdGhlIGtleSB3YXMgbGlzdGVkIGluIHByb3RlY3RlZEtleXMsIGJ1dCB0aGlzXG4gKiBwb3NlZCBwcm9ibGVtcyBpZiBhbiBhbmltYXRpb24gd2FzIHRyaWdnZXJlZCBieSBhZnRlckNoaWxkcmVuIGFuZCBwcm90ZWN0ZWRLZXlzXG4gKiBoYWQgYmVlbiBzZXQgdG8gdHJ1ZSBpbiB0aGUgbWVhbnRpbWUuXG4gKi9cbmZ1bmN0aW9uIHNob3VsZEJsb2NrQW5pbWF0aW9uKF9hLCBrZXkpIHtcbiAgICB2YXIgcHJvdGVjdGVkS2V5cyA9IF9hLnByb3RlY3RlZEtleXMsIG5lZWRzQW5pbWF0aW5nID0gX2EubmVlZHNBbmltYXRpbmc7XG4gICAgdmFyIHNob3VsZEJsb2NrID0gcHJvdGVjdGVkS2V5cy5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIG5lZWRzQW5pbWF0aW5nW2tleV0gIT09IHRydWU7XG4gICAgbmVlZHNBbmltYXRpbmdba2V5XSA9IGZhbHNlO1xuICAgIHJldHVybiBzaG91bGRCbG9jaztcbn1cblxuZXhwb3J0IHsgYW5pbWF0ZVZpc3VhbEVsZW1lbnQsIHNvcnRCeVRyZWVPcmRlciwgc3RvcEFuaW1hdGlvbiB9O1xuIiwiaW1wb3J0IHsgX19zcHJlYWRBcnJheSwgX19yZWFkLCBfX2Fzc2lnbiwgX19yZXN0IH0gZnJvbSAndHNsaWInO1xuaW1wb3J0IHsgaXNBbmltYXRpb25Db250cm9scyB9IGZyb20gJy4uLy4uL2FuaW1hdGlvbi91dGlscy9pcy1hbmltYXRpb24tY29udHJvbHMubWpzJztcbmltcG9ydCB7IGlzS2V5ZnJhbWVzVGFyZ2V0IH0gZnJvbSAnLi4vLi4vYW5pbWF0aW9uL3V0aWxzL2lzLWtleWZyYW1lcy10YXJnZXQubWpzJztcbmltcG9ydCB7IHNoYWxsb3dDb21wYXJlIH0gZnJvbSAnLi4vLi4vdXRpbHMvc2hhbGxvdy1jb21wYXJlLm1qcyc7XG5pbXBvcnQgeyBhbmltYXRlVmlzdWFsRWxlbWVudCB9IGZyb20gJy4vYW5pbWF0aW9uLm1qcyc7XG5pbXBvcnQgeyBBbmltYXRpb25UeXBlIH0gZnJvbSAnLi90eXBlcy5tanMnO1xuaW1wb3J0IHsgaXNWYXJpYW50TGFiZWxzLCByZXNvbHZlVmFyaWFudCwgaXNWYXJpYW50TGFiZWwgfSBmcm9tICcuL3ZhcmlhbnRzLm1qcyc7XG5cbnZhciB2YXJpYW50UHJpb3JpdHlPcmRlciA9IFtcbiAgICBBbmltYXRpb25UeXBlLkFuaW1hdGUsXG4gICAgQW5pbWF0aW9uVHlwZS5JblZpZXcsXG4gICAgQW5pbWF0aW9uVHlwZS5Gb2N1cyxcbiAgICBBbmltYXRpb25UeXBlLkhvdmVyLFxuICAgIEFuaW1hdGlvblR5cGUuVGFwLFxuICAgIEFuaW1hdGlvblR5cGUuRHJhZyxcbiAgICBBbmltYXRpb25UeXBlLkV4aXQsXG5dO1xudmFyIHJldmVyc2VQcmlvcml0eU9yZGVyID0gX19zcHJlYWRBcnJheShbXSwgX19yZWFkKHZhcmlhbnRQcmlvcml0eU9yZGVyKSwgZmFsc2UpLnJldmVyc2UoKTtcbnZhciBudW1BbmltYXRpb25UeXBlcyA9IHZhcmlhbnRQcmlvcml0eU9yZGVyLmxlbmd0aDtcbmZ1bmN0aW9uIGFuaW1hdGVMaXN0KHZpc3VhbEVsZW1lbnQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGFuaW1hdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKGFuaW1hdGlvbnMubWFwKGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgdmFyIGFuaW1hdGlvbiA9IF9hLmFuaW1hdGlvbiwgb3B0aW9ucyA9IF9hLm9wdGlvbnM7XG4gICAgICAgICAgICByZXR1cm4gYW5pbWF0ZVZpc3VhbEVsZW1lbnQodmlzdWFsRWxlbWVudCwgYW5pbWF0aW9uLCBvcHRpb25zKTtcbiAgICAgICAgfSkpO1xuICAgIH07XG59XG5mdW5jdGlvbiBjcmVhdGVBbmltYXRpb25TdGF0ZSh2aXN1YWxFbGVtZW50KSB7XG4gICAgdmFyIGFuaW1hdGUgPSBhbmltYXRlTGlzdCh2aXN1YWxFbGVtZW50KTtcbiAgICB2YXIgc3RhdGUgPSBjcmVhdGVTdGF0ZSgpO1xuICAgIHZhciBhbGxBbmltYXRlZEtleXMgPSB7fTtcbiAgICB2YXIgaXNJbml0aWFsUmVuZGVyID0gdHJ1ZTtcbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHdpbGwgYmUgdXNlZCB0byByZWR1Y2UgdGhlIGFuaW1hdGlvbiBkZWZpbml0aW9ucyBmb3JcbiAgICAgKiBlYWNoIGFjdGl2ZSBhbmltYXRpb24gdHlwZSBpbnRvIGFuIG9iamVjdCBvZiByZXNvbHZlZCB2YWx1ZXMgZm9yIGl0LlxuICAgICAqL1xuICAgIHZhciBidWlsZFJlc29sdmVkVHlwZVZhbHVlcyA9IGZ1bmN0aW9uIChhY2MsIGRlZmluaXRpb24pIHtcbiAgICAgICAgdmFyIHJlc29sdmVkID0gcmVzb2x2ZVZhcmlhbnQodmlzdWFsRWxlbWVudCwgZGVmaW5pdGlvbik7XG4gICAgICAgIGlmIChyZXNvbHZlZCkge1xuICAgICAgICAgICAgcmVzb2x2ZWQudHJhbnNpdGlvbjsgdmFyIHRyYW5zaXRpb25FbmQgPSByZXNvbHZlZC50cmFuc2l0aW9uRW5kLCB0YXJnZXQgPSBfX3Jlc3QocmVzb2x2ZWQsIFtcInRyYW5zaXRpb25cIiwgXCJ0cmFuc2l0aW9uRW5kXCJdKTtcbiAgICAgICAgICAgIGFjYyA9IF9fYXNzaWduKF9fYXNzaWduKF9fYXNzaWduKHt9LCBhY2MpLCB0YXJnZXQpLCB0cmFuc2l0aW9uRW5kKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWNjO1xuICAgIH07XG4gICAgZnVuY3Rpb24gaXNBbmltYXRlZChrZXkpIHtcbiAgICAgICAgcmV0dXJuIGFsbEFuaW1hdGVkS2V5c1trZXldICE9PSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoaXMganVzdCBhbGxvd3MgdXMgdG8gaW5qZWN0IG1vY2tlZCBhbmltYXRpb24gZnVuY3Rpb25zXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0QW5pbWF0ZUZ1bmN0aW9uKG1ha2VBbmltYXRvcikge1xuICAgICAgICBhbmltYXRlID0gbWFrZUFuaW1hdG9yKHZpc3VhbEVsZW1lbnQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaGVuIHdlIHJlY2VpdmUgbmV3IHByb3BzLCB3ZSBuZWVkIHRvOlxuICAgICAqIDEuIENyZWF0ZSBhIGxpc3Qgb2YgcHJvdGVjdGVkIGtleXMgZm9yIGVhY2ggdHlwZS4gVGhpcyBpcyBhIGRpcmVjdG9yeSBvZlxuICAgICAqICAgIHZhbHVlIGtleXMgdGhhdCBhcmUgY3VycmVudGx5IGJlaW5nIFwiaGFuZGxlZFwiIGJ5IHR5cGVzIG9mIGEgaGlnaGVyIHByaW9yaXR5XG4gICAgICogICAgc28gdGhhdCB3aGVuZXZlciBhbiBhbmltYXRpb24gaXMgcGxheWVkIG9mIGEgZ2l2ZW4gdHlwZSwgdGhlc2UgdmFsdWVzIGFyZVxuICAgICAqICAgIHByb3RlY3RlZCBmcm9tIGJlaW5nIGFuaW1hdGVkLlxuICAgICAqIDIuIERldGVybWluZSBpZiBhbiBhbmltYXRpb24gdHlwZSBuZWVkcyBhbmltYXRpbmcuXG4gICAgICogMy4gRGV0ZXJtaW5lIGlmIGFueSB2YWx1ZXMgaGF2ZSBiZWVuIHJlbW92ZWQgZnJvbSBhIHR5cGUgYW5kIGZpZ3VyZSBvdXRcbiAgICAgKiAgICB3aGF0IHRvIGFuaW1hdGUgdGhvc2UgdG8uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYW5pbWF0ZUNoYW5nZXMob3B0aW9ucywgY2hhbmdlZEFjdGl2ZVR5cGUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB2YXIgcHJvcHMgPSB2aXN1YWxFbGVtZW50LmdldFByb3BzKCk7XG4gICAgICAgIHZhciBjb250ZXh0ID0gdmlzdWFsRWxlbWVudC5nZXRWYXJpYW50Q29udGV4dCh0cnVlKSB8fCB7fTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgbGlzdCBvZiBhbmltYXRpb25zIHRoYXQgd2UnbGwgYnVpbGQgaW50byBhcyB3ZSBpdGVyYXRlIHRocm91Z2ggdGhlIGFuaW1hdGlvblxuICAgICAgICAgKiB0eXBlcy4gVGhpcyB3aWxsIGdldCBleGVjdXRlZCBhdCB0aGUgZW5kIG9mIHRoZSBmdW5jdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIHZhciBhbmltYXRpb25zID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBLZWVwIHRyYWNrIG9mIHdoaWNoIHZhbHVlcyBoYXZlIGJlZW4gcmVtb3ZlZC4gVGhlbiwgYXMgd2UgaGl0IGxvd2VyIHByaW9yaXR5XG4gICAgICAgICAqIGFuaW1hdGlvbiB0eXBlcywgd2UgY2FuIGNoZWNrIGlmIHRoZXkgY29udGFpbiByZW1vdmVkIHZhbHVlcyBhbmQgYW5pbWF0ZSB0byB0aGF0LlxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIHJlbW92ZWRLZXlzID0gbmV3IFNldCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBkaWN0aW9uYXJ5IG9mIGFsbCBlbmNvdW50ZXJlZCBrZXlzLiBUaGlzIGlzIGFuIG9iamVjdCB0byBsZXQgdXMgYnVpbGQgaW50byBhbmRcbiAgICAgICAgICogY29weSBpdCB3aXRob3V0IGl0ZXJhdGlvbi4gRWFjaCB0aW1lIHdlIGhpdCBhbiBhbmltYXRpb24gdHlwZSB3ZSBzZXQgaXRzIHByb3RlY3RlZFxuICAgICAgICAgKiBrZXlzIC0gdGhlIGtleXMgaXRzIG5vdCBhbGxvd2VkIHRvIGFuaW1hdGUgLSB0byB0aGUgbGF0ZXN0IHZlcnNpb24gb2YgdGhpcyBvYmplY3QuXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgZW5jb3VudGVyZWRLZXlzID0ge307XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBhIHZhcmlhbnQgaGFzIGJlZW4gcmVtb3ZlZCBhdCBhIGdpdmVuIGluZGV4LCBhbmQgdGhpcyBjb21wb25lbnQgaXMgY29udHJvbGxpbmdcbiAgICAgICAgICogdmFyaWFudCBhbmltYXRpb25zLCB3ZSB3YW50IHRvIGVuc3VyZSBsb3dlci1wcmlvcml0eSB2YXJpYW50cyBhcmUgZm9yY2VkIHRvIGFuaW1hdGUuXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgcmVtb3ZlZFZhcmlhbnRJbmRleCA9IEluZmluaXR5O1xuICAgICAgICB2YXIgX2xvb3BfMSA9IGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IHJldmVyc2VQcmlvcml0eU9yZGVyW2ldO1xuICAgICAgICAgICAgdmFyIHR5cGVTdGF0ZSA9IHN0YXRlW3R5cGVdO1xuICAgICAgICAgICAgdmFyIHByb3AgPSAoX2EgPSBwcm9wc1t0eXBlXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY29udGV4dFt0eXBlXTtcbiAgICAgICAgICAgIHZhciBwcm9wSXNWYXJpYW50ID0gaXNWYXJpYW50TGFiZWwocHJvcCk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElmIHRoaXMgdHlwZSBoYXMgKmp1c3QqIGNoYW5nZWQgaXNBY3RpdmUgc3RhdHVzLCBzZXQgYWN0aXZlRGVsdGFcbiAgICAgICAgICAgICAqIHRvIHRoYXQgc3RhdHVzLiBPdGhlcndpc2Ugc2V0IHRvIG51bGwuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZhciBhY3RpdmVEZWx0YSA9IHR5cGUgPT09IGNoYW5nZWRBY3RpdmVUeXBlID8gdHlwZVN0YXRlLmlzQWN0aXZlIDogbnVsbDtcbiAgICAgICAgICAgIGlmIChhY3RpdmVEZWx0YSA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgcmVtb3ZlZFZhcmlhbnRJbmRleCA9IGk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElmIHRoaXMgcHJvcCBpcyBhbiBpbmhlcml0ZWQgdmFyaWFudCwgcmF0aGVyIHRoYW4gYmVlbiBzZXQgZGlyZWN0bHkgb24gdGhlXG4gICAgICAgICAgICAgKiBjb21wb25lbnQgaXRzZWxmLCB3ZSB3YW50IHRvIG1ha2Ugc3VyZSB3ZSBhbGxvdyB0aGUgcGFyZW50IHRvIHRyaWdnZXIgYW5pbWF0aW9ucy5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBUT0RPOiBDYW4gcHJvYmFibHkgY2hhbmdlIHRoaXMgdG8gYSAhaXNDb250cm9sbGluZ1ZhcmlhbnRzIGNoZWNrXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZhciBpc0luaGVyaXRlZCA9IHByb3AgPT09IGNvbnRleHRbdHlwZV0gJiYgcHJvcCAhPT0gcHJvcHNbdHlwZV0gJiYgcHJvcElzVmFyaWFudDtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKGlzSW5oZXJpdGVkICYmXG4gICAgICAgICAgICAgICAgaXNJbml0aWFsUmVuZGVyICYmXG4gICAgICAgICAgICAgICAgdmlzdWFsRWxlbWVudC5tYW51YWxseUFuaW1hdGVPbk1vdW50KSB7XG4gICAgICAgICAgICAgICAgaXNJbmhlcml0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU2V0IGFsbCBlbmNvdW50ZXJlZCBrZXlzIHNvIGZhciBhcyB0aGUgcHJvdGVjdGVkIGtleXMgZm9yIHRoaXMgdHlwZS4gVGhpcyB3aWxsXG4gICAgICAgICAgICAgKiBiZSBhbnkga2V5IHRoYXQgaGFzIGJlZW4gYW5pbWF0ZWQgb3Igb3RoZXJ3aXNlIGhhbmRsZWQgYnkgYWN0aXZlLCBoaWdoZXItcHJpb3J0aXkgdHlwZXMuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHR5cGVTdGF0ZS5wcm90ZWN0ZWRLZXlzID0gX19hc3NpZ24oe30sIGVuY291bnRlcmVkS2V5cyk7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiB3ZSBjYW4gc2tpcCBhbmFseXNpbmcgdGhpcyBwcm9wIGVhcmx5XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAvLyBJZiBpdCBpc24ndCBhY3RpdmUgYW5kIGhhc24ndCAqanVzdCogYmVlbiBzZXQgYXMgaW5hY3RpdmVcbiAgICAgICAgICAgICghdHlwZVN0YXRlLmlzQWN0aXZlICYmIGFjdGl2ZURlbHRhID09PSBudWxsKSB8fFxuICAgICAgICAgICAgICAgIC8vIElmIHdlIGRpZG4ndCBhbmQgZG9uJ3QgaGF2ZSBhbnkgZGVmaW5lZCBwcm9wIGZvciB0aGlzIGFuaW1hdGlvbiB0eXBlXG4gICAgICAgICAgICAgICAgKCFwcm9wICYmICF0eXBlU3RhdGUucHJldlByb3ApIHx8XG4gICAgICAgICAgICAgICAgLy8gT3IgaWYgdGhlIHByb3AgZG9lc24ndCBkZWZpbmUgYW4gYW5pbWF0aW9uXG4gICAgICAgICAgICAgICAgaXNBbmltYXRpb25Db250cm9scyhwcm9wKSB8fFxuICAgICAgICAgICAgICAgIHR5cGVvZiBwcm9wID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBcImNvbnRpbnVlXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEFzIHdlIGdvIGxvb2sgdGhyb3VnaCB0aGUgdmFsdWVzIGRlZmluZWQgb24gdGhpcyB0eXBlLCBpZiB3ZSBkZXRlY3RcbiAgICAgICAgICAgICAqIGEgY2hhbmdlZCB2YWx1ZSBvciBhIHZhbHVlIHRoYXQgd2FzIHJlbW92ZWQgaW4gYSBoaWdoZXIgcHJpb3JpdHksIHdlIHNldFxuICAgICAgICAgICAgICogdGhpcyB0byB0cnVlIGFuZCBhZGQgdGhpcyBwcm9wIHRvIHRoZSBhbmltYXRpb24gbGlzdC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmFyIHZhcmlhbnREaWRDaGFuZ2UgPSBjaGVja1ZhcmlhbnRzRGlkQ2hhbmdlKHR5cGVTdGF0ZS5wcmV2UHJvcCwgcHJvcCk7XG4gICAgICAgICAgICB2YXIgc2hvdWxkQW5pbWF0ZVR5cGUgPSB2YXJpYW50RGlkQ2hhbmdlIHx8XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UncmUgbWFraW5nIHRoaXMgdmFyaWFudCBhY3RpdmUsIHdlIHdhbnQgdG8gYWx3YXlzIG1ha2UgaXQgYWN0aXZlXG4gICAgICAgICAgICAgICAgKHR5cGUgPT09IGNoYW5nZWRBY3RpdmVUeXBlICYmXG4gICAgICAgICAgICAgICAgICAgIHR5cGVTdGF0ZS5pc0FjdGl2ZSAmJlxuICAgICAgICAgICAgICAgICAgICAhaXNJbmhlcml0ZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgcHJvcElzVmFyaWFudCkgfHxcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSByZW1vdmVkIGEgaGlnaGVyLXByaW9yaXR5IHZhcmlhbnQgKGkgaXMgaW4gcmV2ZXJzZSBvcmRlcilcbiAgICAgICAgICAgICAgICAoaSA+IHJlbW92ZWRWYXJpYW50SW5kZXggJiYgcHJvcElzVmFyaWFudCk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEFzIGFuaW1hdGlvbnMgY2FuIGJlIHNldCBhcyB2YXJpYW50IGxpc3RzLCB2YXJpYW50cyBvciB0YXJnZXQgb2JqZWN0cywgd2VcbiAgICAgICAgICAgICAqIGNvZXJjZSBldmVyeXRoaW5nIHRvIGFuIGFycmF5IGlmIGl0IGlzbid0IG9uZSBhbHJlYWR5XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZhciBkZWZpbml0aW9uTGlzdCA9IEFycmF5LmlzQXJyYXkocHJvcCkgPyBwcm9wIDogW3Byb3BdO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBCdWlsZCBhbiBvYmplY3Qgb2YgYWxsIHRoZSByZXNvbHZlZCB2YWx1ZXMuIFdlJ2xsIHVzZSB0aGlzIGluIHRoZSBzdWJzZXF1ZW50XG4gICAgICAgICAgICAgKiBhbmltYXRlQ2hhbmdlcyBjYWxscyB0byBkZXRlcm1pbmUgd2hldGhlciBhIHZhbHVlIGhhcyBjaGFuZ2VkLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2YXIgcmVzb2x2ZWRWYWx1ZXMgPSBkZWZpbml0aW9uTGlzdC5yZWR1Y2UoYnVpbGRSZXNvbHZlZFR5cGVWYWx1ZXMsIHt9KTtcbiAgICAgICAgICAgIGlmIChhY3RpdmVEZWx0YSA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgcmVzb2x2ZWRWYWx1ZXMgPSB7fTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogTm93IHdlIG5lZWQgdG8gbG9vcCB0aHJvdWdoIGFsbCB0aGUga2V5cyBpbiB0aGUgcHJldiBwcm9wIGFuZCB0aGlzIHByb3AsXG4gICAgICAgICAgICAgKiBhbmQgZGVjaWRlOlxuICAgICAgICAgICAgICogMS4gSWYgdGhlIHZhbHVlIGhhcyBjaGFuZ2VkLCBhbmQgbmVlZHMgYW5pbWF0aW5nXG4gICAgICAgICAgICAgKiAyLiBJZiBpdCBoYXMgYmVlbiByZW1vdmVkLCBhbmQgbmVlZHMgYWRkaW5nIHRvIHRoZSByZW1vdmVkS2V5cyBzZXRcbiAgICAgICAgICAgICAqIDMuIElmIGl0IGhhcyBiZWVuIHJlbW92ZWQgaW4gYSBoaWdoZXIgcHJpb3JpdHkgdHlwZSBhbmQgbmVlZHMgYW5pbWF0aW5nXG4gICAgICAgICAgICAgKiA0LiBJZiBpdCBoYXNuJ3QgYmVlbiByZW1vdmVkIGluIGEgaGlnaGVyIHByaW9yaXR5IGJ1dCBoYXNuJ3QgY2hhbmdlZCwgYW5kXG4gICAgICAgICAgICAgKiAgICBuZWVkcyBhZGRpbmcgdG8gdGhlIHR5cGUncyBwcm90ZWN0ZWRLZXlzIGxpc3QuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZhciBfYiA9IHR5cGVTdGF0ZS5wcmV2UmVzb2x2ZWRWYWx1ZXMsIHByZXZSZXNvbHZlZFZhbHVlcyA9IF9iID09PSB2b2lkIDAgPyB7fSA6IF9iO1xuICAgICAgICAgICAgdmFyIGFsbEtleXMgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcHJldlJlc29sdmVkVmFsdWVzKSwgcmVzb2x2ZWRWYWx1ZXMpO1xuICAgICAgICAgICAgdmFyIG1hcmtUb0FuaW1hdGUgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgc2hvdWxkQW5pbWF0ZVR5cGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJlbW92ZWRLZXlzLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgICAgIHR5cGVTdGF0ZS5uZWVkc0FuaW1hdGluZ1trZXldID0gdHJ1ZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gYWxsS2V5cykge1xuICAgICAgICAgICAgICAgIHZhciBuZXh0ID0gcmVzb2x2ZWRWYWx1ZXNba2V5XTtcbiAgICAgICAgICAgICAgICB2YXIgcHJldiA9IHByZXZSZXNvbHZlZFZhbHVlc1trZXldO1xuICAgICAgICAgICAgICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgaGFuZGxlZCB0aGlzIHdlIGNhbiBqdXN0IHNraXAgYWhlYWRcbiAgICAgICAgICAgICAgICBpZiAoZW5jb3VudGVyZWRLZXlzLmhhc093blByb3BlcnR5KGtleSkpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIElmIHRoZSB2YWx1ZSBoYXMgY2hhbmdlZCwgd2UgcHJvYmFibHkgd2FudCB0byBhbmltYXRlIGl0LlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGlmIChuZXh0ICE9PSBwcmV2KSB7XG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBJZiBib3RoIHZhbHVlcyBhcmUga2V5ZnJhbWVzLCB3ZSBuZWVkIHRvIHNoYWxsb3cgY29tcGFyZSB0aGVtIHRvXG4gICAgICAgICAgICAgICAgICAgICAqIGRldGVjdCB3aGV0aGVyIGFueSB2YWx1ZSBoYXMgY2hhbmdlZC4gSWYgaXQgaGFzLCB3ZSBhbmltYXRlIGl0LlxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzS2V5ZnJhbWVzVGFyZ2V0KG5leHQpICYmIGlzS2V5ZnJhbWVzVGFyZ2V0KHByZXYpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNoYWxsb3dDb21wYXJlKG5leHQsIHByZXYpIHx8IHZhcmlhbnREaWRDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXJrVG9BbmltYXRlKGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBJZiBpdCBoYXNuJ3QgY2hhbmdlZCwgd2Ugd2FudCB0byBlbnN1cmUgaXQgZG9lc24ndCBhbmltYXRlIGJ5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogYWRkaW5nIGl0IHRvIHRoZSBsaXN0IG9mIHByb3RlY3RlZCBrZXlzLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVTdGF0ZS5wcm90ZWN0ZWRLZXlzW2tleV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5leHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgbmV4dCBpcyBkZWZpbmVkIGFuZCBkb2Vzbid0IGVxdWFsIHByZXYsIGl0IG5lZWRzIGFuaW1hdGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFya1RvQW5pbWF0ZShrZXkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgaXQncyB1bmRlZmluZWQsIGl0J3MgYmVlbiByZW1vdmVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZEtleXMuYWRkKGtleSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobmV4dCAhPT0gdW5kZWZpbmVkICYmIHJlbW92ZWRLZXlzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBJZiBuZXh0IGhhc24ndCBjaGFuZ2VkIGFuZCBpdCBpc24ndCB1bmRlZmluZWQsIHdlIHdhbnQgdG8gY2hlY2sgaWYgaXQnc1xuICAgICAgICAgICAgICAgICAgICAgKiBiZWVuIHJlbW92ZWQgYnkgYSBoaWdoZXIgcHJpb3JpdHlcbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIG1hcmtUb0FuaW1hdGUoa2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBJZiBpdCBoYXNuJ3QgY2hhbmdlZCwgd2UgYWRkIGl0IHRvIHRoZSBsaXN0IG9mIHByb3RlY3RlZCB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgICogdG8gZW5zdXJlIGl0IGRvZXNuJ3QgZ2V0IGFuaW1hdGVkLlxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgdHlwZVN0YXRlLnByb3RlY3RlZEtleXNba2V5XSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBVcGRhdGUgdGhlIHR5cGVTdGF0ZSBzbyBuZXh0IHRpbWUgYW5pbWF0ZUNoYW5nZXMgaXMgY2FsbGVkIHdlIGNhbiBjb21wYXJlIHRoZVxuICAgICAgICAgICAgICogbGF0ZXN0IHByb3AgYW5kIHJlc29sdmVkVmFsdWVzIHRvIHRoZXNlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0eXBlU3RhdGUucHJldlByb3AgPSBwcm9wO1xuICAgICAgICAgICAgdHlwZVN0YXRlLnByZXZSZXNvbHZlZFZhbHVlcyA9IHJlc29sdmVkVmFsdWVzO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAodHlwZVN0YXRlLmlzQWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgZW5jb3VudGVyZWRLZXlzID0gX19hc3NpZ24oX19hc3NpZ24oe30sIGVuY291bnRlcmVkS2V5cyksIHJlc29sdmVkVmFsdWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0luaXRpYWxSZW5kZXIgJiYgdmlzdWFsRWxlbWVudC5ibG9ja0luaXRpYWxBbmltYXRpb24pIHtcbiAgICAgICAgICAgICAgICBzaG91bGRBbmltYXRlVHlwZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJZiB0aGlzIGlzIGFuIGluaGVyaXRlZCBwcm9wIHdlIHdhbnQgdG8gaGFyZC1ibG9jayBhbmltYXRpb25zXG4gICAgICAgICAgICAgKiBUT0RPOiBUZXN0IGFzIHRoaXMgc2hvdWxkIHByb2JhYmx5IHN0aWxsIGhhbmRsZSBhbmltYXRpb25zIHRyaWdnZXJlZFxuICAgICAgICAgICAgICogYnkgcmVtb3ZlZCB2YWx1ZXM/XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmIChzaG91bGRBbmltYXRlVHlwZSAmJiAhaXNJbmhlcml0ZWQpIHtcbiAgICAgICAgICAgICAgICBhbmltYXRpb25zLnB1c2guYXBwbHkoYW5pbWF0aW9ucywgX19zcHJlYWRBcnJheShbXSwgX19yZWFkKGRlZmluaXRpb25MaXN0Lm1hcChmdW5jdGlvbiAoYW5pbWF0aW9uKSB7IHJldHVybiAoe1xuICAgICAgICAgICAgICAgICAgICBhbmltYXRpb246IGFuaW1hdGlvbixcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9uczogX19hc3NpZ24oeyB0eXBlOiB0eXBlIH0sIG9wdGlvbnMpLFxuICAgICAgICAgICAgICAgIH0pOyB9KSksIGZhbHNlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJdGVyYXRlIHRocm91Z2ggYWxsIGFuaW1hdGlvbiB0eXBlcyBpbiByZXZlcnNlIHByaW9yaXR5IG9yZGVyLiBGb3IgZWFjaCwgd2Ugd2FudCB0b1xuICAgICAgICAgKiBkZXRlY3Qgd2hpY2ggdmFsdWVzIGl0J3MgaGFuZGxpbmcgYW5kIHdoZXRoZXIgb3Igbm90IHRoZXkndmUgY2hhbmdlZCAoYW5kIHRoZXJlZm9yZVxuICAgICAgICAgKiBuZWVkIHRvIGJlIGFuaW1hdGVkKS4gSWYgYW55IHZhbHVlcyBoYXZlIGJlZW4gcmVtb3ZlZCwgd2Ugd2FudCB0byBkZXRlY3QgdGhvc2UgaW5cbiAgICAgICAgICogbG93ZXIgcHJpb3JpdHkgcHJvcHMgYW5kIGZsYWcgZm9yIGFuaW1hdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtQW5pbWF0aW9uVHlwZXM7IGkrKykge1xuICAgICAgICAgICAgX2xvb3BfMShpKTtcbiAgICAgICAgfVxuICAgICAgICBhbGxBbmltYXRlZEtleXMgPSBfX2Fzc2lnbih7fSwgZW5jb3VudGVyZWRLZXlzKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRoZXJlIGFyZSBzb21lIHJlbW92ZWQgdmFsdWUgdGhhdCBoYXZlbid0IGJlZW4gZGVhbHQgd2l0aCxcbiAgICAgICAgICogd2UgbmVlZCB0byBjcmVhdGUgYSBuZXcgYW5pbWF0aW9uIHRoYXQgZmFsbHMgYmFjayBlaXRoZXIgdG8gdGhlIHZhbHVlXG4gICAgICAgICAqIGRlZmluZWQgaW4gdGhlIHN0eWxlIHByb3AsIG9yIHRoZSBsYXN0IHJlYWQgdmFsdWUuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAocmVtb3ZlZEtleXMuc2l6ZSkge1xuICAgICAgICAgICAgdmFyIGZhbGxiYWNrQW5pbWF0aW9uXzEgPSB7fTtcbiAgICAgICAgICAgIHJlbW92ZWRLZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHZhciBmYWxsYmFja1RhcmdldCA9IHZpc3VhbEVsZW1lbnQuZ2V0QmFzZVRhcmdldChrZXkpO1xuICAgICAgICAgICAgICAgIGlmIChmYWxsYmFja1RhcmdldCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGZhbGxiYWNrQW5pbWF0aW9uXzFba2V5XSA9IGZhbGxiYWNrVGFyZ2V0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYW5pbWF0aW9ucy5wdXNoKHsgYW5pbWF0aW9uOiBmYWxsYmFja0FuaW1hdGlvbl8xIH0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzaG91bGRBbmltYXRlID0gQm9vbGVhbihhbmltYXRpb25zLmxlbmd0aCk7XG4gICAgICAgIGlmIChpc0luaXRpYWxSZW5kZXIgJiZcbiAgICAgICAgICAgIHByb3BzLmluaXRpYWwgPT09IGZhbHNlICYmXG4gICAgICAgICAgICAhdmlzdWFsRWxlbWVudC5tYW51YWxseUFuaW1hdGVPbk1vdW50KSB7XG4gICAgICAgICAgICBzaG91bGRBbmltYXRlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaXNJbml0aWFsUmVuZGVyID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBzaG91bGRBbmltYXRlID8gYW5pbWF0ZShhbmltYXRpb25zKSA6IFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGFuZ2Ugd2hldGhlciBhIGNlcnRhaW4gYW5pbWF0aW9uIHR5cGUgaXMgYWN0aXZlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldEFjdGl2ZSh0eXBlLCBpc0FjdGl2ZSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIC8vIElmIHRoZSBhY3RpdmUgc3RhdGUgaGFzbid0IGNoYW5nZWQsIHdlIGNhbiBzYWZlbHkgZG8gbm90aGluZyBoZXJlXG4gICAgICAgIGlmIChzdGF0ZVt0eXBlXS5pc0FjdGl2ZSA9PT0gaXNBY3RpdmUpXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIC8vIFByb3BhZ2F0ZSBhY3RpdmUgY2hhbmdlIHRvIGNoaWxkcmVuXG4gICAgICAgIChfYSA9IHZpc3VhbEVsZW1lbnQudmFyaWFudENoaWxkcmVuKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHsgdmFyIF9hOyByZXR1cm4gKF9hID0gY2hpbGQuYW5pbWF0aW9uU3RhdGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zZXRBY3RpdmUodHlwZSwgaXNBY3RpdmUpOyB9KTtcbiAgICAgICAgc3RhdGVbdHlwZV0uaXNBY3RpdmUgPSBpc0FjdGl2ZTtcbiAgICAgICAgdmFyIGFuaW1hdGlvbnMgPSBhbmltYXRlQ2hhbmdlcyhvcHRpb25zLCB0eXBlKTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHN0YXRlKSB7XG4gICAgICAgICAgICBzdGF0ZVtrZXldLnByb3RlY3RlZEtleXMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYW5pbWF0aW9ucztcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaXNBbmltYXRlZDogaXNBbmltYXRlZCxcbiAgICAgICAgYW5pbWF0ZUNoYW5nZXM6IGFuaW1hdGVDaGFuZ2VzLFxuICAgICAgICBzZXRBY3RpdmU6IHNldEFjdGl2ZSxcbiAgICAgICAgc2V0QW5pbWF0ZUZ1bmN0aW9uOiBzZXRBbmltYXRlRnVuY3Rpb24sXG4gICAgICAgIGdldFN0YXRlOiBmdW5jdGlvbiAoKSB7IHJldHVybiBzdGF0ZTsgfSxcbiAgICB9O1xufVxuZnVuY3Rpb24gY2hlY2tWYXJpYW50c0RpZENoYW5nZShwcmV2LCBuZXh0KSB7XG4gICAgaWYgKHR5cGVvZiBuZXh0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBuZXh0ICE9PSBwcmV2O1xuICAgIH1cbiAgICBlbHNlIGlmIChpc1ZhcmlhbnRMYWJlbHMobmV4dCkpIHtcbiAgICAgICAgcmV0dXJuICFzaGFsbG93Q29tcGFyZShuZXh0LCBwcmV2KTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gY3JlYXRlVHlwZVN0YXRlKGlzQWN0aXZlKSB7XG4gICAgaWYgKGlzQWN0aXZlID09PSB2b2lkIDApIHsgaXNBY3RpdmUgPSBmYWxzZTsgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGlzQWN0aXZlOiBpc0FjdGl2ZSxcbiAgICAgICAgcHJvdGVjdGVkS2V5czoge30sXG4gICAgICAgIG5lZWRzQW5pbWF0aW5nOiB7fSxcbiAgICAgICAgcHJldlJlc29sdmVkVmFsdWVzOiB7fSxcbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlU3RhdGUoKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiBfYSA9IHt9LFxuICAgICAgICBfYVtBbmltYXRpb25UeXBlLkFuaW1hdGVdID0gY3JlYXRlVHlwZVN0YXRlKHRydWUpLFxuICAgICAgICBfYVtBbmltYXRpb25UeXBlLkluVmlld10gPSBjcmVhdGVUeXBlU3RhdGUoKSxcbiAgICAgICAgX2FbQW5pbWF0aW9uVHlwZS5Ib3Zlcl0gPSBjcmVhdGVUeXBlU3RhdGUoKSxcbiAgICAgICAgX2FbQW5pbWF0aW9uVHlwZS5UYXBdID0gY3JlYXRlVHlwZVN0YXRlKCksXG4gICAgICAgIF9hW0FuaW1hdGlvblR5cGUuRHJhZ10gPSBjcmVhdGVUeXBlU3RhdGUoKSxcbiAgICAgICAgX2FbQW5pbWF0aW9uVHlwZS5Gb2N1c10gPSBjcmVhdGVUeXBlU3RhdGUoKSxcbiAgICAgICAgX2FbQW5pbWF0aW9uVHlwZS5FeGl0XSA9IGNyZWF0ZVR5cGVTdGF0ZSgpLFxuICAgICAgICBfYTtcbn1cblxuZXhwb3J0IHsgY2hlY2tWYXJpYW50c0RpZENoYW5nZSwgY3JlYXRlQW5pbWF0aW9uU3RhdGUsIHZhcmlhbnRQcmlvcml0eU9yZGVyIH07XG4iLCJpbXBvcnQgeyBfX3JlYWQgfSBmcm9tICd0c2xpYic7XG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZUNvbnRleHQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBpc0FuaW1hdGlvbkNvbnRyb2xzIH0gZnJvbSAnLi4vLi4vYW5pbWF0aW9uL3V0aWxzL2lzLWFuaW1hdGlvbi1jb250cm9scy5tanMnO1xuaW1wb3J0IHsgdXNlUHJlc2VuY2UgfSBmcm9tICcuLi8uLi9jb21wb25lbnRzL0FuaW1hdGVQcmVzZW5jZS91c2UtcHJlc2VuY2UubWpzJztcbmltcG9ydCB7IFByZXNlbmNlQ29udGV4dCB9IGZyb20gJy4uLy4uL2NvbnRleHQvUHJlc2VuY2VDb250ZXh0Lm1qcyc7XG5pbXBvcnQgeyBjcmVhdGVBbmltYXRpb25TdGF0ZSB9IGZyb20gJy4uLy4uL3JlbmRlci91dGlscy9hbmltYXRpb24tc3RhdGUubWpzJztcbmltcG9ydCB7IEFuaW1hdGlvblR5cGUgfSBmcm9tICcuLi8uLi9yZW5kZXIvdXRpbHMvdHlwZXMubWpzJztcbmltcG9ydCB7IG1ha2VSZW5kZXJsZXNzQ29tcG9uZW50IH0gZnJvbSAnLi4vdXRpbHMvbWFrZS1yZW5kZXJsZXNzLWNvbXBvbmVudC5tanMnO1xuXG52YXIgYW5pbWF0aW9ucyA9IHtcbiAgICBhbmltYXRpb246IG1ha2VSZW5kZXJsZXNzQ29tcG9uZW50KGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgdmlzdWFsRWxlbWVudCA9IF9hLnZpc3VhbEVsZW1lbnQsIGFuaW1hdGUgPSBfYS5hbmltYXRlO1xuICAgICAgICAvKipcbiAgICAgICAgICogV2UgZHluYW1pY2FsbHkgZ2VuZXJhdGUgdGhlIEFuaW1hdGlvblN0YXRlIG1hbmFnZXIgYXMgaXQgY29udGFpbnMgYSByZWZlcmVuY2VcbiAgICAgICAgICogdG8gdGhlIHVuZGVybHlpbmcgYW5pbWF0aW9uIGxpYnJhcnkuIFdlIG9ubHkgd2FudCB0byBsb2FkIHRoYXQgaWYgd2UgbG9hZCB0aGlzLFxuICAgICAgICAgKiBzbyBwZW9wbGUgY2FuIG9wdGlvbmFsbHkgY29kZSBzcGxpdCBpdCBvdXQgdXNpbmcgdGhlIGBtYCBjb21wb25lbnQuXG4gICAgICAgICAqL1xuICAgICAgICB2aXN1YWxFbGVtZW50LmFuaW1hdGlvblN0YXRlIHx8ICh2aXN1YWxFbGVtZW50LmFuaW1hdGlvblN0YXRlID0gY3JlYXRlQW5pbWF0aW9uU3RhdGUodmlzdWFsRWxlbWVudCkpO1xuICAgICAgICAvKipcbiAgICAgICAgICogU3Vic2NyaWJlIGFueSBwcm92aWRlZCBBbmltYXRpb25Db250cm9scyB0byB0aGUgY29tcG9uZW50J3MgVmlzdWFsRWxlbWVudFxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKGlzQW5pbWF0aW9uQ29udHJvbHMoYW5pbWF0ZSkpIHtcbiAgICAgICAgICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7IHJldHVybiBhbmltYXRlLnN1YnNjcmliZSh2aXN1YWxFbGVtZW50KTsgfSwgW2FuaW1hdGVdKTtcbiAgICAgICAgfVxuICAgIH0pLFxuICAgIGV4aXQ6IG1ha2VSZW5kZXJsZXNzQ29tcG9uZW50KGZ1bmN0aW9uIChwcm9wcykge1xuICAgICAgICB2YXIgY3VzdG9tID0gcHJvcHMuY3VzdG9tLCB2aXN1YWxFbGVtZW50ID0gcHJvcHMudmlzdWFsRWxlbWVudDtcbiAgICAgICAgdmFyIF9hID0gX19yZWFkKHVzZVByZXNlbmNlKCksIDIpLCBpc1ByZXNlbnQgPSBfYVswXSwgc2FmZVRvUmVtb3ZlID0gX2FbMV07XG4gICAgICAgIHZhciBwcmVzZW5jZUNvbnRleHQgPSB1c2VDb250ZXh0KFByZXNlbmNlQ29udGV4dCk7XG4gICAgICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgdmlzdWFsRWxlbWVudC5pc1ByZXNlbnQgPSBpc1ByZXNlbnQ7XG4gICAgICAgICAgICB2YXIgYW5pbWF0aW9uID0gKF9hID0gdmlzdWFsRWxlbWVudC5hbmltYXRpb25TdGF0ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNldEFjdGl2ZShBbmltYXRpb25UeXBlLkV4aXQsICFpc1ByZXNlbnQsIHsgY3VzdG9tOiAoX2IgPSBwcmVzZW5jZUNvbnRleHQgPT09IG51bGwgfHwgcHJlc2VuY2VDb250ZXh0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcmVzZW5jZUNvbnRleHQuY3VzdG9tKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBjdXN0b20gfSk7XG4gICAgICAgICAgICAhaXNQcmVzZW50ICYmIChhbmltYXRpb24gPT09IG51bGwgfHwgYW5pbWF0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhbmltYXRpb24udGhlbihzYWZlVG9SZW1vdmUpKTtcbiAgICAgICAgfSwgW2lzUHJlc2VudF0pO1xuICAgIH0pLFxufTtcblxuZXhwb3J0IHsgYW5pbWF0aW9ucyB9O1xuIiwiY29uc3QgaXNQb2ludCA9IChwb2ludCkgPT4gcG9pbnQuaGFzT3duUHJvcGVydHkoJ3gnKSAmJiBwb2ludC5oYXNPd25Qcm9wZXJ0eSgneScpO1xuXG5leHBvcnQgeyBpc1BvaW50IH07XG4iLCJpbXBvcnQgeyBpc1BvaW50IH0gZnJvbSAnLi9pcy1wb2ludC5tanMnO1xuXG5jb25zdCBpc1BvaW50M0QgPSAocG9pbnQpID0+IGlzUG9pbnQocG9pbnQpICYmIHBvaW50Lmhhc093blByb3BlcnR5KCd6Jyk7XG5cbmV4cG9ydCB7IGlzUG9pbnQzRCB9O1xuIiwiaW1wb3J0IHsgaXNQb2ludCB9IGZyb20gJy4vaXMtcG9pbnQubWpzJztcbmltcG9ydCB7IGlzUG9pbnQzRCB9IGZyb20gJy4vaXMtcG9pbnQtM2QubWpzJztcbmltcG9ydCB7IGlzTnVtIH0gZnJvbSAnLi9pbmMubWpzJztcblxuY29uc3QgZGlzdGFuY2UxRCA9IChhLCBiKSA9PiBNYXRoLmFicyhhIC0gYik7XG5mdW5jdGlvbiBkaXN0YW5jZShhLCBiKSB7XG4gICAgaWYgKGlzTnVtKGEpICYmIGlzTnVtKGIpKSB7XG4gICAgICAgIHJldHVybiBkaXN0YW5jZTFEKGEsIGIpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc1BvaW50KGEpICYmIGlzUG9pbnQoYikpIHtcbiAgICAgICAgY29uc3QgeERlbHRhID0gZGlzdGFuY2UxRChhLngsIGIueCk7XG4gICAgICAgIGNvbnN0IHlEZWx0YSA9IGRpc3RhbmNlMUQoYS55LCBiLnkpO1xuICAgICAgICBjb25zdCB6RGVsdGEgPSBpc1BvaW50M0QoYSkgJiYgaXNQb2ludDNEKGIpID8gZGlzdGFuY2UxRChhLnosIGIueikgOiAwO1xuICAgICAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KHhEZWx0YSwgMikgKyBNYXRoLnBvdyh5RGVsdGEsIDIpICsgTWF0aC5wb3coekRlbHRhLCAyKSk7XG4gICAgfVxufVxuXG5leHBvcnQgeyBkaXN0YW5jZSB9O1xuIiwiaW1wb3J0IHsgX19hc3NpZ24gfSBmcm9tICd0c2xpYic7XG5pbXBvcnQgeyBpc01vdXNlRXZlbnQsIGlzVG91Y2hFdmVudCB9IGZyb20gJy4vdXRpbHMvZXZlbnQtdHlwZS5tanMnO1xuaW1wb3J0IHsgZXh0cmFjdEV2ZW50SW5mbyB9IGZyb20gJy4uL2V2ZW50cy9ldmVudC1pbmZvLm1qcyc7XG5pbXBvcnQgc3luYywgeyBnZXRGcmFtZURhdGEsIGNhbmNlbFN5bmMgfSBmcm9tICdmcmFtZXN5bmMnO1xuaW1wb3J0IHsgc2Vjb25kc1RvTWlsbGlzZWNvbmRzIH0gZnJvbSAnLi4vdXRpbHMvdGltZS1jb252ZXJzaW9uLm1qcyc7XG5pbXBvcnQgeyBhZGRQb2ludGVyRXZlbnQgfSBmcm9tICcuLi9ldmVudHMvdXNlLXBvaW50ZXItZXZlbnQubWpzJztcbmltcG9ydCB7IGRpc3RhbmNlLCBwaXBlIH0gZnJvbSAncG9wbW90aW9uJztcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIFBhblNlc3Npb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUGFuU2Vzc2lvbihldmVudCwgaGFuZGxlcnMsIF9hKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCB0cmFuc2Zvcm1QYWdlUG9pbnQgPSBfYi50cmFuc2Zvcm1QYWdlUG9pbnQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhcnRFdmVudCA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGFzdE1vdmVFdmVudCA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGFzdE1vdmVFdmVudEluZm8gPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmhhbmRsZXJzID0ge307XG4gICAgICAgIHRoaXMudXBkYXRlUG9pbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIShfdGhpcy5sYXN0TW92ZUV2ZW50ICYmIF90aGlzLmxhc3RNb3ZlRXZlbnRJbmZvKSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIgaW5mbyA9IGdldFBhbkluZm8oX3RoaXMubGFzdE1vdmVFdmVudEluZm8sIF90aGlzLmhpc3RvcnkpO1xuICAgICAgICAgICAgdmFyIGlzUGFuU3RhcnRlZCA9IF90aGlzLnN0YXJ0RXZlbnQgIT09IG51bGw7XG4gICAgICAgICAgICAvLyBPbmx5IHN0YXJ0IHBhbm5pbmcgaWYgdGhlIG9mZnNldCBpcyBsYXJnZXIgdGhhbiAzIHBpeGVscy4gSWYgd2UgbWFrZSBpdFxuICAgICAgICAgICAgLy8gYW55IGxhcmdlciB0aGFuIHRoaXMgd2UnbGwgd2FudCB0byByZXNldCB0aGUgcG9pbnRlciBoaXN0b3J5XG4gICAgICAgICAgICAvLyBvbiB0aGUgZmlyc3QgdXBkYXRlIHRvIGF2b2lkIHZpc3VhbCBzbmFwcGluZyB0byB0aGUgY3Vyc29lLlxuICAgICAgICAgICAgdmFyIGlzRGlzdGFuY2VQYXN0VGhyZXNob2xkID0gZGlzdGFuY2UoaW5mby5vZmZzZXQsIHsgeDogMCwgeTogMCB9KSA+PSAzO1xuICAgICAgICAgICAgaWYgKCFpc1BhblN0YXJ0ZWQgJiYgIWlzRGlzdGFuY2VQYXN0VGhyZXNob2xkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHZhciBwb2ludCA9IGluZm8ucG9pbnQ7XG4gICAgICAgICAgICB2YXIgdGltZXN0YW1wID0gZ2V0RnJhbWVEYXRhKCkudGltZXN0YW1wO1xuICAgICAgICAgICAgX3RoaXMuaGlzdG9yeS5wdXNoKF9fYXNzaWduKF9fYXNzaWduKHt9LCBwb2ludCksIHsgdGltZXN0YW1wOiB0aW1lc3RhbXAgfSkpO1xuICAgICAgICAgICAgdmFyIF9hID0gX3RoaXMuaGFuZGxlcnMsIG9uU3RhcnQgPSBfYS5vblN0YXJ0LCBvbk1vdmUgPSBfYS5vbk1vdmU7XG4gICAgICAgICAgICBpZiAoIWlzUGFuU3RhcnRlZCkge1xuICAgICAgICAgICAgICAgIG9uU3RhcnQgJiYgb25TdGFydChfdGhpcy5sYXN0TW92ZUV2ZW50LCBpbmZvKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5zdGFydEV2ZW50ID0gX3RoaXMubGFzdE1vdmVFdmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9uTW92ZSAmJiBvbk1vdmUoX3RoaXMubGFzdE1vdmVFdmVudCwgaW5mbyk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlUG9pbnRlck1vdmUgPSBmdW5jdGlvbiAoZXZlbnQsIGluZm8pIHtcbiAgICAgICAgICAgIF90aGlzLmxhc3RNb3ZlRXZlbnQgPSBldmVudDtcbiAgICAgICAgICAgIF90aGlzLmxhc3RNb3ZlRXZlbnRJbmZvID0gdHJhbnNmb3JtUG9pbnQoaW5mbywgX3RoaXMudHJhbnNmb3JtUGFnZVBvaW50KTtcbiAgICAgICAgICAgIC8vIEJlY2F1c2UgU2FmYXJpIGRvZXNuJ3QgdHJpZ2dlciBtb3VzZXVwIGV2ZW50cyB3aGVuIGl0J3MgYWJvdmUgYSBgPHNlbGVjdD5gXG4gICAgICAgICAgICBpZiAoaXNNb3VzZUV2ZW50KGV2ZW50KSAmJiBldmVudC5idXR0b25zID09PSAwKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuaGFuZGxlUG9pbnRlclVwKGV2ZW50LCBpbmZvKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUaHJvdHRsZSBtb3VzZSBtb3ZlIGV2ZW50IHRvIG9uY2UgcGVyIGZyYW1lXG4gICAgICAgICAgICBzeW5jLnVwZGF0ZShfdGhpcy51cGRhdGVQb2ludCwgdHJ1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlUG9pbnRlclVwID0gZnVuY3Rpb24gKGV2ZW50LCBpbmZvKSB7XG4gICAgICAgICAgICBfdGhpcy5lbmQoKTtcbiAgICAgICAgICAgIHZhciBfYSA9IF90aGlzLmhhbmRsZXJzLCBvbkVuZCA9IF9hLm9uRW5kLCBvblNlc3Npb25FbmQgPSBfYS5vblNlc3Npb25FbmQ7XG4gICAgICAgICAgICB2YXIgcGFuSW5mbyA9IGdldFBhbkluZm8odHJhbnNmb3JtUG9pbnQoaW5mbywgX3RoaXMudHJhbnNmb3JtUGFnZVBvaW50KSwgX3RoaXMuaGlzdG9yeSk7XG4gICAgICAgICAgICBpZiAoX3RoaXMuc3RhcnRFdmVudCAmJiBvbkVuZCkge1xuICAgICAgICAgICAgICAgIG9uRW5kKGV2ZW50LCBwYW5JbmZvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9uU2Vzc2lvbkVuZCAmJiBvblNlc3Npb25FbmQoZXZlbnQsIHBhbkluZm8pO1xuICAgICAgICB9O1xuICAgICAgICAvLyBJZiB3ZSBoYXZlIG1vcmUgdGhhbiBvbmUgdG91Y2gsIGRvbid0IHN0YXJ0IGRldGVjdGluZyB0aGlzIGdlc3R1cmVcbiAgICAgICAgaWYgKGlzVG91Y2hFdmVudChldmVudCkgJiYgZXZlbnQudG91Y2hlcy5sZW5ndGggPiAxKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmhhbmRsZXJzID0gaGFuZGxlcnM7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtUGFnZVBvaW50ID0gdHJhbnNmb3JtUGFnZVBvaW50O1xuICAgICAgICB2YXIgaW5mbyA9IGV4dHJhY3RFdmVudEluZm8oZXZlbnQpO1xuICAgICAgICB2YXIgaW5pdGlhbEluZm8gPSB0cmFuc2Zvcm1Qb2ludChpbmZvLCB0aGlzLnRyYW5zZm9ybVBhZ2VQb2ludCk7XG4gICAgICAgIHZhciBwb2ludCA9IGluaXRpYWxJbmZvLnBvaW50O1xuICAgICAgICB2YXIgdGltZXN0YW1wID0gZ2V0RnJhbWVEYXRhKCkudGltZXN0YW1wO1xuICAgICAgICB0aGlzLmhpc3RvcnkgPSBbX19hc3NpZ24oX19hc3NpZ24oe30sIHBvaW50KSwgeyB0aW1lc3RhbXA6IHRpbWVzdGFtcCB9KV07XG4gICAgICAgIHZhciBvblNlc3Npb25TdGFydCA9IGhhbmRsZXJzLm9uU2Vzc2lvblN0YXJ0O1xuICAgICAgICBvblNlc3Npb25TdGFydCAmJlxuICAgICAgICAgICAgb25TZXNzaW9uU3RhcnQoZXZlbnQsIGdldFBhbkluZm8oaW5pdGlhbEluZm8sIHRoaXMuaGlzdG9yeSkpO1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVycyA9IHBpcGUoYWRkUG9pbnRlckV2ZW50KHdpbmRvdywgXCJwb2ludGVybW92ZVwiLCB0aGlzLmhhbmRsZVBvaW50ZXJNb3ZlKSwgYWRkUG9pbnRlckV2ZW50KHdpbmRvdywgXCJwb2ludGVydXBcIiwgdGhpcy5oYW5kbGVQb2ludGVyVXApLCBhZGRQb2ludGVyRXZlbnQod2luZG93LCBcInBvaW50ZXJjYW5jZWxcIiwgdGhpcy5oYW5kbGVQb2ludGVyVXApKTtcbiAgICB9XG4gICAgUGFuU2Vzc2lvbi5wcm90b3R5cGUudXBkYXRlSGFuZGxlcnMgPSBmdW5jdGlvbiAoaGFuZGxlcnMpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVycyA9IGhhbmRsZXJzO1xuICAgIH07XG4gICAgUGFuU2Vzc2lvbi5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVycyAmJiB0aGlzLnJlbW92ZUxpc3RlbmVycygpO1xuICAgICAgICBjYW5jZWxTeW5jLnVwZGF0ZSh0aGlzLnVwZGF0ZVBvaW50KTtcbiAgICB9O1xuICAgIHJldHVybiBQYW5TZXNzaW9uO1xufSgpKTtcbmZ1bmN0aW9uIHRyYW5zZm9ybVBvaW50KGluZm8sIHRyYW5zZm9ybVBhZ2VQb2ludCkge1xuICAgIHJldHVybiB0cmFuc2Zvcm1QYWdlUG9pbnQgPyB7IHBvaW50OiB0cmFuc2Zvcm1QYWdlUG9pbnQoaW5mby5wb2ludCkgfSA6IGluZm87XG59XG5mdW5jdGlvbiBzdWJ0cmFjdFBvaW50KGEsIGIpIHtcbiAgICByZXR1cm4geyB4OiBhLnggLSBiLngsIHk6IGEueSAtIGIueSB9O1xufVxuZnVuY3Rpb24gZ2V0UGFuSW5mbyhfYSwgaGlzdG9yeSkge1xuICAgIHZhciBwb2ludCA9IF9hLnBvaW50O1xuICAgIHJldHVybiB7XG4gICAgICAgIHBvaW50OiBwb2ludCxcbiAgICAgICAgZGVsdGE6IHN1YnRyYWN0UG9pbnQocG9pbnQsIGxhc3REZXZpY2VQb2ludChoaXN0b3J5KSksXG4gICAgICAgIG9mZnNldDogc3VidHJhY3RQb2ludChwb2ludCwgc3RhcnREZXZpY2VQb2ludChoaXN0b3J5KSksXG4gICAgICAgIHZlbG9jaXR5OiBnZXRWZWxvY2l0eShoaXN0b3J5LCAwLjEpLFxuICAgIH07XG59XG5mdW5jdGlvbiBzdGFydERldmljZVBvaW50KGhpc3RvcnkpIHtcbiAgICByZXR1cm4gaGlzdG9yeVswXTtcbn1cbmZ1bmN0aW9uIGxhc3REZXZpY2VQb2ludChoaXN0b3J5KSB7XG4gICAgcmV0dXJuIGhpc3RvcnlbaGlzdG9yeS5sZW5ndGggLSAxXTtcbn1cbmZ1bmN0aW9uIGdldFZlbG9jaXR5KGhpc3RvcnksIHRpbWVEZWx0YSkge1xuICAgIGlmIChoaXN0b3J5Lmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIHsgeDogMCwgeTogMCB9O1xuICAgIH1cbiAgICB2YXIgaSA9IGhpc3RvcnkubGVuZ3RoIC0gMTtcbiAgICB2YXIgdGltZXN0YW1wZWRQb2ludCA9IG51bGw7XG4gICAgdmFyIGxhc3RQb2ludCA9IGxhc3REZXZpY2VQb2ludChoaXN0b3J5KTtcbiAgICB3aGlsZSAoaSA+PSAwKSB7XG4gICAgICAgIHRpbWVzdGFtcGVkUG9pbnQgPSBoaXN0b3J5W2ldO1xuICAgICAgICBpZiAobGFzdFBvaW50LnRpbWVzdGFtcCAtIHRpbWVzdGFtcGVkUG9pbnQudGltZXN0YW1wID5cbiAgICAgICAgICAgIHNlY29uZHNUb01pbGxpc2Vjb25kcyh0aW1lRGVsdGEpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpLS07XG4gICAgfVxuICAgIGlmICghdGltZXN0YW1wZWRQb2ludCkge1xuICAgICAgICByZXR1cm4geyB4OiAwLCB5OiAwIH07XG4gICAgfVxuICAgIHZhciB0aW1lID0gKGxhc3RQb2ludC50aW1lc3RhbXAgLSB0aW1lc3RhbXBlZFBvaW50LnRpbWVzdGFtcCkgLyAxMDAwO1xuICAgIGlmICh0aW1lID09PSAwKSB7XG4gICAgICAgIHJldHVybiB7IHg6IDAsIHk6IDAgfTtcbiAgICB9XG4gICAgdmFyIGN1cnJlbnRWZWxvY2l0eSA9IHtcbiAgICAgICAgeDogKGxhc3RQb2ludC54IC0gdGltZXN0YW1wZWRQb2ludC54KSAvIHRpbWUsXG4gICAgICAgIHk6IChsYXN0UG9pbnQueSAtIHRpbWVzdGFtcGVkUG9pbnQueSkgLyB0aW1lLFxuICAgIH07XG4gICAgaWYgKGN1cnJlbnRWZWxvY2l0eS54ID09PSBJbmZpbml0eSkge1xuICAgICAgICBjdXJyZW50VmVsb2NpdHkueCA9IDA7XG4gICAgfVxuICAgIGlmIChjdXJyZW50VmVsb2NpdHkueSA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgY3VycmVudFZlbG9jaXR5LnkgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gY3VycmVudFZlbG9jaXR5O1xufVxuXG5leHBvcnQgeyBQYW5TZXNzaW9uIH07XG4iLCJpbXBvcnQgeyBtaXgsIGRpc3RhbmNlIH0gZnJvbSAncG9wbW90aW9uJztcblxuZnVuY3Rpb24gY2FsY0xlbmd0aChheGlzKSB7XG4gICAgcmV0dXJuIGF4aXMubWF4IC0gYXhpcy5taW47XG59XG5mdW5jdGlvbiBpc05lYXIodmFsdWUsIHRhcmdldCwgbWF4RGlzdGFuY2UpIHtcbiAgICBpZiAodGFyZ2V0ID09PSB2b2lkIDApIHsgdGFyZ2V0ID0gMDsgfVxuICAgIGlmIChtYXhEaXN0YW5jZSA9PT0gdm9pZCAwKSB7IG1heERpc3RhbmNlID0gMC4wMTsgfVxuICAgIHJldHVybiBkaXN0YW5jZSh2YWx1ZSwgdGFyZ2V0KSA8IG1heERpc3RhbmNlO1xufVxuZnVuY3Rpb24gY2FsY0F4aXNEZWx0YShkZWx0YSwgc291cmNlLCB0YXJnZXQsIG9yaWdpbikge1xuICAgIGlmIChvcmlnaW4gPT09IHZvaWQgMCkgeyBvcmlnaW4gPSAwLjU7IH1cbiAgICBkZWx0YS5vcmlnaW4gPSBvcmlnaW47XG4gICAgZGVsdGEub3JpZ2luUG9pbnQgPSBtaXgoc291cmNlLm1pbiwgc291cmNlLm1heCwgZGVsdGEub3JpZ2luKTtcbiAgICBkZWx0YS5zY2FsZSA9IGNhbGNMZW5ndGgodGFyZ2V0KSAvIGNhbGNMZW5ndGgoc291cmNlKTtcbiAgICBpZiAoaXNOZWFyKGRlbHRhLnNjYWxlLCAxLCAwLjAwMDEpIHx8IGlzTmFOKGRlbHRhLnNjYWxlKSlcbiAgICAgICAgZGVsdGEuc2NhbGUgPSAxO1xuICAgIGRlbHRhLnRyYW5zbGF0ZSA9XG4gICAgICAgIG1peCh0YXJnZXQubWluLCB0YXJnZXQubWF4LCBkZWx0YS5vcmlnaW4pIC0gZGVsdGEub3JpZ2luUG9pbnQ7XG4gICAgaWYgKGlzTmVhcihkZWx0YS50cmFuc2xhdGUpIHx8IGlzTmFOKGRlbHRhLnRyYW5zbGF0ZSkpXG4gICAgICAgIGRlbHRhLnRyYW5zbGF0ZSA9IDA7XG59XG5mdW5jdGlvbiBjYWxjQm94RGVsdGEoZGVsdGEsIHNvdXJjZSwgdGFyZ2V0LCBvcmlnaW4pIHtcbiAgICBjYWxjQXhpc0RlbHRhKGRlbHRhLngsIHNvdXJjZS54LCB0YXJnZXQueCwgb3JpZ2luID09PSBudWxsIHx8IG9yaWdpbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3JpZ2luLm9yaWdpblgpO1xuICAgIGNhbGNBeGlzRGVsdGEoZGVsdGEueSwgc291cmNlLnksIHRhcmdldC55LCBvcmlnaW4gPT09IG51bGwgfHwgb3JpZ2luID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcmlnaW4ub3JpZ2luWSk7XG59XG5mdW5jdGlvbiBjYWxjUmVsYXRpdmVBeGlzKHRhcmdldCwgcmVsYXRpdmUsIHBhcmVudCkge1xuICAgIHRhcmdldC5taW4gPSBwYXJlbnQubWluICsgcmVsYXRpdmUubWluO1xuICAgIHRhcmdldC5tYXggPSB0YXJnZXQubWluICsgY2FsY0xlbmd0aChyZWxhdGl2ZSk7XG59XG5mdW5jdGlvbiBjYWxjUmVsYXRpdmVCb3godGFyZ2V0LCByZWxhdGl2ZSwgcGFyZW50KSB7XG4gICAgY2FsY1JlbGF0aXZlQXhpcyh0YXJnZXQueCwgcmVsYXRpdmUueCwgcGFyZW50LngpO1xuICAgIGNhbGNSZWxhdGl2ZUF4aXModGFyZ2V0LnksIHJlbGF0aXZlLnksIHBhcmVudC55KTtcbn1cbmZ1bmN0aW9uIGNhbGNSZWxhdGl2ZUF4aXNQb3NpdGlvbih0YXJnZXQsIGxheW91dCwgcGFyZW50KSB7XG4gICAgdGFyZ2V0Lm1pbiA9IGxheW91dC5taW4gLSBwYXJlbnQubWluO1xuICAgIHRhcmdldC5tYXggPSB0YXJnZXQubWluICsgY2FsY0xlbmd0aChsYXlvdXQpO1xufVxuZnVuY3Rpb24gY2FsY1JlbGF0aXZlUG9zaXRpb24odGFyZ2V0LCBsYXlvdXQsIHBhcmVudCkge1xuICAgIGNhbGNSZWxhdGl2ZUF4aXNQb3NpdGlvbih0YXJnZXQueCwgbGF5b3V0LngsIHBhcmVudC54KTtcbiAgICBjYWxjUmVsYXRpdmVBeGlzUG9zaXRpb24odGFyZ2V0LnksIGxheW91dC55LCBwYXJlbnQueSk7XG59XG5cbmV4cG9ydCB7IGNhbGNBeGlzRGVsdGEsIGNhbGNCb3hEZWx0YSwgY2FsY0xlbmd0aCwgY2FsY1JlbGF0aXZlQXhpcywgY2FsY1JlbGF0aXZlQXhpc1Bvc2l0aW9uLCBjYWxjUmVsYXRpdmVCb3gsIGNhbGNSZWxhdGl2ZVBvc2l0aW9uLCBpc05lYXIgfTtcbiIsImltcG9ydCB7IF9fcmVhZCB9IGZyb20gJ3RzbGliJztcbmltcG9ydCB7IGNsYW1wLCBtaXgsIHByb2dyZXNzIH0gZnJvbSAncG9wbW90aW9uJztcbmltcG9ydCB7IGNhbGNMZW5ndGggfSBmcm9tICcuLi8uLi8uLi9wcm9qZWN0aW9uL2dlb21ldHJ5L2RlbHRhLWNhbGMubWpzJztcblxuLyoqXG4gKiBBcHBseSBjb25zdHJhaW50cyB0byBhIHBvaW50LiBUaGVzZSBjb25zdHJhaW50cyBhcmUgYm90aCBwaHlzaWNhbCBhbG9uZyBhblxuICogYXhpcywgYW5kIGFuIGVsYXN0aWMgZmFjdG9yIHRoYXQgZGV0ZXJtaW5lcyBob3cgbXVjaCB0byBjb25zdHJhaW4gdGhlIHBvaW50XG4gKiBieSBpZiBpdCBkb2VzIGxpZSBvdXRzaWRlIHRoZSBkZWZpbmVkIHBhcmFtZXRlcnMuXG4gKi9cbmZ1bmN0aW9uIGFwcGx5Q29uc3RyYWludHMocG9pbnQsIF9hLCBlbGFzdGljKSB7XG4gICAgdmFyIG1pbiA9IF9hLm1pbiwgbWF4ID0gX2EubWF4O1xuICAgIGlmIChtaW4gIT09IHVuZGVmaW5lZCAmJiBwb2ludCA8IG1pbikge1xuICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgbWluIHBvaW50IGRlZmluZWQsIGFuZCB0aGlzIGlzIG91dHNpZGUgb2YgdGhhdCwgY29uc3RyYWluXG4gICAgICAgIHBvaW50ID0gZWxhc3RpYyA/IG1peChtaW4sIHBvaW50LCBlbGFzdGljLm1pbikgOiBNYXRoLm1heChwb2ludCwgbWluKTtcbiAgICB9XG4gICAgZWxzZSBpZiAobWF4ICE9PSB1bmRlZmluZWQgJiYgcG9pbnQgPiBtYXgpIHtcbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIG1heCBwb2ludCBkZWZpbmVkLCBhbmQgdGhpcyBpcyBvdXRzaWRlIG9mIHRoYXQsIGNvbnN0cmFpblxuICAgICAgICBwb2ludCA9IGVsYXN0aWMgPyBtaXgobWF4LCBwb2ludCwgZWxhc3RpYy5tYXgpIDogTWF0aC5taW4ocG9pbnQsIG1heCk7XG4gICAgfVxuICAgIHJldHVybiBwb2ludDtcbn1cbi8qKlxuICogQ2FsY3VsYXRlIGNvbnN0cmFpbnRzIGluIHRlcm1zIG9mIHRoZSB2aWV3cG9ydCB3aGVuIGRlZmluZWQgcmVsYXRpdmVseSB0byB0aGVcbiAqIG1lYXN1cmVkIGF4aXMuIFRoaXMgaXMgbWVhc3VyZWQgZnJvbSB0aGUgbmVhcmVzdCBlZGdlLCBzbyBhIG1heCBjb25zdHJhaW50IG9mIDIwMFxuICogb24gYW4gYXhpcyB3aXRoIGEgbWF4IHZhbHVlIG9mIDMwMCB3b3VsZCByZXR1cm4gYSBjb25zdHJhaW50IG9mIDUwMCAtIGF4aXMgbGVuZ3RoXG4gKi9cbmZ1bmN0aW9uIGNhbGNSZWxhdGl2ZUF4aXNDb25zdHJhaW50cyhheGlzLCBtaW4sIG1heCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIG1pbjogbWluICE9PSB1bmRlZmluZWQgPyBheGlzLm1pbiArIG1pbiA6IHVuZGVmaW5lZCxcbiAgICAgICAgbWF4OiBtYXggIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyBheGlzLm1heCArIG1heCAtIChheGlzLm1heCAtIGF4aXMubWluKVxuICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgfTtcbn1cbi8qKlxuICogQ2FsY3VsYXRlIGNvbnN0cmFpbnRzIGluIHRlcm1zIG9mIHRoZSB2aWV3cG9ydCB3aGVuXG4gKiBkZWZpbmVkIHJlbGF0aXZlbHkgdG8gdGhlIG1lYXN1cmVkIGJvdW5kaW5nIGJveC5cbiAqL1xuZnVuY3Rpb24gY2FsY1JlbGF0aXZlQ29uc3RyYWludHMobGF5b3V0Qm94LCBfYSkge1xuICAgIHZhciB0b3AgPSBfYS50b3AsIGxlZnQgPSBfYS5sZWZ0LCBib3R0b20gPSBfYS5ib3R0b20sIHJpZ2h0ID0gX2EucmlnaHQ7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogY2FsY1JlbGF0aXZlQXhpc0NvbnN0cmFpbnRzKGxheW91dEJveC54LCBsZWZ0LCByaWdodCksXG4gICAgICAgIHk6IGNhbGNSZWxhdGl2ZUF4aXNDb25zdHJhaW50cyhsYXlvdXRCb3gueSwgdG9wLCBib3R0b20pLFxuICAgIH07XG59XG4vKipcbiAqIENhbGN1bGF0ZSB2aWV3cG9ydCBjb25zdHJhaW50cyB3aGVuIGRlZmluZWQgYXMgYW5vdGhlciB2aWV3cG9ydC1yZWxhdGl2ZSBheGlzXG4gKi9cbmZ1bmN0aW9uIGNhbGNWaWV3cG9ydEF4aXNDb25zdHJhaW50cyhsYXlvdXRBeGlzLCBjb25zdHJhaW50c0F4aXMpIHtcbiAgICB2YXIgX2E7XG4gICAgdmFyIG1pbiA9IGNvbnN0cmFpbnRzQXhpcy5taW4gLSBsYXlvdXRBeGlzLm1pbjtcbiAgICB2YXIgbWF4ID0gY29uc3RyYWludHNBeGlzLm1heCAtIGxheW91dEF4aXMubWF4O1xuICAgIC8vIElmIHRoZSBjb25zdHJhaW50cyBheGlzIGlzIGFjdHVhbGx5IHNtYWxsZXIgdGhhbiB0aGUgbGF5b3V0IGF4aXMgdGhlbiB3ZSBjYW5cbiAgICAvLyBmbGlwIHRoZSBjb25zdHJhaW50c1xuICAgIGlmIChjb25zdHJhaW50c0F4aXMubWF4IC0gY29uc3RyYWludHNBeGlzLm1pbiA8XG4gICAgICAgIGxheW91dEF4aXMubWF4IC0gbGF5b3V0QXhpcy5taW4pIHtcbiAgICAgICAgX2EgPSBfX3JlYWQoW21heCwgbWluXSwgMiksIG1pbiA9IF9hWzBdLCBtYXggPSBfYVsxXTtcbiAgICB9XG4gICAgcmV0dXJuIHsgbWluOiBtaW4sIG1heDogbWF4IH07XG59XG4vKipcbiAqIENhbGN1bGF0ZSB2aWV3cG9ydCBjb25zdHJhaW50cyB3aGVuIGRlZmluZWQgYXMgYW5vdGhlciB2aWV3cG9ydC1yZWxhdGl2ZSBib3hcbiAqL1xuZnVuY3Rpb24gY2FsY1ZpZXdwb3J0Q29uc3RyYWludHMobGF5b3V0Qm94LCBjb25zdHJhaW50c0JveCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHg6IGNhbGNWaWV3cG9ydEF4aXNDb25zdHJhaW50cyhsYXlvdXRCb3gueCwgY29uc3RyYWludHNCb3gueCksXG4gICAgICAgIHk6IGNhbGNWaWV3cG9ydEF4aXNDb25zdHJhaW50cyhsYXlvdXRCb3gueSwgY29uc3RyYWludHNCb3gueSksXG4gICAgfTtcbn1cbi8qKlxuICogQ2FsY3VsYXRlIGEgdHJhbnNmb3JtIG9yaWdpbiByZWxhdGl2ZSB0byB0aGUgc291cmNlIGF4aXMsIGJldHdlZW4gMC0xLCB0aGF0IHJlc3VsdHNcbiAqIGluIGFuIGFzdGhldGljYWxseSBwbGVhc2luZyBzY2FsZS90cmFuc2Zvcm0gbmVlZGVkIHRvIHByb2plY3QgZnJvbSBzb3VyY2UgdG8gdGFyZ2V0LlxuICovXG5mdW5jdGlvbiBjYWxjT3JpZ2luKHNvdXJjZSwgdGFyZ2V0KSB7XG4gICAgdmFyIG9yaWdpbiA9IDAuNTtcbiAgICB2YXIgc291cmNlTGVuZ3RoID0gY2FsY0xlbmd0aChzb3VyY2UpO1xuICAgIHZhciB0YXJnZXRMZW5ndGggPSBjYWxjTGVuZ3RoKHRhcmdldCk7XG4gICAgaWYgKHRhcmdldExlbmd0aCA+IHNvdXJjZUxlbmd0aCkge1xuICAgICAgICBvcmlnaW4gPSBwcm9ncmVzcyh0YXJnZXQubWluLCB0YXJnZXQubWF4IC0gc291cmNlTGVuZ3RoLCBzb3VyY2UubWluKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc291cmNlTGVuZ3RoID4gdGFyZ2V0TGVuZ3RoKSB7XG4gICAgICAgIG9yaWdpbiA9IHByb2dyZXNzKHNvdXJjZS5taW4sIHNvdXJjZS5tYXggLSB0YXJnZXRMZW5ndGgsIHRhcmdldC5taW4pO1xuICAgIH1cbiAgICByZXR1cm4gY2xhbXAoMCwgMSwgb3JpZ2luKTtcbn1cbi8qKlxuICogUmViYXNlIHRoZSBjYWxjdWxhdGVkIHZpZXdwb3J0IGNvbnN0cmFpbnRzIHJlbGF0aXZlIHRvIHRoZSBsYXlvdXQubWluIHBvaW50LlxuICovXG5mdW5jdGlvbiByZWJhc2VBeGlzQ29uc3RyYWludHMobGF5b3V0LCBjb25zdHJhaW50cykge1xuICAgIHZhciByZWxhdGl2ZUNvbnN0cmFpbnRzID0ge307XG4gICAgaWYgKGNvbnN0cmFpbnRzLm1pbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlbGF0aXZlQ29uc3RyYWludHMubWluID0gY29uc3RyYWludHMubWluIC0gbGF5b3V0Lm1pbjtcbiAgICB9XG4gICAgaWYgKGNvbnN0cmFpbnRzLm1heCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJlbGF0aXZlQ29uc3RyYWludHMubWF4ID0gY29uc3RyYWludHMubWF4IC0gbGF5b3V0Lm1pbjtcbiAgICB9XG4gICAgcmV0dXJuIHJlbGF0aXZlQ29uc3RyYWludHM7XG59XG52YXIgZGVmYXVsdEVsYXN0aWMgPSAwLjM1O1xuLyoqXG4gKiBBY2NlcHRzIGEgZHJhZ0VsYXN0aWMgcHJvcCBhbmQgcmV0dXJucyByZXNvbHZlZCBlbGFzdGljIHZhbHVlcyBmb3IgZWFjaCBheGlzLlxuICovXG5mdW5jdGlvbiByZXNvbHZlRHJhZ0VsYXN0aWMoZHJhZ0VsYXN0aWMpIHtcbiAgICBpZiAoZHJhZ0VsYXN0aWMgPT09IHZvaWQgMCkgeyBkcmFnRWxhc3RpYyA9IGRlZmF1bHRFbGFzdGljOyB9XG4gICAgaWYgKGRyYWdFbGFzdGljID09PSBmYWxzZSkge1xuICAgICAgICBkcmFnRWxhc3RpYyA9IDA7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRyYWdFbGFzdGljID09PSB0cnVlKSB7XG4gICAgICAgIGRyYWdFbGFzdGljID0gZGVmYXVsdEVsYXN0aWM7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHg6IHJlc29sdmVBeGlzRWxhc3RpYyhkcmFnRWxhc3RpYywgXCJsZWZ0XCIsIFwicmlnaHRcIiksXG4gICAgICAgIHk6IHJlc29sdmVBeGlzRWxhc3RpYyhkcmFnRWxhc3RpYywgXCJ0b3BcIiwgXCJib3R0b21cIiksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVBeGlzRWxhc3RpYyhkcmFnRWxhc3RpYywgbWluTGFiZWwsIG1heExhYmVsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbWluOiByZXNvbHZlUG9pbnRFbGFzdGljKGRyYWdFbGFzdGljLCBtaW5MYWJlbCksXG4gICAgICAgIG1heDogcmVzb2x2ZVBvaW50RWxhc3RpYyhkcmFnRWxhc3RpYywgbWF4TGFiZWwpLFxuICAgIH07XG59XG5mdW5jdGlvbiByZXNvbHZlUG9pbnRFbGFzdGljKGRyYWdFbGFzdGljLCBsYWJlbCkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gdHlwZW9mIGRyYWdFbGFzdGljID09PSBcIm51bWJlclwiXG4gICAgICAgID8gZHJhZ0VsYXN0aWNcbiAgICAgICAgOiAoX2EgPSBkcmFnRWxhc3RpY1tsYWJlbF0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XG59XG5cbmV4cG9ydCB7IGFwcGx5Q29uc3RyYWludHMsIGNhbGNPcmlnaW4sIGNhbGNSZWxhdGl2ZUF4aXNDb25zdHJhaW50cywgY2FsY1JlbGF0aXZlQ29uc3RyYWludHMsIGNhbGNWaWV3cG9ydEF4aXNDb25zdHJhaW50cywgY2FsY1ZpZXdwb3J0Q29uc3RyYWludHMsIGRlZmF1bHRFbGFzdGljLCByZWJhc2VBeGlzQ29uc3RyYWludHMsIHJlc29sdmVBeGlzRWxhc3RpYywgcmVzb2x2ZURyYWdFbGFzdGljLCByZXNvbHZlUG9pbnRFbGFzdGljIH07XG4iLCJ2YXIgY3JlYXRlQXhpc0RlbHRhID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKHtcbiAgICB0cmFuc2xhdGU6IDAsXG4gICAgc2NhbGU6IDEsXG4gICAgb3JpZ2luOiAwLFxuICAgIG9yaWdpblBvaW50OiAwLFxufSk7IH07XG52YXIgY3JlYXRlRGVsdGEgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAoe1xuICAgIHg6IGNyZWF0ZUF4aXNEZWx0YSgpLFxuICAgIHk6IGNyZWF0ZUF4aXNEZWx0YSgpLFxufSk7IH07XG52YXIgY3JlYXRlQXhpcyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7IG1pbjogMCwgbWF4OiAwIH0pOyB9O1xudmFyIGNyZWF0ZUJveCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7XG4gICAgeDogY3JlYXRlQXhpcygpLFxuICAgIHk6IGNyZWF0ZUF4aXMoKSxcbn0pOyB9O1xuXG5leHBvcnQgeyBjcmVhdGVBeGlzLCBjcmVhdGVBeGlzRGVsdGEsIGNyZWF0ZUJveCwgY3JlYXRlRGVsdGEgfTtcbiIsImZ1bmN0aW9uIGVhY2hBeGlzKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIFtjYWxsYmFjayhcInhcIiksIGNhbGxiYWNrKFwieVwiKV07XG59XG5cbmV4cG9ydCB7IGVhY2hBeGlzIH07XG4iLCIvKipcbiAqIEJvdW5kaW5nIGJveGVzIHRlbmQgdG8gYmUgZGVmaW5lZCBhcyB0b3AsIGxlZnQsIHJpZ2h0LCBib3R0b20uIEZvciB2YXJpb3VzIG9wZXJhdGlvbnNcbiAqIGl0J3MgZWFzaWVyIHRvIGNvbnNpZGVyIGVhY2ggYXhpcyBpbmRpdmlkdWFsbHkuIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBhIGJvdW5kaW5nIGJveFxuICogYXMgYSBtYXAgb2Ygc2luZ2xlLWF4aXMgbWluL21heCB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRCb3VuZGluZ0JveFRvQm94KF9hKSB7XG4gICAgdmFyIHRvcCA9IF9hLnRvcCwgbGVmdCA9IF9hLmxlZnQsIHJpZ2h0ID0gX2EucmlnaHQsIGJvdHRvbSA9IF9hLmJvdHRvbTtcbiAgICByZXR1cm4ge1xuICAgICAgICB4OiB7IG1pbjogbGVmdCwgbWF4OiByaWdodCB9LFxuICAgICAgICB5OiB7IG1pbjogdG9wLCBtYXg6IGJvdHRvbSB9LFxuICAgIH07XG59XG5mdW5jdGlvbiBjb252ZXJ0Qm94VG9Cb3VuZGluZ0JveChfYSkge1xuICAgIHZhciB4ID0gX2EueCwgeSA9IF9hLnk7XG4gICAgcmV0dXJuIHsgdG9wOiB5Lm1pbiwgcmlnaHQ6IHgubWF4LCBib3R0b206IHkubWF4LCBsZWZ0OiB4Lm1pbiB9O1xufVxuLyoqXG4gKiBBcHBsaWVzIGEgVHJhbnNmb3JtUG9pbnQgZnVuY3Rpb24gdG8gYSBib3VuZGluZyBib3guIFRyYW5zZm9ybVBvaW50IGlzIHVzdWFsbHkgYSBmdW5jdGlvblxuICogcHJvdmlkZWQgYnkgRnJhbWVyIHRvIGFsbG93IG1lYXN1cmVkIHBvaW50cyB0byBiZSBjb3JyZWN0ZWQgZm9yIGRldmljZSBzY2FsaW5nLiBUaGlzIGlzIHVzZWRcbiAqIHdoZW4gbWVhc3VyaW5nIERPTSBlbGVtZW50cyBhbmQgRE9NIGV2ZW50IHBvaW50cy5cbiAqL1xuZnVuY3Rpb24gdHJhbnNmb3JtQm94UG9pbnRzKHBvaW50LCB0cmFuc2Zvcm1Qb2ludCkge1xuICAgIGlmICghdHJhbnNmb3JtUG9pbnQpXG4gICAgICAgIHJldHVybiBwb2ludDtcbiAgICB2YXIgdG9wTGVmdCA9IHRyYW5zZm9ybVBvaW50KHsgeDogcG9pbnQubGVmdCwgeTogcG9pbnQudG9wIH0pO1xuICAgIHZhciBib3R0b21SaWdodCA9IHRyYW5zZm9ybVBvaW50KHsgeDogcG9pbnQucmlnaHQsIHk6IHBvaW50LmJvdHRvbSB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgICB0b3A6IHRvcExlZnQueSxcbiAgICAgICAgbGVmdDogdG9wTGVmdC54LFxuICAgICAgICBib3R0b206IGJvdHRvbVJpZ2h0LnksXG4gICAgICAgIHJpZ2h0OiBib3R0b21SaWdodC54LFxuICAgIH07XG59XG5cbmV4cG9ydCB7IGNvbnZlcnRCb3VuZGluZ0JveFRvQm94LCBjb252ZXJ0Qm94VG9Cb3VuZGluZ0JveCwgdHJhbnNmb3JtQm94UG9pbnRzIH07XG4iLCJmdW5jdGlvbiBpc0lkZW50aXR5U2NhbGUoc2NhbGUpIHtcbiAgICByZXR1cm4gc2NhbGUgPT09IHVuZGVmaW5lZCB8fCBzY2FsZSA9PT0gMTtcbn1cbmZ1bmN0aW9uIGhhc1NjYWxlKF9hKSB7XG4gICAgdmFyIHNjYWxlID0gX2Euc2NhbGUsIHNjYWxlWCA9IF9hLnNjYWxlWCwgc2NhbGVZID0gX2Euc2NhbGVZO1xuICAgIHJldHVybiAoIWlzSWRlbnRpdHlTY2FsZShzY2FsZSkgfHxcbiAgICAgICAgIWlzSWRlbnRpdHlTY2FsZShzY2FsZVgpIHx8XG4gICAgICAgICFpc0lkZW50aXR5U2NhbGUoc2NhbGVZKSk7XG59XG5mdW5jdGlvbiBoYXNUcmFuc2Zvcm0odmFsdWVzKSB7XG4gICAgcmV0dXJuIChoYXNTY2FsZSh2YWx1ZXMpIHx8XG4gICAgICAgIGhhc1RyYW5zbGF0ZSh2YWx1ZXMueCkgfHxcbiAgICAgICAgaGFzVHJhbnNsYXRlKHZhbHVlcy55KSB8fFxuICAgICAgICB2YWx1ZXMueiB8fFxuICAgICAgICB2YWx1ZXMucm90YXRlIHx8XG4gICAgICAgIHZhbHVlcy5yb3RhdGVYIHx8XG4gICAgICAgIHZhbHVlcy5yb3RhdGVZKTtcbn1cbmZ1bmN0aW9uIGhhc1RyYW5zbGF0ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAmJiB2YWx1ZSAhPT0gXCIwJVwiO1xufVxuXG5leHBvcnQgeyBoYXNTY2FsZSwgaGFzVHJhbnNmb3JtIH07XG4iLCJpbXBvcnQgeyBfX3JlYWQgfSBmcm9tICd0c2xpYic7XG5pbXBvcnQgeyBtaXggfSBmcm9tICdwb3Btb3Rpb24nO1xuaW1wb3J0IHsgaGFzVHJhbnNmb3JtIH0gZnJvbSAnLi4vdXRpbHMvaGFzLXRyYW5zZm9ybS5tanMnO1xuXG4vKipcbiAqIFNjYWxlcyBhIHBvaW50IGJhc2VkIG9uIGEgZmFjdG9yIGFuZCBhbiBvcmlnaW5Qb2ludFxuICovXG5mdW5jdGlvbiBzY2FsZVBvaW50KHBvaW50LCBzY2FsZSwgb3JpZ2luUG9pbnQpIHtcbiAgICB2YXIgZGlzdGFuY2VGcm9tT3JpZ2luID0gcG9pbnQgLSBvcmlnaW5Qb2ludDtcbiAgICB2YXIgc2NhbGVkID0gc2NhbGUgKiBkaXN0YW5jZUZyb21PcmlnaW47XG4gICAgcmV0dXJuIG9yaWdpblBvaW50ICsgc2NhbGVkO1xufVxuLyoqXG4gKiBBcHBsaWVzIGEgdHJhbnNsYXRlL3NjYWxlIGRlbHRhIHRvIGEgcG9pbnRcbiAqL1xuZnVuY3Rpb24gYXBwbHlQb2ludERlbHRhKHBvaW50LCB0cmFuc2xhdGUsIHNjYWxlLCBvcmlnaW5Qb2ludCwgYm94U2NhbGUpIHtcbiAgICBpZiAoYm94U2NhbGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwb2ludCA9IHNjYWxlUG9pbnQocG9pbnQsIGJveFNjYWxlLCBvcmlnaW5Qb2ludCk7XG4gICAgfVxuICAgIHJldHVybiBzY2FsZVBvaW50KHBvaW50LCBzY2FsZSwgb3JpZ2luUG9pbnQpICsgdHJhbnNsYXRlO1xufVxuLyoqXG4gKiBBcHBsaWVzIGEgdHJhbnNsYXRlL3NjYWxlIGRlbHRhIHRvIGFuIGF4aXNcbiAqL1xuZnVuY3Rpb24gYXBwbHlBeGlzRGVsdGEoYXhpcywgdHJhbnNsYXRlLCBzY2FsZSwgb3JpZ2luUG9pbnQsIGJveFNjYWxlKSB7XG4gICAgaWYgKHRyYW5zbGF0ZSA9PT0gdm9pZCAwKSB7IHRyYW5zbGF0ZSA9IDA7IH1cbiAgICBpZiAoc2NhbGUgPT09IHZvaWQgMCkgeyBzY2FsZSA9IDE7IH1cbiAgICBheGlzLm1pbiA9IGFwcGx5UG9pbnREZWx0YShheGlzLm1pbiwgdHJhbnNsYXRlLCBzY2FsZSwgb3JpZ2luUG9pbnQsIGJveFNjYWxlKTtcbiAgICBheGlzLm1heCA9IGFwcGx5UG9pbnREZWx0YShheGlzLm1heCwgdHJhbnNsYXRlLCBzY2FsZSwgb3JpZ2luUG9pbnQsIGJveFNjYWxlKTtcbn1cbi8qKlxuICogQXBwbGllcyBhIHRyYW5zbGF0ZS9zY2FsZSBkZWx0YSB0byBhIGJveFxuICovXG5mdW5jdGlvbiBhcHBseUJveERlbHRhKGJveCwgX2EpIHtcbiAgICB2YXIgeCA9IF9hLngsIHkgPSBfYS55O1xuICAgIGFwcGx5QXhpc0RlbHRhKGJveC54LCB4LnRyYW5zbGF0ZSwgeC5zY2FsZSwgeC5vcmlnaW5Qb2ludCk7XG4gICAgYXBwbHlBeGlzRGVsdGEoYm94LnksIHkudHJhbnNsYXRlLCB5LnNjYWxlLCB5Lm9yaWdpblBvaW50KTtcbn1cbi8qKlxuICogQXBwbHkgYSB0cmVlIG9mIGRlbHRhcyB0byBhIGJveC4gV2UgZG8gdGhpcyB0byBjYWxjdWxhdGUgdGhlIGVmZmVjdCBvZiBhbGwgdGhlIHRyYW5zZm9ybXNcbiAqIGluIGEgdHJlZSB1cG9uIG91ciBib3ggYmVmb3JlIHRoZW4gY2FsY3VsYXRpbmcgaG93IHRvIHByb2plY3QgaXQgaW50byBvdXIgZGVzaXJlZCB2aWV3cG9ydC1yZWxhdGl2ZSBib3hcbiAqXG4gKiBUaGlzIGlzIHRoZSBmaW5hbCBuZXN0ZWQgbG9vcCB3aXRoaW4gdXBkYXRlTGF5b3V0RGVsdGEgZm9yIGZ1dHVyZSByZWZhY3RvcmluZ1xuICovXG5mdW5jdGlvbiBhcHBseVRyZWVEZWx0YXMoYm94LCB0cmVlU2NhbGUsIHRyZWVQYXRoLCBpc1NoYXJlZFRyYW5zaXRpb24pIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGlmIChpc1NoYXJlZFRyYW5zaXRpb24gPT09IHZvaWQgMCkgeyBpc1NoYXJlZFRyYW5zaXRpb24gPSBmYWxzZTsgfVxuICAgIHZhciB0cmVlTGVuZ3RoID0gdHJlZVBhdGgubGVuZ3RoO1xuICAgIGlmICghdHJlZUxlbmd0aClcbiAgICAgICAgcmV0dXJuO1xuICAgIC8vIFJlc2V0IHRoZSB0cmVlU2NhbGVcbiAgICB0cmVlU2NhbGUueCA9IHRyZWVTY2FsZS55ID0gMTtcbiAgICB2YXIgbm9kZTtcbiAgICB2YXIgZGVsdGE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmVlTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbm9kZSA9IHRyZWVQYXRoW2ldO1xuICAgICAgICBkZWx0YSA9IG5vZGUucHJvamVjdGlvbkRlbHRhO1xuICAgICAgICBpZiAoKChfYiA9IChfYSA9IG5vZGUuaW5zdGFuY2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zdHlsZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmRpc3BsYXkpID09PSBcImNvbnRlbnRzXCIpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKGlzU2hhcmVkVHJhbnNpdGlvbiAmJlxuICAgICAgICAgICAgbm9kZS5vcHRpb25zLmxheW91dFNjcm9sbCAmJlxuICAgICAgICAgICAgbm9kZS5zY3JvbGwgJiZcbiAgICAgICAgICAgIG5vZGUgIT09IG5vZGUucm9vdCkge1xuICAgICAgICAgICAgdHJhbnNmb3JtQm94KGJveCwgeyB4OiAtbm9kZS5zY3JvbGwueCwgeTogLW5vZGUuc2Nyb2xsLnkgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlbHRhKSB7XG4gICAgICAgICAgICAvLyBJbmNvcG9yYXRlIGVhY2ggYW5jZXN0b3IncyBzY2FsZSBpbnRvIGEgY3VsbXVsYXRpdmUgdHJlZVNjYWxlIGZvciB0aGlzIGNvbXBvbmVudFxuICAgICAgICAgICAgdHJlZVNjYWxlLnggKj0gZGVsdGEueC5zY2FsZTtcbiAgICAgICAgICAgIHRyZWVTY2FsZS55ICo9IGRlbHRhLnkuc2NhbGU7XG4gICAgICAgICAgICAvLyBBcHBseSBlYWNoIGFuY2VzdG9yJ3MgY2FsY3VsYXRlZCBkZWx0YSBpbnRvIHRoaXMgY29tcG9uZW50J3MgcmVjb3JkZWQgbGF5b3V0IGJveFxuICAgICAgICAgICAgYXBwbHlCb3hEZWx0YShib3gsIGRlbHRhKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNTaGFyZWRUcmFuc2l0aW9uICYmIGhhc1RyYW5zZm9ybShub2RlLmxhdGVzdFZhbHVlcykpIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybUJveChib3gsIG5vZGUubGF0ZXN0VmFsdWVzKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHRyYW5zbGF0ZUF4aXMoYXhpcywgZGlzdGFuY2UpIHtcbiAgICBheGlzLm1pbiA9IGF4aXMubWluICsgZGlzdGFuY2U7XG4gICAgYXhpcy5tYXggPSBheGlzLm1heCArIGRpc3RhbmNlO1xufVxuLyoqXG4gKiBBcHBseSBhIHRyYW5zZm9ybSB0byBhbiBheGlzIGZyb20gdGhlIGxhdGVzdCByZXNvbHZlZCBtb3Rpb24gdmFsdWVzLlxuICogVGhpcyBmdW5jdGlvbiBiYXNpY2FsbHkgYWN0cyBhcyBhIGJyaWRnZSBiZXR3ZWVuIGEgZmxhdCBtb3Rpb24gdmFsdWUgbWFwXG4gKiBhbmQgYXBwbHlBeGlzRGVsdGFcbiAqL1xuZnVuY3Rpb24gdHJhbnNmb3JtQXhpcyhheGlzLCB0cmFuc2Zvcm1zLCBfYSkge1xuICAgIHZhciBfYiA9IF9fcmVhZChfYSwgMyksIGtleSA9IF9iWzBdLCBzY2FsZUtleSA9IF9iWzFdLCBvcmlnaW5LZXkgPSBfYlsyXTtcbiAgICB2YXIgYXhpc09yaWdpbiA9IHRyYW5zZm9ybXNbb3JpZ2luS2V5XSAhPT0gdW5kZWZpbmVkID8gdHJhbnNmb3Jtc1tvcmlnaW5LZXldIDogMC41O1xuICAgIHZhciBvcmlnaW5Qb2ludCA9IG1peChheGlzLm1pbiwgYXhpcy5tYXgsIGF4aXNPcmlnaW4pO1xuICAgIC8vIEFwcGx5IHRoZSBheGlzIGRlbHRhIHRvIHRoZSBmaW5hbCBheGlzXG4gICAgYXBwbHlBeGlzRGVsdGEoYXhpcywgdHJhbnNmb3Jtc1trZXldLCB0cmFuc2Zvcm1zW3NjYWxlS2V5XSwgb3JpZ2luUG9pbnQsIHRyYW5zZm9ybXMuc2NhbGUpO1xufVxuLyoqXG4gKiBUaGUgbmFtZXMgb2YgdGhlIG1vdGlvbiB2YWx1ZXMgd2Ugd2FudCB0byBhcHBseSBhcyB0cmFuc2xhdGlvbiwgc2NhbGUgYW5kIG9yaWdpbi5cbiAqL1xudmFyIHhLZXlzID0gW1wieFwiLCBcInNjYWxlWFwiLCBcIm9yaWdpblhcIl07XG52YXIgeUtleXMgPSBbXCJ5XCIsIFwic2NhbGVZXCIsIFwib3JpZ2luWVwiXTtcbi8qKlxuICogQXBwbHkgYSB0cmFuc2Zvcm0gdG8gYSBib3ggZnJvbSB0aGUgbGF0ZXN0IHJlc29sdmVkIG1vdGlvbiB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIHRyYW5zZm9ybUJveChib3gsIHRyYW5zZm9ybSkge1xuICAgIHRyYW5zZm9ybUF4aXMoYm94LngsIHRyYW5zZm9ybSwgeEtleXMpO1xuICAgIHRyYW5zZm9ybUF4aXMoYm94LnksIHRyYW5zZm9ybSwgeUtleXMpO1xufVxuXG5leHBvcnQgeyBhcHBseUF4aXNEZWx0YSwgYXBwbHlCb3hEZWx0YSwgYXBwbHlQb2ludERlbHRhLCBhcHBseVRyZWVEZWx0YXMsIHNjYWxlUG9pbnQsIHRyYW5zZm9ybUF4aXMsIHRyYW5zZm9ybUJveCwgdHJhbnNsYXRlQXhpcyB9O1xuIiwiaW1wb3J0IHsgY29udmVydEJvdW5kaW5nQm94VG9Cb3gsIHRyYW5zZm9ybUJveFBvaW50cyB9IGZyb20gJy4uL2dlb21ldHJ5L2NvbnZlcnNpb24ubWpzJztcbmltcG9ydCB7IHRyYW5zbGF0ZUF4aXMgfSBmcm9tICcuLi9nZW9tZXRyeS9kZWx0YS1hcHBseS5tanMnO1xuXG5mdW5jdGlvbiBtZWFzdXJlVmlld3BvcnRCb3goaW5zdGFuY2UsIHRyYW5zZm9ybVBvaW50KSB7XG4gICAgcmV0dXJuIGNvbnZlcnRCb3VuZGluZ0JveFRvQm94KHRyYW5zZm9ybUJveFBvaW50cyhpbnN0YW5jZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwgdHJhbnNmb3JtUG9pbnQpKTtcbn1cbmZ1bmN0aW9uIG1lYXN1cmVQYWdlQm94KGVsZW1lbnQsIHJvb3RQcm9qZWN0aW9uTm9kZSwgdHJhbnNmb3JtUGFnZVBvaW50KSB7XG4gICAgdmFyIHZpZXdwb3J0Qm94ID0gbWVhc3VyZVZpZXdwb3J0Qm94KGVsZW1lbnQsIHRyYW5zZm9ybVBhZ2VQb2ludCk7XG4gICAgdmFyIHNjcm9sbCA9IHJvb3RQcm9qZWN0aW9uTm9kZS5zY3JvbGw7XG4gICAgaWYgKHNjcm9sbCkge1xuICAgICAgICB0cmFuc2xhdGVBeGlzKHZpZXdwb3J0Qm94LngsIHNjcm9sbC54KTtcbiAgICAgICAgdHJhbnNsYXRlQXhpcyh2aWV3cG9ydEJveC55LCBzY3JvbGwueSk7XG4gICAgfVxuICAgIHJldHVybiB2aWV3cG9ydEJveDtcbn1cblxuZXhwb3J0IHsgbWVhc3VyZVBhZ2VCb3gsIG1lYXN1cmVWaWV3cG9ydEJveCB9O1xuIiwiaW1wb3J0IHsgX19hc3NpZ24gfSBmcm9tICd0c2xpYic7XG5pbXBvcnQgeyBpbnZhcmlhbnQgfSBmcm9tICdoZXktbGlzdGVuJztcbmltcG9ydCB7IFBhblNlc3Npb24gfSBmcm9tICcuLi9QYW5TZXNzaW9uLm1qcyc7XG5pbXBvcnQgeyBnZXRHbG9iYWxMb2NrIH0gZnJvbSAnLi91dGlscy9sb2NrLm1qcyc7XG5pbXBvcnQgeyBpc1JlZk9iamVjdCB9IGZyb20gJy4uLy4uL3V0aWxzL2lzLXJlZi1vYmplY3QubWpzJztcbmltcG9ydCB7IGFkZFBvaW50ZXJFdmVudCB9IGZyb20gJy4uLy4uL2V2ZW50cy91c2UtcG9pbnRlci1ldmVudC5tanMnO1xuaW1wb3J0IHsgYXBwbHlDb25zdHJhaW50cywgY2FsY1JlbGF0aXZlQ29uc3RyYWludHMsIHJlc29sdmVEcmFnRWxhc3RpYywgcmViYXNlQXhpc0NvbnN0cmFpbnRzLCBjYWxjVmlld3BvcnRDb25zdHJhaW50cywgY2FsY09yaWdpbiwgZGVmYXVsdEVsYXN0aWMgfSBmcm9tICcuL3V0aWxzL2NvbnN0cmFpbnRzLm1qcyc7XG5pbXBvcnQgeyBBbmltYXRpb25UeXBlIH0gZnJvbSAnLi4vLi4vcmVuZGVyL3V0aWxzL3R5cGVzLm1qcyc7XG5pbXBvcnQgeyBjcmVhdGVCb3ggfSBmcm9tICcuLi8uLi9wcm9qZWN0aW9uL2dlb21ldHJ5L21vZGVscy5tanMnO1xuaW1wb3J0IHsgZWFjaEF4aXMgfSBmcm9tICcuLi8uLi9wcm9qZWN0aW9uL3V0aWxzL2VhY2gtYXhpcy5tanMnO1xuaW1wb3J0IHsgbWVhc3VyZVBhZ2VCb3ggfSBmcm9tICcuLi8uLi9wcm9qZWN0aW9uL3V0aWxzL21lYXN1cmUubWpzJztcbmltcG9ydCB7IGV4dHJhY3RFdmVudEluZm8gfSBmcm9tICcuLi8uLi9ldmVudHMvZXZlbnQtaW5mby5tanMnO1xuaW1wb3J0IHsgc3RhcnRBbmltYXRpb24gfSBmcm9tICcuLi8uLi9hbmltYXRpb24vdXRpbHMvdHJhbnNpdGlvbnMubWpzJztcbmltcG9ydCB7IGNvbnZlcnRCb3hUb0JvdW5kaW5nQm94LCBjb252ZXJ0Qm91bmRpbmdCb3hUb0JveCB9IGZyb20gJy4uLy4uL3Byb2plY3Rpb24vZ2VvbWV0cnkvY29udmVyc2lvbi5tanMnO1xuaW1wb3J0IHsgYWRkRG9tRXZlbnQgfSBmcm9tICcuLi8uLi9ldmVudHMvdXNlLWRvbS1ldmVudC5tanMnO1xuaW1wb3J0IHsgbWl4IH0gZnJvbSAncG9wbW90aW9uJztcbmltcG9ydCB7IHBlcmNlbnQgfSBmcm9tICdzdHlsZS12YWx1ZS10eXBlcyc7XG5pbXBvcnQgeyBjYWxjTGVuZ3RoIH0gZnJvbSAnLi4vLi4vcHJvamVjdGlvbi9nZW9tZXRyeS9kZWx0YS1jYWxjLm1qcyc7XG5cbnZhciBlbGVtZW50RHJhZ0NvbnRyb2xzID0gbmV3IFdlYWtNYXAoKTtcbi8qKlxuICpcbiAqL1xuLy8gbGV0IGxhdGVzdFBvaW50ZXJFdmVudDogQW55UG9pbnRlckV2ZW50XG52YXIgVmlzdWFsRWxlbWVudERyYWdDb250cm9scyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBWaXN1YWxFbGVtZW50RHJhZ0NvbnRyb2xzKHZpc3VhbEVsZW1lbnQpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIGRyYWcgZ2VzdHVyZSBsb2NrLCBlbnN1cmluZyBvbmx5IG9uZSBjb21wb25lbnRcbiAgICAgICAgLy8gY2FuIFwiY2FwdHVyZVwiIHRoZSBkcmFnIG9mIG9uZSBvciBib3RoIGF4ZXMuXG4gICAgICAgIC8vIFRPRE86IExvb2sgaW50byBtb3ZpbmcgdGhpcyBpbnRvIHBhbnNlc3Npb24/XG4gICAgICAgIHRoaXMub3Blbkdsb2JhbExvY2sgPSBudWxsO1xuICAgICAgICB0aGlzLmlzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jdXJyZW50RGlyZWN0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5vcmlnaW5Qb2ludCA9IHsgeDogMCwgeTogMCB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHBlcm1pdHRlZCBib3VuZGFyaWVzIG9mIHRyYXZlbCwgaW4gcGl4ZWxzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb25zdHJhaW50cyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmhhc011dGF0ZWRDb25zdHJhaW50cyA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHBlci1heGlzIHJlc29sdmVkIGVsYXN0aWMgdmFsdWVzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5lbGFzdGljID0gY3JlYXRlQm94KCk7XG4gICAgICAgIHRoaXMudmlzdWFsRWxlbWVudCA9IHZpc3VhbEVsZW1lbnQ7XG4gICAgfVxuICAgIFZpc3VhbEVsZW1lbnREcmFnQ29udHJvbHMucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKG9yaWdpbkV2ZW50LCBfYSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgX2MgPSBfYi5zbmFwVG9DdXJzb3IsIHNuYXBUb0N1cnNvciA9IF9jID09PSB2b2lkIDAgPyBmYWxzZSA6IF9jO1xuICAgICAgICAvKipcbiAgICAgICAgICogRG9uJ3Qgc3RhcnQgZHJhZ2dpbmcgaWYgdGhpcyBjb21wb25lbnQgaXMgZXhpdGluZ1xuICAgICAgICAgKi9cbiAgICAgICAgaWYgKHRoaXMudmlzdWFsRWxlbWVudC5pc1ByZXNlbnQgPT09IGZhbHNlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgb25TZXNzaW9uU3RhcnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgIC8vIFN0b3AgYW55IGFuaW1hdGlvbnMgb24gYm90aCBheGlzIHZhbHVlcyBpbW1lZGlhdGVseS4gVGhpcyBhbGxvd3MgdGhlIHVzZXIgdG8gdGhyb3cgYW5kIGNhdGNoXG4gICAgICAgICAgICAvLyB0aGUgY29tcG9uZW50LlxuICAgICAgICAgICAgX3RoaXMuc3RvcEFuaW1hdGlvbigpO1xuICAgICAgICAgICAgaWYgKHNuYXBUb0N1cnNvcikge1xuICAgICAgICAgICAgICAgIF90aGlzLnNuYXBUb0N1cnNvcihleHRyYWN0RXZlbnRJbmZvKGV2ZW50LCBcInBhZ2VcIikucG9pbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgb25TdGFydCA9IGZ1bmN0aW9uIChldmVudCwgaW5mbykge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgLy8gQXR0ZW1wdCB0byBncmFiIHRoZSBnbG9iYWwgZHJhZyBnZXN0dXJlIGxvY2sgLSBtYXliZSBtYWtlIHRoaXMgcGFydCBvZiBQYW5TZXNzaW9uXG4gICAgICAgICAgICB2YXIgX2IgPSBfdGhpcy5nZXRQcm9wcygpLCBkcmFnID0gX2IuZHJhZywgZHJhZ1Byb3BhZ2F0aW9uID0gX2IuZHJhZ1Byb3BhZ2F0aW9uLCBvbkRyYWdTdGFydCA9IF9iLm9uRHJhZ1N0YXJ0O1xuICAgICAgICAgICAgaWYgKGRyYWcgJiYgIWRyYWdQcm9wYWdhdGlvbikge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5vcGVuR2xvYmFsTG9jaylcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub3Blbkdsb2JhbExvY2soKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5vcGVuR2xvYmFsTG9jayA9IGdldEdsb2JhbExvY2soZHJhZyk7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgZG9uICd0IGhhdmUgdGhlIGxvY2ssIGRvbid0IHN0YXJ0IGRyYWdnaW5nXG4gICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5vcGVuR2xvYmFsTG9jaylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuaXNEcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgICBfdGhpcy5jdXJyZW50RGlyZWN0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIF90aGlzLnJlc29sdmVDb25zdHJhaW50cygpO1xuICAgICAgICAgICAgaWYgKF90aGlzLnZpc3VhbEVsZW1lbnQucHJvamVjdGlvbikge1xuICAgICAgICAgICAgICAgIF90aGlzLnZpc3VhbEVsZW1lbnQucHJvamVjdGlvbi5pc0FuaW1hdGlvbkJsb2NrZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIF90aGlzLnZpc3VhbEVsZW1lbnQucHJvamVjdGlvbi50YXJnZXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJlY29yZCBnZXN0dXJlIG9yaWdpblxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBlYWNoQXhpcyhmdW5jdGlvbiAoYXhpcykge1xuICAgICAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnQgPSBfdGhpcy5nZXRBeGlzTW90aW9uVmFsdWUoYXhpcykuZ2V0KCkgfHwgMDtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBJZiB0aGUgTW90aW9uVmFsdWUgaXMgYSBwZXJjZW50YWdlIHZhbHVlIGNvbnZlcnQgdG8gcHhcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBpZiAocGVyY2VudC50ZXN0KGN1cnJlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtZWFzdXJlZEF4aXMgPSAoX2IgPSAoX2EgPSBfdGhpcy52aXN1YWxFbGVtZW50LnByb2plY3Rpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sYXlvdXQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hY3R1YWxbYXhpc107XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZWFzdXJlZEF4aXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBsZW5ndGhfMSA9IGNhbGNMZW5ndGgobWVhc3VyZWRBeGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBsZW5ndGhfMSAqIChwYXJzZUZsb2F0KGN1cnJlbnQpIC8gMTAwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy5vcmlnaW5Qb2ludFtheGlzXSA9IGN1cnJlbnQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIEZpcmUgb25EcmFnU3RhcnQgZXZlbnRcbiAgICAgICAgICAgIG9uRHJhZ1N0YXJ0ID09PSBudWxsIHx8IG9uRHJhZ1N0YXJ0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbkRyYWdTdGFydChldmVudCwgaW5mbyk7XG4gICAgICAgICAgICAoX2EgPSBfdGhpcy52aXN1YWxFbGVtZW50LmFuaW1hdGlvblN0YXRlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2V0QWN0aXZlKEFuaW1hdGlvblR5cGUuRHJhZywgdHJ1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBvbk1vdmUgPSBmdW5jdGlvbiAoZXZlbnQsIGluZm8pIHtcbiAgICAgICAgICAgIC8vIGxhdGVzdFBvaW50ZXJFdmVudCA9IGV2ZW50XG4gICAgICAgICAgICB2YXIgX2EgPSBfdGhpcy5nZXRQcm9wcygpLCBkcmFnUHJvcGFnYXRpb24gPSBfYS5kcmFnUHJvcGFnYXRpb24sIGRyYWdEaXJlY3Rpb25Mb2NrID0gX2EuZHJhZ0RpcmVjdGlvbkxvY2ssIG9uRGlyZWN0aW9uTG9jayA9IF9hLm9uRGlyZWN0aW9uTG9jaywgb25EcmFnID0gX2Eub25EcmFnO1xuICAgICAgICAgICAgLy8gSWYgd2UgZGlkbid0IHN1Y2Nlc3NmdWxseSByZWNlaXZlIHRoZSBnZXN0dXJlIGxvY2ssIGVhcmx5IHJldHVybi5cbiAgICAgICAgICAgIGlmICghZHJhZ1Byb3BhZ2F0aW9uICYmICFfdGhpcy5vcGVuR2xvYmFsTG9jaylcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gaW5mby5vZmZzZXQ7XG4gICAgICAgICAgICAvLyBBdHRlbXB0IHRvIGRldGVjdCBkcmFnIGRpcmVjdGlvbiBpZiBkaXJlY3Rpb25Mb2NrIGlzIHRydWVcbiAgICAgICAgICAgIGlmIChkcmFnRGlyZWN0aW9uTG9jayAmJiBfdGhpcy5jdXJyZW50RGlyZWN0aW9uID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuY3VycmVudERpcmVjdGlvbiA9IGdldEN1cnJlbnREaXJlY3Rpb24ob2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSd2ZSBzdWNjZXNzZnVsbHkgc2V0IGEgZGlyZWN0aW9uLCBub3RpZnkgbGlzdGVuZXJcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuY3VycmVudERpcmVjdGlvbiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBvbkRpcmVjdGlvbkxvY2sgPT09IG51bGwgfHwgb25EaXJlY3Rpb25Mb2NrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbkRpcmVjdGlvbkxvY2soX3RoaXMuY3VycmVudERpcmVjdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFVwZGF0ZSBlYWNoIHBvaW50IHdpdGggdGhlIGxhdGVzdCBwb3NpdGlvblxuICAgICAgICAgICAgX3RoaXMudXBkYXRlQXhpcyhcInhcIiwgaW5mby5wb2ludCwgb2Zmc2V0KTtcbiAgICAgICAgICAgIF90aGlzLnVwZGF0ZUF4aXMoXCJ5XCIsIGluZm8ucG9pbnQsIG9mZnNldCk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElkZWFsbHkgd2Ugd291bGQgbGVhdmUgdGhlIHJlbmRlcmVyIHRvIGZpcmUgbmF0dXJhbGx5IGF0IHRoZSBlbmQgb2ZcbiAgICAgICAgICAgICAqIHRoaXMgZnJhbWUgYnV0IGlmIHRoZSBlbGVtZW50IGlzIGFib3V0IHRvIGNoYW5nZSBsYXlvdXQgYXMgdGhlIHJlc3VsdFxuICAgICAgICAgICAgICogb2YgYSByZS1yZW5kZXIgd2Ugd2FudCB0byBlbnN1cmUgdGhlIGJyb3dzZXIgY2FuIHJlYWQgdGhlIGxhdGVzdFxuICAgICAgICAgICAgICogYm91bmRpbmcgYm94IHRvIGVuc3VyZSB0aGUgcG9pbnRlciBhbmQgZWxlbWVudCBkb24ndCBmYWxsIG91dCBvZiBzeW5jLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBfdGhpcy52aXN1YWxFbGVtZW50LnN5bmNSZW5kZXIoKTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhpcyBtdXN0IGZpcmUgYWZ0ZXIgdGhlIHN5bmNSZW5kZXIgY2FsbCBhcyBpdCBtaWdodCB0cmlnZ2VyIGEgc3RhdGVcbiAgICAgICAgICAgICAqIGNoYW5nZSB3aGljaCBpdHNlbGYgbWlnaHQgdHJpZ2dlciBhIGxheW91dCB1cGRhdGUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIG9uRHJhZyA9PT0gbnVsbCB8fCBvbkRyYWcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uRHJhZyhldmVudCwgaW5mbyk7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBvblNlc3Npb25FbmQgPSBmdW5jdGlvbiAoZXZlbnQsIGluZm8pIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5zdG9wKGV2ZW50LCBpbmZvKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5wYW5TZXNzaW9uID0gbmV3IFBhblNlc3Npb24ob3JpZ2luRXZlbnQsIHtcbiAgICAgICAgICAgIG9uU2Vzc2lvblN0YXJ0OiBvblNlc3Npb25TdGFydCxcbiAgICAgICAgICAgIG9uU3RhcnQ6IG9uU3RhcnQsXG4gICAgICAgICAgICBvbk1vdmU6IG9uTW92ZSxcbiAgICAgICAgICAgIG9uU2Vzc2lvbkVuZDogb25TZXNzaW9uRW5kLFxuICAgICAgICB9LCB7IHRyYW5zZm9ybVBhZ2VQb2ludDogdGhpcy52aXN1YWxFbGVtZW50LmdldFRyYW5zZm9ybVBhZ2VQb2ludCgpIH0pO1xuICAgIH07XG4gICAgVmlzdWFsRWxlbWVudERyYWdDb250cm9scy5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uIChldmVudCwgaW5mbykge1xuICAgICAgICB2YXIgaXNEcmFnZ2luZyA9IHRoaXMuaXNEcmFnZ2luZztcbiAgICAgICAgdGhpcy5jYW5jZWwoKTtcbiAgICAgICAgaWYgKCFpc0RyYWdnaW5nKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgdmVsb2NpdHkgPSBpbmZvLnZlbG9jaXR5O1xuICAgICAgICB0aGlzLnN0YXJ0QW5pbWF0aW9uKHZlbG9jaXR5KTtcbiAgICAgICAgdmFyIG9uRHJhZ0VuZCA9IHRoaXMuZ2V0UHJvcHMoKS5vbkRyYWdFbmQ7XG4gICAgICAgIG9uRHJhZ0VuZCA9PT0gbnVsbCB8fCBvbkRyYWdFbmQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uRHJhZ0VuZChldmVudCwgaW5mbyk7XG4gICAgfTtcbiAgICBWaXN1YWxFbGVtZW50RHJhZ0NvbnRyb2xzLnByb3RvdHlwZS5jYW5jZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHRoaXMuaXNEcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy52aXN1YWxFbGVtZW50LnByb2plY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMudmlzdWFsRWxlbWVudC5wcm9qZWN0aW9uLmlzQW5pbWF0aW9uQmxvY2tlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIChfYSA9IHRoaXMucGFuU2Vzc2lvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmVuZCgpO1xuICAgICAgICB0aGlzLnBhblNlc3Npb24gPSB1bmRlZmluZWQ7XG4gICAgICAgIHZhciBkcmFnUHJvcGFnYXRpb24gPSB0aGlzLmdldFByb3BzKCkuZHJhZ1Byb3BhZ2F0aW9uO1xuICAgICAgICBpZiAoIWRyYWdQcm9wYWdhdGlvbiAmJiB0aGlzLm9wZW5HbG9iYWxMb2NrKSB7XG4gICAgICAgICAgICB0aGlzLm9wZW5HbG9iYWxMb2NrKCk7XG4gICAgICAgICAgICB0aGlzLm9wZW5HbG9iYWxMb2NrID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAoX2IgPSB0aGlzLnZpc3VhbEVsZW1lbnQuYW5pbWF0aW9uU3RhdGUpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zZXRBY3RpdmUoQW5pbWF0aW9uVHlwZS5EcmFnLCBmYWxzZSk7XG4gICAgfTtcbiAgICBWaXN1YWxFbGVtZW50RHJhZ0NvbnRyb2xzLnByb3RvdHlwZS51cGRhdGVBeGlzID0gZnVuY3Rpb24gKGF4aXMsIF9wb2ludCwgb2Zmc2V0KSB7XG4gICAgICAgIHZhciBkcmFnID0gdGhpcy5nZXRQcm9wcygpLmRyYWc7XG4gICAgICAgIC8vIElmIHdlJ3JlIG5vdCBkcmFnZ2luZyB0aGlzIGF4aXMsIGRvIGFuIGVhcmx5IHJldHVybi5cbiAgICAgICAgaWYgKCFvZmZzZXQgfHwgIXNob3VsZERyYWcoYXhpcywgZHJhZywgdGhpcy5jdXJyZW50RGlyZWN0aW9uKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIGF4aXNWYWx1ZSA9IHRoaXMuZ2V0QXhpc01vdGlvblZhbHVlKGF4aXMpO1xuICAgICAgICB2YXIgbmV4dCA9IHRoaXMub3JpZ2luUG9pbnRbYXhpc10gKyBvZmZzZXRbYXhpc107XG4gICAgICAgIC8vIEFwcGx5IGNvbnN0cmFpbnRzXG4gICAgICAgIGlmICh0aGlzLmNvbnN0cmFpbnRzICYmIHRoaXMuY29uc3RyYWludHNbYXhpc10pIHtcbiAgICAgICAgICAgIG5leHQgPSBhcHBseUNvbnN0cmFpbnRzKG5leHQsIHRoaXMuY29uc3RyYWludHNbYXhpc10sIHRoaXMuZWxhc3RpY1theGlzXSk7XG4gICAgICAgIH1cbiAgICAgICAgYXhpc1ZhbHVlLnNldChuZXh0KTtcbiAgICB9O1xuICAgIFZpc3VhbEVsZW1lbnREcmFnQ29udHJvbHMucHJvdG90eXBlLnJlc29sdmVDb25zdHJhaW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9hID0gdGhpcy5nZXRQcm9wcygpLCBkcmFnQ29uc3RyYWludHMgPSBfYS5kcmFnQ29uc3RyYWludHMsIGRyYWdFbGFzdGljID0gX2EuZHJhZ0VsYXN0aWM7XG4gICAgICAgIHZhciBsYXlvdXQgPSAodGhpcy52aXN1YWxFbGVtZW50LnByb2plY3Rpb24gfHwge30pLmxheW91dDtcbiAgICAgICAgdmFyIHByZXZDb25zdHJhaW50cyA9IHRoaXMuY29uc3RyYWludHM7XG4gICAgICAgIGlmIChkcmFnQ29uc3RyYWludHMgJiYgaXNSZWZPYmplY3QoZHJhZ0NvbnN0cmFpbnRzKSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmNvbnN0cmFpbnRzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25zdHJhaW50cyA9IHRoaXMucmVzb2x2ZVJlZkNvbnN0cmFpbnRzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoZHJhZ0NvbnN0cmFpbnRzICYmIGxheW91dCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29uc3RyYWludHMgPSBjYWxjUmVsYXRpdmVDb25zdHJhaW50cyhsYXlvdXQuYWN0dWFsLCBkcmFnQ29uc3RyYWludHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25zdHJhaW50cyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWxhc3RpYyA9IHJlc29sdmVEcmFnRWxhc3RpYyhkcmFnRWxhc3RpYyk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB3ZSdyZSBvdXRwdXR0aW5nIHRvIGV4dGVybmFsIE1vdGlvblZhbHVlcywgd2Ugd2FudCB0byByZWJhc2UgdGhlIG1lYXN1cmVkIGNvbnN0cmFpbnRzXG4gICAgICAgICAqIGZyb20gdmlld3BvcnQtcmVsYXRpdmUgdG8gY29tcG9uZW50LXJlbGF0aXZlLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKHByZXZDb25zdHJhaW50cyAhPT0gdGhpcy5jb25zdHJhaW50cyAmJlxuICAgICAgICAgICAgbGF5b3V0ICYmXG4gICAgICAgICAgICB0aGlzLmNvbnN0cmFpbnRzICYmXG4gICAgICAgICAgICAhdGhpcy5oYXNNdXRhdGVkQ29uc3RyYWludHMpIHtcbiAgICAgICAgICAgIGVhY2hBeGlzKGZ1bmN0aW9uIChheGlzKSB7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLmdldEF4aXNNb3Rpb25WYWx1ZShheGlzKSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5jb25zdHJhaW50c1theGlzXSA9IHJlYmFzZUF4aXNDb25zdHJhaW50cyhsYXlvdXQuYWN0dWFsW2F4aXNdLCBfdGhpcy5jb25zdHJhaW50c1theGlzXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFZpc3VhbEVsZW1lbnREcmFnQ29udHJvbHMucHJvdG90eXBlLnJlc29sdmVSZWZDb25zdHJhaW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5nZXRQcm9wcygpLCBjb25zdHJhaW50cyA9IF9hLmRyYWdDb25zdHJhaW50cywgb25NZWFzdXJlRHJhZ0NvbnN0cmFpbnRzID0gX2Eub25NZWFzdXJlRHJhZ0NvbnN0cmFpbnRzO1xuICAgICAgICBpZiAoIWNvbnN0cmFpbnRzIHx8ICFpc1JlZk9iamVjdChjb25zdHJhaW50cykpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHZhciBjb25zdHJhaW50c0VsZW1lbnQgPSBjb25zdHJhaW50cy5jdXJyZW50O1xuICAgICAgICBpbnZhcmlhbnQoY29uc3RyYWludHNFbGVtZW50ICE9PSBudWxsLCBcIklmIGBkcmFnQ29uc3RyYWludHNgIGlzIHNldCBhcyBhIFJlYWN0IHJlZiwgdGhhdCByZWYgbXVzdCBiZSBwYXNzZWQgdG8gYW5vdGhlciBjb21wb25lbnQncyBgcmVmYCBwcm9wLlwiKTtcbiAgICAgICAgdmFyIHByb2plY3Rpb24gPSB0aGlzLnZpc3VhbEVsZW1lbnQucHJvamVjdGlvbjtcbiAgICAgICAgLy8gVE9ET1xuICAgICAgICBpZiAoIXByb2plY3Rpb24gfHwgIXByb2plY3Rpb24ubGF5b3V0KVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIgY29uc3RyYWludHNCb3ggPSBtZWFzdXJlUGFnZUJveChjb25zdHJhaW50c0VsZW1lbnQsIHByb2plY3Rpb24ucm9vdCwgdGhpcy52aXN1YWxFbGVtZW50LmdldFRyYW5zZm9ybVBhZ2VQb2ludCgpKTtcbiAgICAgICAgdmFyIG1lYXN1cmVkQ29uc3RyYWludHMgPSBjYWxjVmlld3BvcnRDb25zdHJhaW50cyhwcm9qZWN0aW9uLmxheW91dC5hY3R1YWwsIGNvbnN0cmFpbnRzQm94KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRoZXJlJ3MgYW4gb25NZWFzdXJlRHJhZ0NvbnN0cmFpbnRzIGxpc3RlbmVyIHdlIGNhbGwgaXQgYW5kXG4gICAgICAgICAqIGlmIGRpZmZlcmVudCBjb25zdHJhaW50cyBhcmUgcmV0dXJuZWQsIHNldCBjb25zdHJhaW50cyB0byB0aGF0XG4gICAgICAgICAqL1xuICAgICAgICBpZiAob25NZWFzdXJlRHJhZ0NvbnN0cmFpbnRzKSB7XG4gICAgICAgICAgICB2YXIgdXNlckNvbnN0cmFpbnRzID0gb25NZWFzdXJlRHJhZ0NvbnN0cmFpbnRzKGNvbnZlcnRCb3hUb0JvdW5kaW5nQm94KG1lYXN1cmVkQ29uc3RyYWludHMpKTtcbiAgICAgICAgICAgIHRoaXMuaGFzTXV0YXRlZENvbnN0cmFpbnRzID0gISF1c2VyQ29uc3RyYWludHM7XG4gICAgICAgICAgICBpZiAodXNlckNvbnN0cmFpbnRzKSB7XG4gICAgICAgICAgICAgICAgbWVhc3VyZWRDb25zdHJhaW50cyA9IGNvbnZlcnRCb3VuZGluZ0JveFRvQm94KHVzZXJDb25zdHJhaW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lYXN1cmVkQ29uc3RyYWludHM7XG4gICAgfTtcbiAgICBWaXN1YWxFbGVtZW50RHJhZ0NvbnRyb2xzLnByb3RvdHlwZS5zdGFydEFuaW1hdGlvbiA9IGZ1bmN0aW9uICh2ZWxvY2l0eSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLmdldFByb3BzKCksIGRyYWcgPSBfYS5kcmFnLCBkcmFnTW9tZW50dW0gPSBfYS5kcmFnTW9tZW50dW0sIGRyYWdFbGFzdGljID0gX2EuZHJhZ0VsYXN0aWMsIGRyYWdUcmFuc2l0aW9uID0gX2EuZHJhZ1RyYW5zaXRpb24sIGRyYWdTbmFwVG9PcmlnaW4gPSBfYS5kcmFnU25hcFRvT3JpZ2luLCBvbkRyYWdUcmFuc2l0aW9uRW5kID0gX2Eub25EcmFnVHJhbnNpdGlvbkVuZDtcbiAgICAgICAgdmFyIGNvbnN0cmFpbnRzID0gdGhpcy5jb25zdHJhaW50cyB8fCB7fTtcbiAgICAgICAgdmFyIG1vbWVudHVtQW5pbWF0aW9ucyA9IGVhY2hBeGlzKGZ1bmN0aW9uIChheGlzKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBpZiAoIXNob3VsZERyYWcoYXhpcywgZHJhZywgX3RoaXMuY3VycmVudERpcmVjdGlvbikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdHJhbnNpdGlvbiA9IChfYSA9IGNvbnN0cmFpbnRzID09PSBudWxsIHx8IGNvbnN0cmFpbnRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25zdHJhaW50c1theGlzXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDoge307XG4gICAgICAgICAgICBpZiAoZHJhZ1NuYXBUb09yaWdpbilcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uID0geyBtaW46IDAsIG1heDogMCB9O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBPdmVyZGFtcCB0aGUgYm91bmRhcnkgc3ByaW5nIGlmIGBkcmFnRWxhc3RpY2AgaXMgZGlzYWJsZWQuIFRoZXJlJ3Mgc3RpbGwgYSBmcmFtZVxuICAgICAgICAgICAgICogb2Ygc3ByaW5nIGFuaW1hdGlvbnMgc28gd2Ugc2hvdWxkIGxvb2sgaW50byBhZGRpbmcgYSBkaXNhYmxlIHNwcmluZyBvcHRpb24gdG8gYGluZXJ0aWFgLlxuICAgICAgICAgICAgICogV2UgY291bGQgZG8gc29tZXRoaW5nIGhlcmUgd2hlcmUgd2UgYWZmZWN0IHRoZSBgYm91bmNlU3RpZmZuZXNzYCBhbmQgYGJvdW5jZURhbXBpbmdgXG4gICAgICAgICAgICAgKiB1c2luZyB0aGUgdmFsdWUgb2YgYGRyYWdFbGFzdGljYC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmFyIGJvdW5jZVN0aWZmbmVzcyA9IGRyYWdFbGFzdGljID8gMjAwIDogMTAwMDAwMDtcbiAgICAgICAgICAgIHZhciBib3VuY2VEYW1waW5nID0gZHJhZ0VsYXN0aWMgPyA0MCA6IDEwMDAwMDAwO1xuICAgICAgICAgICAgdmFyIGluZXJ0aWEgPSBfX2Fzc2lnbihfX2Fzc2lnbih7IHR5cGU6IFwiaW5lcnRpYVwiLCB2ZWxvY2l0eTogZHJhZ01vbWVudHVtID8gdmVsb2NpdHlbYXhpc10gOiAwLCBib3VuY2VTdGlmZm5lc3M6IGJvdW5jZVN0aWZmbmVzcywgYm91bmNlRGFtcGluZzogYm91bmNlRGFtcGluZywgdGltZUNvbnN0YW50OiA3NTAsIHJlc3REZWx0YTogMSwgcmVzdFNwZWVkOiAxMCB9LCBkcmFnVHJhbnNpdGlvbiksIHRyYW5zaXRpb24pO1xuICAgICAgICAgICAgLy8gSWYgd2UncmUgbm90IGFuaW1hdGluZyBvbiBhbiBleHRlcm5hbGx5LXByb3ZpZGVkIGBNb3Rpb25WYWx1ZWAgd2UgY2FuIHVzZSB0aGVcbiAgICAgICAgICAgIC8vIGNvbXBvbmVudCdzIGFuaW1hdGlvbiBjb250cm9scyB3aGljaCB3aWxsIGhhbmRsZSBpbnRlcmFjdGlvbnMgd2l0aCB3aGlsZUhvdmVyIChldGMpLFxuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIHdlIGp1c3QgaGF2ZSB0byBhbmltYXRlIHRoZSBgTW90aW9uVmFsdWVgIGl0c2VsZi5cbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5zdGFydEF4aXNWYWx1ZUFuaW1hdGlvbihheGlzLCBpbmVydGlhKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFJ1biBhbGwgYW5pbWF0aW9ucyBhbmQgdGhlbiByZXNvbHZlIHRoZSBuZXcgZHJhZyBjb25zdHJhaW50cy5cbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKG1vbWVudHVtQW5pbWF0aW9ucykudGhlbihvbkRyYWdUcmFuc2l0aW9uRW5kKTtcbiAgICB9O1xuICAgIFZpc3VhbEVsZW1lbnREcmFnQ29udHJvbHMucHJvdG90eXBlLnN0YXJ0QXhpc1ZhbHVlQW5pbWF0aW9uID0gZnVuY3Rpb24gKGF4aXMsIHRyYW5zaXRpb24pIHtcbiAgICAgICAgdmFyIGF4aXNWYWx1ZSA9IHRoaXMuZ2V0QXhpc01vdGlvblZhbHVlKGF4aXMpO1xuICAgICAgICByZXR1cm4gc3RhcnRBbmltYXRpb24oYXhpcywgYXhpc1ZhbHVlLCAwLCB0cmFuc2l0aW9uKTtcbiAgICB9O1xuICAgIFZpc3VhbEVsZW1lbnREcmFnQ29udHJvbHMucHJvdG90eXBlLnN0b3BBbmltYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGVhY2hBeGlzKGZ1bmN0aW9uIChheGlzKSB7IHJldHVybiBfdGhpcy5nZXRBeGlzTW90aW9uVmFsdWUoYXhpcykuc3RvcCgpOyB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIERyYWcgd29ya3MgZGlmZmVyZW50bHkgZGVwZW5kaW5nIG9uIHdoaWNoIHByb3BzIGFyZSBwcm92aWRlZC5cbiAgICAgKlxuICAgICAqIC0gSWYgX2RyYWdYIGFuZCBfZHJhZ1kgYXJlIHByb3ZpZGVkLCB3ZSBvdXRwdXQgdGhlIGdlc3R1cmUgZGVsdGEgZGlyZWN0bHkgdG8gdGhvc2UgbW90aW9uIHZhbHVlcy5cbiAgICAgKiAtIE90aGVyd2lzZSwgd2UgYXBwbHkgdGhlIGRlbHRhIHRvIHRoZSB4L3kgbW90aW9uIHZhbHVlcy5cbiAgICAgKi9cbiAgICBWaXN1YWxFbGVtZW50RHJhZ0NvbnRyb2xzLnByb3RvdHlwZS5nZXRBeGlzTW90aW9uVmFsdWUgPSBmdW5jdGlvbiAoYXhpcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICB2YXIgZHJhZ0tleSA9IFwiX2RyYWdcIiArIGF4aXMudG9VcHBlckNhc2UoKTtcbiAgICAgICAgdmFyIGV4dGVybmFsTW90aW9uVmFsdWUgPSB0aGlzLnZpc3VhbEVsZW1lbnQuZ2V0UHJvcHMoKVtkcmFnS2V5XTtcbiAgICAgICAgcmV0dXJuIGV4dGVybmFsTW90aW9uVmFsdWVcbiAgICAgICAgICAgID8gZXh0ZXJuYWxNb3Rpb25WYWx1ZVxuICAgICAgICAgICAgOiB0aGlzLnZpc3VhbEVsZW1lbnQuZ2V0VmFsdWUoYXhpcywgKF9iID0gKF9hID0gdGhpcy52aXN1YWxFbGVtZW50LmdldFByb3BzKCkuaW5pdGlhbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW2F4aXNdKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAwKTtcbiAgICB9O1xuICAgIFZpc3VhbEVsZW1lbnREcmFnQ29udHJvbHMucHJvdG90eXBlLnNuYXBUb0N1cnNvciA9IGZ1bmN0aW9uIChwb2ludCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBlYWNoQXhpcyhmdW5jdGlvbiAoYXhpcykge1xuICAgICAgICAgICAgdmFyIGRyYWcgPSBfdGhpcy5nZXRQcm9wcygpLmRyYWc7XG4gICAgICAgICAgICAvLyBJZiB3ZSdyZSBub3QgZHJhZ2dpbmcgdGhpcyBheGlzLCBkbyBhbiBlYXJseSByZXR1cm4uXG4gICAgICAgICAgICBpZiAoIXNob3VsZERyYWcoYXhpcywgZHJhZywgX3RoaXMuY3VycmVudERpcmVjdGlvbikpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIHByb2plY3Rpb24gPSBfdGhpcy52aXN1YWxFbGVtZW50LnByb2plY3Rpb247XG4gICAgICAgICAgICB2YXIgYXhpc1ZhbHVlID0gX3RoaXMuZ2V0QXhpc01vdGlvblZhbHVlKGF4aXMpO1xuICAgICAgICAgICAgaWYgKHByb2plY3Rpb24gJiYgcHJvamVjdGlvbi5sYXlvdXQpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2EgPSBwcm9qZWN0aW9uLmxheW91dC5hY3R1YWxbYXhpc10sIG1pbiA9IF9hLm1pbiwgbWF4ID0gX2EubWF4O1xuICAgICAgICAgICAgICAgIGF4aXNWYWx1ZS5zZXQocG9pbnRbYXhpc10gLSBtaXgobWluLCBtYXgsIDAuNSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFdoZW4gdGhlIHZpZXdwb3J0IHJlc2l6ZXMgd2Ugd2FudCB0byBjaGVjayBpZiB0aGUgbWVhc3VyZWQgY29uc3RyYWludHNcbiAgICAgKiBoYXZlIGNoYW5nZWQgYW5kLCBpZiBzbywgcmVwb3NpdGlvbiB0aGUgZWxlbWVudCB3aXRoaW4gdGhvc2UgbmV3IGNvbnN0cmFpbnRzXG4gICAgICogcmVsYXRpdmUgdG8gd2hlcmUgaXQgd2FzIGJlZm9yZSB0aGUgcmVzaXplLlxuICAgICAqL1xuICAgIFZpc3VhbEVsZW1lbnREcmFnQ29udHJvbHMucHJvdG90eXBlLnNjYWxlUG9zaXRpb25XaXRoaW5Db25zdHJhaW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB2YXIgX2IgPSB0aGlzLmdldFByb3BzKCksIGRyYWcgPSBfYi5kcmFnLCBkcmFnQ29uc3RyYWludHMgPSBfYi5kcmFnQ29uc3RyYWludHM7XG4gICAgICAgIHZhciBwcm9qZWN0aW9uID0gdGhpcy52aXN1YWxFbGVtZW50LnByb2plY3Rpb247XG4gICAgICAgIGlmICghaXNSZWZPYmplY3QoZHJhZ0NvbnN0cmFpbnRzKSB8fCAhcHJvamVjdGlvbiB8fCAhdGhpcy5jb25zdHJhaW50cylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0b3AgY3VycmVudCBhbmltYXRpb25zIGFzIHRoZXJlIGNhbiBiZSB2aXN1YWwgZ2xpdGNoaW5nIGlmIHdlIHRyeSB0byBkb1xuICAgICAgICAgKiB0aGlzIG1pZC1hbmltYXRpb25cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RvcEFuaW1hdGlvbigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVjb3JkIHRoZSByZWxhdGl2ZSBwb3NpdGlvbiBvZiB0aGUgZHJhZ2dlZCBlbGVtZW50IHJlbGF0aXZlIHRvIHRoZVxuICAgICAgICAgKiBjb25zdHJhaW50cyBib3ggYW5kIHNhdmUgYXMgYSBwcm9ncmVzcyB2YWx1ZS5cbiAgICAgICAgICovXG4gICAgICAgIHZhciBib3hQcm9ncmVzcyA9IHsgeDogMCwgeTogMCB9O1xuICAgICAgICBlYWNoQXhpcyhmdW5jdGlvbiAoYXhpcykge1xuICAgICAgICAgICAgdmFyIGF4aXNWYWx1ZSA9IF90aGlzLmdldEF4aXNNb3Rpb25WYWx1ZShheGlzKTtcbiAgICAgICAgICAgIGlmIChheGlzVmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGF0ZXN0ID0gYXhpc1ZhbHVlLmdldCgpO1xuICAgICAgICAgICAgICAgIGJveFByb2dyZXNzW2F4aXNdID0gY2FsY09yaWdpbih7IG1pbjogbGF0ZXN0LCBtYXg6IGxhdGVzdCB9LCBfdGhpcy5jb25zdHJhaW50c1theGlzXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvKipcbiAgICAgICAgICogVXBkYXRlIHRoZSBsYXlvdXQgb2YgdGhpcyBlbGVtZW50IGFuZCByZXNvbHZlIHRoZSBsYXRlc3QgZHJhZyBjb25zdHJhaW50c1xuICAgICAgICAgKi9cbiAgICAgICAgdmFyIHRyYW5zZm9ybVRlbXBsYXRlID0gdGhpcy52aXN1YWxFbGVtZW50LmdldFByb3BzKCkudHJhbnNmb3JtVGVtcGxhdGU7XG4gICAgICAgIHRoaXMudmlzdWFsRWxlbWVudC5nZXRJbnN0YW5jZSgpLnN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVRlbXBsYXRlXG4gICAgICAgICAgICA/IHRyYW5zZm9ybVRlbXBsYXRlKHt9LCBcIlwiKVxuICAgICAgICAgICAgOiBcIm5vbmVcIjtcbiAgICAgICAgKF9hID0gcHJvamVjdGlvbi5yb290KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudXBkYXRlU2Nyb2xsKCk7XG4gICAgICAgIHByb2plY3Rpb24udXBkYXRlTGF5b3V0KCk7XG4gICAgICAgIHRoaXMucmVzb2x2ZUNvbnN0cmFpbnRzKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGb3IgZWFjaCBheGlzLCBjYWxjdWxhdGUgdGhlIGN1cnJlbnQgcHJvZ3Jlc3Mgb2YgdGhlIGxheW91dCBheGlzXG4gICAgICAgICAqIHdpdGhpbiB0aGUgbmV3IGNvbnN0cmFpbnRzLlxuICAgICAgICAgKi9cbiAgICAgICAgZWFjaEF4aXMoZnVuY3Rpb24gKGF4aXMpIHtcbiAgICAgICAgICAgIGlmICghc2hvdWxkRHJhZyhheGlzLCBkcmFnLCBudWxsKSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENhbGN1bGF0ZSBhIG5ldyB0cmFuc2Zvcm0gYmFzZWQgb24gdGhlIHByZXZpb3VzIGJveCBwcm9ncmVzc1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2YXIgYXhpc1ZhbHVlID0gX3RoaXMuZ2V0QXhpc01vdGlvblZhbHVlKGF4aXMpO1xuICAgICAgICAgICAgdmFyIF9hID0gX3RoaXMuY29uc3RyYWludHNbYXhpc10sIG1pbiA9IF9hLm1pbiwgbWF4ID0gX2EubWF4O1xuICAgICAgICAgICAgYXhpc1ZhbHVlLnNldChtaXgobWluLCBtYXgsIGJveFByb2dyZXNzW2F4aXNdKSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgVmlzdWFsRWxlbWVudERyYWdDb250cm9scy5wcm90b3R5cGUuYWRkTGlzdGVuZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGVsZW1lbnREcmFnQ29udHJvbHMuc2V0KHRoaXMudmlzdWFsRWxlbWVudCwgdGhpcyk7XG4gICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy52aXN1YWxFbGVtZW50LmdldEluc3RhbmNlKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBdHRhY2ggYSBwb2ludGVyZG93biBldmVudCBsaXN0ZW5lciBvbiB0aGlzIERPTSBlbGVtZW50IHRvIGluaXRpYXRlIGRyYWcgdHJhY2tpbmcuXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgc3RvcFBvaW50ZXJMaXN0ZW5lciA9IGFkZFBvaW50ZXJFdmVudChlbGVtZW50LCBcInBvaW50ZXJkb3duXCIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgdmFyIF9hID0gX3RoaXMuZ2V0UHJvcHMoKSwgZHJhZyA9IF9hLmRyYWcsIF9iID0gX2EuZHJhZ0xpc3RlbmVyLCBkcmFnTGlzdGVuZXIgPSBfYiA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9iO1xuICAgICAgICAgICAgZHJhZyAmJiBkcmFnTGlzdGVuZXIgJiYgX3RoaXMuc3RhcnQoZXZlbnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIG1lYXN1cmVEcmFnQ29uc3RyYWludHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZHJhZ0NvbnN0cmFpbnRzID0gX3RoaXMuZ2V0UHJvcHMoKS5kcmFnQ29uc3RyYWludHM7XG4gICAgICAgICAgICBpZiAoaXNSZWZPYmplY3QoZHJhZ0NvbnN0cmFpbnRzKSkge1xuICAgICAgICAgICAgICAgIF90aGlzLmNvbnN0cmFpbnRzID0gX3RoaXMucmVzb2x2ZVJlZkNvbnN0cmFpbnRzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHZhciBwcm9qZWN0aW9uID0gdGhpcy52aXN1YWxFbGVtZW50LnByb2plY3Rpb247XG4gICAgICAgIHZhciBzdG9wTWVhc3VyZUxheW91dExpc3RlbmVyID0gcHJvamVjdGlvbi5hZGRFdmVudExpc3RlbmVyKFwibWVhc3VyZVwiLCBtZWFzdXJlRHJhZ0NvbnN0cmFpbnRzKTtcbiAgICAgICAgaWYgKHByb2plY3Rpb24gJiYgIXByb2plY3Rpb24ubGF5b3V0KSB7XG4gICAgICAgICAgICAoX2EgPSBwcm9qZWN0aW9uLnJvb3QpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS51cGRhdGVTY3JvbGwoKTtcbiAgICAgICAgICAgIHByb2plY3Rpb24udXBkYXRlTGF5b3V0KCk7XG4gICAgICAgIH1cbiAgICAgICAgbWVhc3VyZURyYWdDb25zdHJhaW50cygpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQXR0YWNoIGEgd2luZG93IHJlc2l6ZSBsaXN0ZW5lciB0byBzY2FsZSB0aGUgZHJhZ2dhYmxlIHRhcmdldCB3aXRoaW4gaXRzIGRlZmluZWRcbiAgICAgICAgICogY29uc3RyYWludHMgYXMgdGhlIHdpbmRvdyByZXNpemVzLlxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIHN0b3BSZXNpemVMaXN0ZW5lciA9IGFkZERvbUV2ZW50KHdpbmRvdywgXCJyZXNpemVcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLnNjYWxlUG9zaXRpb25XaXRoaW5Db25zdHJhaW50cygpO1xuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRoZSBlbGVtZW50J3MgbGF5b3V0IGNoYW5nZXMsIGNhbGN1bGF0ZSB0aGUgZGVsdGEgYW5kIGFwcGx5IHRoYXQgdG9cbiAgICAgICAgICogdGhlIGRyYWcgZ2VzdHVyZSdzIG9yaWdpbiBwb2ludC5cbiAgICAgICAgICovXG4gICAgICAgIHByb2plY3Rpb24uYWRkRXZlbnRMaXN0ZW5lcihcImRpZFVwZGF0ZVwiLCAoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgZGVsdGEgPSBfYS5kZWx0YSwgaGFzTGF5b3V0Q2hhbmdlZCA9IF9hLmhhc0xheW91dENoYW5nZWQ7XG4gICAgICAgICAgICBpZiAoX3RoaXMuaXNEcmFnZ2luZyAmJiBoYXNMYXlvdXRDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgZWFjaEF4aXMoZnVuY3Rpb24gKGF4aXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1vdGlvblZhbHVlID0gX3RoaXMuZ2V0QXhpc01vdGlvblZhbHVlKGF4aXMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW1vdGlvblZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5vcmlnaW5Qb2ludFtheGlzXSArPSBkZWx0YVtheGlzXS50cmFuc2xhdGU7XG4gICAgICAgICAgICAgICAgICAgIG1vdGlvblZhbHVlLnNldChtb3Rpb25WYWx1ZS5nZXQoKSArIGRlbHRhW2F4aXNdLnRyYW5zbGF0ZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgX3RoaXMudmlzdWFsRWxlbWVudC5zeW5jUmVuZGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHN0b3BSZXNpemVMaXN0ZW5lcigpO1xuICAgICAgICAgICAgc3RvcFBvaW50ZXJMaXN0ZW5lcigpO1xuICAgICAgICAgICAgc3RvcE1lYXN1cmVMYXlvdXRMaXN0ZW5lcigpO1xuICAgICAgICB9O1xuICAgIH07XG4gICAgVmlzdWFsRWxlbWVudERyYWdDb250cm9scy5wcm90b3R5cGUuZ2V0UHJvcHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IHRoaXMudmlzdWFsRWxlbWVudC5nZXRQcm9wcygpO1xuICAgICAgICB2YXIgX2EgPSBwcm9wcy5kcmFnLCBkcmFnID0gX2EgPT09IHZvaWQgMCA/IGZhbHNlIDogX2EsIF9iID0gcHJvcHMuZHJhZ0RpcmVjdGlvbkxvY2ssIGRyYWdEaXJlY3Rpb25Mb2NrID0gX2IgPT09IHZvaWQgMCA/IGZhbHNlIDogX2IsIF9jID0gcHJvcHMuZHJhZ1Byb3BhZ2F0aW9uLCBkcmFnUHJvcGFnYXRpb24gPSBfYyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfYywgX2QgPSBwcm9wcy5kcmFnQ29uc3RyYWludHMsIGRyYWdDb25zdHJhaW50cyA9IF9kID09PSB2b2lkIDAgPyBmYWxzZSA6IF9kLCBfZSA9IHByb3BzLmRyYWdFbGFzdGljLCBkcmFnRWxhc3RpYyA9IF9lID09PSB2b2lkIDAgPyBkZWZhdWx0RWxhc3RpYyA6IF9lLCBfZiA9IHByb3BzLmRyYWdNb21lbnR1bSwgZHJhZ01vbWVudHVtID0gX2YgPT09IHZvaWQgMCA/IHRydWUgOiBfZjtcbiAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBwcm9wcyksIHsgZHJhZzogZHJhZywgZHJhZ0RpcmVjdGlvbkxvY2s6IGRyYWdEaXJlY3Rpb25Mb2NrLCBkcmFnUHJvcGFnYXRpb246IGRyYWdQcm9wYWdhdGlvbiwgZHJhZ0NvbnN0cmFpbnRzOiBkcmFnQ29uc3RyYWludHMsIGRyYWdFbGFzdGljOiBkcmFnRWxhc3RpYywgZHJhZ01vbWVudHVtOiBkcmFnTW9tZW50dW0gfSk7XG4gICAgfTtcbiAgICByZXR1cm4gVmlzdWFsRWxlbWVudERyYWdDb250cm9scztcbn0oKSk7XG5mdW5jdGlvbiBzaG91bGREcmFnKGRpcmVjdGlvbiwgZHJhZywgY3VycmVudERpcmVjdGlvbikge1xuICAgIHJldHVybiAoKGRyYWcgPT09IHRydWUgfHwgZHJhZyA9PT0gZGlyZWN0aW9uKSAmJlxuICAgICAgICAoY3VycmVudERpcmVjdGlvbiA9PT0gbnVsbCB8fCBjdXJyZW50RGlyZWN0aW9uID09PSBkaXJlY3Rpb24pKTtcbn1cbi8qKlxuICogQmFzZWQgb24gYW4geC95IG9mZnNldCBkZXRlcm1pbmUgdGhlIGN1cnJlbnQgZHJhZyBkaXJlY3Rpb24uIElmIGJvdGggYXhpcycgb2Zmc2V0cyBhcmUgbG93ZXJcbiAqIHRoYW4gdGhlIHByb3ZpZGVkIHRocmVzaG9sZCwgcmV0dXJuIGBudWxsYC5cbiAqXG4gKiBAcGFyYW0gb2Zmc2V0IC0gVGhlIHgveSBvZmZzZXQgZnJvbSBvcmlnaW4uXG4gKiBAcGFyYW0gbG9ja1RocmVzaG9sZCAtIChPcHRpb25hbCkgLSB0aGUgbWluaW11bSBhYnNvbHV0ZSBvZmZzZXQgYmVmb3JlIHdlIGNhbiBkZXRlcm1pbmUgYSBkcmFnIGRpcmVjdGlvbi5cbiAqL1xuZnVuY3Rpb24gZ2V0Q3VycmVudERpcmVjdGlvbihvZmZzZXQsIGxvY2tUaHJlc2hvbGQpIHtcbiAgICBpZiAobG9ja1RocmVzaG9sZCA9PT0gdm9pZCAwKSB7IGxvY2tUaHJlc2hvbGQgPSAxMDsgfVxuICAgIHZhciBkaXJlY3Rpb24gPSBudWxsO1xuICAgIGlmIChNYXRoLmFicyhvZmZzZXQueSkgPiBsb2NrVGhyZXNob2xkKSB7XG4gICAgICAgIGRpcmVjdGlvbiA9IFwieVwiO1xuICAgIH1cbiAgICBlbHNlIGlmIChNYXRoLmFicyhvZmZzZXQueCkgPiBsb2NrVGhyZXNob2xkKSB7XG4gICAgICAgIGRpcmVjdGlvbiA9IFwieFwiO1xuICAgIH1cbiAgICByZXR1cm4gZGlyZWN0aW9uO1xufVxuXG5leHBvcnQgeyBWaXN1YWxFbGVtZW50RHJhZ0NvbnRyb2xzLCBlbGVtZW50RHJhZ0NvbnRyb2xzIH07XG4iLCJpbXBvcnQgeyB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBWaXN1YWxFbGVtZW50RHJhZ0NvbnRyb2xzIH0gZnJvbSAnLi9WaXN1YWxFbGVtZW50RHJhZ0NvbnRyb2xzLm1qcyc7XG5pbXBvcnQgeyB1c2VDb25zdGFudCB9IGZyb20gJy4uLy4uL3V0aWxzL3VzZS1jb25zdGFudC5tanMnO1xuXG4vKipcbiAqIEEgaG9vayB0aGF0IGFsbG93cyBhbiBlbGVtZW50IHRvIGJlIGRyYWdnZWQuXG4gKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIHVzZURyYWcocHJvcHMpIHtcbiAgICB2YXIgZ3JvdXBEcmFnQ29udHJvbHMgPSBwcm9wcy5kcmFnQ29udHJvbHMsIHZpc3VhbEVsZW1lbnQgPSBwcm9wcy52aXN1YWxFbGVtZW50O1xuICAgIHZhciBkcmFnQ29udHJvbHMgPSB1c2VDb25zdGFudChmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgVmlzdWFsRWxlbWVudERyYWdDb250cm9scyh2aXN1YWxFbGVtZW50KTsgfSk7XG4gICAgLy8gSWYgd2UndmUgYmVlbiBwcm92aWRlZCBhIERyYWdDb250cm9scyBmb3IgbWFudWFsIGNvbnRyb2wgb3ZlciB0aGUgZHJhZyBnZXN0dXJlLFxuICAgIC8vIHN1YnNjcmliZSB0aGlzIGNvbXBvbmVudCB0byBpdCBvbiBtb3VudC5cbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkgeyByZXR1cm4gZ3JvdXBEcmFnQ29udHJvbHMgJiYgZ3JvdXBEcmFnQ29udHJvbHMuc3Vic2NyaWJlKGRyYWdDb250cm9scyk7IH0sIFtkcmFnQ29udHJvbHMsIGdyb3VwRHJhZ0NvbnRyb2xzXSk7XG4gICAgLy8gQXBwbHkgdGhlIGV2ZW50IGxpc3RlbmVycyB0byB0aGUgZWxlbWVudFxuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7IHJldHVybiBkcmFnQ29udHJvbHMuYWRkTGlzdGVuZXJzKCk7IH0sIFtkcmFnQ29udHJvbHNdKTtcbn1cblxuZXhwb3J0IHsgdXNlRHJhZyB9O1xuIiwiaW1wb3J0IHsgdXNlUmVmLCB1c2VDb250ZXh0LCB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBNb3Rpb25Db25maWdDb250ZXh0IH0gZnJvbSAnLi4vY29udGV4dC9Nb3Rpb25Db25maWdDb250ZXh0Lm1qcyc7XG5pbXBvcnQgeyB1c2VVbm1vdW50RWZmZWN0IH0gZnJvbSAnLi4vdXRpbHMvdXNlLXVubW91bnQtZWZmZWN0Lm1qcyc7XG5pbXBvcnQgeyB1c2VQb2ludGVyRXZlbnQgfSBmcm9tICcuLi9ldmVudHMvdXNlLXBvaW50ZXItZXZlbnQubWpzJztcbmltcG9ydCB7IFBhblNlc3Npb24gfSBmcm9tICcuL1BhblNlc3Npb24ubWpzJztcblxuLyoqXG4gKlxuICogQHBhcmFtIGhhbmRsZXJzIC1cbiAqIEBwYXJhbSByZWYgLVxuICpcbiAqIEBwcml2YXRlUmVtYXJrc1xuICogQ3VycmVudGx5IHRoaXMgc2V0cyBuZXcgcGFuIGdlc3R1cmUgZnVuY3Rpb25zIGV2ZXJ5IHJlbmRlci4gVGhlIG1lbW8gcm91dGUgaGFzIGJlZW4gZXhwbG9yZWRcbiAqIGluIHRoZSBwYXN0IGJ1dCB1bHRpbWF0ZWx5IHdlJ3JlIHN0aWxsIGNyZWF0aW5nIG5ldyBmdW5jdGlvbnMgZXZlcnkgcmVuZGVyLiBBbiBvcHRpbWlzYXRpb25cbiAqIHRvIGV4cGxvcmUgaXMgY3JlYXRpbmcgdGhlIHBhbiBnZXN0dXJlcyBhbmQgbG9hZGluZyB0aGVtIGludG8gYSBgcmVmYC5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gdXNlUGFuR2VzdHVyZShfYSkge1xuICAgIHZhciBvblBhbiA9IF9hLm9uUGFuLCBvblBhblN0YXJ0ID0gX2Eub25QYW5TdGFydCwgb25QYW5FbmQgPSBfYS5vblBhbkVuZCwgb25QYW5TZXNzaW9uU3RhcnQgPSBfYS5vblBhblNlc3Npb25TdGFydCwgdmlzdWFsRWxlbWVudCA9IF9hLnZpc3VhbEVsZW1lbnQ7XG4gICAgdmFyIGhhc1BhbkV2ZW50cyA9IG9uUGFuIHx8IG9uUGFuU3RhcnQgfHwgb25QYW5FbmQgfHwgb25QYW5TZXNzaW9uU3RhcnQ7XG4gICAgdmFyIHBhblNlc3Npb24gPSB1c2VSZWYobnVsbCk7XG4gICAgdmFyIHRyYW5zZm9ybVBhZ2VQb2ludCA9IHVzZUNvbnRleHQoTW90aW9uQ29uZmlnQ29udGV4dCkudHJhbnNmb3JtUGFnZVBvaW50O1xuICAgIHZhciBoYW5kbGVycyA9IHtcbiAgICAgICAgb25TZXNzaW9uU3RhcnQ6IG9uUGFuU2Vzc2lvblN0YXJ0LFxuICAgICAgICBvblN0YXJ0OiBvblBhblN0YXJ0LFxuICAgICAgICBvbk1vdmU6IG9uUGFuLFxuICAgICAgICBvbkVuZDogZnVuY3Rpb24gKGV2ZW50LCBpbmZvKSB7XG4gICAgICAgICAgICBwYW5TZXNzaW9uLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICAgICAgb25QYW5FbmQgJiYgb25QYW5FbmQoZXZlbnQsIGluZm8pO1xuICAgICAgICB9LFxuICAgIH07XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHBhblNlc3Npb24uY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcGFuU2Vzc2lvbi5jdXJyZW50LnVwZGF0ZUhhbmRsZXJzKGhhbmRsZXJzKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGZ1bmN0aW9uIG9uUG9pbnRlckRvd24oZXZlbnQpIHtcbiAgICAgICAgcGFuU2Vzc2lvbi5jdXJyZW50ID0gbmV3IFBhblNlc3Npb24oZXZlbnQsIGhhbmRsZXJzLCB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1QYWdlUG9pbnQ6IHRyYW5zZm9ybVBhZ2VQb2ludCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHVzZVBvaW50ZXJFdmVudCh2aXN1YWxFbGVtZW50LCBcInBvaW50ZXJkb3duXCIsIGhhc1BhbkV2ZW50cyAmJiBvblBvaW50ZXJEb3duKTtcbiAgICB1c2VVbm1vdW50RWZmZWN0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIHBhblNlc3Npb24uY3VycmVudCAmJiBwYW5TZXNzaW9uLmN1cnJlbnQuZW5kKCk7IH0pO1xufVxuXG5leHBvcnQgeyB1c2VQYW5HZXN0dXJlIH07XG4iLCJpbXBvcnQgeyB1c2VEcmFnIH0gZnJvbSAnLi4vLi4vZ2VzdHVyZXMvZHJhZy91c2UtZHJhZy5tanMnO1xuaW1wb3J0IHsgdXNlUGFuR2VzdHVyZSB9IGZyb20gJy4uLy4uL2dlc3R1cmVzL3VzZS1wYW4tZ2VzdHVyZS5tanMnO1xuaW1wb3J0IHsgbWFrZVJlbmRlcmxlc3NDb21wb25lbnQgfSBmcm9tICcuLi91dGlscy9tYWtlLXJlbmRlcmxlc3MtY29tcG9uZW50Lm1qcyc7XG5cbnZhciBkcmFnID0ge1xuICAgIHBhbjogbWFrZVJlbmRlcmxlc3NDb21wb25lbnQodXNlUGFuR2VzdHVyZSksXG4gICAgZHJhZzogbWFrZVJlbmRlcmxlc3NDb21wb25lbnQodXNlRHJhZyksXG59O1xuXG5leHBvcnQgeyBkcmFnIH07XG4iLCJpbXBvcnQgeyBfX3NwcmVhZEFycmF5LCBfX3JlYWQgfSBmcm9tICd0c2xpYic7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb25NYW5hZ2VyIH0gZnJvbSAnLi4vLi4vdXRpbHMvc3Vic2NyaXB0aW9uLW1hbmFnZXIubWpzJztcblxudmFyIG5hbWVzID0gW1xuICAgIFwiTGF5b3V0TWVhc3VyZVwiLFxuICAgIFwiQmVmb3JlTGF5b3V0TWVhc3VyZVwiLFxuICAgIFwiTGF5b3V0VXBkYXRlXCIsXG4gICAgXCJWaWV3cG9ydEJveFVwZGF0ZVwiLFxuICAgIFwiVXBkYXRlXCIsXG4gICAgXCJSZW5kZXJcIixcbiAgICBcIkFuaW1hdGlvbkNvbXBsZXRlXCIsXG4gICAgXCJMYXlvdXRBbmltYXRpb25Db21wbGV0ZVwiLFxuICAgIFwiQW5pbWF0aW9uU3RhcnRcIixcbiAgICBcIkxheW91dEFuaW1hdGlvblN0YXJ0XCIsXG4gICAgXCJTZXRBeGlzVGFyZ2V0XCIsXG4gICAgXCJVbm1vdW50XCIsXG5dO1xuZnVuY3Rpb24gY3JlYXRlTGlmZWN5Y2xlcygpIHtcbiAgICB2YXIgbWFuYWdlcnMgPSBuYW1lcy5tYXAoZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IFN1YnNjcmlwdGlvbk1hbmFnZXIoKTsgfSk7XG4gICAgdmFyIHByb3BTdWJzY3JpcHRpb25zID0ge307XG4gICAgdmFyIGxpZmVjeWNsZXMgPSB7XG4gICAgICAgIGNsZWFyQWxsTGlzdGVuZXJzOiBmdW5jdGlvbiAoKSB7IHJldHVybiBtYW5hZ2Vycy5mb3JFYWNoKGZ1bmN0aW9uIChtYW5hZ2VyKSB7IHJldHVybiBtYW5hZ2VyLmNsZWFyKCk7IH0pOyB9LFxuICAgICAgICB1cGRhdGVQcm9wTGlzdGVuZXJzOiBmdW5jdGlvbiAocHJvcHMpIHtcbiAgICAgICAgICAgIG5hbWVzLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgdmFyIG9uID0gXCJvblwiICsgbmFtZTtcbiAgICAgICAgICAgICAgICB2YXIgcHJvcExpc3RlbmVyID0gcHJvcHNbb25dO1xuICAgICAgICAgICAgICAgIC8vIFVuc3Vic2NyaWJlIGV4aXN0aW5nIHN1YnNjcmlwdGlvblxuICAgICAgICAgICAgICAgIChfYSA9IHByb3BTdWJzY3JpcHRpb25zW25hbWVdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChwcm9wU3Vic2NyaXB0aW9ucyk7XG4gICAgICAgICAgICAgICAgLy8gQWRkIG5ldyBzdWJzY3JpcHRpb25cbiAgICAgICAgICAgICAgICBpZiAocHJvcExpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3BTdWJzY3JpcHRpb25zW25hbWVdID0gbGlmZWN5Y2xlc1tvbl0ocHJvcExpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICB9O1xuICAgIG1hbmFnZXJzLmZvckVhY2goZnVuY3Rpb24gKG1hbmFnZXIsIGkpIHtcbiAgICAgICAgbGlmZWN5Y2xlc1tcIm9uXCIgKyBuYW1lc1tpXV0gPSBmdW5jdGlvbiAoaGFuZGxlcikgeyByZXR1cm4gbWFuYWdlci5hZGQoaGFuZGxlcik7IH07XG4gICAgICAgIGxpZmVjeWNsZXNbXCJub3RpZnlcIiArIG5hbWVzW2ldXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtYW5hZ2VyLm5vdGlmeS5hcHBseShtYW5hZ2VyLCBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQoYXJncyksIGZhbHNlKSk7XG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIGxpZmVjeWNsZXM7XG59XG5cbmV4cG9ydCB7IGNyZWF0ZUxpZmVjeWNsZXMgfTtcbiIsImltcG9ydCB7IHdhcm5PbmNlIH0gZnJvbSAnLi4vLi4vdXRpbHMvd2Fybi1vbmNlLm1qcyc7XG5pbXBvcnQgeyBtb3Rpb25WYWx1ZSB9IGZyb20gJy4uLy4uL3ZhbHVlL2luZGV4Lm1qcyc7XG5pbXBvcnQgeyBpc01vdGlvblZhbHVlIH0gZnJvbSAnLi4vLi4vdmFsdWUvdXRpbHMvaXMtbW90aW9uLXZhbHVlLm1qcyc7XG5cbmZ1bmN0aW9uIHVwZGF0ZU1vdGlvblZhbHVlc0Zyb21Qcm9wcyhlbGVtZW50LCBuZXh0LCBwcmV2KSB7XG4gICAgdmFyIF9hO1xuICAgIGZvciAodmFyIGtleSBpbiBuZXh0KSB7XG4gICAgICAgIHZhciBuZXh0VmFsdWUgPSBuZXh0W2tleV07XG4gICAgICAgIHZhciBwcmV2VmFsdWUgPSBwcmV2W2tleV07XG4gICAgICAgIGlmIChpc01vdGlvblZhbHVlKG5leHRWYWx1ZSkpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgdGhpcyBpcyBhIG1vdGlvbiB2YWx1ZSBmb3VuZCBpbiBwcm9wcyBvciBzdHlsZSwgd2Ugd2FudCB0byBhZGQgaXRcbiAgICAgICAgICAgICAqIHRvIG91ciB2aXN1YWwgZWxlbWVudCdzIG1vdGlvbiB2YWx1ZSBtYXAuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGVsZW1lbnQuYWRkVmFsdWUoa2V5LCBuZXh0VmFsdWUpO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDaGVjayB0aGUgdmVyc2lvbiBvZiB0aGUgaW5jb21pbmcgbW90aW9uIHZhbHVlIHdpdGggdGhpcyB2ZXJzaW9uXG4gICAgICAgICAgICAgKiBhbmQgd2FybiBhZ2FpbnN0IG1pc21hdGNoZXMuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJkZXZlbG9wbWVudFwiKSB7XG4gICAgICAgICAgICAgICAgd2Fybk9uY2UobmV4dFZhbHVlLnZlcnNpb24gPT09IFwiNi41LjFcIiwgXCJBdHRlbXB0aW5nIHRvIG1peCBGcmFtZXIgTW90aW9uIHZlcnNpb25zIFwiLmNvbmNhdChuZXh0VmFsdWUudmVyc2lvbiwgXCIgd2l0aCA2LjUuMSBtYXkgbm90IHdvcmsgYXMgZXhwZWN0ZWQuXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc01vdGlvblZhbHVlKHByZXZWYWx1ZSkpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgd2UncmUgc3dhcHBpbmcgdG8gYSBuZXcgbW90aW9uIHZhbHVlLCBjcmVhdGUgYSBuZXcgbW90aW9uIHZhbHVlXG4gICAgICAgICAgICAgKiBmcm9tIHRoYXRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZWxlbWVudC5hZGRWYWx1ZShrZXksIG1vdGlvblZhbHVlKG5leHRWYWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByZXZWYWx1ZSAhPT0gbmV4dFZhbHVlKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElmIHRoaXMgaXMgYSBmbGF0IHZhbHVlIHRoYXQgaGFzIGNoYW5nZWQsIHVwZGF0ZSB0aGUgbW90aW9uIHZhbHVlXG4gICAgICAgICAgICAgKiBvciBjcmVhdGUgb25lIGlmIGl0IGRvZXNuJ3QgZXhpc3QuIFdlIG9ubHkgd2FudCB0byBkbyB0aGlzIGlmIHdlJ3JlXG4gICAgICAgICAgICAgKiBub3QgaGFuZGxpbmcgdGhlIHZhbHVlIHdpdGggb3VyIGFuaW1hdGlvbiBzdGF0ZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQuaGFzVmFsdWUoa2V5KSkge1xuICAgICAgICAgICAgICAgIHZhciBleGlzdGluZ1ZhbHVlID0gZWxlbWVudC5nZXRWYWx1ZShrZXkpO1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IE9ubHkgdXBkYXRlIHZhbHVlcyB0aGF0IGFyZW4ndCBiZWluZyBhbmltYXRlZCBvciBldmVuIGxvb2tlZCBhdFxuICAgICAgICAgICAgICAgICFleGlzdGluZ1ZhbHVlLmhhc0FuaW1hdGVkICYmIGV4aXN0aW5nVmFsdWUuc2V0KG5leHRWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LmFkZFZhbHVlKGtleSwgbW90aW9uVmFsdWUoKF9hID0gZWxlbWVudC5nZXRTdGF0aWNWYWx1ZShrZXkpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBuZXh0VmFsdWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBIYW5kbGUgcmVtb3ZlZCB2YWx1ZXNcbiAgICBmb3IgKHZhciBrZXkgaW4gcHJldikge1xuICAgICAgICBpZiAobmV4dFtrZXldID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBlbGVtZW50LnJlbW92ZVZhbHVlKGtleSk7XG4gICAgfVxuICAgIHJldHVybiBuZXh0O1xufVxuXG5leHBvcnQgeyB1cGRhdGVNb3Rpb25WYWx1ZXNGcm9tUHJvcHMgfTtcbiIsImltcG9ydCB7IF9fYXNzaWduLCBfX3NwcmVhZEFycmF5LCBfX3JlYWQgfSBmcm9tICd0c2xpYic7XG5pbXBvcnQgc3luYywgeyBjYW5jZWxTeW5jIH0gZnJvbSAnZnJhbWVzeW5jJztcbmltcG9ydCB7IG1vdGlvblZhbHVlIH0gZnJvbSAnLi4vdmFsdWUvaW5kZXgubWpzJztcbmltcG9ydCB7IGlzTW90aW9uVmFsdWUgfSBmcm9tICcuLi92YWx1ZS91dGlscy9pcy1tb3Rpb24tdmFsdWUubWpzJztcbmltcG9ydCB7IHZhcmlhbnRQcmlvcml0eU9yZGVyIH0gZnJvbSAnLi91dGlscy9hbmltYXRpb24tc3RhdGUubWpzJztcbmltcG9ydCB7IGNyZWF0ZUxpZmVjeWNsZXMgfSBmcm9tICcuL3V0aWxzL2xpZmVjeWNsZXMubWpzJztcbmltcG9ydCB7IHVwZGF0ZU1vdGlvblZhbHVlc0Zyb21Qcm9wcyB9IGZyb20gJy4vdXRpbHMvbW90aW9uLXZhbHVlcy5tanMnO1xuaW1wb3J0IHsgY2hlY2tJZkNvbnRyb2xsaW5nVmFyaWFudHMsIGNoZWNrSWZWYXJpYW50Tm9kZSwgaXNWYXJpYW50TGFiZWwgfSBmcm9tICcuL3V0aWxzL3ZhcmlhbnRzLm1qcyc7XG5cbnZhciB2aXN1YWxFbGVtZW50ID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgdmFyIF9iID0gX2EudHJlZVR5cGUsIHRyZWVUeXBlID0gX2IgPT09IHZvaWQgMCA/IFwiXCIgOiBfYiwgYnVpbGQgPSBfYS5idWlsZCwgZ2V0QmFzZVRhcmdldCA9IF9hLmdldEJhc2VUYXJnZXQsIG1ha2VUYXJnZXRBbmltYXRhYmxlID0gX2EubWFrZVRhcmdldEFuaW1hdGFibGUsIG1lYXN1cmVWaWV3cG9ydEJveCA9IF9hLm1lYXN1cmVWaWV3cG9ydEJveCwgcmVuZGVySW5zdGFuY2UgPSBfYS5yZW5kZXIsIHJlYWRWYWx1ZUZyb21JbnN0YW5jZSA9IF9hLnJlYWRWYWx1ZUZyb21JbnN0YW5jZSwgcmVtb3ZlVmFsdWVGcm9tUmVuZGVyU3RhdGUgPSBfYS5yZW1vdmVWYWx1ZUZyb21SZW5kZXJTdGF0ZSwgc29ydE5vZGVQb3NpdGlvbiA9IF9hLnNvcnROb2RlUG9zaXRpb24sIHNjcmFwZU1vdGlvblZhbHVlc0Zyb21Qcm9wcyA9IF9hLnNjcmFwZU1vdGlvblZhbHVlc0Zyb21Qcm9wcztcbiAgICByZXR1cm4gZnVuY3Rpb24gKF9hLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBwYXJlbnQgPSBfYS5wYXJlbnQsIHByb3BzID0gX2EucHJvcHMsIHByZXNlbmNlSWQgPSBfYS5wcmVzZW5jZUlkLCBibG9ja0luaXRpYWxBbmltYXRpb24gPSBfYS5ibG9ja0luaXRpYWxBbmltYXRpb24sIHZpc3VhbFN0YXRlID0gX2EudmlzdWFsU3RhdGUsIHNob3VsZFJlZHVjZU1vdGlvbiA9IF9hLnNob3VsZFJlZHVjZU1vdGlvbjtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAgICAgdmFyIGlzTW91bnRlZCA9IGZhbHNlO1xuICAgICAgICB2YXIgbGF0ZXN0VmFsdWVzID0gdmlzdWFsU3RhdGUubGF0ZXN0VmFsdWVzLCByZW5kZXJTdGF0ZSA9IHZpc3VhbFN0YXRlLnJlbmRlclN0YXRlO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGluc3RhbmNlIG9mIHRoZSByZW5kZXItc3BlY2lmaWMgbm9kZSB0aGF0IHdpbGwgYmUgaHlkcmF0ZWQgYnkgdGhlXG4gICAgICAgICAqIGV4cG9zZWQgUmVhY3QgcmVmLiBTbyBmb3IgZXhhbXBsZSwgdGhpcyB2aXN1YWwgZWxlbWVudCBjYW4gaG9zdCBhXG4gICAgICAgICAqIEhUTUxFbGVtZW50LCBwbGFpbiBvYmplY3QsIG9yIFRocmVlLmpzIG9iamVjdC4gVGhlIGZ1bmN0aW9ucyBwcm92aWRlZFxuICAgICAgICAgKiBpbiBWaXN1YWxFbGVtZW50Q29uZmlnIGFsbG93IHVzIHRvIGludGVyZmFjZSB3aXRoIHRoaXMgaW5zdGFuY2UuXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgaW5zdGFuY2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYW5hZ2VzIHRoZSBzdWJzY3JpcHRpb25zIGZvciBhIHZpc3VhbCBlbGVtZW50J3MgbGlmZWN5Y2xlLCBmb3IgaW5zdGFuY2VcbiAgICAgICAgICogb25SZW5kZXJcbiAgICAgICAgICovXG4gICAgICAgIHZhciBsaWZlY3ljbGVzID0gY3JlYXRlTGlmZWN5Y2xlcygpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBtYXAgb2YgYWxsIG1vdGlvbiB2YWx1ZXMgYXR0YWNoZWQgdG8gdGhpcyB2aXN1YWwgZWxlbWVudC4gTW90aW9uXG4gICAgICAgICAqIHZhbHVlcyBhcmUgc291cmNlIG9mIHRydXRoIGZvciBhbnkgZ2l2ZW4gYW5pbWF0ZWQgdmFsdWUuIEEgbW90aW9uXG4gICAgICAgICAqIHZhbHVlIG1pZ2h0IGJlIHByb3ZpZGVkIGV4dGVybmFsbHkgYnkgdGhlIGNvbXBvbmVudCB2aWEgcHJvcHMuXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgdmFsdWVzID0gbmV3IE1hcCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBtYXAgb2YgZXZlcnkgc3Vic2NyaXB0aW9uIHRoYXQgYmluZHMgdGhlIHByb3ZpZGVkIG9yIGdlbmVyYXRlZFxuICAgICAgICAgKiBtb3Rpb24gdmFsdWVzIG9uQ2hhbmdlIGxpc3RlbmVycyB0byB0aGlzIHZpc3VhbCBlbGVtZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIHZhbHVlU3Vic2NyaXB0aW9ucyA9IG5ldyBNYXAoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgcmVmZXJlbmNlIHRvIHRoZSBwcmV2aW91c2x5LXByb3ZpZGVkIG1vdGlvbiB2YWx1ZXMgYXMgcmV0dXJuZWRcbiAgICAgICAgICogZnJvbSBzY3JhcGVNb3Rpb25WYWx1ZXNGcm9tUHJvcHMuIFdlIHVzZSB0aGUga2V5cyBpbiBoZXJlIHRvIGRldGVybWluZVxuICAgICAgICAgKiBpZiBhbnkgbW90aW9uIHZhbHVlcyBuZWVkIHRvIGJlIHJlbW92ZWQgYWZ0ZXIgcHJvcHMgYXJlIHVwZGF0ZWQuXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgcHJldk1vdGlvblZhbHVlcyA9IHt9O1xuICAgICAgICAvKipcbiAgICAgICAgICogV2hlbiB2YWx1ZXMgYXJlIHJlbW92ZWQgZnJvbSBhbGwgYW5pbWF0aW9uIHByb3BzIHdlIG5lZWQgdG8gc2VhcmNoXG4gICAgICAgICAqIGZvciBhIGZhbGxiYWNrIHZhbHVlIHRvIGFuaW1hdGUgdG8uIFRoZXNlIHZhbHVlcyBhcmUgdHJhY2tlZCBpbiBiYXNlVGFyZ2V0LlxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIGJhc2VUYXJnZXQgPSBfX2Fzc2lnbih7fSwgbGF0ZXN0VmFsdWVzKTtcbiAgICAgICAgLy8gSW50ZXJuYWwgbWV0aG9kcyA9PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9uIG1vdW50LCB0aGlzIHdpbGwgYmUgaHlkcmF0ZWQgd2l0aCBhIGNhbGxiYWNrIHRvIGRpc2Nvbm5lY3RcbiAgICAgICAgICogdGhpcyB2aXN1YWwgZWxlbWVudCBmcm9tIGl0cyBwYXJlbnQgb24gdW5tb3VudC5cbiAgICAgICAgICovXG4gICAgICAgIHZhciByZW1vdmVGcm9tVmFyaWFudFRyZWU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW5kZXIgdGhlIGVsZW1lbnQgd2l0aCB0aGUgbGF0ZXN0IHN0eWxlcyBvdXRzaWRlIG9mIHRoZSBSZWFjdFxuICAgICAgICAgKiByZW5kZXIgbGlmZWN5Y2xlXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICAgICAgICBpZiAoIWluc3RhbmNlIHx8ICFpc01vdW50ZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdHJpZ2dlckJ1aWxkKCk7XG4gICAgICAgICAgICByZW5kZXJJbnN0YW5jZShpbnN0YW5jZSwgcmVuZGVyU3RhdGUsIHByb3BzLnN0eWxlLCBlbGVtZW50LnByb2plY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHRyaWdnZXJCdWlsZCgpIHtcbiAgICAgICAgICAgIGJ1aWxkKGVsZW1lbnQsIHJlbmRlclN0YXRlLCBsYXRlc3RWYWx1ZXMsIG9wdGlvbnMsIHByb3BzKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgICAgICAgICBsaWZlY3ljbGVzLm5vdGlmeVVwZGF0ZShsYXRlc3RWYWx1ZXMpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gYmluZFRvTW90aW9uVmFsdWUoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIHJlbW92ZU9uQ2hhbmdlID0gdmFsdWUub25DaGFuZ2UoZnVuY3Rpb24gKGxhdGVzdFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgbGF0ZXN0VmFsdWVzW2tleV0gPSBsYXRlc3RWYWx1ZTtcbiAgICAgICAgICAgICAgICBwcm9wcy5vblVwZGF0ZSAmJiBzeW5jLnVwZGF0ZSh1cGRhdGUsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIHJlbW92ZU9uUmVuZGVyUmVxdWVzdCA9IHZhbHVlLm9uUmVuZGVyUmVxdWVzdChlbGVtZW50LnNjaGVkdWxlUmVuZGVyKTtcbiAgICAgICAgICAgIHZhbHVlU3Vic2NyaXB0aW9ucy5zZXQoa2V5LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlT25DaGFuZ2UoKTtcbiAgICAgICAgICAgICAgICByZW1vdmVPblJlbmRlclJlcXVlc3QoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbnkgbW90aW9uIHZhbHVlcyB0aGF0IGFyZSBwcm92aWRlZCB0byB0aGUgZWxlbWVudCB3aGVuIGNyZWF0ZWRcbiAgICAgICAgICogYXJlbid0IHlldCBib3VuZCB0byB0aGUgZWxlbWVudCwgYXMgdGhpcyB3b3VsZCB0ZWNobmljYWxseSBiZSBpbXB1cmUuXG4gICAgICAgICAqIEhvd2V2ZXIsIHdlIGl0ZXJhdGUgdGhyb3VnaCB0aGUgbW90aW9uIHZhbHVlcyBhbmQgc2V0IHRoZW0gdG8gdGhlXG4gICAgICAgICAqIGluaXRpYWwgdmFsdWVzIGZvciB0aGlzIGNvbXBvbmVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogVE9ETzogVGhpcyBpcyBpbXB1cmUgYW5kIHdlIHNob3VsZCBsb29rIGF0IGNoYW5naW5nIHRoaXMgdG8gcnVuIG9uIG1vdW50LlxuICAgICAgICAgKiBEb2luZyBzbyB3aWxsIGJyZWFrIHNvbWUgdGVzdHMgYnV0IHRoaXMgaXNuJ3QgbmVjY2Vzc2FyaWx5IGEgYnJlYWtpbmcgY2hhbmdlLFxuICAgICAgICAgKiBtb3JlIGEgcmVmbGVjdGlvbiBvZiB0aGUgdGVzdC5cbiAgICAgICAgICovXG4gICAgICAgIHZhciBpbml0aWFsTW90aW9uVmFsdWVzID0gc2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzKHByb3BzKTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIGluaXRpYWxNb3Rpb25WYWx1ZXMpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IGluaXRpYWxNb3Rpb25WYWx1ZXNba2V5XTtcbiAgICAgICAgICAgIGlmIChsYXRlc3RWYWx1ZXNba2V5XSAhPT0gdW5kZWZpbmVkICYmIGlzTW90aW9uVmFsdWUodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUuc2V0KGxhdGVzdFZhbHVlc1trZXldLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERldGVybWluZSB3aGF0IHJvbGUgdGhpcyB2aXN1YWwgZWxlbWVudCBzaG91bGQgdGFrZSBpbiB0aGUgdmFyaWFudCB0cmVlLlxuICAgICAgICAgKi9cbiAgICAgICAgdmFyIGlzQ29udHJvbGxpbmdWYXJpYW50cyA9IGNoZWNrSWZDb250cm9sbGluZ1ZhcmlhbnRzKHByb3BzKTtcbiAgICAgICAgdmFyIGlzVmFyaWFudE5vZGUgPSBjaGVja0lmVmFyaWFudE5vZGUocHJvcHMpO1xuICAgICAgICB2YXIgZWxlbWVudCA9IF9fYXNzaWduKF9fYXNzaWduKHsgdHJlZVR5cGU6IHRyZWVUeXBlLCBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhpcyBpcyBhIG1pcnJvciBvZiB0aGUgaW50ZXJuYWwgaW5zdGFuY2UgcHJvcCwgd2hpY2gga2VlcHNcbiAgICAgICAgICAgICAqIFZpc3VhbEVsZW1lbnQgdHlwZS1jb21wYXRpYmxlIHdpdGggUmVhY3QncyBSZWZPYmplY3QuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGN1cnJlbnQ6IG51bGwsIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUaGUgZGVwdGggb2YgdGhpcyB2aXN1YWwgZWxlbWVudCB3aXRoaW4gdGhlIHZpc3VhbCBlbGVtZW50IHRyZWUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGRlcHRoOiBwYXJlbnQgPyBwYXJlbnQuZGVwdGggKyAxIDogMCwgcGFyZW50OiBwYXJlbnQsIGNoaWxkcmVuOiBuZXcgU2V0KCksIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBwcmVzZW5jZUlkOiBwcmVzZW5jZUlkLCBzaG91bGRSZWR1Y2VNb3Rpb246IHNob3VsZFJlZHVjZU1vdGlvbiwgXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElmIHRoaXMgY29tcG9uZW50IGlzIHBhcnQgb2YgdGhlIHZhcmlhbnQgdHJlZSwgaXQgc2hvdWxkIHRyYWNrXG4gICAgICAgICAgICAgKiBhbnkgY2hpbGRyZW4gdGhhdCBhcmUgYWxzbyBwYXJ0IG9mIHRoZSB0cmVlLiBUaGlzIGlzIGVzc2VudGlhbGx5XG4gICAgICAgICAgICAgKiBhIHNoYWRvdyB0cmVlIHRvIHNpbXBsaWZ5IGxvZ2ljIGFyb3VuZCBob3cgdG8gc3RhZ2dlciBvdmVyIGNoaWxkcmVuLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2YXJpYW50Q2hpbGRyZW46IGlzVmFyaWFudE5vZGUgPyBuZXcgU2V0KCkgOiB1bmRlZmluZWQsIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBXaGV0aGVyIHRoaXMgaW5zdGFuY2UgaXMgdmlzaWJsZS4gVGhpcyBjYW4gYmUgY2hhbmdlZCBpbXBlcmF0aXZlbHlcbiAgICAgICAgICAgICAqIGJ5IHRoZSBwcm9qZWN0aW9uIHRyZWUsIGlzIGFuYWxvZ291cyB0byBDU1MncyB2aXNpYmlsaXR5IGluIHRoYXRcbiAgICAgICAgICAgICAqIGhpZGRlbiBlbGVtZW50cyBzaG91bGQgdGFrZSB1cCBsYXlvdXQsIGFuZCBuZWVkcyBlbmFjdGluZyBieSB0aGUgY29uZmlndXJlZFxuICAgICAgICAgICAgICogcmVuZGVyIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpc1Zpc2libGU6IHVuZGVmaW5lZCwgXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIE5vcm1hbGx5LCBpZiBhIGNvbXBvbmVudCBpcyBjb250cm9sbGVkIGJ5IGEgcGFyZW50J3MgdmFyaWFudHMsIGl0IGNhblxuICAgICAgICAgICAgICogcmVseSBvbiB0aGF0IGFuY2VzdG9yIHRvIHRyaWdnZXIgYW5pbWF0aW9ucyBmdXJ0aGVyIGRvd24gdGhlIHRyZWUuXG4gICAgICAgICAgICAgKiBIb3dldmVyLCBpZiBhIGNvbXBvbmVudCBpcyBjcmVhdGVkIGFmdGVyIGl0cyBwYXJlbnQgaXMgbW91bnRlZCwgdGhlIHBhcmVudFxuICAgICAgICAgICAgICogd29uJ3QgdHJpZ2dlciB0aGF0IG1vdW50IGFuaW1hdGlvbiBzbyB0aGUgY2hpbGQgbmVlZHMgdG8uXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogVE9ETzogVGhpcyBtaWdodCBiZSBiZXR0ZXIgcmVwbGFjZWQgd2l0aCBhIG1ldGhvZCBpc1BhcmVudE1vdW50ZWRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgbWFudWFsbHlBbmltYXRlT25Nb3VudDogQm9vbGVhbihwYXJlbnQgPT09IG51bGwgfHwgcGFyZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJlbnQuaXNNb3VudGVkKCkpLCBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhpcyBjYW4gYmUgc2V0IGJ5IEFuaW1hdGVQcmVzZW5jZSB0byBmb3JjZSBjb21wb25lbnRzIHRoYXQgbW91bnRcbiAgICAgICAgICAgICAqIGF0IHRoZSBzYW1lIHRpbWUgYXMgaXQgdG8gbW91bnQgYXMgaWYgdGhleSBoYXZlIGluaXRpYWw9e2ZhbHNlfSBzZXQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGJsb2NrSW5pdGlhbEFuaW1hdGlvbjogYmxvY2tJbml0aWFsQW5pbWF0aW9uLCBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRGV0ZXJtaW5lIHdoZXRoZXIgdGhpcyBjb21wb25lbnQgaGFzIG1vdW50ZWQgeWV0LiBUaGlzIGlzIG1vc3RseSB1c2VkXG4gICAgICAgICAgICAgKiBieSB2YXJpYW50IGNoaWxkcmVuIHRvIGRldGVybWluZSB3aGV0aGVyIHRoZXkgbmVlZCB0byB0cmlnZ2VyIHRoZWlyXG4gICAgICAgICAgICAgKiBvd24gYW5pbWF0aW9ucyBvbiBtb3VudC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaXNNb3VudGVkOiBmdW5jdGlvbiAoKSB7IHJldHVybiBCb29sZWFuKGluc3RhbmNlKTsgfSwgbW91bnQ6IGZ1bmN0aW9uIChuZXdJbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgIGlzTW91bnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgaW5zdGFuY2UgPSBlbGVtZW50LmN1cnJlbnQgPSBuZXdJbnN0YW5jZTtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5wcm9qZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQucHJvamVjdGlvbi5tb3VudChuZXdJbnN0YW5jZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc1ZhcmlhbnROb2RlICYmIHBhcmVudCAmJiAhaXNDb250cm9sbGluZ1ZhcmlhbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZUZyb21WYXJpYW50VHJlZSA9IHBhcmVudCA9PT0gbnVsbCB8fCBwYXJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmVudC5hZGRWYXJpYW50Q2hpbGQoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7IHJldHVybiBiaW5kVG9Nb3Rpb25WYWx1ZShrZXksIHZhbHVlKTsgfSk7XG4gICAgICAgICAgICAgICAgcGFyZW50ID09PSBudWxsIHx8IHBhcmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFyZW50LmNoaWxkcmVuLmFkZChlbGVtZW50KTtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnNldFByb3BzKHByb3BzKTtcbiAgICAgICAgICAgIH0sIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB1bm1vdW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIChfYSA9IGVsZW1lbnQucHJvamVjdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnVubW91bnQoKTtcbiAgICAgICAgICAgICAgICBjYW5jZWxTeW5jLnVwZGF0ZSh1cGRhdGUpO1xuICAgICAgICAgICAgICAgIGNhbmNlbFN5bmMucmVuZGVyKHJlbmRlcik7XG4gICAgICAgICAgICAgICAgdmFsdWVTdWJzY3JpcHRpb25zLmZvckVhY2goZnVuY3Rpb24gKHJlbW92ZSkgeyByZXR1cm4gcmVtb3ZlKCk7IH0pO1xuICAgICAgICAgICAgICAgIHJlbW92ZUZyb21WYXJpYW50VHJlZSA9PT0gbnVsbCB8fCByZW1vdmVGcm9tVmFyaWFudFRyZWUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlbW92ZUZyb21WYXJpYW50VHJlZSgpO1xuICAgICAgICAgICAgICAgIHBhcmVudCA9PT0gbnVsbCB8fCBwYXJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmVudC5jaGlsZHJlbi5kZWxldGUoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgbGlmZWN5Y2xlcy5jbGVhckFsbExpc3RlbmVycygpO1xuICAgICAgICAgICAgICAgIGluc3RhbmNlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGlzTW91bnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfSwgXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEFkZCBhIGNoaWxkIHZpc3VhbCBlbGVtZW50IHRvIG91ciBzZXQgb2YgY2hpbGRyZW4uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGFkZFZhcmlhbnRDaGlsZDogZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIHZhciBjbG9zZXN0VmFyaWFudE5vZGUgPSBlbGVtZW50LmdldENsb3Nlc3RWYXJpYW50Tm9kZSgpO1xuICAgICAgICAgICAgICAgIGlmIChjbG9zZXN0VmFyaWFudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgKF9hID0gY2xvc2VzdFZhcmlhbnROb2RlLnZhcmlhbnRDaGlsZHJlbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFkZChjaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2xvc2VzdFZhcmlhbnROb2RlLnZhcmlhbnRDaGlsZHJlbi5kZWxldGUoY2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHNvcnROb2RlUG9zaXRpb246IGZ1bmN0aW9uIChvdGhlcikge1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIElmIHRoZXNlIG5vZGVzIGFyZW4ndCBldmVuIG9mIHRoZSBzYW1lIHR5cGUgd2UgY2FuJ3QgY29tcGFyZSB0aGVpciBkZXB0aC5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBpZiAoIXNvcnROb2RlUG9zaXRpb24gfHwgdHJlZVR5cGUgIT09IG90aGVyLnRyZWVUeXBlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgICAgICByZXR1cm4gc29ydE5vZGVQb3NpdGlvbihlbGVtZW50LmdldEluc3RhbmNlKCksIG90aGVyLmdldEluc3RhbmNlKCkpO1xuICAgICAgICAgICAgfSwgXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJldHVybnMgdGhlIGNsb3Nlc3QgdmFyaWFudCBub2RlIGluIHRoZSB0cmVlIHN0YXJ0aW5nIGZyb21cbiAgICAgICAgICAgICAqIHRoaXMgdmlzdWFsIGVsZW1lbnQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldENsb3Nlc3RWYXJpYW50Tm9kZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc1ZhcmlhbnROb2RlID8gZWxlbWVudCA6IHBhcmVudCA9PT0gbnVsbCB8fCBwYXJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmVudC5nZXRDbG9zZXN0VmFyaWFudE5vZGUoKTtcbiAgICAgICAgICAgIH0sIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBFeHBvc2UgdGhlIGxhdGVzdCBsYXlvdXRJZCBwcm9wLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXRMYXlvdXRJZDogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvcHMubGF5b3V0SWQ7IH0sIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGluc3RhbmNlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXRJbnN0YW5jZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gaW5zdGFuY2U7IH0sIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXQvc2V0IHRoZSBsYXRlc3Qgc3RhdGljIHZhbHVlcy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0U3RhdGljVmFsdWU6IGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIGxhdGVzdFZhbHVlc1trZXldOyB9LCBzZXRTdGF0aWNWYWx1ZTogZnVuY3Rpb24gKGtleSwgdmFsdWUpIHsgcmV0dXJuIChsYXRlc3RWYWx1ZXNba2V5XSA9IHZhbHVlKTsgfSwgXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJldHVybnMgdGhlIGxhdGVzdCBtb3Rpb24gdmFsdWUgc3RhdGUuIEN1cnJlbnRseSBvbmx5IHVzZWQgdG8gdGFrZVxuICAgICAgICAgICAgICogYSBzbmFwc2hvdCBvZiB0aGUgdmlzdWFsIGVsZW1lbnQgLSBwZXJoYXBzIHRoaXMgY2FuIHJldHVybiB0aGUgd2hvbGVcbiAgICAgICAgICAgICAqIHZpc3VhbCBzdGF0ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXRMYXRlc3RWYWx1ZXM6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxhdGVzdFZhbHVlczsgfSwgXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFNldCB0aGUgdmlzaWJsaXR5IG9mIHRoZSB2aXN1YWwgZWxlbWVudC4gSWYgaXQncyBjaGFuZ2VkLCBzY2hlZHVsZVxuICAgICAgICAgICAgICogYSByZW5kZXIgdG8gcmVmbGVjdCB0aGVzZSBjaGFuZ2VzLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBzZXRWaXNpYmlsaXR5OiBmdW5jdGlvbiAodmlzaWJpbGl0eSkge1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50LmlzVmlzaWJsZSA9PT0gdmlzaWJpbGl0eSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuaXNWaXNpYmxlID0gdmlzaWJpbGl0eTtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnNjaGVkdWxlUmVuZGVyKCk7XG4gICAgICAgICAgICB9LCBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogTWFrZSBhIHRhcmdldCBhbmltYXRhYmxlIGJ5IFBvcG1vdGlvbi4gRm9yIGluc3RhbmNlLCBpZiB3ZSdyZVxuICAgICAgICAgICAgICogdHJ5aW5nIHRvIGFuaW1hdGUgd2lkdGggZnJvbSAxMDBweCB0byAxMDB2dyB3ZSBuZWVkIHRvIG1lYXN1cmUgMTAwdndcbiAgICAgICAgICAgICAqIGluIHBpeGVscyB0byBkZXRlcm1pbmUgd2hhdCB3ZSByZWFsbHkgbmVlZCB0byBhbmltYXRlIHRvLiBUaGlzIGlzIGFsc29cbiAgICAgICAgICAgICAqIHBsdWdnYWJsZSB0byBzdXBwb3J0IEZyYW1lcidzIGN1c3RvbSB2YWx1ZSB0eXBlcyBsaWtlIENvbG9yLFxuICAgICAgICAgICAgICogYW5kIENTUyB2YXJpYWJsZXMuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIG1ha2VUYXJnZXRBbmltYXRhYmxlOiBmdW5jdGlvbiAodGFyZ2V0LCBjYW5NdXRhdGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2FuTXV0YXRlID09PSB2b2lkIDApIHsgY2FuTXV0YXRlID0gdHJ1ZTsgfVxuICAgICAgICAgICAgICAgIHJldHVybiBtYWtlVGFyZ2V0QW5pbWF0YWJsZShlbGVtZW50LCB0YXJnZXQsIHByb3BzLCBjYW5NdXRhdGUpO1xuICAgICAgICAgICAgfSwgXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIE1lYXN1cmUgdGhlIGN1cnJlbnQgdmlld3BvcnQgYm94IHdpdGggb3Igd2l0aG91dCB0cmFuc2Zvcm1zLlxuICAgICAgICAgICAgICogT25seSBtZWFzdXJlcyBheGlzLWFsaWduZWQgYm94ZXMsIHJvdGF0ZSBhbmQgc2tldyBtdXN0IGJlIG1hbnVhbGx5XG4gICAgICAgICAgICAgKiByZW1vdmVkIHdpdGggYSByZS1yZW5kZXIgdG8gd29yay5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgbWVhc3VyZVZpZXdwb3J0Qm94OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lYXN1cmVWaWV3cG9ydEJveChpbnN0YW5jZSwgcHJvcHMpO1xuICAgICAgICAgICAgfSwgXG4gICAgICAgICAgICAvLyBNb3Rpb24gdmFsdWVzID09PT09PT09PT09PT09PT09PT09PT09PVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBZGQgYSBtb3Rpb24gdmFsdWUgYW5kIGJpbmQgaXQgdG8gdGhpcyB2aXN1YWwgZWxlbWVudC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgYWRkVmFsdWU6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGV4aXN0aW5nIHZhbHVlIGlmIGl0IGV4aXN0c1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50Lmhhc1ZhbHVlKGtleSkpXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlVmFsdWUoa2V5KTtcbiAgICAgICAgICAgICAgICB2YWx1ZXMuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIGxhdGVzdFZhbHVlc1trZXldID0gdmFsdWUuZ2V0KCk7XG4gICAgICAgICAgICAgICAgYmluZFRvTW90aW9uVmFsdWUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9LCBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmVtb3ZlIGEgbW90aW9uIHZhbHVlIGFuZCB1bmJpbmQgYW55IGFjdGl2ZSBzdWJzY3JpcHRpb25zLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICByZW1vdmVWYWx1ZTogZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICB2YWx1ZXMuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICAgICAgKF9hID0gdmFsdWVTdWJzY3JpcHRpb25zLmdldChrZXkpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EoKTtcbiAgICAgICAgICAgICAgICB2YWx1ZVN1YnNjcmlwdGlvbnMuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGxhdGVzdFZhbHVlc1trZXldO1xuICAgICAgICAgICAgICAgIHJlbW92ZVZhbHVlRnJvbVJlbmRlclN0YXRlKGtleSwgcmVuZGVyU3RhdGUpO1xuICAgICAgICAgICAgfSwgXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENoZWNrIHdoZXRoZXIgd2UgaGF2ZSBhIG1vdGlvbiB2YWx1ZSBmb3IgdGhpcyBrZXlcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaGFzVmFsdWU6IGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIHZhbHVlcy5oYXMoa2V5KTsgfSwgXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldCBhIG1vdGlvbiB2YWx1ZSBmb3IgdGhpcyBrZXkuIElmIGNhbGxlZCB3aXRoIGEgZGVmYXVsdFxuICAgICAgICAgICAgICogdmFsdWUsIHdlJ2xsIGNyZWF0ZSBvbmUgaWYgbm9uZSBleGlzdHMuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldFZhbHVlOiBmdW5jdGlvbiAoa2V5LCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSB2YWx1ZXMuZ2V0KGtleSk7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBtb3Rpb25WYWx1ZShkZWZhdWx0VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmFkZFZhbHVlKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9LCBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSXRlcmF0ZSBvdmVyIG91ciBtb3Rpb24gdmFsdWVzLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmb3JFYWNoVmFsdWU6IGZ1bmN0aW9uIChjYWxsYmFjaykgeyByZXR1cm4gdmFsdWVzLmZvckVhY2goY2FsbGJhY2spOyB9LCBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgd2UncmUgdHJ5aW5nIHRvIGFuaW1hdGUgdG8gYSBwcmV2aW91c2x5IHVuZW5jb3VudGVyZWQgdmFsdWUsXG4gICAgICAgICAgICAgKiB3ZSBuZWVkIHRvIGNoZWNrIGZvciBpdCBpbiBvdXIgc3RhdGUgYW5kIGFzIGEgbGFzdCByZXNvcnQgcmVhZCBpdFxuICAgICAgICAgICAgICogZGlyZWN0bHkgZnJvbSB0aGUgaW5zdGFuY2UgKHdoaWNoIG1pZ2h0IGhhdmUgcGVyZm9ybWFuY2UgaW1wbGljYXRpb25zKS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgcmVhZFZhbHVlOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIHJldHVybiAoX2EgPSBsYXRlc3RWYWx1ZXNba2V5XSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogcmVhZFZhbHVlRnJvbUluc3RhbmNlKGluc3RhbmNlLCBrZXksIG9wdGlvbnMpO1xuICAgICAgICAgICAgfSwgXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFNldCB0aGUgYmFzZSB0YXJnZXQgdG8gbGF0ZXIgYW5pbWF0ZSBiYWNrIHRvLiBUaGlzIGlzIGN1cnJlbnRseVxuICAgICAgICAgICAgICogb25seSBoeWRyYXRlZCBvbiBjcmVhdGlvbiBhbmQgd2hlbiB3ZSBmaXJzdCByZWFkIGEgdmFsdWUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHNldEJhc2VUYXJnZXQ6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgYmFzZVRhcmdldFtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9LCBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRmluZCB0aGUgYmFzZSB0YXJnZXQgZm9yIGEgdmFsdWUgdGhhdHMgYmVlbiByZW1vdmVkIGZyb20gYWxsIGFuaW1hdGlvblxuICAgICAgICAgICAgICogcHJvcHMuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldEJhc2VUYXJnZXQ6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZ2V0QmFzZVRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gZ2V0QmFzZVRhcmdldChwcm9wcywga2V5KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldCAhPT0gdW5kZWZpbmVkICYmICFpc01vdGlvblZhbHVlKHRhcmdldCkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYmFzZVRhcmdldFtrZXldO1xuICAgICAgICAgICAgfSB9LCBsaWZlY3ljbGVzKSwgeyBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQnVpbGQgdGhlIHJlbmRlcmVyIHN0YXRlIGJhc2VkIG9uIHRoZSBsYXRlc3QgdmlzdWFsIHN0YXRlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBidWlsZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRyaWdnZXJCdWlsZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZW5kZXJTdGF0ZTtcbiAgICAgICAgICAgIH0sIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTY2hlZHVsZSBhIHJlbmRlciBvbiB0aGUgbmV4dCBhbmltYXRpb24gZnJhbWUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHNjaGVkdWxlUmVuZGVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgc3luYy5yZW5kZXIocmVuZGVyLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgICB9LCBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU3luY2hyb25vdXNseSBmaXJlIHJlbmRlci4gSXQncyBwcmVmZXJlZCB0aGF0IHdlIGJhdGNoIHJlbmRlcnMgYnV0XG4gICAgICAgICAgICAgKiBpbiBtYW55IGNpcmN1bXN0YW5jZXMsIGxpa2UgbGF5b3V0IG1lYXN1cmVtZW50LCB3ZSBuZWVkIHRvIHJ1biB0aGlzXG4gICAgICAgICAgICAgKiBzeW5jaHJvbm91c2x5LiBIb3dldmVyIGluIHRob3NlIGluc3RhbmNlcyBvdGhlciBtZWFzdXJlcyBzaG91bGQgYmUgdGFrZW5cbiAgICAgICAgICAgICAqIHRvIGJhdGNoIHJlYWRzL3dyaXRlcy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgc3luY1JlbmRlcjogcmVuZGVyLCBcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVXBkYXRlIHRoZSBwcm92aWRlZCBwcm9wcy4gRW5zdXJlIGFueSBuZXdseS1hZGRlZCBtb3Rpb24gdmFsdWVzIGFyZVxuICAgICAgICAgICAgICogYWRkZWQgdG8gb3VyIG1hcCwgb2xkIG9uZXMgcmVtb3ZlZCwgYW5kIGxpc3RlbmVycyB1cGRhdGVkLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBzZXRQcm9wczogZnVuY3Rpb24gKG5ld1Byb3BzKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5ld1Byb3BzLnRyYW5zZm9ybVRlbXBsYXRlIHx8IHByb3BzLnRyYW5zZm9ybVRlbXBsYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuc2NoZWR1bGVSZW5kZXIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHJvcHMgPSBuZXdQcm9wcztcbiAgICAgICAgICAgICAgICBsaWZlY3ljbGVzLnVwZGF0ZVByb3BMaXN0ZW5lcnMobmV3UHJvcHMpO1xuICAgICAgICAgICAgICAgIHByZXZNb3Rpb25WYWx1ZXMgPSB1cGRhdGVNb3Rpb25WYWx1ZXNGcm9tUHJvcHMoZWxlbWVudCwgc2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzKHByb3BzKSwgcHJldk1vdGlvblZhbHVlcyk7XG4gICAgICAgICAgICB9LCBnZXRQcm9wczogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvcHM7IH0sIFxuICAgICAgICAgICAgLy8gVmFyaWFudHMgPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJldHVybnMgdGhlIHZhcmlhbnQgZGVmaW5pdGlvbiB3aXRoIGEgZ2l2ZW4gbmFtZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0VmFyaWFudDogZnVuY3Rpb24gKG5hbWUpIHsgdmFyIF9hOyByZXR1cm4gKF9hID0gcHJvcHMudmFyaWFudHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVtuYW1lXTsgfSwgXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJldHVybnMgdGhlIGRlZmluZWQgZGVmYXVsdCB0cmFuc2l0aW9uIG9uIHRoaXMgY29tcG9uZW50LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXREZWZhdWx0VHJhbnNpdGlvbjogZnVuY3Rpb24gKCkgeyByZXR1cm4gcHJvcHMudHJhbnNpdGlvbjsgfSwgZ2V0VHJhbnNmb3JtUGFnZVBvaW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3BzLnRyYW5zZm9ybVBhZ2VQb2ludDtcbiAgICAgICAgICAgIH0sIFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBVc2VkIGJ5IGNoaWxkIHZhcmlhbnQgbm9kZXMgdG8gZ2V0IHRoZSBjbG9zZXN0IGFuY2VzdG9yIHZhcmlhbnQgcHJvcHMuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldFZhcmlhbnRDb250ZXh0OiBmdW5jdGlvbiAoc3RhcnRBdFBhcmVudCkge1xuICAgICAgICAgICAgICAgIGlmIChzdGFydEF0UGFyZW50ID09PSB2b2lkIDApIHsgc3RhcnRBdFBhcmVudCA9IGZhbHNlOyB9XG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0QXRQYXJlbnQpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJlbnQgPT09IG51bGwgfHwgcGFyZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJlbnQuZ2V0VmFyaWFudENvbnRleHQoKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzQ29udHJvbGxpbmdWYXJpYW50cykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29udGV4dF8xID0gKHBhcmVudCA9PT0gbnVsbCB8fCBwYXJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmVudC5nZXRWYXJpYW50Q29udGV4dCgpKSB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BzLmluaXRpYWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dF8xLmluaXRpYWwgPSBwcm9wcy5pbml0aWFsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250ZXh0XzE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBjb250ZXh0ID0ge307XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1WYXJpYW50UHJvcHM7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmFtZV8xID0gdmFyaWFudFByb3BzW2ldO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvcCA9IHByb3BzW25hbWVfMV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1ZhcmlhbnRMYWJlbChwcm9wKSB8fCBwcm9wID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dFtuYW1lXzFdID0gcHJvcDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY29udGV4dDtcbiAgICAgICAgICAgIH0gfSk7XG4gICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH07XG59O1xudmFyIHZhcmlhbnRQcm9wcyA9IF9fc3ByZWFkQXJyYXkoW1wiaW5pdGlhbFwiXSwgX19yZWFkKHZhcmlhbnRQcmlvcml0eU9yZGVyKSwgZmFsc2UpO1xudmFyIG51bVZhcmlhbnRQcm9wcyA9IHZhcmlhbnRQcm9wcy5sZW5ndGg7XG5cbmV4cG9ydCB7IHZpc3VhbEVsZW1lbnQgfTtcbiIsImltcG9ydCB7IF9fcmVzdCwgX19hc3NpZ24sIF9fcmVhZCB9IGZyb20gJ3RzbGliJztcbmltcG9ydCB7IGludmFyaWFudCB9IGZyb20gJ2hleS1saXN0ZW4nO1xuXG5mdW5jdGlvbiBpc0NTU1ZhcmlhYmxlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZS5zdGFydHNXaXRoKFwidmFyKC0tXCIpO1xufVxuLyoqXG4gKiBQYXJzZSBGcmFtZXIncyBzcGVjaWFsIENTUyB2YXJpYWJsZSBmb3JtYXQgaW50byBhIENTUyB0b2tlbiBhbmQgYSBmYWxsYmFjay5cbiAqXG4gKiBgYGBcbiAqIGB2YXIoLS1mb28sICNmZmYpYCA9PiBbYC0tZm9vYCwgJyNmZmYnXVxuICogYGBgXG4gKlxuICogQHBhcmFtIGN1cnJlbnRcbiAqL1xudmFyIGNzc1ZhcmlhYmxlUmVnZXggPSAvdmFyXFwoKC0tW2EtekEtWjAtOS1fXSspLD8gPyhbYS16QS1aMC05ICgpJSMuLC1dKyk/XFwpLztcbmZ1bmN0aW9uIHBhcnNlQ1NTVmFyaWFibGUoY3VycmVudCkge1xuICAgIHZhciBtYXRjaCA9IGNzc1ZhcmlhYmxlUmVnZXguZXhlYyhjdXJyZW50KTtcbiAgICBpZiAoIW1hdGNoKVxuICAgICAgICByZXR1cm4gWyxdO1xuICAgIHZhciBfYSA9IF9fcmVhZChtYXRjaCwgMyksIHRva2VuID0gX2FbMV0sIGZhbGxiYWNrID0gX2FbMl07XG4gICAgcmV0dXJuIFt0b2tlbiwgZmFsbGJhY2tdO1xufVxudmFyIG1heERlcHRoID0gNDtcbmZ1bmN0aW9uIGdldFZhcmlhYmxlVmFsdWUoY3VycmVudCwgZWxlbWVudCwgZGVwdGgpIHtcbiAgICBpZiAoZGVwdGggPT09IHZvaWQgMCkgeyBkZXB0aCA9IDE7IH1cbiAgICBpbnZhcmlhbnQoZGVwdGggPD0gbWF4RGVwdGgsIFwiTWF4IENTUyB2YXJpYWJsZSBmYWxsYmFjayBkZXB0aCBkZXRlY3RlZCBpbiBwcm9wZXJ0eSBcXFwiXCIuY29uY2F0KGN1cnJlbnQsIFwiXFxcIi4gVGhpcyBtYXkgaW5kaWNhdGUgYSBjaXJjdWxhciBmYWxsYmFjayBkZXBlbmRlbmN5LlwiKSk7XG4gICAgdmFyIF9hID0gX19yZWFkKHBhcnNlQ1NTVmFyaWFibGUoY3VycmVudCksIDIpLCB0b2tlbiA9IF9hWzBdLCBmYWxsYmFjayA9IF9hWzFdO1xuICAgIC8vIE5vIENTUyB2YXJpYWJsZSBkZXRlY3RlZFxuICAgIGlmICghdG9rZW4pXG4gICAgICAgIHJldHVybjtcbiAgICAvLyBBdHRlbXB0IHRvIHJlYWQgdGhpcyBDU1MgdmFyaWFibGUgb2ZmIHRoZSBlbGVtZW50XG4gICAgdmFyIHJlc29sdmVkID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkuZ2V0UHJvcGVydHlWYWx1ZSh0b2tlbik7XG4gICAgaWYgKHJlc29sdmVkKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlZC50cmltKCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzQ1NTVmFyaWFibGUoZmFsbGJhY2spKSB7XG4gICAgICAgIC8vIFRoZSBmYWxsYmFjayBtaWdodCBpdHNlbGYgYmUgYSBDU1MgdmFyaWFibGUsIGluIHdoaWNoIGNhc2Ugd2UgYXR0ZW1wdCB0byByZXNvbHZlIGl0IHRvby5cbiAgICAgICAgcmV0dXJuIGdldFZhcmlhYmxlVmFsdWUoZmFsbGJhY2ssIGVsZW1lbnQsIGRlcHRoICsgMSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsbGJhY2s7XG4gICAgfVxufVxuLyoqXG4gKiBSZXNvbHZlIENTUyB2YXJpYWJsZXMgZnJvbVxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiByZXNvbHZlQ1NTVmFyaWFibGVzKHZpc3VhbEVsZW1lbnQsIF9hLCB0cmFuc2l0aW9uRW5kKSB7XG4gICAgdmFyIF9iO1xuICAgIHZhciB0YXJnZXQgPSBfX3Jlc3QoX2EsIFtdKTtcbiAgICB2YXIgZWxlbWVudCA9IHZpc3VhbEVsZW1lbnQuZ2V0SW5zdGFuY2UoKTtcbiAgICBpZiAoIShlbGVtZW50IGluc3RhbmNlb2YgRWxlbWVudCkpXG4gICAgICAgIHJldHVybiB7IHRhcmdldDogdGFyZ2V0LCB0cmFuc2l0aW9uRW5kOiB0cmFuc2l0aW9uRW5kIH07XG4gICAgLy8gSWYgYHRyYW5zaXRpb25FbmRgIGlzbid0IGB1bmRlZmluZWRgLCBjbG9uZSBpdC4gV2UgY291bGQgY2xvbmUgYHRhcmdldGAgYW5kIGB0cmFuc2l0aW9uRW5kYFxuICAgIC8vIG9ubHkgaWYgdGhleSBjaGFuZ2UgYnV0IEkgdGhpbmsgdGhpcyByZWFkcyBjbGVhcmVyIGFuZCB0aGlzIGlzbid0IGEgcGVyZm9ybWFuY2UtY3JpdGljYWwgcGF0aC5cbiAgICBpZiAodHJhbnNpdGlvbkVuZCkge1xuICAgICAgICB0cmFuc2l0aW9uRW5kID0gX19hc3NpZ24oe30sIHRyYW5zaXRpb25FbmQpO1xuICAgIH1cbiAgICAvLyBHbyB0aHJvdWdoIGV4aXN0aW5nIGBNb3Rpb25WYWx1ZWBzIGFuZCBlbnN1cmUgYW55IGV4aXN0aW5nIENTUyB2YXJpYWJsZXMgYXJlIHJlc29sdmVkXG4gICAgdmlzdWFsRWxlbWVudC5mb3JFYWNoVmFsdWUoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBjdXJyZW50ID0gdmFsdWUuZ2V0KCk7XG4gICAgICAgIGlmICghaXNDU1NWYXJpYWJsZShjdXJyZW50KSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIHJlc29sdmVkID0gZ2V0VmFyaWFibGVWYWx1ZShjdXJyZW50LCBlbGVtZW50KTtcbiAgICAgICAgaWYgKHJlc29sdmVkKVxuICAgICAgICAgICAgdmFsdWUuc2V0KHJlc29sdmVkKTtcbiAgICB9KTtcbiAgICAvLyBDeWNsZSB0aHJvdWdoIGV2ZXJ5IHRhcmdldCBwcm9wZXJ0eSBhbmQgcmVzb2x2ZSBDU1MgdmFyaWFibGVzLiBDdXJyZW50bHlcbiAgICAvLyB3ZSBvbmx5IHJlYWQgc2luZ2xlLXZhciBwcm9wZXJ0aWVzIGxpa2UgYHZhcigtLWZvbylgLCBub3QgYGNhbGModmFyKC0tZm9vKSArIDIwcHgpYFxuICAgIGZvciAodmFyIGtleSBpbiB0YXJnZXQpIHtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSB0YXJnZXRba2V5XTtcbiAgICAgICAgaWYgKCFpc0NTU1ZhcmlhYmxlKGN1cnJlbnQpKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIHZhciByZXNvbHZlZCA9IGdldFZhcmlhYmxlVmFsdWUoY3VycmVudCwgZWxlbWVudCk7XG4gICAgICAgIGlmICghcmVzb2x2ZWQpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgLy8gQ2xvbmUgdGFyZ2V0IGlmIGl0IGhhc24ndCBhbHJlYWR5IGJlZW5cbiAgICAgICAgdGFyZ2V0W2tleV0gPSByZXNvbHZlZDtcbiAgICAgICAgLy8gSWYgdGhlIHVzZXIgaGFzbid0IGFscmVhZHkgc2V0IHRoaXMga2V5IG9uIGB0cmFuc2l0aW9uRW5kYCwgc2V0IGl0IHRvIHRoZSB1bnJlc29sdmVkXG4gICAgICAgIC8vIENTUyB2YXJpYWJsZS4gVGhpcyB3aWxsIGVuc3VyZSB0aGF0IGFmdGVyIHRoZSBhbmltYXRpb24gdGhlIGNvbXBvbmVudCB3aWxsIHJlZmxlY3RcbiAgICAgICAgLy8gY2hhbmdlcyBpbiB0aGUgdmFsdWUgb2YgdGhlIENTUyB2YXJpYWJsZS5cbiAgICAgICAgaWYgKHRyYW5zaXRpb25FbmQpXG4gICAgICAgICAgICAoX2IgPSB0cmFuc2l0aW9uRW5kW2tleV0pICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICh0cmFuc2l0aW9uRW5kW2tleV0gPSBjdXJyZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdGFyZ2V0OiB0YXJnZXQsIHRyYW5zaXRpb25FbmQ6IHRyYW5zaXRpb25FbmQgfTtcbn1cblxuZXhwb3J0IHsgY3NzVmFyaWFibGVSZWdleCwgcGFyc2VDU1NWYXJpYWJsZSwgcmVzb2x2ZUNTU1ZhcmlhYmxlcyB9O1xuIiwiaW1wb3J0IHsgX19hc3NpZ24sIF9fcmVhZCB9IGZyb20gJ3RzbGliJztcbmltcG9ydCB7IG51bWJlciwgcHggfSBmcm9tICdzdHlsZS12YWx1ZS10eXBlcyc7XG5pbXBvcnQgeyBpc0tleWZyYW1lc1RhcmdldCB9IGZyb20gJy4uLy4uLy4uL2FuaW1hdGlvbi91dGlscy9pcy1rZXlmcmFtZXMtdGFyZ2V0Lm1qcyc7XG5pbXBvcnQgeyBpbnZhcmlhbnQgfSBmcm9tICdoZXktbGlzdGVuJztcbmltcG9ydCB7IHRyYW5zZm9ybVByb3BzIH0gZnJvbSAnLi4vLi4vaHRtbC91dGlscy90cmFuc2Zvcm0ubWpzJztcbmltcG9ydCB7IGZpbmREaW1lbnNpb25WYWx1ZVR5cGUgfSBmcm9tICcuLi92YWx1ZS10eXBlcy9kaW1lbnNpb25zLm1qcyc7XG5cbnZhciBwb3NpdGlvbmFsS2V5cyA9IG5ldyBTZXQoW1xuICAgIFwid2lkdGhcIixcbiAgICBcImhlaWdodFwiLFxuICAgIFwidG9wXCIsXG4gICAgXCJsZWZ0XCIsXG4gICAgXCJyaWdodFwiLFxuICAgIFwiYm90dG9tXCIsXG4gICAgXCJ4XCIsXG4gICAgXCJ5XCIsXG5dKTtcbnZhciBpc1Bvc2l0aW9uYWxLZXkgPSBmdW5jdGlvbiAoa2V5KSB7IHJldHVybiBwb3NpdGlvbmFsS2V5cy5oYXMoa2V5KTsgfTtcbnZhciBoYXNQb3NpdGlvbmFsS2V5ID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh0YXJnZXQpLnNvbWUoaXNQb3NpdGlvbmFsS2V5KTtcbn07XG52YXIgc2V0QW5kUmVzZXRWZWxvY2l0eSA9IGZ1bmN0aW9uICh2YWx1ZSwgdG8pIHtcbiAgICAvLyBMb29rcyBvZGQgYnV0IHNldHRpbmcgaXQgdHdpY2UgZG9lc24ndCByZW5kZXIsIGl0J2xsIGp1c3RcbiAgICAvLyBzZXQgYm90aCBwcmV2IGFuZCBjdXJyZW50IHRvIHRoZSBsYXRlc3QgdmFsdWVcbiAgICB2YWx1ZS5zZXQodG8sIGZhbHNlKTtcbiAgICB2YWx1ZS5zZXQodG8pO1xufTtcbnZhciBpc051bU9yUHhUeXBlID0gZnVuY3Rpb24gKHYpIHtcbiAgICByZXR1cm4gdiA9PT0gbnVtYmVyIHx8IHYgPT09IHB4O1xufTtcbnZhciBCb3VuZGluZ0JveERpbWVuc2lvbjtcbihmdW5jdGlvbiAoQm91bmRpbmdCb3hEaW1lbnNpb24pIHtcbiAgICBCb3VuZGluZ0JveERpbWVuc2lvbltcIndpZHRoXCJdID0gXCJ3aWR0aFwiO1xuICAgIEJvdW5kaW5nQm94RGltZW5zaW9uW1wiaGVpZ2h0XCJdID0gXCJoZWlnaHRcIjtcbiAgICBCb3VuZGluZ0JveERpbWVuc2lvbltcImxlZnRcIl0gPSBcImxlZnRcIjtcbiAgICBCb3VuZGluZ0JveERpbWVuc2lvbltcInJpZ2h0XCJdID0gXCJyaWdodFwiO1xuICAgIEJvdW5kaW5nQm94RGltZW5zaW9uW1widG9wXCJdID0gXCJ0b3BcIjtcbiAgICBCb3VuZGluZ0JveERpbWVuc2lvbltcImJvdHRvbVwiXSA9IFwiYm90dG9tXCI7XG59KShCb3VuZGluZ0JveERpbWVuc2lvbiB8fCAoQm91bmRpbmdCb3hEaW1lbnNpb24gPSB7fSkpO1xudmFyIGdldFBvc0Zyb21NYXRyaXggPSBmdW5jdGlvbiAobWF0cml4LCBwb3MpIHtcbiAgICByZXR1cm4gcGFyc2VGbG9hdChtYXRyaXguc3BsaXQoXCIsIFwiKVtwb3NdKTtcbn07XG52YXIgZ2V0VHJhbnNsYXRlRnJvbU1hdHJpeCA9IGZ1bmN0aW9uIChwb3MyLCBwb3MzKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChfYmJveCwgX2EpIHtcbiAgICAgICAgdmFyIHRyYW5zZm9ybSA9IF9hLnRyYW5zZm9ybTtcbiAgICAgICAgaWYgKHRyYW5zZm9ybSA9PT0gXCJub25lXCIgfHwgIXRyYW5zZm9ybSlcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB2YXIgbWF0cml4M2QgPSB0cmFuc2Zvcm0ubWF0Y2goL15tYXRyaXgzZFxcKCguKylcXCkkLyk7XG4gICAgICAgIGlmIChtYXRyaXgzZCkge1xuICAgICAgICAgICAgcmV0dXJuIGdldFBvc0Zyb21NYXRyaXgobWF0cml4M2RbMV0sIHBvczMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIG1hdHJpeCA9IHRyYW5zZm9ybS5tYXRjaCgvXm1hdHJpeFxcKCguKylcXCkkLyk7XG4gICAgICAgICAgICBpZiAobWF0cml4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldFBvc0Zyb21NYXRyaXgobWF0cml4WzFdLCBwb3MyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn07XG52YXIgdHJhbnNmb3JtS2V5cyA9IG5ldyBTZXQoW1wieFwiLCBcInlcIiwgXCJ6XCJdKTtcbnZhciBub25UcmFuc2xhdGlvbmFsVHJhbnNmb3JtS2V5cyA9IHRyYW5zZm9ybVByb3BzLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7IHJldHVybiAhdHJhbnNmb3JtS2V5cy5oYXMoa2V5KTsgfSk7XG5mdW5jdGlvbiByZW1vdmVOb25UcmFuc2xhdGlvbmFsVHJhbnNmb3JtKHZpc3VhbEVsZW1lbnQpIHtcbiAgICB2YXIgcmVtb3ZlZFRyYW5zZm9ybXMgPSBbXTtcbiAgICBub25UcmFuc2xhdGlvbmFsVHJhbnNmb3JtS2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdmlzdWFsRWxlbWVudC5nZXRWYWx1ZShrZXkpO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVtb3ZlZFRyYW5zZm9ybXMucHVzaChba2V5LCB2YWx1ZS5nZXQoKV0pO1xuICAgICAgICAgICAgdmFsdWUuc2V0KGtleS5zdGFydHNXaXRoKFwic2NhbGVcIikgPyAxIDogMCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBBcHBseSBjaGFuZ2VzIHRvIGVsZW1lbnQgYmVmb3JlIG1lYXN1cmVtZW50XG4gICAgaWYgKHJlbW92ZWRUcmFuc2Zvcm1zLmxlbmd0aClcbiAgICAgICAgdmlzdWFsRWxlbWVudC5zeW5jUmVuZGVyKCk7XG4gICAgcmV0dXJuIHJlbW92ZWRUcmFuc2Zvcm1zO1xufVxudmFyIHBvc2l0aW9uYWxWYWx1ZXMgPSB7XG4gICAgLy8gRGltZW5zaW9uc1xuICAgIHdpZHRoOiBmdW5jdGlvbiAoX2EsIF9iKSB7XG4gICAgICAgIHZhciB4ID0gX2EueDtcbiAgICAgICAgdmFyIF9jID0gX2IucGFkZGluZ0xlZnQsIHBhZGRpbmdMZWZ0ID0gX2MgPT09IHZvaWQgMCA/IFwiMFwiIDogX2MsIF9kID0gX2IucGFkZGluZ1JpZ2h0LCBwYWRkaW5nUmlnaHQgPSBfZCA9PT0gdm9pZCAwID8gXCIwXCIgOiBfZDtcbiAgICAgICAgcmV0dXJuIHgubWF4IC0geC5taW4gLSBwYXJzZUZsb2F0KHBhZGRpbmdMZWZ0KSAtIHBhcnNlRmxvYXQocGFkZGluZ1JpZ2h0KTtcbiAgICB9LFxuICAgIGhlaWdodDogZnVuY3Rpb24gKF9hLCBfYikge1xuICAgICAgICB2YXIgeSA9IF9hLnk7XG4gICAgICAgIHZhciBfYyA9IF9iLnBhZGRpbmdUb3AsIHBhZGRpbmdUb3AgPSBfYyA9PT0gdm9pZCAwID8gXCIwXCIgOiBfYywgX2QgPSBfYi5wYWRkaW5nQm90dG9tLCBwYWRkaW5nQm90dG9tID0gX2QgPT09IHZvaWQgMCA/IFwiMFwiIDogX2Q7XG4gICAgICAgIHJldHVybiB5Lm1heCAtIHkubWluIC0gcGFyc2VGbG9hdChwYWRkaW5nVG9wKSAtIHBhcnNlRmxvYXQocGFkZGluZ0JvdHRvbSk7XG4gICAgfSxcbiAgICB0b3A6IGZ1bmN0aW9uIChfYmJveCwgX2EpIHtcbiAgICAgICAgdmFyIHRvcCA9IF9hLnRvcDtcbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQodG9wKTtcbiAgICB9LFxuICAgIGxlZnQ6IGZ1bmN0aW9uIChfYmJveCwgX2EpIHtcbiAgICAgICAgdmFyIGxlZnQgPSBfYS5sZWZ0O1xuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChsZWZ0KTtcbiAgICB9LFxuICAgIGJvdHRvbTogZnVuY3Rpb24gKF9hLCBfYikge1xuICAgICAgICB2YXIgeSA9IF9hLnk7XG4gICAgICAgIHZhciB0b3AgPSBfYi50b3A7XG4gICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHRvcCkgKyAoeS5tYXggLSB5Lm1pbik7XG4gICAgfSxcbiAgICByaWdodDogZnVuY3Rpb24gKF9hLCBfYikge1xuICAgICAgICB2YXIgeCA9IF9hLng7XG4gICAgICAgIHZhciBsZWZ0ID0gX2IubGVmdDtcbiAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQobGVmdCkgKyAoeC5tYXggLSB4Lm1pbik7XG4gICAgfSxcbiAgICAvLyBUcmFuc2Zvcm1cbiAgICB4OiBnZXRUcmFuc2xhdGVGcm9tTWF0cml4KDQsIDEzKSxcbiAgICB5OiBnZXRUcmFuc2xhdGVGcm9tTWF0cml4KDUsIDE0KSxcbn07XG52YXIgY29udmVydENoYW5nZWRWYWx1ZVR5cGVzID0gZnVuY3Rpb24gKHRhcmdldCwgdmlzdWFsRWxlbWVudCwgY2hhbmdlZEtleXMpIHtcbiAgICB2YXIgb3JpZ2luQmJveCA9IHZpc3VhbEVsZW1lbnQubWVhc3VyZVZpZXdwb3J0Qm94KCk7XG4gICAgdmFyIGVsZW1lbnQgPSB2aXN1YWxFbGVtZW50LmdldEluc3RhbmNlKCk7XG4gICAgdmFyIGVsZW1lbnRDb21wdXRlZFN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbiAgICB2YXIgZGlzcGxheSA9IGVsZW1lbnRDb21wdXRlZFN0eWxlLmRpc3BsYXk7XG4gICAgdmFyIG9yaWdpbiA9IHt9O1xuICAgIC8vIElmIHRoZSBlbGVtZW50IGlzIGN1cnJlbnRseSBzZXQgdG8gZGlzcGxheTogXCJub25lXCIsIG1ha2UgaXQgdmlzaWJsZSBiZWZvcmVcbiAgICAvLyBtZWFzdXJpbmcgdGhlIHRhcmdldCBib3VuZGluZyBib3hcbiAgICBpZiAoZGlzcGxheSA9PT0gXCJub25lXCIpIHtcbiAgICAgICAgdmlzdWFsRWxlbWVudC5zZXRTdGF0aWNWYWx1ZShcImRpc3BsYXlcIiwgdGFyZ2V0LmRpc3BsYXkgfHwgXCJibG9ja1wiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVjb3JkIG9yaWdpbnMgYmVmb3JlIHdlIHJlbmRlciBhbmQgdXBkYXRlIHN0eWxlc1xuICAgICAqL1xuICAgIGNoYW5nZWRLZXlzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBvcmlnaW5ba2V5XSA9IHBvc2l0aW9uYWxWYWx1ZXNba2V5XShvcmlnaW5CYm94LCBlbGVtZW50Q29tcHV0ZWRTdHlsZSk7XG4gICAgfSk7XG4gICAgLy8gQXBwbHkgdGhlIGxhdGVzdCB2YWx1ZXMgKGFzIHNldCBpbiBjaGVja0FuZENvbnZlcnRDaGFuZ2VkVmFsdWVUeXBlcylcbiAgICB2aXN1YWxFbGVtZW50LnN5bmNSZW5kZXIoKTtcbiAgICB2YXIgdGFyZ2V0QmJveCA9IHZpc3VhbEVsZW1lbnQubWVhc3VyZVZpZXdwb3J0Qm94KCk7XG4gICAgY2hhbmdlZEtleXMuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIC8vIFJlc3RvcmUgc3R5bGVzIHRvIHRoZWlyICoqY2FsY3VsYXRlZCBjb21wdXRlZCBzdHlsZSoqLCBub3QgdGhlaXIgYWN0dWFsXG4gICAgICAgIC8vIG9yaWdpbmFsbHkgc2V0IHN0eWxlLiBUaGlzIGFsbG93cyB1cyB0byBhbmltYXRlIGJldHdlZW4gZXF1aXZhbGVudCBwaXhlbCB1bml0cy5cbiAgICAgICAgdmFyIHZhbHVlID0gdmlzdWFsRWxlbWVudC5nZXRWYWx1ZShrZXkpO1xuICAgICAgICBzZXRBbmRSZXNldFZlbG9jaXR5KHZhbHVlLCBvcmlnaW5ba2V5XSk7XG4gICAgICAgIHRhcmdldFtrZXldID0gcG9zaXRpb25hbFZhbHVlc1trZXldKHRhcmdldEJib3gsIGVsZW1lbnRDb21wdXRlZFN0eWxlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdGFyZ2V0O1xufTtcbnZhciBjaGVja0FuZENvbnZlcnRDaGFuZ2VkVmFsdWVUeXBlcyA9IGZ1bmN0aW9uICh2aXN1YWxFbGVtZW50LCB0YXJnZXQsIG9yaWdpbiwgdHJhbnNpdGlvbkVuZCkge1xuICAgIGlmIChvcmlnaW4gPT09IHZvaWQgMCkgeyBvcmlnaW4gPSB7fTsgfVxuICAgIGlmICh0cmFuc2l0aW9uRW5kID09PSB2b2lkIDApIHsgdHJhbnNpdGlvbkVuZCA9IHt9OyB9XG4gICAgdGFyZ2V0ID0gX19hc3NpZ24oe30sIHRhcmdldCk7XG4gICAgdHJhbnNpdGlvbkVuZCA9IF9fYXNzaWduKHt9LCB0cmFuc2l0aW9uRW5kKTtcbiAgICB2YXIgdGFyZ2V0UG9zaXRpb25hbEtleXMgPSBPYmplY3Qua2V5cyh0YXJnZXQpLmZpbHRlcihpc1Bvc2l0aW9uYWxLZXkpO1xuICAgIC8vIFdlIHdhbnQgdG8gcmVtb3ZlIGFueSB0cmFuc2Zvcm0gdmFsdWVzIHRoYXQgY291bGQgYWZmZWN0IHRoZSBlbGVtZW50J3MgYm91bmRpbmcgYm94IGJlZm9yZVxuICAgIC8vIGl0J3MgbWVhc3VyZWQuIFdlJ2xsIHJlYXBwbHkgdGhlc2UgbGF0ZXIuXG4gICAgdmFyIHJlbW92ZWRUcmFuc2Zvcm1WYWx1ZXMgPSBbXTtcbiAgICB2YXIgaGFzQXR0ZW1wdGVkVG9SZW1vdmVUcmFuc2Zvcm1WYWx1ZXMgPSBmYWxzZTtcbiAgICB2YXIgY2hhbmdlZFZhbHVlVHlwZUtleXMgPSBbXTtcbiAgICB0YXJnZXRQb3NpdGlvbmFsS2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdmlzdWFsRWxlbWVudC5nZXRWYWx1ZShrZXkpO1xuICAgICAgICBpZiAoIXZpc3VhbEVsZW1lbnQuaGFzVmFsdWUoa2V5KSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIGZyb20gPSBvcmlnaW5ba2V5XTtcbiAgICAgICAgdmFyIGZyb21UeXBlID0gZmluZERpbWVuc2lvblZhbHVlVHlwZShmcm9tKTtcbiAgICAgICAgdmFyIHRvID0gdGFyZ2V0W2tleV07XG4gICAgICAgIHZhciB0b1R5cGU7XG4gICAgICAgIC8vIFRPRE86IFRoZSBjdXJyZW50IGltcGxlbWVudGF0aW9uIG9mIHRoaXMgYmFzaWNhbGx5IHRocm93cyBhbiBlcnJvclxuICAgICAgICAvLyBpZiB5b3UgdHJ5IGFuZCBkbyB2YWx1ZSBjb252ZXJzaW9uIHZpYSBrZXlmcmFtZXMuIFRoZXJlJ3MgcHJvYmFibHlcbiAgICAgICAgLy8gYSB3YXkgb2YgZG9pbmcgdGhpcyBidXQgdGhlIHBlcmZvcm1hbmNlIGltcGxpY2F0aW9ucyB3b3VsZCBuZWVkIGdyZWF0ZXIgc2NydXRpbnksXG4gICAgICAgIC8vIGFzIGl0J2QgYmUgZG9pbmcgbXVsdGlwbGUgcmVzaXplLXJlbWVhc3VyZSBvcGVyYXRpb25zLlxuICAgICAgICBpZiAoaXNLZXlmcmFtZXNUYXJnZXQodG8pKSB7XG4gICAgICAgICAgICB2YXIgbnVtS2V5ZnJhbWVzID0gdG8ubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIGZyb21JbmRleCA9IHRvWzBdID09PSBudWxsID8gMSA6IDA7XG4gICAgICAgICAgICBmcm9tID0gdG9bZnJvbUluZGV4XTtcbiAgICAgICAgICAgIGZyb21UeXBlID0gZmluZERpbWVuc2lvblZhbHVlVHlwZShmcm9tKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSBmcm9tSW5kZXg7IGkgPCBudW1LZXlmcmFtZXM7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICghdG9UeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvVHlwZSA9IGZpbmREaW1lbnNpb25WYWx1ZVR5cGUodG9baV0pO1xuICAgICAgICAgICAgICAgICAgICBpbnZhcmlhbnQodG9UeXBlID09PSBmcm9tVHlwZSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKGlzTnVtT3JQeFR5cGUoZnJvbVR5cGUpICYmIGlzTnVtT3JQeFR5cGUodG9UeXBlKSksIFwiS2V5ZnJhbWVzIG11c3QgYmUgb2YgdGhlIHNhbWUgZGltZW5zaW9uIGFzIHRoZSBjdXJyZW50IHZhbHVlXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaW52YXJpYW50KGZpbmREaW1lbnNpb25WYWx1ZVR5cGUodG9baV0pID09PSB0b1R5cGUsIFwiQWxsIGtleWZyYW1lcyBtdXN0IGJlIG9mIHRoZSBzYW1lIHR5cGVcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdG9UeXBlID0gZmluZERpbWVuc2lvblZhbHVlVHlwZSh0byk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZyb21UeXBlICE9PSB0b1R5cGUpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZXkncmUgYm90aCBqdXN0IG51bWJlciBvciBweCwgY29udmVydCB0aGVtIGJvdGggdG8gbnVtYmVycyByYXRoZXIgdGhhblxuICAgICAgICAgICAgLy8gcmVseWluZyBvbiByZXNpemUvcmVtZWFzdXJlIHRvIGNvbnZlcnQgKHdoaWNoIGlzIHdhc3RlZnVsIGluIHRoaXMgc2l0dWF0aW9uKVxuICAgICAgICAgICAgaWYgKGlzTnVtT3JQeFR5cGUoZnJvbVR5cGUpICYmIGlzTnVtT3JQeFR5cGUodG9UeXBlKSkge1xuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50ID0gdmFsdWUuZ2V0KCk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjdXJyZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLnNldChwYXJzZUZsb2F0KGN1cnJlbnQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0byA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHBhcnNlRmxvYXQodG8pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHRvKSAmJiB0b1R5cGUgPT09IHB4KSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gdG8ubWFwKHBhcnNlRmxvYXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKChmcm9tVHlwZSA9PT0gbnVsbCB8fCBmcm9tVHlwZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZnJvbVR5cGUudHJhbnNmb3JtKSAmJlxuICAgICAgICAgICAgICAgICh0b1R5cGUgPT09IG51bGwgfHwgdG9UeXBlID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0b1R5cGUudHJhbnNmb3JtKSAmJlxuICAgICAgICAgICAgICAgIChmcm9tID09PSAwIHx8IHRvID09PSAwKSkge1xuICAgICAgICAgICAgICAgIC8vIElmIG9uZSBvciB0aGUgb3RoZXIgdmFsdWUgaXMgMCwgaXQncyBzYWZlIHRvIGNvZXJjZSBpdCB0byB0aGVcbiAgICAgICAgICAgICAgICAvLyB0eXBlIG9mIHRoZSBvdGhlciB3aXRob3V0IG1lYXN1cmVtZW50XG4gICAgICAgICAgICAgICAgaWYgKGZyb20gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUuc2V0KHRvVHlwZS50cmFuc2Zvcm0oZnJvbSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBmcm9tVHlwZS50cmFuc2Zvcm0odG8pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIElmIHdlJ3JlIGdvaW5nIHRvIGRvIHZhbHVlIGNvbnZlcnNpb24gdmlhIERPTSBtZWFzdXJlbWVudHMsIHdlIGZpcnN0XG4gICAgICAgICAgICAgICAgLy8gbmVlZCB0byByZW1vdmUgbm9uLXBvc2l0aW9uYWwgdHJhbnNmb3JtIHZhbHVlcyB0aGF0IGNvdWxkIGFmZmVjdCB0aGUgYmJveCBtZWFzdXJlbWVudHMuXG4gICAgICAgICAgICAgICAgaWYgKCFoYXNBdHRlbXB0ZWRUb1JlbW92ZVRyYW5zZm9ybVZhbHVlcykge1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVkVHJhbnNmb3JtVmFsdWVzID1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZU5vblRyYW5zbGF0aW9uYWxUcmFuc2Zvcm0odmlzdWFsRWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIGhhc0F0dGVtcHRlZFRvUmVtb3ZlVHJhbnNmb3JtVmFsdWVzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2hhbmdlZFZhbHVlVHlwZUtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgICAgIHRyYW5zaXRpb25FbmRba2V5XSA9XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb25FbmRba2V5XSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHRyYW5zaXRpb25FbmRba2V5XVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB0YXJnZXRba2V5XTtcbiAgICAgICAgICAgICAgICBzZXRBbmRSZXNldFZlbG9jaXR5KHZhbHVlLCB0byk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoY2hhbmdlZFZhbHVlVHlwZUtleXMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBzY3JvbGxZXzEgPSBjaGFuZ2VkVmFsdWVUeXBlS2V5cy5pbmRleE9mKFwiaGVpZ2h0XCIpID49IDBcbiAgICAgICAgICAgID8gd2luZG93LnBhZ2VZT2Zmc2V0XG4gICAgICAgICAgICA6IG51bGw7XG4gICAgICAgIHZhciBjb252ZXJ0ZWRUYXJnZXQgPSBjb252ZXJ0Q2hhbmdlZFZhbHVlVHlwZXModGFyZ2V0LCB2aXN1YWxFbGVtZW50LCBjaGFuZ2VkVmFsdWVUeXBlS2V5cyk7XG4gICAgICAgIC8vIElmIHdlIHJlbW92ZWQgdHJhbnNmb3JtIHZhbHVlcywgcmVhcHBseSB0aGVtIGJlZm9yZSB0aGUgbmV4dCByZW5kZXJcbiAgICAgICAgaWYgKHJlbW92ZWRUcmFuc2Zvcm1WYWx1ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZW1vdmVkVHJhbnNmb3JtVmFsdWVzLmZvckVhY2goZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9iID0gX19yZWFkKF9hLCAyKSwga2V5ID0gX2JbMF0sIHZhbHVlID0gX2JbMV07XG4gICAgICAgICAgICAgICAgdmlzdWFsRWxlbWVudC5nZXRWYWx1ZShrZXkpLnNldCh2YWx1ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZWFwcGx5IG9yaWdpbmFsIHZhbHVlc1xuICAgICAgICB2aXN1YWxFbGVtZW50LnN5bmNSZW5kZXIoKTtcbiAgICAgICAgLy8gUmVzdG9yZSBzY3JvbGwgcG9zaXRpb25cbiAgICAgICAgaWYgKHNjcm9sbFlfMSAhPT0gbnVsbClcbiAgICAgICAgICAgIHdpbmRvdy5zY3JvbGxUbyh7IHRvcDogc2Nyb2xsWV8xIH0pO1xuICAgICAgICByZXR1cm4geyB0YXJnZXQ6IGNvbnZlcnRlZFRhcmdldCwgdHJhbnNpdGlvbkVuZDogdHJhbnNpdGlvbkVuZCB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHsgdGFyZ2V0OiB0YXJnZXQsIHRyYW5zaXRpb25FbmQ6IHRyYW5zaXRpb25FbmQgfTtcbiAgICB9XG59O1xuLyoqXG4gKiBDb252ZXJ0IHZhbHVlIHR5cGVzIGZvciB4L3kvd2lkdGgvaGVpZ2h0L3RvcC9sZWZ0L2JvdHRvbS9yaWdodFxuICpcbiAqIEFsbG93cyBhbmltYXRpb24gYmV0d2VlbiBgJ2F1dG8nYCAtPiBgJzEwMCUnYCBvciBgMGAgLT4gYCdjYWxjKDUwJSAtIDEwdncpJ2BcbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gdW5pdENvbnZlcnNpb24odmlzdWFsRWxlbWVudCwgdGFyZ2V0LCBvcmlnaW4sIHRyYW5zaXRpb25FbmQpIHtcbiAgICByZXR1cm4gaGFzUG9zaXRpb25hbEtleSh0YXJnZXQpXG4gICAgICAgID8gY2hlY2tBbmRDb252ZXJ0Q2hhbmdlZFZhbHVlVHlwZXModmlzdWFsRWxlbWVudCwgdGFyZ2V0LCBvcmlnaW4sIHRyYW5zaXRpb25FbmQpXG4gICAgICAgIDogeyB0YXJnZXQ6IHRhcmdldCwgdHJhbnNpdGlvbkVuZDogdHJhbnNpdGlvbkVuZCB9O1xufVxuXG5leHBvcnQgeyBCb3VuZGluZ0JveERpbWVuc2lvbiwgcG9zaXRpb25hbFZhbHVlcywgdW5pdENvbnZlcnNpb24gfTtcbiIsImltcG9ydCB7IHJlc29sdmVDU1NWYXJpYWJsZXMgfSBmcm9tICcuL2Nzcy12YXJpYWJsZXMtY29udmVyc2lvbi5tanMnO1xuaW1wb3J0IHsgdW5pdENvbnZlcnNpb24gfSBmcm9tICcuL3VuaXQtY29udmVyc2lvbi5tanMnO1xuXG4vKipcbiAqIFBhcnNlIGEgRE9NIHZhcmlhbnQgdG8gbWFrZSBpdCBhbmltYXRhYmxlLiBUaGlzIGludm9sdmVzIHJlc29sdmluZyBDU1MgdmFyaWFibGVzXG4gKiBhbmQgZW5zdXJpbmcgYW5pbWF0aW9ucyBsaWtlIFwiMjAlXCIgPT4gXCJjYWxjKDUwdncpXCIgYXJlIHBlcmZvcm1lZCBpbiBwaXhlbHMuXG4gKi9cbnZhciBwYXJzZURvbVZhcmlhbnQgPSBmdW5jdGlvbiAodmlzdWFsRWxlbWVudCwgdGFyZ2V0LCBvcmlnaW4sIHRyYW5zaXRpb25FbmQpIHtcbiAgICB2YXIgcmVzb2x2ZWQgPSByZXNvbHZlQ1NTVmFyaWFibGVzKHZpc3VhbEVsZW1lbnQsIHRhcmdldCwgdHJhbnNpdGlvbkVuZCk7XG4gICAgdGFyZ2V0ID0gcmVzb2x2ZWQudGFyZ2V0O1xuICAgIHRyYW5zaXRpb25FbmQgPSByZXNvbHZlZC50cmFuc2l0aW9uRW5kO1xuICAgIHJldHVybiB1bml0Q29udmVyc2lvbih2aXN1YWxFbGVtZW50LCB0YXJnZXQsIG9yaWdpbiwgdHJhbnNpdGlvbkVuZCk7XG59O1xuXG5leHBvcnQgeyBwYXJzZURvbVZhcmlhbnQgfTtcbiIsImltcG9ydCB7IF9fcmVzdCwgX19hc3NpZ24gfSBmcm9tICd0c2xpYic7XG5pbXBvcnQgeyB2aXN1YWxFbGVtZW50IH0gZnJvbSAnLi4vaW5kZXgubWpzJztcbmltcG9ydCB7IGdldE9yaWdpbiwgY2hlY2tUYXJnZXRGb3JOZXdWYWx1ZXMgfSBmcm9tICcuLi91dGlscy9zZXR0ZXJzLm1qcyc7XG5pbXBvcnQgeyBidWlsZEhUTUxTdHlsZXMgfSBmcm9tICcuL3V0aWxzL2J1aWxkLXN0eWxlcy5tanMnO1xuaW1wb3J0IHsgaXNDU1NWYXJpYWJsZSB9IGZyb20gJy4uL2RvbS91dGlscy9pcy1jc3MtdmFyaWFibGUubWpzJztcbmltcG9ydCB7IHBhcnNlRG9tVmFyaWFudCB9IGZyb20gJy4uL2RvbS91dGlscy9wYXJzZS1kb20tdmFyaWFudC5tanMnO1xuaW1wb3J0IHsgaXNUcmFuc2Zvcm1Qcm9wIH0gZnJvbSAnLi91dGlscy90cmFuc2Zvcm0ubWpzJztcbmltcG9ydCB7IHNjcmFwZU1vdGlvblZhbHVlc0Zyb21Qcm9wcyB9IGZyb20gJy4vdXRpbHMvc2NyYXBlLW1vdGlvbi12YWx1ZXMubWpzJztcbmltcG9ydCB7IHJlbmRlckhUTUwgfSBmcm9tICcuL3V0aWxzL3JlbmRlci5tanMnO1xuaW1wb3J0IHsgZ2V0RGVmYXVsdFZhbHVlVHlwZSB9IGZyb20gJy4uL2RvbS92YWx1ZS10eXBlcy9kZWZhdWx0cy5tanMnO1xuaW1wb3J0IHsgbWVhc3VyZVZpZXdwb3J0Qm94IH0gZnJvbSAnLi4vLi4vcHJvamVjdGlvbi91dGlscy9tZWFzdXJlLm1qcyc7XG5cbmZ1bmN0aW9uIGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkge1xuICAgIHJldHVybiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbn1cbnZhciBodG1sQ29uZmlnID0ge1xuICAgIHRyZWVUeXBlOiBcImRvbVwiLFxuICAgIHJlYWRWYWx1ZUZyb21JbnN0YW5jZTogZnVuY3Rpb24gKGRvbUVsZW1lbnQsIGtleSkge1xuICAgICAgICBpZiAoaXNUcmFuc2Zvcm1Qcm9wKGtleSkpIHtcbiAgICAgICAgICAgIHZhciBkZWZhdWx0VHlwZSA9IGdldERlZmF1bHRWYWx1ZVR5cGUoa2V5KTtcbiAgICAgICAgICAgIHJldHVybiBkZWZhdWx0VHlwZSA/IGRlZmF1bHRUeXBlLmRlZmF1bHQgfHwgMCA6IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgY29tcHV0ZWRTdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoZG9tRWxlbWVudCk7XG4gICAgICAgICAgICByZXR1cm4gKChpc0NTU1ZhcmlhYmxlKGtleSlcbiAgICAgICAgICAgICAgICA/IGNvbXB1dGVkU3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShrZXkpXG4gICAgICAgICAgICAgICAgOiBjb21wdXRlZFN0eWxlW2tleV0pIHx8IDApO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBzb3J0Tm9kZVBvc2l0aW9uOiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAvKipcbiAgICAgICAgICogY29tcGFyZURvY3VtZW50UG9zaXRpb24gcmV0dXJucyBhIGJpdG1hc2ssIGJ5IHVzaW5nIHRoZSBiaXR3aXNlICZcbiAgICAgICAgICogd2UncmUgcmV0dXJuaW5nIHRydWUgaWYgMiBpbiB0aGF0IGJpdG1hc2sgaXMgc2V0IHRvIHRydWUuIDIgaXMgc2V0XG4gICAgICAgICAqIHRvIHRydWUgaWYgYiBwcmVjZWVkcyBhLlxuICAgICAgICAgKi9cbiAgICAgICAgcmV0dXJuIGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oYikgJiAyID8gMSA6IC0xO1xuICAgIH0sXG4gICAgZ2V0QmFzZVRhcmdldDogZnVuY3Rpb24gKHByb3BzLCBrZXkpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKF9hID0gcHJvcHMuc3R5bGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVtrZXldO1xuICAgIH0sXG4gICAgbWVhc3VyZVZpZXdwb3J0Qm94OiBmdW5jdGlvbiAoZWxlbWVudCwgX2EpIHtcbiAgICAgICAgdmFyIHRyYW5zZm9ybVBhZ2VQb2ludCA9IF9hLnRyYW5zZm9ybVBhZ2VQb2ludDtcbiAgICAgICAgcmV0dXJuIG1lYXN1cmVWaWV3cG9ydEJveChlbGVtZW50LCB0cmFuc2Zvcm1QYWdlUG9pbnQpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogUmVzZXQgdGhlIHRyYW5zZm9ybSBvbiB0aGUgY3VycmVudCBFbGVtZW50LiBUaGlzIGlzIGNhbGxlZCBhcyBwYXJ0XG4gICAgICogb2YgYSBiYXRjaGVkIHByb2Nlc3MgYWNyb3NzIHRoZSBlbnRpcmUgbGF5b3V0IHRyZWUuIFRvIHJlbW92ZSB0aGlzIHdyaXRlXG4gICAgICogY3ljbGUgaXQnZCBiZSBpbnRlcmVzdGluZyB0byBzZWUgaWYgaXQncyBwb3NzaWJsZSB0byBcInVuZG9cIiBhbGwgdGhlIGN1cnJlbnRcbiAgICAgKiBsYXlvdXQgdHJhbnNmb3JtcyB1cCB0aGUgdHJlZSBpbiB0aGUgc2FtZSB3YXkgdGhpcy5nZXRCb3VuZGluZ0JveFdpdGhvdXRUcmFuc2Zvcm1zXG4gICAgICogd29ya3NcbiAgICAgKi9cbiAgICByZXNldFRyYW5zZm9ybTogZnVuY3Rpb24gKGVsZW1lbnQsIGRvbUVsZW1lbnQsIHByb3BzKSB7XG4gICAgICAgIHZhciB0cmFuc2Zvcm1UZW1wbGF0ZSA9IHByb3BzLnRyYW5zZm9ybVRlbXBsYXRlO1xuICAgICAgICBkb21FbGVtZW50LnN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVRlbXBsYXRlXG4gICAgICAgICAgICA/IHRyYW5zZm9ybVRlbXBsYXRlKHt9LCBcIlwiKVxuICAgICAgICAgICAgOiBcIm5vbmVcIjtcbiAgICAgICAgLy8gRW5zdXJlIHRoYXQgd2hhdGV2ZXIgaGFwcGVucyBuZXh0LCB3ZSByZXN0b3JlIG91ciB0cmFuc2Zvcm0gb24gdGhlIG5leHQgZnJhbWVcbiAgICAgICAgZWxlbWVudC5zY2hlZHVsZVJlbmRlcigpO1xuICAgIH0sXG4gICAgcmVzdG9yZVRyYW5zZm9ybTogZnVuY3Rpb24gKGluc3RhbmNlLCBtdXRhYmxlU3RhdGUpIHtcbiAgICAgICAgaW5zdGFuY2Uuc3R5bGUudHJhbnNmb3JtID0gbXV0YWJsZVN0YXRlLnN0eWxlLnRyYW5zZm9ybTtcbiAgICB9LFxuICAgIHJlbW92ZVZhbHVlRnJvbVJlbmRlclN0YXRlOiBmdW5jdGlvbiAoa2V5LCBfYSkge1xuICAgICAgICB2YXIgdmFycyA9IF9hLnZhcnMsIHN0eWxlID0gX2Euc3R5bGU7XG4gICAgICAgIGRlbGV0ZSB2YXJzW2tleV07XG4gICAgICAgIGRlbGV0ZSBzdHlsZVtrZXldO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogRW5zdXJlIHRoYXQgSFRNTCBhbmQgRnJhbWVyLXNwZWNpZmljIHZhbHVlIHR5cGVzIGxpa2UgYHB4YC0+YCVgIGFuZCBgQ29sb3JgXG4gICAgICogY2FuIGJlIGFuaW1hdGVkIGJ5IE1vdGlvbi5cbiAgICAgKi9cbiAgICBtYWtlVGFyZ2V0QW5pbWF0YWJsZTogZnVuY3Rpb24gKGVsZW1lbnQsIF9hLCBfYiwgaXNNb3VudGVkKSB7XG4gICAgICAgIHZhciB0cmFuc2Zvcm1WYWx1ZXMgPSBfYi50cmFuc2Zvcm1WYWx1ZXM7XG4gICAgICAgIGlmIChpc01vdW50ZWQgPT09IHZvaWQgMCkgeyBpc01vdW50ZWQgPSB0cnVlOyB9XG4gICAgICAgIHZhciB0cmFuc2l0aW9uID0gX2EudHJhbnNpdGlvbiwgdHJhbnNpdGlvbkVuZCA9IF9hLnRyYW5zaXRpb25FbmQsIHRhcmdldCA9IF9fcmVzdChfYSwgW1widHJhbnNpdGlvblwiLCBcInRyYW5zaXRpb25FbmRcIl0pO1xuICAgICAgICB2YXIgb3JpZ2luID0gZ2V0T3JpZ2luKHRhcmdldCwgdHJhbnNpdGlvbiB8fCB7fSwgZWxlbWVudCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBGcmFtZXIgaGFzIHByb3ZpZGVkIGEgZnVuY3Rpb24gdG8gY29udmVydCBgQ29sb3JgIGV0YyB2YWx1ZSB0eXBlcywgY29udmVydCB0aGVtXG4gICAgICAgICAqL1xuICAgICAgICBpZiAodHJhbnNmb3JtVmFsdWVzKSB7XG4gICAgICAgICAgICBpZiAodHJhbnNpdGlvbkVuZClcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uRW5kID0gdHJhbnNmb3JtVmFsdWVzKHRyYW5zaXRpb25FbmQpO1xuICAgICAgICAgICAgaWYgKHRhcmdldClcbiAgICAgICAgICAgICAgICB0YXJnZXQgPSB0cmFuc2Zvcm1WYWx1ZXModGFyZ2V0KTtcbiAgICAgICAgICAgIGlmIChvcmlnaW4pXG4gICAgICAgICAgICAgICAgb3JpZ2luID0gdHJhbnNmb3JtVmFsdWVzKG9yaWdpbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTW91bnRlZCkge1xuICAgICAgICAgICAgY2hlY2tUYXJnZXRGb3JOZXdWYWx1ZXMoZWxlbWVudCwgdGFyZ2V0LCBvcmlnaW4pO1xuICAgICAgICAgICAgdmFyIHBhcnNlZCA9IHBhcnNlRG9tVmFyaWFudChlbGVtZW50LCB0YXJnZXQsIG9yaWdpbiwgdHJhbnNpdGlvbkVuZCk7XG4gICAgICAgICAgICB0cmFuc2l0aW9uRW5kID0gcGFyc2VkLnRyYW5zaXRpb25FbmQ7XG4gICAgICAgICAgICB0YXJnZXQgPSBwYXJzZWQudGFyZ2V0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfX2Fzc2lnbih7IHRyYW5zaXRpb246IHRyYW5zaXRpb24sIHRyYW5zaXRpb25FbmQ6IHRyYW5zaXRpb25FbmQgfSwgdGFyZ2V0KTtcbiAgICB9LFxuICAgIHNjcmFwZU1vdGlvblZhbHVlc0Zyb21Qcm9wczogc2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzLFxuICAgIGJ1aWxkOiBmdW5jdGlvbiAoZWxlbWVudCwgcmVuZGVyU3RhdGUsIGxhdGVzdFZhbHVlcywgb3B0aW9ucywgcHJvcHMpIHtcbiAgICAgICAgaWYgKGVsZW1lbnQuaXNWaXNpYmxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlbmRlclN0YXRlLnN0eWxlLnZpc2liaWxpdHkgPSBlbGVtZW50LmlzVmlzaWJsZVxuICAgICAgICAgICAgICAgID8gXCJ2aXNpYmxlXCJcbiAgICAgICAgICAgICAgICA6IFwiaGlkZGVuXCI7XG4gICAgICAgIH1cbiAgICAgICAgYnVpbGRIVE1MU3R5bGVzKHJlbmRlclN0YXRlLCBsYXRlc3RWYWx1ZXMsIG9wdGlvbnMsIHByb3BzLnRyYW5zZm9ybVRlbXBsYXRlKTtcbiAgICB9LFxuICAgIHJlbmRlcjogcmVuZGVySFRNTCxcbn07XG52YXIgaHRtbFZpc3VhbEVsZW1lbnQgPSB2aXN1YWxFbGVtZW50KGh0bWxDb25maWcpO1xuXG5leHBvcnQgeyBnZXRDb21wdXRlZFN0eWxlLCBodG1sQ29uZmlnLCBodG1sVmlzdWFsRWxlbWVudCB9O1xuIiwiaW1wb3J0IHsgX19hc3NpZ24gfSBmcm9tICd0c2xpYic7XG5pbXBvcnQgeyB2aXN1YWxFbGVtZW50IH0gZnJvbSAnLi4vaW5kZXgubWpzJztcbmltcG9ydCB7IHNjcmFwZU1vdGlvblZhbHVlc0Zyb21Qcm9wcyB9IGZyb20gJy4vdXRpbHMvc2NyYXBlLW1vdGlvbi12YWx1ZXMubWpzJztcbmltcG9ydCB7IGh0bWxDb25maWcgfSBmcm9tICcuLi9odG1sL3Zpc3VhbC1lbGVtZW50Lm1qcyc7XG5pbXBvcnQgeyBidWlsZFNWR0F0dHJzIH0gZnJvbSAnLi91dGlscy9idWlsZC1hdHRycy5tanMnO1xuaW1wb3J0IHsgY2FtZWxUb0Rhc2ggfSBmcm9tICcuLi9kb20vdXRpbHMvY2FtZWwtdG8tZGFzaC5tanMnO1xuaW1wb3J0IHsgY2FtZWxDYXNlQXR0cmlidXRlcyB9IGZyb20gJy4vdXRpbHMvY2FtZWwtY2FzZS1hdHRycy5tanMnO1xuaW1wb3J0IHsgaXNUcmFuc2Zvcm1Qcm9wIH0gZnJvbSAnLi4vaHRtbC91dGlscy90cmFuc2Zvcm0ubWpzJztcbmltcG9ydCB7IHJlbmRlclNWRyB9IGZyb20gJy4vdXRpbHMvcmVuZGVyLm1qcyc7XG5pbXBvcnQgeyBnZXREZWZhdWx0VmFsdWVUeXBlIH0gZnJvbSAnLi4vZG9tL3ZhbHVlLXR5cGVzL2RlZmF1bHRzLm1qcyc7XG5cbnZhciBzdmdWaXN1YWxFbGVtZW50ID0gdmlzdWFsRWxlbWVudChfX2Fzc2lnbihfX2Fzc2lnbih7fSwgaHRtbENvbmZpZyksIHsgZ2V0QmFzZVRhcmdldDogZnVuY3Rpb24gKHByb3BzLCBrZXkpIHtcbiAgICAgICAgcmV0dXJuIHByb3BzW2tleV07XG4gICAgfSwgcmVhZFZhbHVlRnJvbUluc3RhbmNlOiBmdW5jdGlvbiAoZG9tRWxlbWVudCwga2V5KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKGlzVHJhbnNmb3JtUHJvcChrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gKChfYSA9IGdldERlZmF1bHRWYWx1ZVR5cGUoa2V5KSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRlZmF1bHQpIHx8IDA7XG4gICAgICAgIH1cbiAgICAgICAga2V5ID0gIWNhbWVsQ2FzZUF0dHJpYnV0ZXMuaGFzKGtleSkgPyBjYW1lbFRvRGFzaChrZXkpIDoga2V5O1xuICAgICAgICByZXR1cm4gZG9tRWxlbWVudC5nZXRBdHRyaWJ1dGUoa2V5KTtcbiAgICB9LCBzY3JhcGVNb3Rpb25WYWx1ZXNGcm9tUHJvcHM6IHNjcmFwZU1vdGlvblZhbHVlc0Zyb21Qcm9wcywgYnVpbGQ6IGZ1bmN0aW9uIChfZWxlbWVudCwgcmVuZGVyU3RhdGUsIGxhdGVzdFZhbHVlcywgb3B0aW9ucywgcHJvcHMpIHtcbiAgICAgICAgYnVpbGRTVkdBdHRycyhyZW5kZXJTdGF0ZSwgbGF0ZXN0VmFsdWVzLCBvcHRpb25zLCBwcm9wcy50cmFuc2Zvcm1UZW1wbGF0ZSk7XG4gICAgfSwgcmVuZGVyOiByZW5kZXJTVkcgfSkpO1xuXG5leHBvcnQgeyBzdmdWaXN1YWxFbGVtZW50IH07XG4iLCJpbXBvcnQgeyBodG1sVmlzdWFsRWxlbWVudCB9IGZyb20gJy4uL2h0bWwvdmlzdWFsLWVsZW1lbnQubWpzJztcbmltcG9ydCB7IHN2Z1Zpc3VhbEVsZW1lbnQgfSBmcm9tICcuLi9zdmcvdmlzdWFsLWVsZW1lbnQubWpzJztcbmltcG9ydCB7IGlzU1ZHQ29tcG9uZW50IH0gZnJvbSAnLi91dGlscy9pcy1zdmctY29tcG9uZW50Lm1qcyc7XG5cbnZhciBjcmVhdGVEb21WaXN1YWxFbGVtZW50ID0gZnVuY3Rpb24gKENvbXBvbmVudCwgb3B0aW9ucykge1xuICAgIHJldHVybiBpc1NWR0NvbXBvbmVudChDb21wb25lbnQpXG4gICAgICAgID8gc3ZnVmlzdWFsRWxlbWVudChvcHRpb25zLCB7IGVuYWJsZUhhcmR3YXJlQWNjZWxlcmF0aW9uOiBmYWxzZSB9KVxuICAgICAgICA6IGh0bWxWaXN1YWxFbGVtZW50KG9wdGlvbnMsIHsgZW5hYmxlSGFyZHdhcmVBY2NlbGVyYXRpb246IHRydWUgfSk7XG59O1xuXG5leHBvcnQgeyBjcmVhdGVEb21WaXN1YWxFbGVtZW50IH07XG4iLCJpbXBvcnQgeyBweCB9IGZyb20gJ3N0eWxlLXZhbHVlLXR5cGVzJztcblxuZnVuY3Rpb24gcGl4ZWxzVG9QZXJjZW50KHBpeGVscywgYXhpcykge1xuICAgIGlmIChheGlzLm1heCA9PT0gYXhpcy5taW4pXG4gICAgICAgIHJldHVybiAwO1xuICAgIHJldHVybiAocGl4ZWxzIC8gKGF4aXMubWF4IC0gYXhpcy5taW4pKSAqIDEwMDtcbn1cbi8qKlxuICogV2UgYWx3YXlzIGNvcnJlY3QgYm9yZGVyUmFkaXVzIGFzIGEgcGVyY2VudGFnZSByYXRoZXIgdGhhbiBwaXhlbHMgdG8gcmVkdWNlIHBhaW50cy5cbiAqIEZvciBleGFtcGxlLCBpZiB5b3UgYXJlIHByb2plY3RpbmcgYSBib3ggdGhhdCBpcyAxMDBweCB3aWRlIHdpdGggYSAxMHB4IGJvcmRlclJhZGl1c1xuICogaW50byBhIGJveCB0aGF0IGlzIDIwMHB4IHdpZGUgd2l0aCBhIDIwcHggYm9yZGVyUmFkaXVzLCB0aGF0IGlzIGFjdHVhbGx5IGEgMTAlXG4gKiBib3JkZXJSYWRpdXMgaW4gYm90aCBzdGF0ZXMuIElmIHdlIGFuaW1hdGUgYmV0d2VlbiB0aGUgdHdvIGluIHBpeGVscyB0aGF0IHdpbGwgdHJpZ2dlclxuICogYSBwYWludCBlYWNoIHRpbWUuIElmIHdlIGFuaW1hdGUgYmV0d2VlbiB0aGUgdHdvIGluIHBlcmNlbnRhZ2Ugd2UnbGwgYXZvaWQgYSBwYWludC5cbiAqL1xudmFyIGNvcnJlY3RCb3JkZXJSYWRpdXMgPSB7XG4gICAgY29ycmVjdDogZnVuY3Rpb24gKGxhdGVzdCwgbm9kZSkge1xuICAgICAgICBpZiAoIW5vZGUudGFyZ2V0KVxuICAgICAgICAgICAgcmV0dXJuIGxhdGVzdDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIGxhdGVzdCBpcyBhIHN0cmluZywgaWYgaXQncyBhIHBlcmNlbnRhZ2Ugd2UgY2FuIHJldHVybiBpbW1lZGlhdGVseSBhcyBpdCdzXG4gICAgICAgICAqIGdvaW5nIHRvIGJlIHN0cmV0Y2hlZCBhcHByb3ByaWF0ZWx5LiBPdGhlcndpc2UsIGlmIGl0J3MgYSBwaXhlbCwgY29udmVydCBpdCB0byBhIG51bWJlci5cbiAgICAgICAgICovXG4gICAgICAgIGlmICh0eXBlb2YgbGF0ZXN0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBpZiAocHgudGVzdChsYXRlc3QpKSB7XG4gICAgICAgICAgICAgICAgbGF0ZXN0ID0gcGFyc2VGbG9hdChsYXRlc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxhdGVzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgbGF0ZXN0IGlzIGEgbnVtYmVyLCBpdCdzIGEgcGl4ZWwgdmFsdWUuIFdlIHVzZSB0aGUgY3VycmVudCB2aWV3cG9ydEJveCB0byBjYWxjdWxhdGUgdGhhdFxuICAgICAgICAgKiBwaXhlbCB2YWx1ZSBhcyBhIHBlcmNlbnRhZ2Ugb2YgZWFjaCBheGlzXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgeCA9IHBpeGVsc1RvUGVyY2VudChsYXRlc3QsIG5vZGUudGFyZ2V0LngpO1xuICAgICAgICB2YXIgeSA9IHBpeGVsc1RvUGVyY2VudChsYXRlc3QsIG5vZGUudGFyZ2V0LnkpO1xuICAgICAgICByZXR1cm4gXCJcIi5jb25jYXQoeCwgXCIlIFwiKS5jb25jYXQoeSwgXCIlXCIpO1xuICAgIH0sXG59O1xuXG5leHBvcnQgeyBjb3JyZWN0Qm9yZGVyUmFkaXVzLCBwaXhlbHNUb1BlcmNlbnQgfTtcbiIsImltcG9ydCB7IG1peCB9IGZyb20gJ3BvcG1vdGlvbic7XG5pbXBvcnQgeyBjb21wbGV4IH0gZnJvbSAnc3R5bGUtdmFsdWUtdHlwZXMnO1xuaW1wb3J0IHsgY3NzVmFyaWFibGVSZWdleCB9IGZyb20gJy4uLy4uL3JlbmRlci9kb20vdXRpbHMvY3NzLXZhcmlhYmxlcy1jb252ZXJzaW9uLm1qcyc7XG5cbnZhciB2YXJUb2tlbiA9IFwiXyRjc3NcIjtcbnZhciBjb3JyZWN0Qm94U2hhZG93ID0ge1xuICAgIGNvcnJlY3Q6IGZ1bmN0aW9uIChsYXRlc3QsIF9hKSB7XG4gICAgICAgIHZhciB0cmVlU2NhbGUgPSBfYS50cmVlU2NhbGUsIHByb2plY3Rpb25EZWx0YSA9IF9hLnByb2plY3Rpb25EZWx0YTtcbiAgICAgICAgdmFyIG9yaWdpbmFsID0gbGF0ZXN0O1xuICAgICAgICAvKipcbiAgICAgICAgICogV2UgbmVlZCB0byBmaXJzdCBzdHJpcCBhbmQgc3RvcmUgQ1NTIHZhcmlhYmxlcyBmcm9tIHRoZSBzdHJpbmcuXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgY29udGFpbnNDU1NWYXJpYWJsZXMgPSBsYXRlc3QuaW5jbHVkZXMoXCJ2YXIoXCIpO1xuICAgICAgICB2YXIgY3NzVmFyaWFibGVzID0gW107XG4gICAgICAgIGlmIChjb250YWluc0NTU1ZhcmlhYmxlcykge1xuICAgICAgICAgICAgbGF0ZXN0ID0gbGF0ZXN0LnJlcGxhY2UoY3NzVmFyaWFibGVSZWdleCwgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgY3NzVmFyaWFibGVzLnB1c2gobWF0Y2gpO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YXJUb2tlbjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzaGFkb3cgPSBjb21wbGV4LnBhcnNlKGxhdGVzdCk7XG4gICAgICAgIC8vIFRPRE86IERvZXNuJ3Qgc3VwcG9ydCBtdWx0aXBsZSBzaGFkb3dzXG4gICAgICAgIGlmIChzaGFkb3cubGVuZ3RoID4gNSlcbiAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbDtcbiAgICAgICAgdmFyIHRlbXBsYXRlID0gY29tcGxleC5jcmVhdGVUcmFuc2Zvcm1lcihsYXRlc3QpO1xuICAgICAgICB2YXIgb2Zmc2V0ID0gdHlwZW9mIHNoYWRvd1swXSAhPT0gXCJudW1iZXJcIiA/IDEgOiAwO1xuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIG92ZXJhbGwgY29udGV4dCBzY2FsZVxuICAgICAgICB2YXIgeFNjYWxlID0gcHJvamVjdGlvbkRlbHRhLnguc2NhbGUgKiB0cmVlU2NhbGUueDtcbiAgICAgICAgdmFyIHlTY2FsZSA9IHByb2plY3Rpb25EZWx0YS55LnNjYWxlICogdHJlZVNjYWxlLnk7XG4gICAgICAgIHNoYWRvd1swICsgb2Zmc2V0XSAvPSB4U2NhbGU7XG4gICAgICAgIHNoYWRvd1sxICsgb2Zmc2V0XSAvPSB5U2NhbGU7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZGVhbGx5IHdlJ2QgY29ycmVjdCB4IGFuZCB5IHNjYWxlcyBpbmRpdmlkdWFsbHksIGJ1dCBiZWNhdXNlIGJsdXIgYW5kXG4gICAgICAgICAqIHNwcmVhZCBhcHBseSB0byBib3RoIHdlIGhhdmUgdG8gdGFrZSBhIHNjYWxlIGF2ZXJhZ2UgYW5kIGFwcGx5IHRoYXQgaW5zdGVhZC5cbiAgICAgICAgICogV2UgY291bGQgcG90ZW50aWFsbHkgaW1wcm92ZSB0aGUgb3V0Y29tZSBvZiB0aGlzIGJ5IGluY29ycG9yYXRpbmcgdGhlIHJhdGlvIGJldHdlZW5cbiAgICAgICAgICogdGhlIHR3byBzY2FsZXMuXG4gICAgICAgICAqL1xuICAgICAgICB2YXIgYXZlcmFnZVNjYWxlID0gbWl4KHhTY2FsZSwgeVNjYWxlLCAwLjUpO1xuICAgICAgICAvLyBCbHVyXG4gICAgICAgIGlmICh0eXBlb2Ygc2hhZG93WzIgKyBvZmZzZXRdID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgc2hhZG93WzIgKyBvZmZzZXRdIC89IGF2ZXJhZ2VTY2FsZTtcbiAgICAgICAgLy8gU3ByZWFkXG4gICAgICAgIGlmICh0eXBlb2Ygc2hhZG93WzMgKyBvZmZzZXRdID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgc2hhZG93WzMgKyBvZmZzZXRdIC89IGF2ZXJhZ2VTY2FsZTtcbiAgICAgICAgdmFyIG91dHB1dCA9IHRlbXBsYXRlKHNoYWRvdyk7XG4gICAgICAgIGlmIChjb250YWluc0NTU1ZhcmlhYmxlcykge1xuICAgICAgICAgICAgdmFyIGlfMSA9IDA7XG4gICAgICAgICAgICBvdXRwdXQgPSBvdXRwdXQucmVwbGFjZSh2YXJUb2tlbiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBjc3NWYXJpYWJsZSA9IGNzc1ZhcmlhYmxlc1tpXzFdO1xuICAgICAgICAgICAgICAgIGlfMSsrO1xuICAgICAgICAgICAgICAgIHJldHVybiBjc3NWYXJpYWJsZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfSxcbn07XG5cbmV4cG9ydCB7IGNvcnJlY3RCb3hTaGFkb3cgfTtcbiIsImltcG9ydCB7IF9fZXh0ZW5kcywgX19hc3NpZ24sIF9fcmVhZCB9IGZyb20gJ3RzbGliJztcbmltcG9ydCBzeW5jIGZyb20gJ2ZyYW1lc3luYyc7XG5pbXBvcnQgUmVhY3RfX2RlZmF1bHQsIHsgdXNlQ29udGV4dCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZVByZXNlbmNlIH0gZnJvbSAnLi4vLi4vLi4vY29tcG9uZW50cy9BbmltYXRlUHJlc2VuY2UvdXNlLXByZXNlbmNlLm1qcyc7XG5pbXBvcnQgeyBMYXlvdXRHcm91cENvbnRleHQgfSBmcm9tICcuLi8uLi8uLi9jb250ZXh0L0xheW91dEdyb3VwQ29udGV4dC5tanMnO1xuaW1wb3J0IHsgU3dpdGNoTGF5b3V0R3JvdXBDb250ZXh0IH0gZnJvbSAnLi4vLi4vLi4vY29udGV4dC9Td2l0Y2hMYXlvdXRHcm91cENvbnRleHQubWpzJztcbmltcG9ydCB7IGdsb2JhbFByb2plY3Rpb25TdGF0ZSB9IGZyb20gJy4uLy4uLy4uL3Byb2plY3Rpb24vbm9kZS9zdGF0ZS5tanMnO1xuaW1wb3J0IHsgY29ycmVjdEJvcmRlclJhZGl1cyB9IGZyb20gJy4uLy4uLy4uL3Byb2plY3Rpb24vc3R5bGVzL3NjYWxlLWJvcmRlci1yYWRpdXMubWpzJztcbmltcG9ydCB7IGNvcnJlY3RCb3hTaGFkb3cgfSBmcm9tICcuLi8uLi8uLi9wcm9qZWN0aW9uL3N0eWxlcy9zY2FsZS1ib3gtc2hhZG93Lm1qcyc7XG5pbXBvcnQgeyBhZGRTY2FsZUNvcnJlY3RvciB9IGZyb20gJy4uLy4uLy4uL3Byb2plY3Rpb24vc3R5bGVzL3NjYWxlLWNvcnJlY3Rpb24ubWpzJztcblxudmFyIE1lYXN1cmVMYXlvdXRXaXRoQ29udGV4dCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoTWVhc3VyZUxheW91dFdpdGhDb250ZXh0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1lYXN1cmVMYXlvdXRXaXRoQ29udGV4dCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIG9ubHkgbW91bnRzIHByb2plY3Rpb24gbm9kZXMgZm9yIGNvbXBvbmVudHMgdGhhdFxuICAgICAqIG5lZWQgbWVhc3VyaW5nLCB3ZSBtaWdodCB3YW50IHRvIGRvIGl0IGZvciBhbGwgY29tcG9uZW50c1xuICAgICAqIGluIG9yZGVyIHRvIGluY29ycG9yYXRlIHRyYW5zZm9ybXNcbiAgICAgKi9cbiAgICBNZWFzdXJlTGF5b3V0V2l0aENvbnRleHQucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgX2EgPSB0aGlzLnByb3BzLCB2aXN1YWxFbGVtZW50ID0gX2EudmlzdWFsRWxlbWVudCwgbGF5b3V0R3JvdXAgPSBfYS5sYXlvdXRHcm91cCwgc3dpdGNoTGF5b3V0R3JvdXAgPSBfYS5zd2l0Y2hMYXlvdXRHcm91cCwgbGF5b3V0SWQgPSBfYS5sYXlvdXRJZDtcbiAgICAgICAgdmFyIHByb2plY3Rpb24gPSB2aXN1YWxFbGVtZW50LnByb2plY3Rpb247XG4gICAgICAgIGFkZFNjYWxlQ29ycmVjdG9yKGRlZmF1bHRTY2FsZUNvcnJlY3RvcnMpO1xuICAgICAgICBpZiAocHJvamVjdGlvbikge1xuICAgICAgICAgICAgaWYgKGxheW91dEdyb3VwID09PSBudWxsIHx8IGxheW91dEdyb3VwID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsYXlvdXRHcm91cC5ncm91cClcbiAgICAgICAgICAgICAgICBsYXlvdXRHcm91cC5ncm91cC5hZGQocHJvamVjdGlvbik7XG4gICAgICAgICAgICBpZiAoKHN3aXRjaExheW91dEdyb3VwID09PSBudWxsIHx8IHN3aXRjaExheW91dEdyb3VwID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzd2l0Y2hMYXlvdXRHcm91cC5yZWdpc3RlcikgJiYgbGF5b3V0SWQpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2hMYXlvdXRHcm91cC5yZWdpc3Rlcihwcm9qZWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByb2plY3Rpb24ucm9vdC5kaWRVcGRhdGUoKTtcbiAgICAgICAgICAgIHByb2plY3Rpb24uYWRkRXZlbnRMaXN0ZW5lcihcImFuaW1hdGlvbkNvbXBsZXRlXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zYWZlVG9SZW1vdmUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcHJvamVjdGlvbi5zZXRPcHRpb25zKF9fYXNzaWduKF9fYXNzaWduKHt9LCBwcm9qZWN0aW9uLm9wdGlvbnMpLCB7IG9uRXhpdENvbXBsZXRlOiBmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5zYWZlVG9SZW1vdmUoKTsgfSB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgZ2xvYmFsUHJvamVjdGlvblN0YXRlLmhhc0V2ZXJVcGRhdGVkID0gdHJ1ZTtcbiAgICB9O1xuICAgIE1lYXN1cmVMYXlvdXRXaXRoQ29udGV4dC5wcm90b3R5cGUuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgPSBmdW5jdGlvbiAocHJldlByb3BzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYSA9IHRoaXMucHJvcHMsIGxheW91dERlcGVuZGVuY3kgPSBfYS5sYXlvdXREZXBlbmRlbmN5LCB2aXN1YWxFbGVtZW50ID0gX2EudmlzdWFsRWxlbWVudCwgZHJhZyA9IF9hLmRyYWcsIGlzUHJlc2VudCA9IF9hLmlzUHJlc2VudDtcbiAgICAgICAgdmFyIHByb2plY3Rpb24gPSB2aXN1YWxFbGVtZW50LnByb2plY3Rpb247XG4gICAgICAgIGlmICghcHJvamVjdGlvbilcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogVE9ETzogV2UgdXNlIHRoaXMgZGF0YSBpbiByZWxlZ2F0ZSB0byBkZXRlcm1pbmUgd2hldGhlciB0b1xuICAgICAgICAgKiBwcm9tb3RlIGEgcHJldmlvdXMgZWxlbWVudC4gVGhlcmUncyBubyBndWFyYW50ZWUgaXRzIHByZXNlbmNlIGRhdGFcbiAgICAgICAgICogd2lsbCBoYXZlIHVwZGF0ZWQgYnkgdGhpcyBwb2ludCAtIGlmIGEgYnVnIGxpa2UgdGhpcyBhcmlzZXMgaXQgd2lsbFxuICAgICAgICAgKiBoYXZlIHRvIGJlIHRoYXQgd2UgbWFya0ZvclJlbGVnYXRpb24gYW5kIHRoZW4gZmluZCBhIG5ldyBsZWFkIHNvbWUgb3RoZXIgd2F5LFxuICAgICAgICAgKiBwZXJoYXBzIGluIGRpZFVwZGF0ZVxuICAgICAgICAgKi9cbiAgICAgICAgcHJvamVjdGlvbi5pc1ByZXNlbnQgPSBpc1ByZXNlbnQ7XG4gICAgICAgIGlmIChkcmFnIHx8XG4gICAgICAgICAgICBwcmV2UHJvcHMubGF5b3V0RGVwZW5kZW5jeSAhPT0gbGF5b3V0RGVwZW5kZW5jeSB8fFxuICAgICAgICAgICAgbGF5b3V0RGVwZW5kZW5jeSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwcm9qZWN0aW9uLndpbGxVcGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2FmZVRvUmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByZXZQcm9wcy5pc1ByZXNlbnQgIT09IGlzUHJlc2VudCkge1xuICAgICAgICAgICAgaWYgKGlzUHJlc2VudCkge1xuICAgICAgICAgICAgICAgIHByb2plY3Rpb24ucHJvbW90ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIXByb2plY3Rpb24ucmVsZWdhdGUoKSkge1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIElmIHRoZXJlJ3MgYW5vdGhlciBzdGFjayBtZW1iZXIgdGFraW5nIG92ZXIgZnJvbSB0aGlzIG9uZSxcbiAgICAgICAgICAgICAgICAgKiBpdCdzIGluIGNoYXJnZSBvZiB0aGUgZXhpdCBhbmltYXRpb24gYW5kIHRoZXJlZm9yZSBzaG91bGRcbiAgICAgICAgICAgICAgICAgKiBiZSBpbiBjaGFyZ2Ugb2YgdGhlIHNhZmUgdG8gcmVtb3ZlLiBPdGhlcndpc2Ugd2UgY2FsbCBpdCBoZXJlLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHN5bmMucG9zdFJlbmRlcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoKF9hID0gcHJvamVjdGlvbi5nZXRTdGFjaygpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWVtYmVycy5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zYWZlVG9SZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgTWVhc3VyZUxheW91dFdpdGhDb250ZXh0LnByb3RvdHlwZS5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwcm9qZWN0aW9uID0gdGhpcy5wcm9wcy52aXN1YWxFbGVtZW50LnByb2plY3Rpb247XG4gICAgICAgIGlmIChwcm9qZWN0aW9uKSB7XG4gICAgICAgICAgICBwcm9qZWN0aW9uLnJvb3QuZGlkVXBkYXRlKCk7XG4gICAgICAgICAgICBpZiAoIXByb2plY3Rpb24uY3VycmVudEFuaW1hdGlvbiAmJiBwcm9qZWN0aW9uLmlzTGVhZCgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zYWZlVG9SZW1vdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgTWVhc3VyZUxheW91dFdpdGhDb250ZXh0LnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hID0gdGhpcy5wcm9wcywgdmlzdWFsRWxlbWVudCA9IF9hLnZpc3VhbEVsZW1lbnQsIGxheW91dEdyb3VwID0gX2EubGF5b3V0R3JvdXAsIHByb21vdGVDb250ZXh0ID0gX2Euc3dpdGNoTGF5b3V0R3JvdXA7XG4gICAgICAgIHZhciBwcm9qZWN0aW9uID0gdmlzdWFsRWxlbWVudC5wcm9qZWN0aW9uO1xuICAgICAgICBpZiAocHJvamVjdGlvbikge1xuICAgICAgICAgICAgcHJvamVjdGlvbi5zY2hlZHVsZUNoZWNrQWZ0ZXJVbm1vdW50KCk7XG4gICAgICAgICAgICBpZiAobGF5b3V0R3JvdXAgPT09IG51bGwgfHwgbGF5b3V0R3JvdXAgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxheW91dEdyb3VwLmdyb3VwKVxuICAgICAgICAgICAgICAgIGxheW91dEdyb3VwLmdyb3VwLnJlbW92ZShwcm9qZWN0aW9uKTtcbiAgICAgICAgICAgIGlmIChwcm9tb3RlQ29udGV4dCA9PT0gbnVsbCB8fCBwcm9tb3RlQ29udGV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJvbW90ZUNvbnRleHQuZGVyZWdpc3RlcilcbiAgICAgICAgICAgICAgICBwcm9tb3RlQ29udGV4dC5kZXJlZ2lzdGVyKHByb2plY3Rpb24pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNZWFzdXJlTGF5b3V0V2l0aENvbnRleHQucHJvdG90eXBlLnNhZmVUb1JlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNhZmVUb1JlbW92ZSA9IHRoaXMucHJvcHMuc2FmZVRvUmVtb3ZlO1xuICAgICAgICBzYWZlVG9SZW1vdmUgPT09IG51bGwgfHwgc2FmZVRvUmVtb3ZlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzYWZlVG9SZW1vdmUoKTtcbiAgICB9O1xuICAgIE1lYXN1cmVMYXlvdXRXaXRoQ29udGV4dC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIHJldHVybiBNZWFzdXJlTGF5b3V0V2l0aENvbnRleHQ7XG59KFJlYWN0X19kZWZhdWx0LkNvbXBvbmVudCkpO1xuZnVuY3Rpb24gTWVhc3VyZUxheW91dChwcm9wcykge1xuICAgIHZhciBfYSA9IF9fcmVhZCh1c2VQcmVzZW5jZSgpLCAyKSwgaXNQcmVzZW50ID0gX2FbMF0sIHNhZmVUb1JlbW92ZSA9IF9hWzFdO1xuICAgIHZhciBsYXlvdXRHcm91cCA9IHVzZUNvbnRleHQoTGF5b3V0R3JvdXBDb250ZXh0KTtcbiAgICByZXR1cm4gKFJlYWN0X19kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoTWVhc3VyZUxheW91dFdpdGhDb250ZXh0LCBfX2Fzc2lnbih7fSwgcHJvcHMsIHsgbGF5b3V0R3JvdXA6IGxheW91dEdyb3VwLCBzd2l0Y2hMYXlvdXRHcm91cDogdXNlQ29udGV4dChTd2l0Y2hMYXlvdXRHcm91cENvbnRleHQpLCBpc1ByZXNlbnQ6IGlzUHJlc2VudCwgc2FmZVRvUmVtb3ZlOiBzYWZlVG9SZW1vdmUgfSkpKTtcbn1cbnZhciBkZWZhdWx0U2NhbGVDb3JyZWN0b3JzID0ge1xuICAgIGJvcmRlclJhZGl1czogX19hc3NpZ24oX19hc3NpZ24oe30sIGNvcnJlY3RCb3JkZXJSYWRpdXMpLCB7IGFwcGx5VG86IFtcbiAgICAgICAgICAgIFwiYm9yZGVyVG9wTGVmdFJhZGl1c1wiLFxuICAgICAgICAgICAgXCJib3JkZXJUb3BSaWdodFJhZGl1c1wiLFxuICAgICAgICAgICAgXCJib3JkZXJCb3R0b21MZWZ0UmFkaXVzXCIsXG4gICAgICAgICAgICBcImJvcmRlckJvdHRvbVJpZ2h0UmFkaXVzXCIsXG4gICAgICAgIF0gfSksXG4gICAgYm9yZGVyVG9wTGVmdFJhZGl1czogY29ycmVjdEJvcmRlclJhZGl1cyxcbiAgICBib3JkZXJUb3BSaWdodFJhZGl1czogY29ycmVjdEJvcmRlclJhZGl1cyxcbiAgICBib3JkZXJCb3R0b21MZWZ0UmFkaXVzOiBjb3JyZWN0Qm9yZGVyUmFkaXVzLFxuICAgIGJvcmRlckJvdHRvbVJpZ2h0UmFkaXVzOiBjb3JyZWN0Qm9yZGVyUmFkaXVzLFxuICAgIGJveFNoYWRvdzogY29ycmVjdEJveFNoYWRvdyxcbn07XG5cbmV4cG9ydCB7IE1lYXN1cmVMYXlvdXQgfTtcbiIsImltcG9ydCB7IE1lYXN1cmVMYXlvdXQgfSBmcm9tICcuL01lYXN1cmVMYXlvdXQubWpzJztcblxudmFyIGxheW91dEZlYXR1cmVzID0ge1xuICAgIG1lYXN1cmVMYXlvdXQ6IE1lYXN1cmVMYXlvdXQsXG59O1xuXG5leHBvcnQgeyBsYXlvdXRGZWF0dXJlcyB9O1xuIiwiaW1wb3J0IHsgbW90aW9uVmFsdWUgfSBmcm9tICcuLi92YWx1ZS9pbmRleC5tanMnO1xuaW1wb3J0IHsgaXNNb3Rpb25WYWx1ZSB9IGZyb20gJy4uL3ZhbHVlL3V0aWxzL2lzLW1vdGlvbi12YWx1ZS5tanMnO1xuaW1wb3J0IHsgc3RhcnRBbmltYXRpb24gfSBmcm9tICcuL3V0aWxzL3RyYW5zaXRpb25zLm1qcyc7XG5cbi8qKlxuICogQW5pbWF0ZSBhIHNpbmdsZSB2YWx1ZSBvciBhIGBNb3Rpb25WYWx1ZWAuXG4gKlxuICogVGhlIGZpcnN0IGFyZ3VtZW50IGlzIGVpdGhlciBhIGBNb3Rpb25WYWx1ZWAgdG8gYW5pbWF0ZSwgb3IgYW4gaW5pdGlhbCBhbmltYXRpb24gdmFsdWUuXG4gKlxuICogVGhlIHNlY29uZCBpcyBlaXRoZXIgYSB2YWx1ZSB0byBhbmltYXRlIHRvLCBvciBhbiBhcnJheSBvZiBrZXlmcmFtZXMgdG8gYW5pbWF0ZSB0aHJvdWdoLlxuICpcbiAqIFRoZSB0aGlyZCBhcmd1bWVudCBjYW4gYmUgZWl0aGVyIHR3ZWVuIG9yIHNwcmluZyBvcHRpb25zLCBhbmQgb3B0aW9uYWwgbGlmZWN5Y2xlIG1ldGhvZHM6IGBvblVwZGF0ZWAsIGBvblBsYXlgLCBgb25Db21wbGV0ZWAsIGBvblJlcGVhdGAgYW5kIGBvblN0b3BgLlxuICpcbiAqIFJldHVybnMgYEFuaW1hdGlvblBsYXliYWNrQ29udHJvbHNgLCBjdXJyZW50bHkganVzdCBhIGBzdG9wYCBtZXRob2QuXG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogY29uc3QgeCA9IHVzZU1vdGlvblZhbHVlKDApXG4gKlxuICogdXNlRWZmZWN0KCgpID0+IHtcbiAqICAgY29uc3QgY29udHJvbHMgPSBhbmltYXRlKHgsIDEwMCwge1xuICogICAgIHR5cGU6IFwic3ByaW5nXCIsXG4gKiAgICAgc3RpZmZuZXNzOiAyMDAwLFxuICogICAgIG9uQ29tcGxldGU6IHYgPT4ge31cbiAqICAgfSlcbiAqXG4gKiAgIHJldHVybiBjb250cm9scy5zdG9wXG4gKiB9KVxuICogYGBgXG4gKlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBhbmltYXRlKGZyb20sIHRvLCB0cmFuc2l0aW9uKSB7XG4gICAgaWYgKHRyYW5zaXRpb24gPT09IHZvaWQgMCkgeyB0cmFuc2l0aW9uID0ge307IH1cbiAgICB2YXIgdmFsdWUgPSBpc01vdGlvblZhbHVlKGZyb20pID8gZnJvbSA6IG1vdGlvblZhbHVlKGZyb20pO1xuICAgIHN0YXJ0QW5pbWF0aW9uKFwiXCIsIHZhbHVlLCB0bywgdHJhbnNpdGlvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3RvcDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdmFsdWUuc3RvcCgpOyB9LFxuICAgICAgICBpc0FuaW1hdGluZzogZnVuY3Rpb24gKCkgeyByZXR1cm4gdmFsdWUuaXNBbmltYXRpbmcoKTsgfSxcbiAgICB9O1xufVxuXG5leHBvcnQgeyBhbmltYXRlIH07XG4iLCJpbXBvcnQgeyBtaXgsIHByb2dyZXNzLCBsaW5lYXIsIGNpcmNPdXQgfSBmcm9tICdwb3Btb3Rpb24nO1xuaW1wb3J0IHsgcHgsIHBlcmNlbnQgfSBmcm9tICdzdHlsZS12YWx1ZS10eXBlcyc7XG5cbnZhciBib3JkZXJzID0gW1wiVG9wTGVmdFwiLCBcIlRvcFJpZ2h0XCIsIFwiQm90dG9tTGVmdFwiLCBcIkJvdHRvbVJpZ2h0XCJdO1xudmFyIG51bUJvcmRlcnMgPSBib3JkZXJzLmxlbmd0aDtcbnZhciBhc051bWJlciA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgPyBwYXJzZUZsb2F0KHZhbHVlKSA6IHZhbHVlO1xufTtcbnZhciBpc1B4ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiB8fCBweC50ZXN0KHZhbHVlKTtcbn07XG5mdW5jdGlvbiBtaXhWYWx1ZXModGFyZ2V0LCBmb2xsb3csIGxlYWQsIHByb2dyZXNzLCBzaG91bGRDcm9zc2ZhZGVPcGFjaXR5LCBpc09ubHlNZW1iZXIpIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgaWYgKHNob3VsZENyb3NzZmFkZU9wYWNpdHkpIHtcbiAgICAgICAgdGFyZ2V0Lm9wYWNpdHkgPSBtaXgoMCwgXG4gICAgICAgIC8vIChmb2xsb3c/Lm9wYWNpdHkgYXMgbnVtYmVyKSA/PyAwLFxuICAgICAgICAvLyBUT0RPIFJlaW5zdGF0ZSB0aGlzIGlmIG9ubHkgY2hpbGRcbiAgICAgICAgKF9hID0gbGVhZC5vcGFjaXR5KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAxLCBlYXNlQ3Jvc3NmYWRlSW4ocHJvZ3Jlc3MpKTtcbiAgICAgICAgdGFyZ2V0Lm9wYWNpdHlFeGl0ID0gbWl4KChfYiA9IGZvbGxvdy5vcGFjaXR5KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAxLCAwLCBlYXNlQ3Jvc3NmYWRlT3V0KHByb2dyZXNzKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzT25seU1lbWJlcikge1xuICAgICAgICB0YXJnZXQub3BhY2l0eSA9IG1peCgoX2MgPSBmb2xsb3cub3BhY2l0eSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogMSwgKF9kID0gbGVhZC5vcGFjaXR5KSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiAxLCBwcm9ncmVzcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1peCBib3JkZXIgcmFkaXVzXG4gICAgICovXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1Cb3JkZXJzOyBpKyspIHtcbiAgICAgICAgdmFyIGJvcmRlckxhYmVsID0gXCJib3JkZXJcIi5jb25jYXQoYm9yZGVyc1tpXSwgXCJSYWRpdXNcIik7XG4gICAgICAgIHZhciBmb2xsb3dSYWRpdXMgPSBnZXRSYWRpdXMoZm9sbG93LCBib3JkZXJMYWJlbCk7XG4gICAgICAgIHZhciBsZWFkUmFkaXVzID0gZ2V0UmFkaXVzKGxlYWQsIGJvcmRlckxhYmVsKTtcbiAgICAgICAgaWYgKGZvbGxvd1JhZGl1cyA9PT0gdW5kZWZpbmVkICYmIGxlYWRSYWRpdXMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBmb2xsb3dSYWRpdXMgfHwgKGZvbGxvd1JhZGl1cyA9IDApO1xuICAgICAgICBsZWFkUmFkaXVzIHx8IChsZWFkUmFkaXVzID0gMCk7XG4gICAgICAgIHZhciBjYW5NaXggPSBmb2xsb3dSYWRpdXMgPT09IDAgfHxcbiAgICAgICAgICAgIGxlYWRSYWRpdXMgPT09IDAgfHxcbiAgICAgICAgICAgIGlzUHgoZm9sbG93UmFkaXVzKSA9PT0gaXNQeChsZWFkUmFkaXVzKTtcbiAgICAgICAgaWYgKGNhbk1peCkge1xuICAgICAgICAgICAgdGFyZ2V0W2JvcmRlckxhYmVsXSA9IE1hdGgubWF4KG1peChhc051bWJlcihmb2xsb3dSYWRpdXMpLCBhc051bWJlcihsZWFkUmFkaXVzKSwgcHJvZ3Jlc3MpLCAwKTtcbiAgICAgICAgICAgIGlmIChwZXJjZW50LnRlc3QobGVhZFJhZGl1cykgfHwgcGVyY2VudC50ZXN0KGZvbGxvd1JhZGl1cykpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRbYm9yZGVyTGFiZWxdICs9IFwiJVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGFyZ2V0W2JvcmRlckxhYmVsXSA9IGxlYWRSYWRpdXM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogTWl4IHJvdGF0aW9uXG4gICAgICovXG4gICAgaWYgKGZvbGxvdy5yb3RhdGUgfHwgbGVhZC5yb3RhdGUpIHtcbiAgICAgICAgdGFyZ2V0LnJvdGF0ZSA9IG1peChmb2xsb3cucm90YXRlIHx8IDAsIGxlYWQucm90YXRlIHx8IDAsIHByb2dyZXNzKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRSYWRpdXModmFsdWVzLCByYWRpdXNOYW1lKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoX2EgPSB2YWx1ZXNbcmFkaXVzTmFtZV0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHZhbHVlcy5ib3JkZXJSYWRpdXM7XG59XG4vLyAvKipcbi8vICAqIFdlIG9ubHkgd2FudCB0byBtaXggdGhlIGJhY2tncm91bmQgY29sb3IgaWYgdGhlcmUncyBhIGZvbGxvdyBlbGVtZW50XG4vLyAgKiB0aGF0IHdlJ3JlIG5vdCBjcm9zc2ZhZGluZyBvcGFjaXR5IGJldHdlZW4uIEZvciBpbnN0YW5jZSB3aXRoIHN3aXRjaFxuLy8gICogQW5pbWF0ZVNoYXJlZExheW91dCBhbmltYXRpb25zLCB0aGlzIGhlbHBzIHRoZSBpbGx1c2lvbiBvZiBhIGNvbnRpbnVvdXNcbi8vICAqIGVsZW1lbnQgYmVpbmcgYW5pbWF0ZWQgYnV0IGFsc28gY3V0cyBkb3duIG9uIHRoZSBudW1iZXIgb2YgcGFpbnRzIHRyaWdnZXJlZFxuLy8gICogZm9yIGVsZW1lbnRzIHdoZXJlIG9wYWNpdHkgaXMgZG9pbmcgdGhhdCB3b3JrIGZvciB1cy5cbi8vICAqL1xuLy8gaWYgKFxuLy8gICAgICFoYXNGb2xsb3dFbGVtZW50ICYmXG4vLyAgICAgbGF0ZXN0TGVhZFZhbHVlcy5iYWNrZ3JvdW5kQ29sb3IgJiZcbi8vICAgICBsYXRlc3RGb2xsb3dWYWx1ZXMuYmFja2dyb3VuZENvbG9yXG4vLyApIHtcbi8vICAgICAvKipcbi8vICAgICAgKiBUaGlzIGlzbid0IGlkZWFsIHBlcmZvcm1hbmNlLXdpc2UgYXMgbWl4Q29sb3IgaXMgY3JlYXRpbmcgYSBuZXcgZnVuY3Rpb24gZXZlcnkgZnJhbWUuXG4vLyAgICAgICogV2UgY291bGQgcHJvYmFibHkgY3JlYXRlIGEgbWl4ZXIgdGhhdCBydW5zIGF0IHRoZSBzdGFydCBvZiB0aGUgYW5pbWF0aW9uIGJ1dFxuLy8gICAgICAqIHRoZSBpZGVhIGJlaGluZCB0aGUgY3Jvc3NmYWRlciBpcyB0aGF0IGl0IHJ1bnMgZHluYW1pY2FsbHkgYmV0d2VlbiB0d28gcG90ZW50aWFsbHlcbi8vICAgICAgKiBjaGFuZ2luZyB0YXJnZXRzIChpZSBvcGFjaXR5IG9yIGJvcmRlclJhZGl1cyBtYXkgYmUgYW5pbWF0aW5nIGluZGVwZW5kZW50bHkgdmlhIHZhcmlhbnRzKVxuLy8gICAgICAqL1xuLy8gICAgIGxlYWRTdGF0ZS5iYWNrZ3JvdW5kQ29sb3IgPSBmb2xsb3dTdGF0ZS5iYWNrZ3JvdW5kQ29sb3IgPSBtaXhDb2xvcihcbi8vICAgICAgICAgbGF0ZXN0Rm9sbG93VmFsdWVzLmJhY2tncm91bmRDb2xvciBhcyBzdHJpbmcsXG4vLyAgICAgICAgIGxhdGVzdExlYWRWYWx1ZXMuYmFja2dyb3VuZENvbG9yIGFzIHN0cmluZ1xuLy8gICAgICkocClcbi8vIH1cbnZhciBlYXNlQ3Jvc3NmYWRlSW4gPSBjb21wcmVzcygwLCAwLjUsIGNpcmNPdXQpO1xudmFyIGVhc2VDcm9zc2ZhZGVPdXQgPSBjb21wcmVzcygwLjUsIDAuOTUsIGxpbmVhcik7XG5mdW5jdGlvbiBjb21wcmVzcyhtaW4sIG1heCwgZWFzaW5nKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIC8vIENvdWxkIHJlcGxhY2UgaWZzIHdpdGggY2xhbXBcbiAgICAgICAgaWYgKHAgPCBtaW4pXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgaWYgKHAgPiBtYXgpXG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgcmV0dXJuIGVhc2luZyhwcm9ncmVzcyhtaW4sIG1heCwgcCkpO1xuICAgIH07XG59XG5cbmV4cG9ydCB7IG1peFZhbHVlcyB9O1xuIiwiLyoqXG4gKiBSZXNldCBhbiBheGlzIHRvIHRoZSBwcm92aWRlZCBvcmlnaW4gYm94LlxuICpcbiAqIFRoaXMgaXMgYSBtdXRhdGl2ZSBvcGVyYXRpb24uXG4gKi9cbmZ1bmN0aW9uIGNvcHlBeGlzSW50byhheGlzLCBvcmlnaW5BeGlzKSB7XG4gICAgYXhpcy5taW4gPSBvcmlnaW5BeGlzLm1pbjtcbiAgICBheGlzLm1heCA9IG9yaWdpbkF4aXMubWF4O1xufVxuLyoqXG4gKiBSZXNldCBhIGJveCB0byB0aGUgcHJvdmlkZWQgb3JpZ2luIGJveC5cbiAqXG4gKiBUaGlzIGlzIGEgbXV0YXRpdmUgb3BlcmF0aW9uLlxuICovXG5mdW5jdGlvbiBjb3B5Qm94SW50byhib3gsIG9yaWdpbkJveCkge1xuICAgIGNvcHlBeGlzSW50byhib3gueCwgb3JpZ2luQm94LngpO1xuICAgIGNvcHlBeGlzSW50byhib3gueSwgb3JpZ2luQm94LnkpO1xufVxuXG5leHBvcnQgeyBjb3B5QXhpc0ludG8sIGNvcHlCb3hJbnRvIH07XG4iLCJpbXBvcnQgeyBfX3JlYWQgfSBmcm9tICd0c2xpYic7XG5pbXBvcnQgeyBtaXggfSBmcm9tICdwb3Btb3Rpb24nO1xuaW1wb3J0IHsgcGVyY2VudCB9IGZyb20gJ3N0eWxlLXZhbHVlLXR5cGVzJztcbmltcG9ydCB7IHNjYWxlUG9pbnQgfSBmcm9tICcuL2RlbHRhLWFwcGx5Lm1qcyc7XG5cbi8qKlxuICogUmVtb3ZlIGEgZGVsdGEgZnJvbSBhIHBvaW50LiBUaGlzIGlzIGVzc2VudGlhbGx5IHRoZSBzdGVwcyBvZiBhcHBseVBvaW50RGVsdGEgaW4gcmV2ZXJzZVxuICovXG5mdW5jdGlvbiByZW1vdmVQb2ludERlbHRhKHBvaW50LCB0cmFuc2xhdGUsIHNjYWxlLCBvcmlnaW5Qb2ludCwgYm94U2NhbGUpIHtcbiAgICBwb2ludCAtPSB0cmFuc2xhdGU7XG4gICAgcG9pbnQgPSBzY2FsZVBvaW50KHBvaW50LCAxIC8gc2NhbGUsIG9yaWdpblBvaW50KTtcbiAgICBpZiAoYm94U2NhbGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwb2ludCA9IHNjYWxlUG9pbnQocG9pbnQsIDEgLyBib3hTY2FsZSwgb3JpZ2luUG9pbnQpO1xuICAgIH1cbiAgICByZXR1cm4gcG9pbnQ7XG59XG4vKipcbiAqIFJlbW92ZSBhIGRlbHRhIGZyb20gYW4gYXhpcy4gVGhpcyBpcyBlc3NlbnRpYWxseSB0aGUgc3RlcHMgb2YgYXBwbHlBeGlzRGVsdGEgaW4gcmV2ZXJzZVxuICovXG5mdW5jdGlvbiByZW1vdmVBeGlzRGVsdGEoYXhpcywgdHJhbnNsYXRlLCBzY2FsZSwgb3JpZ2luLCBib3hTY2FsZSwgb3JpZ2luQXhpcywgc291cmNlQXhpcykge1xuICAgIGlmICh0cmFuc2xhdGUgPT09IHZvaWQgMCkgeyB0cmFuc2xhdGUgPSAwOyB9XG4gICAgaWYgKHNjYWxlID09PSB2b2lkIDApIHsgc2NhbGUgPSAxOyB9XG4gICAgaWYgKG9yaWdpbiA9PT0gdm9pZCAwKSB7IG9yaWdpbiA9IDAuNTsgfVxuICAgIGlmIChvcmlnaW5BeGlzID09PSB2b2lkIDApIHsgb3JpZ2luQXhpcyA9IGF4aXM7IH1cbiAgICBpZiAoc291cmNlQXhpcyA9PT0gdm9pZCAwKSB7IHNvdXJjZUF4aXMgPSBheGlzOyB9XG4gICAgaWYgKHBlcmNlbnQudGVzdCh0cmFuc2xhdGUpKSB7XG4gICAgICAgIHRyYW5zbGF0ZSA9IHBhcnNlRmxvYXQodHJhbnNsYXRlKTtcbiAgICAgICAgdmFyIHJlbGF0aXZlUHJvZ3Jlc3MgPSBtaXgoc291cmNlQXhpcy5taW4sIHNvdXJjZUF4aXMubWF4LCB0cmFuc2xhdGUgLyAxMDApO1xuICAgICAgICB0cmFuc2xhdGUgPSByZWxhdGl2ZVByb2dyZXNzIC0gc291cmNlQXhpcy5taW47XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdHJhbnNsYXRlICE9PSBcIm51bWJlclwiKVxuICAgICAgICByZXR1cm47XG4gICAgdmFyIG9yaWdpblBvaW50ID0gbWl4KG9yaWdpbkF4aXMubWluLCBvcmlnaW5BeGlzLm1heCwgb3JpZ2luKTtcbiAgICBpZiAoYXhpcyA9PT0gb3JpZ2luQXhpcylcbiAgICAgICAgb3JpZ2luUG9pbnQgLT0gdHJhbnNsYXRlO1xuICAgIGF4aXMubWluID0gcmVtb3ZlUG9pbnREZWx0YShheGlzLm1pbiwgdHJhbnNsYXRlLCBzY2FsZSwgb3JpZ2luUG9pbnQsIGJveFNjYWxlKTtcbiAgICBheGlzLm1heCA9IHJlbW92ZVBvaW50RGVsdGEoYXhpcy5tYXgsIHRyYW5zbGF0ZSwgc2NhbGUsIG9yaWdpblBvaW50LCBib3hTY2FsZSk7XG59XG4vKipcbiAqIFJlbW92ZSBhIHRyYW5zZm9ybXMgZnJvbSBhbiBheGlzLiBUaGlzIGlzIGVzc2VudGlhbGx5IHRoZSBzdGVwcyBvZiBhcHBseUF4aXNUcmFuc2Zvcm1zIGluIHJldmVyc2VcbiAqIGFuZCBhY3RzIGFzIGEgYnJpZGdlIGJldHdlZW4gbW90aW9uIHZhbHVlcyBhbmQgcmVtb3ZlQXhpc0RlbHRhXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUF4aXNUcmFuc2Zvcm1zKGF4aXMsIHRyYW5zZm9ybXMsIF9hLCBvcmlnaW4sIHNvdXJjZUF4aXMpIHtcbiAgICB2YXIgX2IgPSBfX3JlYWQoX2EsIDMpLCBrZXkgPSBfYlswXSwgc2NhbGVLZXkgPSBfYlsxXSwgb3JpZ2luS2V5ID0gX2JbMl07XG4gICAgcmVtb3ZlQXhpc0RlbHRhKGF4aXMsIHRyYW5zZm9ybXNba2V5XSwgdHJhbnNmb3Jtc1tzY2FsZUtleV0sIHRyYW5zZm9ybXNbb3JpZ2luS2V5XSwgdHJhbnNmb3Jtcy5zY2FsZSwgb3JpZ2luLCBzb3VyY2VBeGlzKTtcbn1cbi8qKlxuICogVGhlIG5hbWVzIG9mIHRoZSBtb3Rpb24gdmFsdWVzIHdlIHdhbnQgdG8gYXBwbHkgYXMgdHJhbnNsYXRpb24sIHNjYWxlIGFuZCBvcmlnaW4uXG4gKi9cbnZhciB4S2V5cyA9IFtcInhcIiwgXCJzY2FsZVhcIiwgXCJvcmlnaW5YXCJdO1xudmFyIHlLZXlzID0gW1wieVwiLCBcInNjYWxlWVwiLCBcIm9yaWdpbllcIl07XG4vKipcbiAqIFJlbW92ZSBhIHRyYW5zZm9ybXMgZnJvbSBhbiBib3guIFRoaXMgaXMgZXNzZW50aWFsbHkgdGhlIHN0ZXBzIG9mIGFwcGx5QXhpc0JveCBpbiByZXZlcnNlXG4gKiBhbmQgYWN0cyBhcyBhIGJyaWRnZSBiZXR3ZWVuIG1vdGlvbiB2YWx1ZXMgYW5kIHJlbW92ZUF4aXNEZWx0YVxuICovXG5mdW5jdGlvbiByZW1vdmVCb3hUcmFuc2Zvcm1zKGJveCwgdHJhbnNmb3Jtcywgb3JpZ2luQm94LCBzb3VyY2VCb3gpIHtcbiAgICByZW1vdmVBeGlzVHJhbnNmb3Jtcyhib3gueCwgdHJhbnNmb3JtcywgeEtleXMsIG9yaWdpbkJveCA9PT0gbnVsbCB8fCBvcmlnaW5Cb3ggPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9yaWdpbkJveC54LCBzb3VyY2VCb3ggPT09IG51bGwgfHwgc291cmNlQm94ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzb3VyY2VCb3gueCk7XG4gICAgcmVtb3ZlQXhpc1RyYW5zZm9ybXMoYm94LnksIHRyYW5zZm9ybXMsIHlLZXlzLCBvcmlnaW5Cb3ggPT09IG51bGwgfHwgb3JpZ2luQm94ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcmlnaW5Cb3gueSwgc291cmNlQm94ID09PSBudWxsIHx8IHNvdXJjZUJveCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc291cmNlQm94LnkpO1xufVxuXG5leHBvcnQgeyByZW1vdmVBeGlzRGVsdGEsIHJlbW92ZUF4aXNUcmFuc2Zvcm1zLCByZW1vdmVCb3hUcmFuc2Zvcm1zLCByZW1vdmVQb2ludERlbHRhIH07XG4iLCJmdW5jdGlvbiBpc0F4aXNEZWx0YVplcm8oZGVsdGEpIHtcbiAgICByZXR1cm4gZGVsdGEudHJhbnNsYXRlID09PSAwICYmIGRlbHRhLnNjYWxlID09PSAxO1xufVxuZnVuY3Rpb24gaXNEZWx0YVplcm8oZGVsdGEpIHtcbiAgICByZXR1cm4gaXNBeGlzRGVsdGFaZXJvKGRlbHRhLngpICYmIGlzQXhpc0RlbHRhWmVybyhkZWx0YS55KTtcbn1cbmZ1bmN0aW9uIGJveEVxdWFscyhhLCBiKSB7XG4gICAgcmV0dXJuIChhLngubWluID09PSBiLngubWluICYmXG4gICAgICAgIGEueC5tYXggPT09IGIueC5tYXggJiZcbiAgICAgICAgYS55Lm1pbiA9PT0gYi55Lm1pbiAmJlxuICAgICAgICBhLnkubWF4ID09PSBiLnkubWF4KTtcbn1cblxuZXhwb3J0IHsgYm94RXF1YWxzLCBpc0RlbHRhWmVybyB9O1xuIiwiaW1wb3J0IHsgYWRkVW5pcXVlSXRlbSwgcmVtb3ZlSXRlbSB9IGZyb20gJy4uLy4uL3V0aWxzL2FycmF5Lm1qcyc7XG5cbnZhciBOb2RlU3RhY2sgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTm9kZVN0YWNrKCkge1xuICAgICAgICB0aGlzLm1lbWJlcnMgPSBbXTtcbiAgICB9XG4gICAgTm9kZVN0YWNrLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBhZGRVbmlxdWVJdGVtKHRoaXMubWVtYmVycywgbm9kZSk7XG4gICAgICAgIG5vZGUuc2NoZWR1bGVSZW5kZXIoKTtcbiAgICB9O1xuICAgIE5vZGVTdGFjay5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgcmVtb3ZlSXRlbSh0aGlzLm1lbWJlcnMsIG5vZGUpO1xuICAgICAgICBpZiAobm9kZSA9PT0gdGhpcy5wcmV2TGVhZCkge1xuICAgICAgICAgICAgdGhpcy5wcmV2TGVhZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZSA9PT0gdGhpcy5sZWFkKSB7XG4gICAgICAgICAgICB2YXIgcHJldkxlYWQgPSB0aGlzLm1lbWJlcnNbdGhpcy5tZW1iZXJzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgaWYgKHByZXZMZWFkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9tb3RlKHByZXZMZWFkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgTm9kZVN0YWNrLnByb3RvdHlwZS5yZWxlZ2F0ZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHZhciBpbmRleE9mTm9kZSA9IHRoaXMubWVtYmVycy5maW5kSW5kZXgoZnVuY3Rpb24gKG1lbWJlcikgeyByZXR1cm4gbm9kZSA9PT0gbWVtYmVyOyB9KTtcbiAgICAgICAgaWYgKGluZGV4T2ZOb2RlID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmluZCB0aGUgbmV4dCBwcm9qZWN0aW9uIG5vZGUgdGhhdCBpcyBwcmVzZW50XG4gICAgICAgICAqL1xuICAgICAgICB2YXIgcHJldkxlYWQ7XG4gICAgICAgIGZvciAodmFyIGkgPSBpbmRleE9mTm9kZTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIHZhciBtZW1iZXIgPSB0aGlzLm1lbWJlcnNbaV07XG4gICAgICAgICAgICBpZiAobWVtYmVyLmlzUHJlc2VudCAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBwcmV2TGVhZCA9IG1lbWJlcjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocHJldkxlYWQpIHtcbiAgICAgICAgICAgIHRoaXMucHJvbW90ZShwcmV2TGVhZCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTm9kZVN0YWNrLnByb3RvdHlwZS5wcm9tb3RlID0gZnVuY3Rpb24gKG5vZGUsIHByZXNlcnZlRm9sbG93T3BhY2l0eSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHZhciBwcmV2TGVhZCA9IHRoaXMubGVhZDtcbiAgICAgICAgaWYgKG5vZGUgPT09IHByZXZMZWFkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLnByZXZMZWFkID0gcHJldkxlYWQ7XG4gICAgICAgIHRoaXMubGVhZCA9IG5vZGU7XG4gICAgICAgIG5vZGUuc2hvdygpO1xuICAgICAgICBpZiAocHJldkxlYWQpIHtcbiAgICAgICAgICAgIHByZXZMZWFkLmluc3RhbmNlICYmIHByZXZMZWFkLnNjaGVkdWxlUmVuZGVyKCk7XG4gICAgICAgICAgICBub2RlLnNjaGVkdWxlUmVuZGVyKCk7XG4gICAgICAgICAgICBub2RlLnJlc3VtZUZyb20gPSBwcmV2TGVhZDtcbiAgICAgICAgICAgIGlmIChwcmVzZXJ2ZUZvbGxvd09wYWNpdHkpIHtcbiAgICAgICAgICAgICAgICBub2RlLnJlc3VtZUZyb20ucHJlc2VydmVPcGFjaXR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcmV2TGVhZC5zbmFwc2hvdCkge1xuICAgICAgICAgICAgICAgIG5vZGUuc25hcHNob3QgPSBwcmV2TGVhZC5zbmFwc2hvdDtcbiAgICAgICAgICAgICAgICBub2RlLnNuYXBzaG90LmxhdGVzdFZhbHVlcyA9XG4gICAgICAgICAgICAgICAgICAgIHByZXZMZWFkLmFuaW1hdGlvblZhbHVlcyB8fCBwcmV2TGVhZC5sYXRlc3RWYWx1ZXM7XG4gICAgICAgICAgICAgICAgbm9kZS5zbmFwc2hvdC5pc1NoYXJlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKF9hID0gbm9kZS5yb290KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaXNVcGRhdGluZykge1xuICAgICAgICAgICAgICAgIG5vZGUuaXNMYXlvdXREaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY3Jvc3NmYWRlID0gbm9kZS5vcHRpb25zLmNyb3NzZmFkZTtcbiAgICAgICAgICAgIGlmIChjcm9zc2ZhZGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcHJldkxlYWQuaGlkZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUT0RPOlxuICAgICAgICAgICAgICogICAtIFRlc3QgYm9yZGVyIHJhZGl1cyB3aGVuIHByZXZpb3VzIG5vZGUgd2FzIGRlbGV0ZWRcbiAgICAgICAgICAgICAqICAgLSBib3hTaGFkb3cgbWl4aW5nXG4gICAgICAgICAgICAgKiAgIC0gU2hhcmVkIGJldHdlZW4gZWxlbWVudCBBIGluIHNjcm9sbGVkIGNvbnRhaW5lciBhbmQgZWxlbWVudCBCIChzY3JvbGwgc3RheXMgdGhlIHNhbWUgb3IgY2hhbmdlcylcbiAgICAgICAgICAgICAqICAgLSBTaGFyZWQgYmV0d2VlbiBlbGVtZW50IEEgaW4gdHJhbnNmb3JtZWQgY29udGFpbmVyIGFuZCBlbGVtZW50IEIgKHRyYW5zZm9ybSBzdGF5cyB0aGUgc2FtZSBvciBjaGFuZ2VzKVxuICAgICAgICAgICAgICogICAtIFNoYXJlZCBiZXR3ZWVuIGVsZW1lbnQgQSBpbiBzY3JvbGxlZCBwYWdlIGFuZCBlbGVtZW50IEIgKHNjcm9sbCBzdGF5cyB0aGUgc2FtZSBvciBjaGFuZ2VzKVxuICAgICAgICAgICAgICogLS0tXG4gICAgICAgICAgICAgKiAgIC0gQ3Jvc3NmYWRlIG9wYWNpdHkgb2Ygcm9vdCBub2Rlc1xuICAgICAgICAgICAgICogICAtIGxheW91dElkIGNoYW5nZXMgYWZ0ZXIgYW5pbWF0aW9uXG4gICAgICAgICAgICAgKiAgIC0gbGF5b3V0SWQgY2hhbmdlcyBtaWQgYW5pbWF0aW9uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgfVxuICAgIH07XG4gICAgTm9kZVN0YWNrLnByb3RvdHlwZS5leGl0QW5pbWF0aW9uQ29tcGxldGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubWVtYmVycy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lO1xuICAgICAgICAgICAgKF9iID0gKF9hID0gbm9kZS5vcHRpb25zKS5vbkV4aXRDb21wbGV0ZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpO1xuICAgICAgICAgICAgKF9lID0gKF9jID0gbm9kZS5yZXN1bWluZ0Zyb20pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiAoX2QgPSBfYy5vcHRpb25zKS5vbkV4aXRDb21wbGV0ZSkgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLmNhbGwoX2QpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIE5vZGVTdGFjay5wcm90b3R5cGUuc2NoZWR1bGVSZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubWVtYmVycy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICBub2RlLmluc3RhbmNlICYmIG5vZGUuc2NoZWR1bGVSZW5kZXIoZmFsc2UpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENsZWFyIGFueSBsZWFkcyB0aGF0IGhhdmUgYmVlbiByZW1vdmVkIHRoaXMgcmVuZGVyIHRvIHByZXZlbnQgdGhlbSBmcm9tIGJlaW5nXG4gICAgICogdXNlZCBpbiBmdXR1cmUgYW5pbWF0aW9ucyBhbmQgdG8gcHJldmVudCBtZW1vcnkgbGVha3NcbiAgICAgKi9cbiAgICBOb2RlU3RhY2sucHJvdG90eXBlLnJlbW92ZUxlYWRTbmFwc2hvdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMubGVhZCAmJiB0aGlzLmxlYWQuc25hcHNob3QpIHtcbiAgICAgICAgICAgIHRoaXMubGVhZC5zbmFwc2hvdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIE5vZGVTdGFjaztcbn0oKSk7XG5cbmV4cG9ydCB7IE5vZGVTdGFjayB9O1xuIiwidmFyIGlkZW50aXR5UHJvamVjdGlvbiA9IFwidHJhbnNsYXRlM2QoMHB4LCAwcHgsIDApIHNjYWxlKDEsIDEpIHNjYWxlKDEsIDEpXCI7XG5mdW5jdGlvbiBidWlsZFByb2plY3Rpb25UcmFuc2Zvcm0oZGVsdGEsIHRyZWVTY2FsZSwgbGF0ZXN0VHJhbnNmb3JtKSB7XG4gICAgLyoqXG4gICAgICogVGhlIHRyYW5zbGF0aW9ucyB3ZSB1c2UgdG8gY2FsY3VsYXRlIGFyZSBhbHdheXMgcmVsYXRpdmUgdG8gdGhlIHZpZXdwb3J0IGNvb3JkaW5hdGUgc3BhY2UuXG4gICAgICogQnV0IHdoZW4gd2UgYXBwbHkgc2NhbGVzLCB3ZSBhbHNvIHNjYWxlIHRoZSBjb29yZGluYXRlIHNwYWNlIG9mIGFuIGVsZW1lbnQgYW5kIGl0cyBjaGlsZHJlbi5cbiAgICAgKiBGb3IgaW5zdGFuY2UgaWYgd2UgaGF2ZSBhIHRyZWVTY2FsZSAodGhlIGN1bG1pbmF0aW9uIG9mIGFsbCBwYXJlbnQgc2NhbGVzKSBvZiAwLjUgYW5kIHdlIG5lZWRcbiAgICAgKiB0byBtb3ZlIGFuIGVsZW1lbnQgMTAwIHBpeGVscywgd2UgYWN0dWFsbHkgbmVlZCB0byBtb3ZlIGl0IDIwMCBpbiB3aXRoaW4gdGhhdCBzY2FsZWQgc3BhY2UuXG4gICAgICovXG4gICAgdmFyIHhUcmFuc2xhdGUgPSBkZWx0YS54LnRyYW5zbGF0ZSAvIHRyZWVTY2FsZS54O1xuICAgIHZhciB5VHJhbnNsYXRlID0gZGVsdGEueS50cmFuc2xhdGUgLyB0cmVlU2NhbGUueTtcbiAgICB2YXIgdHJhbnNmb3JtID0gXCJ0cmFuc2xhdGUzZChcIi5jb25jYXQoeFRyYW5zbGF0ZSwgXCJweCwgXCIpLmNvbmNhdCh5VHJhbnNsYXRlLCBcInB4LCAwKSBcIik7XG4gICAgLyoqXG4gICAgICogQXBwbHkgc2NhbGUgY29ycmVjdGlvbiBmb3IgdGhlIHRyZWUgdHJhbnNmb3JtLlxuICAgICAqIFRoaXMgd2lsbCBhcHBseSBzY2FsZSB0byB0aGUgc2NyZWVuLW9yaWVudGF0ZWQgYXhlcy5cbiAgICAgKi9cbiAgICB0cmFuc2Zvcm0gKz0gXCJzY2FsZShcIi5jb25jYXQoMSAvIHRyZWVTY2FsZS54LCBcIiwgXCIpLmNvbmNhdCgxIC8gdHJlZVNjYWxlLnksIFwiKSBcIik7XG4gICAgaWYgKGxhdGVzdFRyYW5zZm9ybSkge1xuICAgICAgICB2YXIgcm90YXRlID0gbGF0ZXN0VHJhbnNmb3JtLnJvdGF0ZSwgcm90YXRlWCA9IGxhdGVzdFRyYW5zZm9ybS5yb3RhdGVYLCByb3RhdGVZID0gbGF0ZXN0VHJhbnNmb3JtLnJvdGF0ZVk7XG4gICAgICAgIGlmIChyb3RhdGUpXG4gICAgICAgICAgICB0cmFuc2Zvcm0gKz0gXCJyb3RhdGUoXCIuY29uY2F0KHJvdGF0ZSwgXCJkZWcpIFwiKTtcbiAgICAgICAgaWYgKHJvdGF0ZVgpXG4gICAgICAgICAgICB0cmFuc2Zvcm0gKz0gXCJyb3RhdGVYKFwiLmNvbmNhdChyb3RhdGVYLCBcImRlZykgXCIpO1xuICAgICAgICBpZiAocm90YXRlWSlcbiAgICAgICAgICAgIHRyYW5zZm9ybSArPSBcInJvdGF0ZVkoXCIuY29uY2F0KHJvdGF0ZVksIFwiZGVnKSBcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFwcGx5IHNjYWxlIHRvIG1hdGNoIHRoZSBzaXplIG9mIHRoZSBlbGVtZW50IHRvIHRoZSBzaXplIHdlIHdhbnQgaXQuXG4gICAgICogVGhpcyB3aWxsIGFwcGx5IHNjYWxlIHRvIHRoZSBlbGVtZW50LW9yaWVudGF0ZWQgYXhlcy5cbiAgICAgKi9cbiAgICB2YXIgZWxlbWVudFNjYWxlWCA9IGRlbHRhLnguc2NhbGUgKiB0cmVlU2NhbGUueDtcbiAgICB2YXIgZWxlbWVudFNjYWxlWSA9IGRlbHRhLnkuc2NhbGUgKiB0cmVlU2NhbGUueTtcbiAgICB0cmFuc2Zvcm0gKz0gXCJzY2FsZShcIi5jb25jYXQoZWxlbWVudFNjYWxlWCwgXCIsIFwiKS5jb25jYXQoZWxlbWVudFNjYWxlWSwgXCIpXCIpO1xuICAgIHJldHVybiB0cmFuc2Zvcm0gPT09IGlkZW50aXR5UHJvamVjdGlvbiA/IFwibm9uZVwiIDogdHJhbnNmb3JtO1xufVxuXG5leHBvcnQgeyBidWlsZFByb2plY3Rpb25UcmFuc2Zvcm0sIGlkZW50aXR5UHJvamVjdGlvbiB9O1xuIiwidmFyIGNvbXBhcmVCeURlcHRoID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYS5kZXB0aCAtIGIuZGVwdGg7XG59O1xuXG5leHBvcnQgeyBjb21wYXJlQnlEZXB0aCB9O1xuIiwiaW1wb3J0IHsgYWRkVW5pcXVlSXRlbSwgcmVtb3ZlSXRlbSB9IGZyb20gJy4uLy4uL3V0aWxzL2FycmF5Lm1qcyc7XG5pbXBvcnQgeyBjb21wYXJlQnlEZXB0aCB9IGZyb20gJy4vY29tcGFyZS1ieS1kZXB0aC5tanMnO1xuXG52YXIgRmxhdFRyZWUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRmxhdFRyZWUoKSB7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgdGhpcy5pc0RpcnR5ID0gZmFsc2U7XG4gICAgfVxuICAgIEZsYXRUcmVlLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgYWRkVW5pcXVlSXRlbSh0aGlzLmNoaWxkcmVuLCBjaGlsZCk7XG4gICAgICAgIHRoaXMuaXNEaXJ0eSA9IHRydWU7XG4gICAgfTtcbiAgICBGbGF0VHJlZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIHJlbW92ZUl0ZW0odGhpcy5jaGlsZHJlbiwgY2hpbGQpO1xuICAgICAgICB0aGlzLmlzRGlydHkgPSB0cnVlO1xuICAgIH07XG4gICAgRmxhdFRyZWUucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5pc0RpcnR5ICYmIHRoaXMuY2hpbGRyZW4uc29ydChjb21wYXJlQnlEZXB0aCk7XG4gICAgICAgIHRoaXMuaXNEaXJ0eSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goY2FsbGJhY2spO1xuICAgIH07XG4gICAgcmV0dXJuIEZsYXRUcmVlO1xufSgpKTtcblxuZXhwb3J0IHsgRmxhdFRyZWUgfTtcbiIsImltcG9ydCB7IF9fc3ByZWFkQXJyYXksIF9fcmVhZCwgX19hc3NpZ24gfSBmcm9tICd0c2xpYic7XG5pbXBvcnQgc3luYywgeyBjYW5jZWxTeW5jLCBmbHVzaFN5bmMgfSBmcm9tICdmcmFtZXN5bmMnO1xuaW1wb3J0IHsgbWl4IH0gZnJvbSAncG9wbW90aW9uJztcbmltcG9ydCB7IGFuaW1hdGUgfSBmcm9tICcuLi8uLi9hbmltYXRpb24vYW5pbWF0ZS5tanMnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uTWFuYWdlciB9IGZyb20gJy4uLy4uL3V0aWxzL3N1YnNjcmlwdGlvbi1tYW5hZ2VyLm1qcyc7XG5pbXBvcnQgeyBtaXhWYWx1ZXMgfSBmcm9tICcuLi9hbmltYXRpb24vbWl4LXZhbHVlcy5tanMnO1xuaW1wb3J0IHsgY29weUJveEludG8gfSBmcm9tICcuLi9nZW9tZXRyeS9jb3B5Lm1qcyc7XG5pbXBvcnQgeyB0cmFuc2xhdGVBeGlzLCB0cmFuc2Zvcm1Cb3gsIGFwcGx5Qm94RGVsdGEsIGFwcGx5VHJlZURlbHRhcyB9IGZyb20gJy4uL2dlb21ldHJ5L2RlbHRhLWFwcGx5Lm1qcyc7XG5pbXBvcnQgeyBjYWxjUmVsYXRpdmVQb3NpdGlvbiwgY2FsY1JlbGF0aXZlQm94LCBjYWxjQm94RGVsdGEsIGNhbGNMZW5ndGggfSBmcm9tICcuLi9nZW9tZXRyeS9kZWx0YS1jYWxjLm1qcyc7XG5pbXBvcnQgeyByZW1vdmVCb3hUcmFuc2Zvcm1zIH0gZnJvbSAnLi4vZ2VvbWV0cnkvZGVsdGEtcmVtb3ZlLm1qcyc7XG5pbXBvcnQgeyBjcmVhdGVCb3gsIGNyZWF0ZURlbHRhIH0gZnJvbSAnLi4vZ2VvbWV0cnkvbW9kZWxzLm1qcyc7XG5pbXBvcnQgeyBnZXRWYWx1ZVRyYW5zaXRpb24gfSBmcm9tICcuLi8uLi9hbmltYXRpb24vdXRpbHMvdHJhbnNpdGlvbnMubWpzJztcbmltcG9ydCB7IGJveEVxdWFscywgaXNEZWx0YVplcm8gfSBmcm9tICcuLi9nZW9tZXRyeS91dGlscy5tanMnO1xuaW1wb3J0IHsgTm9kZVN0YWNrIH0gZnJvbSAnLi4vc2hhcmVkL3N0YWNrLm1qcyc7XG5pbXBvcnQgeyBzY2FsZUNvcnJlY3RvcnMgfSBmcm9tICcuLi9zdHlsZXMvc2NhbGUtY29ycmVjdGlvbi5tanMnO1xuaW1wb3J0IHsgYnVpbGRQcm9qZWN0aW9uVHJhbnNmb3JtIH0gZnJvbSAnLi4vc3R5bGVzL3RyYW5zZm9ybS5tanMnO1xuaW1wb3J0IHsgZWFjaEF4aXMgfSBmcm9tICcuLi91dGlscy9lYWNoLWF4aXMubWpzJztcbmltcG9ydCB7IGhhc1RyYW5zZm9ybSwgaGFzU2NhbGUgfSBmcm9tICcuLi91dGlscy9oYXMtdHJhbnNmb3JtLm1qcyc7XG5pbXBvcnQgeyB0cmFuc2Zvcm1BeGVzIH0gZnJvbSAnLi4vLi4vcmVuZGVyL2h0bWwvdXRpbHMvdHJhbnNmb3JtLm1qcyc7XG5pbXBvcnQgeyBGbGF0VHJlZSB9IGZyb20gJy4uLy4uL3JlbmRlci91dGlscy9mbGF0LXRyZWUubWpzJztcbmltcG9ydCB7IHJlc29sdmVNb3Rpb25WYWx1ZSB9IGZyb20gJy4uLy4uL3ZhbHVlL3V0aWxzL3Jlc29sdmUtbW90aW9uLXZhbHVlLm1qcyc7XG5pbXBvcnQgeyBnbG9iYWxQcm9qZWN0aW9uU3RhdGUgfSBmcm9tICcuL3N0YXRlLm1qcyc7XG5cbi8qKlxuICogV2UgdXNlIDEwMDAgYXMgdGhlIGFuaW1hdGlvbiB0YXJnZXQgYXMgMC0xMDAwIG1hcHMgYmV0dGVyIHRvIHBpeGVscyB0aGFuIDAtMVxuICogd2hpY2ggaGFzIGEgbm90aWNlYWJsZSBkaWZmZXJlbmNlIGluIHNwcmluZyBhbmltYXRpb25zXG4gKi9cbnZhciBhbmltYXRpb25UYXJnZXQgPSAxMDAwO1xuZnVuY3Rpb24gY3JlYXRlUHJvamVjdGlvbk5vZGUoX2EpIHtcbiAgICB2YXIgYXR0YWNoUmVzaXplTGlzdGVuZXIgPSBfYS5hdHRhY2hSZXNpemVMaXN0ZW5lciwgZGVmYXVsdFBhcmVudCA9IF9hLmRlZmF1bHRQYXJlbnQsIG1lYXN1cmVTY3JvbGwgPSBfYS5tZWFzdXJlU2Nyb2xsLCBjaGVja0lzU2Nyb2xsUm9vdCA9IF9hLmNoZWNrSXNTY3JvbGxSb290LCByZXNldFRyYW5zZm9ybSA9IF9hLnJlc2V0VHJhbnNmb3JtO1xuICAgIHJldHVybiAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIFByb2plY3Rpb25Ob2RlKGlkLCBsYXRlc3RWYWx1ZXMsIHBhcmVudCkge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIGlmIChsYXRlc3RWYWx1ZXMgPT09IHZvaWQgMCkgeyBsYXRlc3RWYWx1ZXMgPSB7fTsgfVxuICAgICAgICAgICAgaWYgKHBhcmVudCA9PT0gdm9pZCAwKSB7IHBhcmVudCA9IGRlZmF1bHRQYXJlbnQgPT09IG51bGwgfHwgZGVmYXVsdFBhcmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGVmYXVsdFBhcmVudCgpOyB9XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEEgU2V0IGNvbnRhaW5pbmcgYWxsIHRoaXMgY29tcG9uZW50J3MgY2hpbGRyZW4uIFRoaXMgaXMgdXNlZCB0byBpdGVyYXRlXG4gICAgICAgICAgICAgKiB0aHJvdWdoIHRoZSBjaGlsZHJlbi5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBUT0RPOiBUaGlzIGNvdWxkIGJlIGZhc3RlciB0byBpdGVyYXRlIGFzIGEgZmxhdCBhcnJheSBzdG9yZWQgb24gdGhlIHJvb3Qgbm9kZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbiA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogT3B0aW9ucyBmb3IgdGhlIG5vZGUuIFdlIHVzZSB0aGlzIHRvIGNvbmZpZ3VyZSB3aGF0IGtpbmQgb2YgbGF5b3V0IGFuaW1hdGlvbnNcbiAgICAgICAgICAgICAqIHdlIHNob3VsZCBwZXJmb3JtIChpZiBhbnkpLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogV2UgdXNlIHRoaXMgdG8gZGV0ZWN0IHdoZW4gaXRzIHNhZmUgdG8gc2h1dCBkb3duIHBhcnQgb2YgYSBwcm9qZWN0aW9uIHRyZWUuXG4gICAgICAgICAgICAgKiBXZSBoYXZlIHRvIGtlZXAgcHJvamVjdGluZyBjaGlsZHJlbiBmb3Igc2NhbGUgY29ycmVjdGlvbiBhbmQgcmVsYXRpdmUgcHJvamVjdGlvblxuICAgICAgICAgICAgICogdW50aWwgYWxsIHRoZWlyIHBhcmVudHMgc3RvcCBwZXJmb3JtaW5nIGxheW91dCBhbmltYXRpb25zLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmlzVHJlZUFuaW1hdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5pc0FuaW1hdGlvbkJsb2NrZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRmxhZyB0byB0cnVlIGlmIHdlIHRoaW5rIHRoaXMgbGF5b3V0IGhhcyBiZWVuIGNoYW5nZWQuIFdlIGNhbid0IGFsd2F5cyBrbm93IHRoaXMsXG4gICAgICAgICAgICAgKiBjdXJyZW50bHkgd2Ugc2V0IGl0IHRvIHRydWUgZXZlcnkgdGltZSBhIGNvbXBvbmVudCByZW5kZXJzLCBvciBpZiBpdCBoYXMgYSBsYXlvdXREZXBlbmRlbmN5XG4gICAgICAgICAgICAgKiBpZiB0aGF0IGhhcyBjaGFuZ2VkIGJldHdlZW4gcmVuZGVycy4gQWRkaXRpb25hbGx5LCBjb21wb25lbnRzIGNhbiBiZSBncm91cGVkIGJ5IExheW91dEdyb3VwXG4gICAgICAgICAgICAgKiBhbmQgaWYgb25lIG5vZGUgaXMgZGlydGllZCwgdGhleSBhbGwgYXJlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmlzTGF5b3V0RGlydHkgPSBmYWxzZTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQmxvY2sgbGF5b3V0IHVwZGF0ZXMgZm9yIGluc3RhbnQgbGF5b3V0IHRyYW5zaXRpb25zIHRocm91Z2hvdXQgdGhlIHRyZWUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMudXBkYXRlTWFudWFsbHlCbG9ja2VkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUJsb2NrZWRCeVJlc2l6ZSA9IGZhbHNlO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTZXQgdG8gdHJ1ZSBiZXR3ZWVuIHRoZSBzdGFydCBvZiB0aGUgZmlyc3QgYHdpbGxVcGRhdGVgIGNhbGwgYW5kIHRoZSBlbmQgb2YgdGhlIGBkaWRVcGRhdGVgXG4gICAgICAgICAgICAgKiBjYWxsLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmlzVXBkYXRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgdGhpcyBpcyBhbiBTVkcgZWxlbWVudCB3ZSBjdXJyZW50bHkgZGlzYWJsZSBwcm9qZWN0aW9uIHRyYW5zZm9ybXNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5pc1NWRyA9IGZhbHNlO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBGbGFnIHRvIHRydWUgKGR1cmluZyBwcm9tb3Rpb24pIGlmIGEgbm9kZSBkb2luZyBhbiBpbnN0YW50IGxheW91dCB0cmFuc2l0aW9uIG5lZWRzIHRvIHJlc2V0XG4gICAgICAgICAgICAgKiBpdHMgcHJvamVjdGlvbiBzdHlsZXMuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMubmVlZHNSZXNldCA9IGZhbHNlO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBGbGFncyB3aGV0aGVyIHRoaXMgbm9kZSBzaG91bGQgaGF2ZSBpdHMgdHJhbnNmb3JtIHJlc2V0IHByaW9yIHRvIG1lYXN1cmluZy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5zaG91bGRSZXNldFRyYW5zZm9ybSA9IGZhbHNlO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBbiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBjYWxjdWxhdGVkIGNvbnRleHR1YWwvYWNjdW11bGF0ZWQvdHJlZSBzY2FsZS5cbiAgICAgICAgICAgICAqIFRoaXMgd2lsbCBiZSB1c2VkIHRvIHNjYWxlIGNhbGN1bGNhdGVkIHByb2plY3Rpb24gdHJhbnNmb3JtcywgYXMgdGhlc2UgYXJlXG4gICAgICAgICAgICAgKiBjYWxjdWxhdGVkIGluIHNjcmVlbi1zcGFjZSBidXQgbmVlZCB0byBiZSBzY2FsZWQgZm9yIGVsZW1lbnRzIHRvIGFjdHVhbGx5XG4gICAgICAgICAgICAgKiBtYWtlIGl0IHRvIHRoZWlyIGNhbGN1bGF0ZWQgZGVzdGluYXRpb25zLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIFRPRE86IExhenktaW5pdFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLnRyZWVTY2FsZSA9IHsgeDogMSwgeTogMSB9O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmV2ZW50SGFuZGxlcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICAvLyBOb3RlOiBDdXJyZW50bHkgb25seSBydW5uaW5nIG9uIHJvb3Qgbm9kZVxuICAgICAgICAgICAgdGhpcy5wb3RlbnRpYWxOb2RlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tVcGRhdGVGYWlsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLmlzVXBkYXRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuaXNVcGRhdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5jbGVhckFsbFNuYXBzaG90cygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVByb2plY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMubm9kZXMuZm9yRWFjaChyZXNvbHZlVGFyZ2V0RGVsdGEpO1xuICAgICAgICAgICAgICAgIF90aGlzLm5vZGVzLmZvckVhY2goY2FsY1Byb2plY3Rpb24pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuaGFzUHJvamVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmlzVmlzaWJsZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmFuaW1hdGlvblByb2dyZXNzID0gMDtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU2hhcmVkIGxheW91dFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAvLyBUT0RPIE9ubHkgcnVubmluZyBvbiByb290IG5vZGVcbiAgICAgICAgICAgIHRoaXMuc2hhcmVkTm9kZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAgICAgICB0aGlzLmxhdGVzdFZhbHVlcyA9IGxhdGVzdFZhbHVlcztcbiAgICAgICAgICAgIHRoaXMucm9vdCA9IHBhcmVudCA/IHBhcmVudC5yb290IHx8IHBhcmVudCA6IHRoaXM7XG4gICAgICAgICAgICB0aGlzLnBhdGggPSBwYXJlbnQgPyBfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChwYXJlbnQucGF0aCksIGZhbHNlKSwgW3BhcmVudF0sIGZhbHNlKSA6IFtdO1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgICAgICB0aGlzLmRlcHRoID0gcGFyZW50ID8gcGFyZW50LmRlcHRoICsgMSA6IDA7XG4gICAgICAgICAgICBpZCAmJiB0aGlzLnJvb3QucmVnaXN0ZXJQb3RlbnRpYWxOb2RlKGlkLCB0aGlzKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5wYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXRoW2ldLnNob3VsZFJlc2V0VHJhbnNmb3JtID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnJvb3QgPT09IHRoaXMpXG4gICAgICAgICAgICAgICAgdGhpcy5ub2RlcyA9IG5ldyBGbGF0VHJlZSgpO1xuICAgICAgICB9XG4gICAgICAgIFByb2plY3Rpb25Ob2RlLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKG5hbWUsIGhhbmRsZXIpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5ldmVudEhhbmRsZXJzLmhhcyhuYW1lKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRIYW5kbGVycy5zZXQobmFtZSwgbmV3IFN1YnNjcmlwdGlvbk1hbmFnZXIoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ldmVudEhhbmRsZXJzLmdldChuYW1lKS5hZGQoaGFuZGxlcik7XG4gICAgICAgIH07XG4gICAgICAgIFByb2plY3Rpb25Ob2RlLnByb3RvdHlwZS5ub3RpZnlMaXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzdWJzY3JpcHRpb25NYW5hZ2VyID0gdGhpcy5ldmVudEhhbmRsZXJzLmdldChuYW1lKTtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbk1hbmFnZXIgPT09IG51bGwgfHwgc3Vic2NyaXB0aW9uTWFuYWdlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3Vic2NyaXB0aW9uTWFuYWdlci5ub3RpZnkuYXBwbHkoc3Vic2NyaXB0aW9uTWFuYWdlciwgX19zcHJlYWRBcnJheShbXSwgX19yZWFkKGFyZ3MpLCBmYWxzZSkpO1xuICAgICAgICB9O1xuICAgICAgICBQcm9qZWN0aW9uTm9kZS5wcm90b3R5cGUuaGFzTGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV2ZW50SGFuZGxlcnMuaGFzKG5hbWUpO1xuICAgICAgICB9O1xuICAgICAgICBQcm9qZWN0aW9uTm9kZS5wcm90b3R5cGUucmVnaXN0ZXJQb3RlbnRpYWxOb2RlID0gZnVuY3Rpb24gKGlkLCBub2RlKSB7XG4gICAgICAgICAgICB0aGlzLnBvdGVudGlhbE5vZGVzLnNldChpZCwgbm9kZSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaWZlY3ljbGVzXG4gICAgICAgICAqL1xuICAgICAgICBQcm9qZWN0aW9uTm9kZS5wcm90b3R5cGUubW91bnQgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIGlzTGF5b3V0RGlydHkpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBpZiAoaXNMYXlvdXREaXJ0eSA9PT0gdm9pZCAwKSB7IGlzTGF5b3V0RGlydHkgPSBmYWxzZTsgfVxuICAgICAgICAgICAgaWYgKHRoaXMuaW5zdGFuY2UpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdGhpcy5pc1NWRyA9XG4gICAgICAgICAgICAgICAgaW5zdGFuY2UgaW5zdGFuY2VvZiBTVkdFbGVtZW50ICYmIGluc3RhbmNlLnRhZ05hbWUgIT09IFwic3ZnXCI7XG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlID0gaW5zdGFuY2U7XG4gICAgICAgICAgICB2YXIgX2IgPSB0aGlzLm9wdGlvbnMsIGxheW91dElkID0gX2IubGF5b3V0SWQsIGxheW91dCA9IF9iLmxheW91dCwgdmlzdWFsRWxlbWVudCA9IF9iLnZpc3VhbEVsZW1lbnQ7XG4gICAgICAgICAgICBpZiAodmlzdWFsRWxlbWVudCAmJiAhdmlzdWFsRWxlbWVudC5nZXRJbnN0YW5jZSgpKSB7XG4gICAgICAgICAgICAgICAgdmlzdWFsRWxlbWVudC5tb3VudChpbnN0YW5jZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJvb3Qubm9kZXMuYWRkKHRoaXMpO1xuICAgICAgICAgICAgKF9hID0gdGhpcy5wYXJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jaGlsZHJlbi5hZGQodGhpcyk7XG4gICAgICAgICAgICB0aGlzLmlkICYmIHRoaXMucm9vdC5wb3RlbnRpYWxOb2Rlcy5kZWxldGUodGhpcy5pZCk7XG4gICAgICAgICAgICBpZiAoaXNMYXlvdXREaXJ0eSAmJiAobGF5b3V0IHx8IGxheW91dElkKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaXNMYXlvdXREaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYXR0YWNoUmVzaXplTGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgdW5ibG9ja1RpbWVvdXRfMTtcbiAgICAgICAgICAgICAgICB2YXIgcmVzaXplVW5ibG9ja1VwZGF0ZV8xID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKF90aGlzLnJvb3QudXBkYXRlQmxvY2tlZEJ5UmVzaXplID0gZmFsc2UpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgYXR0YWNoUmVzaXplTGlzdGVuZXIoaW5zdGFuY2UsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucm9vdC51cGRhdGVCbG9ja2VkQnlSZXNpemUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodW5ibG9ja1RpbWVvdXRfMSk7XG4gICAgICAgICAgICAgICAgICAgIHVuYmxvY2tUaW1lb3V0XzEgPSB3aW5kb3cuc2V0VGltZW91dChyZXNpemVVbmJsb2NrVXBkYXRlXzEsIDI1MCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChnbG9iYWxQcm9qZWN0aW9uU3RhdGUuaGFzQW5pbWF0ZWRTaW5jZVJlc2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2xvYmFsUHJvamVjdGlvblN0YXRlLmhhc0FuaW1hdGVkU2luY2VSZXNpemUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLm5vZGVzLmZvckVhY2goZmluaXNoQW5pbWF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxheW91dElkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yb290LnJlZ2lzdGVyU2hhcmVkTm9kZShsYXlvdXRJZCwgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBPbmx5IHJlZ2lzdGVyIHRoZSBoYW5kbGVyIGlmIGl0IHJlcXVpcmVzIGxheW91dCBhbmltYXRpb25cbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYW5pbWF0ZSAhPT0gZmFsc2UgJiZcbiAgICAgICAgICAgICAgICB2aXN1YWxFbGVtZW50ICYmXG4gICAgICAgICAgICAgICAgKGxheW91dElkIHx8IGxheW91dCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoXCJkaWRVcGRhdGVcIiwgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYiwgX2MsIF9kLCBfZSwgX2Y7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkZWx0YSA9IF9hLmRlbHRhLCBoYXNMYXlvdXRDaGFuZ2VkID0gX2EuaGFzTGF5b3V0Q2hhbmdlZCwgaGFzUmVsYXRpdmVUYXJnZXRDaGFuZ2VkID0gX2EuaGFzUmVsYXRpdmVUYXJnZXRDaGFuZ2VkLCBuZXdMYXlvdXQgPSBfYS5sYXlvdXQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5pc1RyZWVBbmltYXRpb25CbG9ja2VkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnRhcmdldCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnJlbGF0aXZlVGFyZ2V0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IENoZWNrIGhlcmUgaWYgYW4gYW5pbWF0aW9uIGV4aXN0c1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGF5b3V0VHJhbnNpdGlvbiA9IChfYyA9IChfYiA9IF90aGlzLm9wdGlvbnMudHJhbnNpdGlvbikgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdmlzdWFsRWxlbWVudC5nZXREZWZhdWx0VHJhbnNpdGlvbigpKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBkZWZhdWx0TGF5b3V0VHJhbnNpdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9nID0gdmlzdWFsRWxlbWVudC5nZXRQcm9wcygpLCBvbkxheW91dEFuaW1hdGlvblN0YXJ0ID0gX2cub25MYXlvdXRBbmltYXRpb25TdGFydCwgb25MYXlvdXRBbmltYXRpb25Db21wbGV0ZSA9IF9nLm9uTGF5b3V0QW5pbWF0aW9uQ29tcGxldGU7XG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBUaGUgdGFyZ2V0IGxheW91dCBvZiB0aGUgZWxlbWVudCBtaWdodCBzdGF5IHRoZSBzYW1lLFxuICAgICAgICAgICAgICAgICAgICAgKiBidXQgaXRzIHBvc2l0aW9uIHJlbGF0aXZlIHRvIGl0cyBwYXJlbnQgaGFzIGNoYW5nZWQuXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0Q2hhbmdlZCA9ICFfdGhpcy50YXJnZXRMYXlvdXQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICFib3hFcXVhbHMoX3RoaXMudGFyZ2V0TGF5b3V0LCBuZXdMYXlvdXQpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNSZWxhdGl2ZVRhcmdldENoYW5nZWQ7XG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBJZiB0aGUgbGF5b3V0IGhhc24ndCBzZWVtZWQgdG8gaGF2ZSBjaGFuZ2VkLCBpdCBtaWdodCBiZSB0aGF0IHRoZVxuICAgICAgICAgICAgICAgICAgICAgKiBlbGVtZW50IGlzIHZpc3VhbGx5IGluIHRoZSBzYW1lIHBsYWNlIGluIHRoZSBkb2N1bWVudCBidXQgaXRzIHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgICAqIHJlbGF0aXZlIHRvIGl0cyBwYXJlbnQgaGFzIGluZGVlZCBjaGFuZ2VkLiBTbyBoZXJlIHdlIGNoZWNrIGZvciB0aGF0LlxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgdmFyIGhhc09ubHlSZWxhdGl2ZVRhcmdldENoYW5nZWQgPSAhaGFzTGF5b3V0Q2hhbmdlZCAmJiBoYXNSZWxhdGl2ZVRhcmdldENoYW5nZWQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoKF9kID0gX3RoaXMucmVzdW1lRnJvbSkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLmluc3RhbmNlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgaGFzT25seVJlbGF0aXZlVGFyZ2V0Q2hhbmdlZCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKGhhc0xheW91dENoYW5nZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAodGFyZ2V0Q2hhbmdlZCB8fCAhX3RoaXMuY3VycmVudEFuaW1hdGlvbikpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMucmVzdW1lRnJvbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnJlc3VtaW5nRnJvbSA9IF90aGlzLnJlc3VtZUZyb207XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVzdW1pbmdGcm9tLnJlc3VtaW5nRnJvbSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnNldEFuaW1hdGlvbk9yaWdpbihkZWx0YSwgaGFzT25seVJlbGF0aXZlVGFyZ2V0Q2hhbmdlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYW5pbWF0aW9uT3B0aW9ucyA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBnZXRWYWx1ZVRyYW5zaXRpb24obGF5b3V0VHJhbnNpdGlvbiwgXCJsYXlvdXRcIikpLCB7IG9uUGxheTogb25MYXlvdXRBbmltYXRpb25TdGFydCwgb25Db21wbGV0ZTogb25MYXlvdXRBbmltYXRpb25Db21wbGV0ZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2aXN1YWxFbGVtZW50LnNob3VsZFJlZHVjZU1vdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbk9wdGlvbnMuZGVsYXkgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbk9wdGlvbnMudHlwZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc3RhcnRBbmltYXRpb24oYW5pbWF0aW9uT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIElmIHRoZSBsYXlvdXQgaGFzbid0IGNoYW5nZWQgYW5kIHdlIGhhdmUgYW4gYW5pbWF0aW9uIHRoYXQgaGFzbid0IHN0YXJ0ZWQgeWV0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICogZmluaXNoIGl0IGltbWVkaWF0ZWx5LiBPdGhlcndpc2UgaXQgd2lsbCBiZSBhbmltYXRpbmcgZnJvbSBhIGxvY2F0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiB0aGF0IHdhcyBwcm9iYWJseSBuZXZlciBjb21taXRlZCB0byBzY3JlZW4gYW5kIGxvb2sgbGlrZSBhIGp1bXB5IGJveC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFoYXNMYXlvdXRDaGFuZ2VkICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuYW5pbWF0aW9uUHJvZ3Jlc3MgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5maW5pc2hBbmltYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmlzTGVhZCgpICYmICgoX2YgPSAoX2UgPSBfdGhpcy5vcHRpb25zKS5vbkV4aXRDb21wbGV0ZSkgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLmNhbGwoX2UpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBfdGhpcy50YXJnZXRMYXlvdXQgPSBuZXdMYXlvdXQ7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFByb2plY3Rpb25Ob2RlLnByb3RvdHlwZS51bm1vdW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5sYXlvdXRJZCAmJiB0aGlzLndpbGxVcGRhdGUoKTtcbiAgICAgICAgICAgIHRoaXMucm9vdC5ub2Rlcy5yZW1vdmUodGhpcyk7XG4gICAgICAgICAgICAoX2EgPSB0aGlzLmdldFN0YWNrKCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZW1vdmUodGhpcyk7XG4gICAgICAgICAgICAoX2IgPSB0aGlzLnBhcmVudCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNoaWxkcmVuLmRlbGV0ZSh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuaW5zdGFuY2UgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjYW5jZWxTeW5jLnByZVJlbmRlcih0aGlzLnVwZGF0ZVByb2plY3Rpb24pO1xuICAgICAgICB9O1xuICAgICAgICAvLyBvbmx5IG9uIHRoZSByb290XG4gICAgICAgIFByb2plY3Rpb25Ob2RlLnByb3RvdHlwZS5ibG9ja1VwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlTWFudWFsbHlCbG9ja2VkID0gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgUHJvamVjdGlvbk5vZGUucHJvdG90eXBlLnVuYmxvY2tVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZU1hbnVhbGx5QmxvY2tlZCA9IGZhbHNlO1xuICAgICAgICB9O1xuICAgICAgICBQcm9qZWN0aW9uTm9kZS5wcm90b3R5cGUuaXNVcGRhdGVCbG9ja2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlTWFudWFsbHlCbG9ja2VkIHx8IHRoaXMudXBkYXRlQmxvY2tlZEJ5UmVzaXplO1xuICAgICAgICB9O1xuICAgICAgICBQcm9qZWN0aW9uTm9kZS5wcm90b3R5cGUuaXNUcmVlQW5pbWF0aW9uQmxvY2tlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5pc0FuaW1hdGlvbkJsb2NrZWQgfHxcbiAgICAgICAgICAgICAgICAoKF9hID0gdGhpcy5wYXJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pc1RyZWVBbmltYXRpb25CbG9ja2VkKCkpIHx8XG4gICAgICAgICAgICAgICAgZmFsc2UpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBOb3RlOiBjdXJyZW50bHkgb25seSBydW5uaW5nIG9uIHJvb3Qgbm9kZVxuICAgICAgICBQcm9qZWN0aW9uTm9kZS5wcm90b3R5cGUuc3RhcnRVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1VwZGF0ZUJsb2NrZWQoKSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB0aGlzLmlzVXBkYXRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgKF9hID0gdGhpcy5ub2RlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZvckVhY2gocmVzZXRSb3RhdGlvbik7XG4gICAgICAgIH07XG4gICAgICAgIFByb2plY3Rpb25Ob2RlLnByb3RvdHlwZS53aWxsVXBkYXRlID0gZnVuY3Rpb24gKHNob3VsZE5vdGlmeUxpc3RlbmVycykge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgICBpZiAoc2hvdWxkTm90aWZ5TGlzdGVuZXJzID09PSB2b2lkIDApIHsgc2hvdWxkTm90aWZ5TGlzdGVuZXJzID0gdHJ1ZTsgfVxuICAgICAgICAgICAgaWYgKHRoaXMucm9vdC5pc1VwZGF0ZUJsb2NrZWQoKSkge1xuICAgICAgICAgICAgICAgIChfYiA9IChfYSA9IHRoaXMub3B0aW9ucykub25FeGl0Q29tcGxldGUpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAhdGhpcy5yb290LmlzVXBkYXRpbmcgJiYgdGhpcy5yb290LnN0YXJ0VXBkYXRlKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0xheW91dERpcnR5KVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMuaXNMYXlvdXREaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5wYXRoW2ldO1xuICAgICAgICAgICAgICAgIG5vZGUuc2hvdWxkUmVzZXRUcmFuc2Zvcm0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFRPRE86IENoZWNrIHdlIGhhdmVuJ3QgdXBkYXRlZCB0aGUgc2Nyb2xsXG4gICAgICAgICAgICAgICAgICogc2luY2UgdGhlIGxhc3QgZGlkVXBkYXRlXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgbm9kZS51cGRhdGVTY3JvbGwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBfZCA9IHRoaXMub3B0aW9ucywgbGF5b3V0SWQgPSBfZC5sYXlvdXRJZCwgbGF5b3V0ID0gX2QubGF5b3V0O1xuICAgICAgICAgICAgaWYgKGxheW91dElkID09PSB1bmRlZmluZWQgJiYgIWxheW91dClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIgdHJhbnNmb3JtVGVtcGxhdGUgPSAoX2MgPSB0aGlzLm9wdGlvbnMudmlzdWFsRWxlbWVudCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmdldFByb3BzKCkudHJhbnNmb3JtVGVtcGxhdGU7XG4gICAgICAgICAgICB0aGlzLnByZXZUcmFuc2Zvcm1UZW1wbGF0ZVZhbHVlID0gdHJhbnNmb3JtVGVtcGxhdGUgPT09IG51bGwgfHwgdHJhbnNmb3JtVGVtcGxhdGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRyYW5zZm9ybVRlbXBsYXRlKHRoaXMubGF0ZXN0VmFsdWVzLCBcIlwiKTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU25hcHNob3QoKTtcbiAgICAgICAgICAgIHNob3VsZE5vdGlmeUxpc3RlbmVycyAmJiB0aGlzLm5vdGlmeUxpc3RlbmVycyhcIndpbGxVcGRhdGVcIik7XG4gICAgICAgIH07XG4gICAgICAgIC8vIE5vdGU6IEN1cnJlbnRseSBvbmx5IHJ1bm5pbmcgb24gcm9vdCBub2RlXG4gICAgICAgIFByb2plY3Rpb25Ob2RlLnByb3RvdHlwZS5kaWRVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdXBkYXRlV2FzQmxvY2tlZCA9IHRoaXMuaXNVcGRhdGVCbG9ja2VkKCk7XG4gICAgICAgICAgICAvLyBXaGVuIGRvaW5nIGFuIGluc3RhbnQgdHJhbnNpdGlvbiwgd2Ugc2tpcCB0aGUgbGF5b3V0IHVwZGF0ZSxcbiAgICAgICAgICAgIC8vIGJ1dCBzaG91bGQgc3RpbGwgY2xlYW4gdXAgdGhlIG1lYXN1cmVtZW50cyBzbyB0aGF0IHRoZSBuZXh0XG4gICAgICAgICAgICAvLyBzbmFwc2hvdCBjb3VsZCBiZSB0YWtlbiBjb3JyZWN0bHkuXG4gICAgICAgICAgICBpZiAodXBkYXRlV2FzQmxvY2tlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMudW5ibG9ja1VwZGF0ZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJBbGxTbmFwc2hvdHMoKTtcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVzLmZvckVhY2goY2xlYXJNZWFzdXJlbWVudHMpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5pc1VwZGF0aW5nKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMuaXNVcGRhdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTZWFyY2ggZm9yIGFuZCBtb3VudCBuZXdseS1hZGRlZCBwcm9qZWN0aW9uIGVsZW1lbnRzLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIFRPRE86IEV2ZXJ5IHRpbWUgYSBuZXcgY29tcG9uZW50IGlzIHJlbmRlcmVkIHdlIGNvdWxkIHNlYXJjaCB1cCB0aGUgdHJlZSBmb3JcbiAgICAgICAgICAgICAqIHRoZSBjbG9zZXN0IG1vdW50ZWQgbm9kZSBhbmQgcXVlcnkgZnJvbSB0aGVyZSByYXRoZXIgdGhhbiBkb2N1bWVudC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKHRoaXMucG90ZW50aWFsTm9kZXMuc2l6ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucG90ZW50aWFsTm9kZXMuZm9yRWFjaChtb3VudE5vZGVFYXJseSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3RlbnRpYWxOb2Rlcy5jbGVhcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBXcml0ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLm5vZGVzLmZvckVhY2gocmVzZXRUcmFuc2Zvcm1TdHlsZSk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJlYWQgPT09PT09PT09PT09PT09PT09XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIC8vIFVwZGF0ZSBsYXlvdXQgbWVhc3VyZW1lbnRzIG9mIHVwZGF0ZWQgY2hpbGRyZW5cbiAgICAgICAgICAgIHRoaXMubm9kZXMuZm9yRWFjaCh1cGRhdGVMYXlvdXQpO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBXcml0ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAvLyBOb3RpZnkgbGlzdGVuZXJzIHRoYXQgdGhlIGxheW91dCBpcyB1cGRhdGVkXG4gICAgICAgICAgICB0aGlzLm5vZGVzLmZvckVhY2gobm90aWZ5TGF5b3V0VXBkYXRlKTtcbiAgICAgICAgICAgIHRoaXMuY2xlYXJBbGxTbmFwc2hvdHMoKTtcbiAgICAgICAgICAgIC8vIEZsdXNoIGFueSBzY2hlZHVsZWQgdXBkYXRlc1xuICAgICAgICAgICAgZmx1c2hTeW5jLnVwZGF0ZSgpO1xuICAgICAgICAgICAgZmx1c2hTeW5jLnByZVJlbmRlcigpO1xuICAgICAgICAgICAgZmx1c2hTeW5jLnJlbmRlcigpO1xuICAgICAgICB9O1xuICAgICAgICBQcm9qZWN0aW9uTm9kZS5wcm90b3R5cGUuY2xlYXJBbGxTbmFwc2hvdHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLm5vZGVzLmZvckVhY2goY2xlYXJTbmFwc2hvdCk7XG4gICAgICAgICAgICB0aGlzLnNoYXJlZE5vZGVzLmZvckVhY2gocmVtb3ZlTGVhZFNuYXBzaG90cyk7XG4gICAgICAgIH07XG4gICAgICAgIFByb2plY3Rpb25Ob2RlLnByb3RvdHlwZS5zY2hlZHVsZVVwZGF0ZVByb2plY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBzeW5jLnByZVJlbmRlcih0aGlzLnVwZGF0ZVByb2plY3Rpb24sIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgUHJvamVjdGlvbk5vZGUucHJvdG90eXBlLnNjaGVkdWxlQ2hlY2tBZnRlclVubW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJZiB0aGUgdW5tb3VudGluZyBub2RlIGlzIGluIGEgbGF5b3V0R3JvdXAgYW5kIGRpZCB0cmlnZ2VyIGEgd2lsbFVwZGF0ZSxcbiAgICAgICAgICAgICAqIHdlIG1hbnVhbGx5IGNhbGwgZGlkVXBkYXRlIHRvIGdpdmUgYSBjaGFuY2UgdG8gdGhlIHNpYmxpbmdzIHRvIGFuaW1hdGUuXG4gICAgICAgICAgICAgKiBPdGhlcndpc2UsIGNsZWFudXAgYWxsIHNuYXBzaG90cyB0byBwcmV2ZW50cyBmdXR1cmUgbm9kZXMgZnJvbSByZXVzaW5nIHRoZW0uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHN5bmMucG9zdFJlbmRlcihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLmlzTGF5b3V0RGlydHkpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucm9vdC5kaWRVcGRhdGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnJvb3QuY2hlY2tVcGRhdGVGYWlsZWQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZSBtZWFzdXJlbWVudHNcbiAgICAgICAgICovXG4gICAgICAgIFByb2plY3Rpb25Ob2RlLnByb3RvdHlwZS51cGRhdGVTbmFwc2hvdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNuYXBzaG90IHx8ICF0aGlzLmluc3RhbmNlKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHZhciBtZWFzdXJlZCA9IHRoaXMubWVhc3VyZSgpO1xuICAgICAgICAgICAgdmFyIGxheW91dCA9IHRoaXMucmVtb3ZlVHJhbnNmb3JtKHRoaXMucmVtb3ZlRWxlbWVudFNjcm9sbChtZWFzdXJlZCkpO1xuICAgICAgICAgICAgcm91bmRCb3gobGF5b3V0KTtcbiAgICAgICAgICAgIHRoaXMuc25hcHNob3QgPSB7XG4gICAgICAgICAgICAgICAgbWVhc3VyZWQ6IG1lYXN1cmVkLFxuICAgICAgICAgICAgICAgIGxheW91dDogbGF5b3V0LFxuICAgICAgICAgICAgICAgIGxhdGVzdFZhbHVlczoge30sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICBQcm9qZWN0aW9uTm9kZS5wcm90b3R5cGUudXBkYXRlTGF5b3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmluc3RhbmNlKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIC8vIFRPRE86IEluY29ycG9yYXRlIGludG8gYSBmb3J3YXJkZWQgc2Nyb2xsIG9mZnNldFxuICAgICAgICAgICAgdGhpcy51cGRhdGVTY3JvbGwoKTtcbiAgICAgICAgICAgIGlmICghKHRoaXMub3B0aW9ucy5hbHdheXNNZWFzdXJlTGF5b3V0ICYmIHRoaXMuaXNMZWFkKCkpICYmXG4gICAgICAgICAgICAgICAgIXRoaXMuaXNMYXlvdXREaXJ0eSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogV2hlbiBhIG5vZGUgaXMgbW91bnRlZCwgaXQgc2ltcGx5IHJlc3VtZXMgZnJvbSB0aGUgcHJldkxlYWQnc1xuICAgICAgICAgICAgICogc25hcHNob3QgaW5zdGVhZCBvZiB0YWtpbmcgYSBuZXcgb25lLCBidXQgdGhlIGFuY2VzdG9ycyBzY3JvbGxcbiAgICAgICAgICAgICAqIG1pZ2h0IGhhdmUgdXBkYXRlZCB3aGlsZSB0aGUgcHJldkxlYWQgaXMgdW5tb3VudGVkLiBXZSBuZWVkIHRvXG4gICAgICAgICAgICAgKiB1cGRhdGUgdGhlIHNjcm9sbCBhZ2FpbiB0byBtYWtlIHN1cmUgdGhlIGxheW91dCB3ZSBtZWFzdXJlIGlzXG4gICAgICAgICAgICAgKiB1cCB0byBkYXRlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAodGhpcy5yZXN1bWVGcm9tICYmICF0aGlzLnJlc3VtZUZyb20uaW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMucGF0aFtpXTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS51cGRhdGVTY3JvbGwoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbWVhc3VyZWQgPSB0aGlzLm1lYXN1cmUoKTtcbiAgICAgICAgICAgIHJvdW5kQm94KG1lYXN1cmVkKTtcbiAgICAgICAgICAgIHZhciBwcmV2TGF5b3V0ID0gdGhpcy5sYXlvdXQ7XG4gICAgICAgICAgICB0aGlzLmxheW91dCA9IHtcbiAgICAgICAgICAgICAgICBtZWFzdXJlZDogbWVhc3VyZWQsXG4gICAgICAgICAgICAgICAgYWN0dWFsOiB0aGlzLnJlbW92ZUVsZW1lbnRTY3JvbGwobWVhc3VyZWQpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMubGF5b3V0Q29ycmVjdGVkID0gY3JlYXRlQm94KCk7XG4gICAgICAgICAgICB0aGlzLmlzTGF5b3V0RGlydHkgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMucHJvamVjdGlvbkRlbHRhID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5ub3RpZnlMaXN0ZW5lcnMoXCJtZWFzdXJlXCIsIHRoaXMubGF5b3V0LmFjdHVhbCk7XG4gICAgICAgICAgICAoX2EgPSB0aGlzLm9wdGlvbnMudmlzdWFsRWxlbWVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm5vdGlmeUxheW91dE1lYXN1cmUodGhpcy5sYXlvdXQuYWN0dWFsLCBwcmV2TGF5b3V0ID09PSBudWxsIHx8IHByZXZMYXlvdXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHByZXZMYXlvdXQuYWN0dWFsKTtcbiAgICAgICAgfTtcbiAgICAgICAgUHJvamVjdGlvbk5vZGUucHJvdG90eXBlLnVwZGF0ZVNjcm9sbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMubGF5b3V0U2Nyb2xsICYmIHRoaXMuaW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlzU2Nyb2xsUm9vdCA9IGNoZWNrSXNTY3JvbGxSb290KHRoaXMuaW5zdGFuY2UpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsID0gbWVhc3VyZVNjcm9sbCh0aGlzLmluc3RhbmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgUHJvamVjdGlvbk5vZGUucHJvdG90eXBlLnJlc2V0VHJhbnNmb3JtID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgaWYgKCFyZXNldFRyYW5zZm9ybSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIgaXNSZXNldFJlcXVlc3RlZCA9IHRoaXMuaXNMYXlvdXREaXJ0eSB8fCB0aGlzLnNob3VsZFJlc2V0VHJhbnNmb3JtO1xuICAgICAgICAgICAgdmFyIGhhc1Byb2plY3Rpb24gPSB0aGlzLnByb2plY3Rpb25EZWx0YSAmJiAhaXNEZWx0YVplcm8odGhpcy5wcm9qZWN0aW9uRGVsdGEpO1xuICAgICAgICAgICAgdmFyIHRyYW5zZm9ybVRlbXBsYXRlID0gKF9hID0gdGhpcy5vcHRpb25zLnZpc3VhbEVsZW1lbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRQcm9wcygpLnRyYW5zZm9ybVRlbXBsYXRlO1xuICAgICAgICAgICAgdmFyIHRyYW5zZm9ybVRlbXBsYXRlVmFsdWUgPSB0cmFuc2Zvcm1UZW1wbGF0ZSA9PT0gbnVsbCB8fCB0cmFuc2Zvcm1UZW1wbGF0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdHJhbnNmb3JtVGVtcGxhdGUodGhpcy5sYXRlc3RWYWx1ZXMsIFwiXCIpO1xuICAgICAgICAgICAgdmFyIHRyYW5zZm9ybVRlbXBsYXRlSGFzQ2hhbmdlZCA9IHRyYW5zZm9ybVRlbXBsYXRlVmFsdWUgIT09IHRoaXMucHJldlRyYW5zZm9ybVRlbXBsYXRlVmFsdWU7XG4gICAgICAgICAgICBpZiAoaXNSZXNldFJlcXVlc3RlZCAmJlxuICAgICAgICAgICAgICAgIChoYXNQcm9qZWN0aW9uIHx8XG4gICAgICAgICAgICAgICAgICAgIGhhc1RyYW5zZm9ybSh0aGlzLmxhdGVzdFZhbHVlcykgfHxcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtVGVtcGxhdGVIYXNDaGFuZ2VkKSkge1xuICAgICAgICAgICAgICAgIHJlc2V0VHJhbnNmb3JtKHRoaXMuaW5zdGFuY2UsIHRyYW5zZm9ybVRlbXBsYXRlVmFsdWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2hvdWxkUmVzZXRUcmFuc2Zvcm0gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLnNjaGVkdWxlUmVuZGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFByb2plY3Rpb25Ob2RlLnByb3RvdHlwZS5tZWFzdXJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHZpc3VhbEVsZW1lbnQgPSB0aGlzLm9wdGlvbnMudmlzdWFsRWxlbWVudDtcbiAgICAgICAgICAgIGlmICghdmlzdWFsRWxlbWVudClcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQm94KCk7XG4gICAgICAgICAgICB2YXIgYm94ID0gdmlzdWFsRWxlbWVudC5tZWFzdXJlVmlld3BvcnRCb3goKTtcbiAgICAgICAgICAgIC8vIFJlbW92ZSB2aWV3cG9ydCBzY3JvbGwgdG8gZ2l2ZSBwYWdlLXJlbGF0aXZlIGNvb3JkaW5hdGVzXG4gICAgICAgICAgICB2YXIgc2Nyb2xsID0gdGhpcy5yb290LnNjcm9sbDtcbiAgICAgICAgICAgIGlmIChzY3JvbGwpIHtcbiAgICAgICAgICAgICAgICB0cmFuc2xhdGVBeGlzKGJveC54LCBzY3JvbGwueCk7XG4gICAgICAgICAgICAgICAgdHJhbnNsYXRlQXhpcyhib3gueSwgc2Nyb2xsLnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGJveDtcbiAgICAgICAgfTtcbiAgICAgICAgUHJvamVjdGlvbk5vZGUucHJvdG90eXBlLnJlbW92ZUVsZW1lbnRTY3JvbGwgPSBmdW5jdGlvbiAoYm94KSB7XG4gICAgICAgICAgICB2YXIgYm94V2l0aG91dFNjcm9sbCA9IGNyZWF0ZUJveCgpO1xuICAgICAgICAgICAgY29weUJveEludG8oYm94V2l0aG91dFNjcm9sbCwgYm94KTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUGVyZm9ybWFuY2UgVE9ETzogS2VlcCBhIGN1bXVsYXRpdmUgc2Nyb2xsIG9mZnNldCBkb3duIHRoZSB0cmVlXG4gICAgICAgICAgICAgKiByYXRoZXIgdGhhbiBsb29wIGJhY2sgdXAgdGhlIHBhdGguXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5wYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLnBhdGhbaV07XG4gICAgICAgICAgICAgICAgdmFyIHNjcm9sbF8xID0gbm9kZS5zY3JvbGwsIG9wdGlvbnMgPSBub2RlLm9wdGlvbnMsIGlzU2Nyb2xsUm9vdCA9IG5vZGUuaXNTY3JvbGxSb290O1xuICAgICAgICAgICAgICAgIGlmIChub2RlICE9PSB0aGlzLnJvb3QgJiYgc2Nyb2xsXzEgJiYgb3B0aW9ucy5sYXlvdXRTY3JvbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAqIElmIHRoaXMgaXMgYSBuZXcgc2Nyb2xsIHJvb3QsIHdlIHdhbnQgdG8gcmVtb3ZlIGFsbCBwcmV2aW91cyBzY3JvbGxzXG4gICAgICAgICAgICAgICAgICAgICAqIGZyb20gdGhlIHZpZXdwb3J0IGJveC5cbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1Njcm9sbFJvb3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvcHlCb3hJbnRvKGJveFdpdGhvdXRTY3JvbGwsIGJveCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcm9vdFNjcm9sbCA9IHRoaXMucm9vdC5zY3JvbGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIFVuZG8gdGhlIGFwcGxpY2F0aW9uIG9mIHBhZ2Ugc2Nyb2xsIHRoYXQgd2FzIG9yaWdpbmFsbHkgYWRkZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIHRvIHRoZSBtZWFzdXJlZCBib3VuZGluZyBib3guXG4gICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyb290U2Nyb2xsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRlQXhpcyhib3hXaXRob3V0U2Nyb2xsLngsIC1yb290U2Nyb2xsLngpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0ZUF4aXMoYm94V2l0aG91dFNjcm9sbC55LCAtcm9vdFNjcm9sbC55KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGVBeGlzKGJveFdpdGhvdXRTY3JvbGwueCwgc2Nyb2xsXzEueCk7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0ZUF4aXMoYm94V2l0aG91dFNjcm9sbC55LCBzY3JvbGxfMS55KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYm94V2l0aG91dFNjcm9sbDtcbiAgICAgICAgfTtcbiAgICAgICAgUHJvamVjdGlvbk5vZGUucHJvdG90eXBlLmFwcGx5VHJhbnNmb3JtID0gZnVuY3Rpb24gKGJveCwgdHJhbnNmb3JtT25seSkge1xuICAgICAgICAgICAgaWYgKHRyYW5zZm9ybU9ubHkgPT09IHZvaWQgMCkgeyB0cmFuc2Zvcm1Pbmx5ID0gZmFsc2U7IH1cbiAgICAgICAgICAgIHZhciB3aXRoVHJhbnNmb3JtcyA9IGNyZWF0ZUJveCgpO1xuICAgICAgICAgICAgY29weUJveEludG8od2l0aFRyYW5zZm9ybXMsIGJveCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBub2RlID0gdGhpcy5wYXRoW2ldO1xuICAgICAgICAgICAgICAgIGlmICghdHJhbnNmb3JtT25seSAmJlxuICAgICAgICAgICAgICAgICAgICBub2RlLm9wdGlvbnMubGF5b3V0U2Nyb2xsICYmXG4gICAgICAgICAgICAgICAgICAgIG5vZGUuc2Nyb2xsICYmXG4gICAgICAgICAgICAgICAgICAgIG5vZGUgIT09IG5vZGUucm9vdCkge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm1Cb3god2l0aFRyYW5zZm9ybXMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHg6IC1ub2RlLnNjcm9sbC54LFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogLW5vZGUuc2Nyb2xsLnksXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWhhc1RyYW5zZm9ybShub2RlLmxhdGVzdFZhbHVlcykpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybUJveCh3aXRoVHJhbnNmb3Jtcywgbm9kZS5sYXRlc3RWYWx1ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhhc1RyYW5zZm9ybSh0aGlzLmxhdGVzdFZhbHVlcykpIHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1Cb3god2l0aFRyYW5zZm9ybXMsIHRoaXMubGF0ZXN0VmFsdWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB3aXRoVHJhbnNmb3JtcztcbiAgICAgICAgfTtcbiAgICAgICAgUHJvamVjdGlvbk5vZGUucHJvdG90eXBlLnJlbW92ZVRyYW5zZm9ybSA9IGZ1bmN0aW9uIChib3gpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHZhciBib3hXaXRob3V0VHJhbnNmb3JtID0gY3JlYXRlQm94KCk7XG4gICAgICAgICAgICBjb3B5Qm94SW50byhib3hXaXRob3V0VHJhbnNmb3JtLCBib3gpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMucGF0aFtpXTtcbiAgICAgICAgICAgICAgICBpZiAoIW5vZGUuaW5zdGFuY2UpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGlmICghaGFzVHJhbnNmb3JtKG5vZGUubGF0ZXN0VmFsdWVzKSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgaGFzU2NhbGUobm9kZS5sYXRlc3RWYWx1ZXMpICYmIG5vZGUudXBkYXRlU25hcHNob3QoKTtcbiAgICAgICAgICAgICAgICB2YXIgc291cmNlQm94ID0gY3JlYXRlQm94KCk7XG4gICAgICAgICAgICAgICAgdmFyIG5vZGVCb3ggPSBub2RlLm1lYXN1cmUoKTtcbiAgICAgICAgICAgICAgICBjb3B5Qm94SW50byhzb3VyY2VCb3gsIG5vZGVCb3gpO1xuICAgICAgICAgICAgICAgIHJlbW92ZUJveFRyYW5zZm9ybXMoYm94V2l0aG91dFRyYW5zZm9ybSwgbm9kZS5sYXRlc3RWYWx1ZXMsIChfYSA9IG5vZGUuc25hcHNob3QpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sYXlvdXQsIHNvdXJjZUJveCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGFzVHJhbnNmb3JtKHRoaXMubGF0ZXN0VmFsdWVzKSkge1xuICAgICAgICAgICAgICAgIHJlbW92ZUJveFRyYW5zZm9ybXMoYm94V2l0aG91dFRyYW5zZm9ybSwgdGhpcy5sYXRlc3RWYWx1ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGJveFdpdGhvdXRUcmFuc2Zvcm07XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgUHJvamVjdGlvbk5vZGUucHJvdG90eXBlLnNldFRhcmdldERlbHRhID0gZnVuY3Rpb24gKGRlbHRhKSB7XG4gICAgICAgICAgICB0aGlzLnRhcmdldERlbHRhID0gZGVsdGE7XG4gICAgICAgICAgICB0aGlzLnJvb3Quc2NoZWR1bGVVcGRhdGVQcm9qZWN0aW9uKCk7XG4gICAgICAgIH07XG4gICAgICAgIFByb2plY3Rpb25Ob2RlLnByb3RvdHlwZS5zZXRPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucyA9IF9fYXNzaWduKF9fYXNzaWduKF9fYXNzaWduKHt9LCB0aGlzLm9wdGlvbnMpLCBvcHRpb25zKSwgeyBjcm9zc2ZhZGU6IChfYSA9IG9wdGlvbnMuY3Jvc3NmYWRlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0cnVlIH0pO1xuICAgICAgICB9O1xuICAgICAgICBQcm9qZWN0aW9uTm9kZS5wcm90b3R5cGUuY2xlYXJNZWFzdXJlbWVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMubGF5b3V0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5zbmFwc2hvdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMucHJldlRyYW5zZm9ybVRlbXBsYXRlVmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLnRhcmdldERlbHRhID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy50YXJnZXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLmlzTGF5b3V0RGlydHkgPSBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZyYW1lIGNhbGN1bGF0aW9uc1xuICAgICAgICAgKi9cbiAgICAgICAgUHJvamVjdGlvbk5vZGUucHJvdG90eXBlLnJlc29sdmVUYXJnZXREZWx0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHZhciBfYiA9IHRoaXMub3B0aW9ucywgbGF5b3V0ID0gX2IubGF5b3V0LCBsYXlvdXRJZCA9IF9iLmxheW91dElkO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJZiB3ZSBoYXZlIG5vIGxheW91dCwgd2UgY2FuJ3QgcGVyZm9ybSBwcm9qZWN0aW9uLCBzbyBlYXJseSByZXR1cm5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKCF0aGlzLmxheW91dCB8fCAhKGxheW91dCB8fCBsYXlvdXRJZCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJZiB3ZSBkb24ndCBoYXZlIGEgdGFyZ2V0RGVsdGEgYnV0IGRvIGhhdmUgYSBsYXlvdXQsIHdlIGNhbiBhdHRlbXB0IHRvIHJlc29sdmVcbiAgICAgICAgICAgICAqIGEgcmVsYXRpdmVQYXJlbnQuIFRoaXMgd2lsbCBhbGxvdyBhIGNvbXBvbmVudCB0byBwZXJmb3JtIHNjYWxlIGNvcnJlY3Rpb25cbiAgICAgICAgICAgICAqIGV2ZW4gaWYgbm8gYW5pbWF0aW9uIGhhcyBzdGFydGVkLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAvLyBUT0RPIElmIHRoaXMgaXMgdW5zdWNjZXNzZnVsIHRoaXMgY3VycmVudGx5IGhhcHBlbnMgZXZlcnkgZnJhbWVcbiAgICAgICAgICAgIGlmICghdGhpcy50YXJnZXREZWx0YSAmJiAhdGhpcy5yZWxhdGl2ZVRhcmdldCkge1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IFRoaXMgaXMgYSBzZW1pLXJlcGV0aXRpb24gb2YgZnVydGhlciBkb3duIHRoaXMgZnVuY3Rpb24sIG1ha2UgRFJZXG4gICAgICAgICAgICAgICAgdGhpcy5yZWxhdGl2ZVBhcmVudCA9IHRoaXMuZ2V0Q2xvc2VzdFByb2plY3RpbmdQYXJlbnQoKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZWxhdGl2ZVBhcmVudCAmJiB0aGlzLnJlbGF0aXZlUGFyZW50LmxheW91dCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbGF0aXZlVGFyZ2V0ID0gY3JlYXRlQm94KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVsYXRpdmVUYXJnZXRPcmlnaW4gPSBjcmVhdGVCb3goKTtcbiAgICAgICAgICAgICAgICAgICAgY2FsY1JlbGF0aXZlUG9zaXRpb24odGhpcy5yZWxhdGl2ZVRhcmdldE9yaWdpbiwgdGhpcy5sYXlvdXQuYWN0dWFsLCB0aGlzLnJlbGF0aXZlUGFyZW50LmxheW91dC5hY3R1YWwpO1xuICAgICAgICAgICAgICAgICAgICBjb3B5Qm94SW50byh0aGlzLnJlbGF0aXZlVGFyZ2V0LCB0aGlzLnJlbGF0aXZlVGFyZ2V0T3JpZ2luKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElmIHdlIGhhdmUgbm8gcmVsYXRpdmUgdGFyZ2V0IG9yIG5vIHRhcmdldCBkZWx0YSBvdXIgdGFyZ2V0IGlzbid0IHZhbGlkXG4gICAgICAgICAgICAgKiBmb3IgdGhpcyBmcmFtZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKCF0aGlzLnJlbGF0aXZlVGFyZ2V0ICYmICF0aGlzLnRhcmdldERlbHRhKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogTGF6eS1pbml0IHRhcmdldCBkYXRhIHN0cnVjdHVyZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoIXRoaXMudGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy50YXJnZXQgPSBjcmVhdGVCb3goKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRhcmdldFdpdGhUcmFuc2Zvcm1zID0gY3JlYXRlQm94KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElmIHdlJ3ZlIGdvdCBhIHJlbGF0aXZlIGJveCBmb3IgdGhpcyBjb21wb25lbnQsIHJlc29sdmUgaXQgaW50byBhIHRhcmdldCByZWxhdGl2ZSB0byB0aGUgcGFyZW50LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAodGhpcy5yZWxhdGl2ZVRhcmdldCAmJlxuICAgICAgICAgICAgICAgIHRoaXMucmVsYXRpdmVUYXJnZXRPcmlnaW4gJiZcbiAgICAgICAgICAgICAgICAoKF9hID0gdGhpcy5yZWxhdGl2ZVBhcmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICBjYWxjUmVsYXRpdmVCb3godGhpcy50YXJnZXQsIHRoaXMucmVsYXRpdmVUYXJnZXQsIHRoaXMucmVsYXRpdmVQYXJlbnQudGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBJZiB3ZSd2ZSBvbmx5IGdvdCBhIHRhcmdldERlbHRhLCByZXNvbHZlIGl0IGludG8gYSB0YXJnZXRcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMudGFyZ2V0RGVsdGEpIHtcbiAgICAgICAgICAgICAgICBpZiAoQm9vbGVhbih0aGlzLnJlc3VtaW5nRnJvbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogVGhpcyBpcyBjcmVhdGluZyBhIG5ldyBvYmplY3QgZXZlcnkgZnJhbWVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50YXJnZXQgPSB0aGlzLmFwcGx5VHJhbnNmb3JtKHRoaXMubGF5b3V0LmFjdHVhbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb3B5Qm94SW50byh0aGlzLnRhcmdldCwgdGhpcy5sYXlvdXQuYWN0dWFsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXBwbHlCb3hEZWx0YSh0aGlzLnRhcmdldCwgdGhpcy50YXJnZXREZWx0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBJZiBubyB0YXJnZXQsIHVzZSBvd24gbGF5b3V0IGFzIHRhcmdldFxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGNvcHlCb3hJbnRvKHRoaXMudGFyZ2V0LCB0aGlzLmxheW91dC5hY3R1YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJZiB3ZSd2ZSBiZWVuIHRvbGQgdG8gYXR0ZW1wdCB0byByZXNvbHZlIGEgcmVsYXRpdmUgdGFyZ2V0LCBkbyBzby5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKHRoaXMuYXR0ZW1wdFRvUmVzb2x2ZVJlbGF0aXZlVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hdHRlbXB0VG9SZXNvbHZlUmVsYXRpdmVUYXJnZXQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbGF0aXZlUGFyZW50ID0gdGhpcy5nZXRDbG9zZXN0UHJvamVjdGluZ1BhcmVudCgpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlbGF0aXZlUGFyZW50ICYmXG4gICAgICAgICAgICAgICAgICAgIEJvb2xlYW4odGhpcy5yZWxhdGl2ZVBhcmVudC5yZXN1bWluZ0Zyb20pID09PVxuICAgICAgICAgICAgICAgICAgICAgICAgQm9vbGVhbih0aGlzLnJlc3VtaW5nRnJvbSkgJiZcbiAgICAgICAgICAgICAgICAgICAgIXRoaXMucmVsYXRpdmVQYXJlbnQub3B0aW9ucy5sYXlvdXRTY3JvbGwgJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWxhdGl2ZVBhcmVudC50YXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWxhdGl2ZVRhcmdldCA9IGNyZWF0ZUJveCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbGF0aXZlVGFyZ2V0T3JpZ2luID0gY3JlYXRlQm94KCk7XG4gICAgICAgICAgICAgICAgICAgIGNhbGNSZWxhdGl2ZVBvc2l0aW9uKHRoaXMucmVsYXRpdmVUYXJnZXRPcmlnaW4sIHRoaXMudGFyZ2V0LCB0aGlzLnJlbGF0aXZlUGFyZW50LnRhcmdldCk7XG4gICAgICAgICAgICAgICAgICAgIGNvcHlCb3hJbnRvKHRoaXMucmVsYXRpdmVUYXJnZXQsIHRoaXMucmVsYXRpdmVUYXJnZXRPcmlnaW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgUHJvamVjdGlvbk5vZGUucHJvdG90eXBlLmdldENsb3Nlc3RQcm9qZWN0aW5nUGFyZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnBhcmVudCB8fCBoYXNUcmFuc2Zvcm0odGhpcy5wYXJlbnQubGF0ZXN0VmFsdWVzKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKCh0aGlzLnBhcmVudC5yZWxhdGl2ZVRhcmdldCB8fCB0aGlzLnBhcmVudC50YXJnZXREZWx0YSkgJiZcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudC5sYXlvdXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnQuZ2V0Q2xvc2VzdFByb2plY3RpbmdQYXJlbnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgUHJvamVjdGlvbk5vZGUucHJvdG90eXBlLmNhbGNQcm9qZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgdmFyIF9iID0gdGhpcy5vcHRpb25zLCBsYXlvdXQgPSBfYi5sYXlvdXQsIGxheW91dElkID0gX2IubGF5b3V0SWQ7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElmIHRoaXMgc2VjdGlvbiBvZiB0aGUgdHJlZSBpc24ndCBhbmltYXRpbmcgd2UgY2FuXG4gICAgICAgICAgICAgKiBkZWxldGUgb3VyIHRhcmdldCBzb3VyY2VzIGZvciB0aGUgZm9sbG93aW5nIGZyYW1lLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmlzVHJlZUFuaW1hdGluZyA9IEJvb2xlYW4oKChfYSA9IHRoaXMucGFyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaXNUcmVlQW5pbWF0aW5nKSB8fFxuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudEFuaW1hdGlvbiB8fFxuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0FuaW1hdGlvbik7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNUcmVlQW5pbWF0aW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50YXJnZXREZWx0YSA9IHRoaXMucmVsYXRpdmVUYXJnZXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMubGF5b3V0IHx8ICEobGF5b3V0IHx8IGxheW91dElkKSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIgbGVhZCA9IHRoaXMuZ2V0TGVhZCgpO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZXNldCB0aGUgY29ycmVjdGVkIGJveCB3aXRoIHRoZSBsYXRlc3QgdmFsdWVzIGZyb20gYm94LCBhcyB3ZSdyZSB0aGVuIGdvaW5nXG4gICAgICAgICAgICAgKiB0byBwZXJmb3JtIG11dGF0aXZlIG9wZXJhdGlvbnMgb24gaXQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNvcHlCb3hJbnRvKHRoaXMubGF5b3V0Q29ycmVjdGVkLCB0aGlzLmxheW91dC5hY3R1YWwpO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBcHBseSBhbGwgdGhlIHBhcmVudCBkZWx0YXMgdG8gdGhpcyBib3ggdG8gcHJvZHVjZSB0aGUgY29ycmVjdGVkIGJveC4gVGhpc1xuICAgICAgICAgICAgICogaXMgdGhlIGxheW91dCBib3gsIGFzIGl0IHdpbGwgYXBwZWFyIG9uIHNjcmVlbiBhcyBhIHJlc3VsdCBvZiB0aGUgdHJhbnNmb3JtcyBvZiBpdHMgcGFyZW50cy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgYXBwbHlUcmVlRGVsdGFzKHRoaXMubGF5b3V0Q29ycmVjdGVkLCB0aGlzLnRyZWVTY2FsZSwgdGhpcy5wYXRoLCBCb29sZWFuKHRoaXMucmVzdW1pbmdGcm9tKSB8fCB0aGlzICE9PSBsZWFkKTtcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSBsZWFkLnRhcmdldDtcbiAgICAgICAgICAgIGlmICghdGFyZ2V0KVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmICghdGhpcy5wcm9qZWN0aW9uRGVsdGEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb2plY3Rpb25EZWx0YSA9IGNyZWF0ZURlbHRhKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9qZWN0aW9uRGVsdGFXaXRoVHJhbnNmb3JtID0gY3JlYXRlRGVsdGEoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwcmV2VHJlZVNjYWxlWCA9IHRoaXMudHJlZVNjYWxlLng7XG4gICAgICAgICAgICB2YXIgcHJldlRyZWVTY2FsZVkgPSB0aGlzLnRyZWVTY2FsZS55O1xuICAgICAgICAgICAgdmFyIHByZXZQcm9qZWN0aW9uVHJhbnNmb3JtID0gdGhpcy5wcm9qZWN0aW9uVHJhbnNmb3JtO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBVcGRhdGUgdGhlIGRlbHRhIGJldHdlZW4gdGhlIGNvcnJlY3RlZCBib3ggYW5kIHRoZSB0YXJnZXQgYm94IGJlZm9yZSB1c2VyLXNldCB0cmFuc2Zvcm1zIHdlcmUgYXBwbGllZC5cbiAgICAgICAgICAgICAqIFRoaXMgd2lsbCBhbGxvdyB1cyB0byBjYWxjdWxhdGUgdGhlIGNvcnJlY3RlZCBib3JkZXJSYWRpdXMgYW5kIGJveFNoYWRvdyB0byBjb21wZW5zYXRlXG4gICAgICAgICAgICAgKiBmb3Igb3VyIGxheW91dCByZXByb2plY3Rpb24sIGJ1dCBzdGlsbCBhbGxvdyB0aGVtIHRvIGJlIHNjYWxlZCBjb3JyZWN0bHkgYnkgdGhlIHVzZXIuXG4gICAgICAgICAgICAgKiBJdCBtaWdodCBiZSB0aGF0IHRvIHNpbXBsaWZ5IHRoaXMgd2UgbWF5IHdhbnQgdG8gYWNjZXB0IHRoYXQgdXNlci1zZXQgc2NhbGUgaXMgYWxzbyBjb3JyZWN0ZWRcbiAgICAgICAgICAgICAqIGFuZCB3ZSB3b3VsZG4ndCBoYXZlIHRvIGtlZXAgYW5kIGNhbGMgYm90aCBkZWx0YXMsIE9SIHdlIGNvdWxkIHN1cHBvcnQgYSB1c2VyIHNldHRpbmdcbiAgICAgICAgICAgICAqIHRvIGFsbG93IHBlb3BsZSB0byBjaG9vc2Ugd2hldGhlciB0aGVzZSBzdHlsZXMgYXJlIGNvcnJlY3RlZCBiYXNlZCBvbiBqdXN0IHRoZVxuICAgICAgICAgICAgICogbGF5b3V0IHJlcHJvamVjdGlvbiBvciB0aGUgZmluYWwgYm91bmRpbmcgYm94LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjYWxjQm94RGVsdGEodGhpcy5wcm9qZWN0aW9uRGVsdGEsIHRoaXMubGF5b3V0Q29ycmVjdGVkLCB0YXJnZXQsIHRoaXMubGF0ZXN0VmFsdWVzKTtcbiAgICAgICAgICAgIHRoaXMucHJvamVjdGlvblRyYW5zZm9ybSA9IGJ1aWxkUHJvamVjdGlvblRyYW5zZm9ybSh0aGlzLnByb2plY3Rpb25EZWx0YSwgdGhpcy50cmVlU2NhbGUpO1xuICAgICAgICAgICAgaWYgKHRoaXMucHJvamVjdGlvblRyYW5zZm9ybSAhPT0gcHJldlByb2plY3Rpb25UcmFuc2Zvcm0gfHxcbiAgICAgICAgICAgICAgICB0aGlzLnRyZWVTY2FsZS54ICE9PSBwcmV2VHJlZVNjYWxlWCB8fFxuICAgICAgICAgICAgICAgIHRoaXMudHJlZVNjYWxlLnkgIT09IHByZXZUcmVlU2NhbGVZKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oYXNQcm9qZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVSZW5kZXIoKTtcbiAgICAgICAgICAgICAgICB0aGlzLm5vdGlmeUxpc3RlbmVycyhcInByb2plY3Rpb25VcGRhdGVcIiwgdGFyZ2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgUHJvamVjdGlvbk5vZGUucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmlzVmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gVE9ETzogU2NoZWR1bGUgcmVuZGVyXG4gICAgICAgIH07XG4gICAgICAgIFByb2plY3Rpb25Ob2RlLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5pc1Zpc2libGUgPSB0cnVlO1xuICAgICAgICAgICAgLy8gVE9ETzogU2NoZWR1bGUgcmVuZGVyXG4gICAgICAgIH07XG4gICAgICAgIFByb2plY3Rpb25Ob2RlLnByb3RvdHlwZS5zY2hlZHVsZVJlbmRlciA9IGZ1bmN0aW9uIChub3RpZnlBbGwpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgaWYgKG5vdGlmeUFsbCA9PT0gdm9pZCAwKSB7IG5vdGlmeUFsbCA9IHRydWU7IH1cbiAgICAgICAgICAgIChfYiA9IChfYSA9IHRoaXMub3B0aW9ucykuc2NoZWR1bGVSZW5kZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hKTtcbiAgICAgICAgICAgIG5vdGlmeUFsbCAmJiAoKF9jID0gdGhpcy5nZXRTdGFjaygpKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Muc2NoZWR1bGVSZW5kZXIoKSk7XG4gICAgICAgICAgICBpZiAodGhpcy5yZXN1bWluZ0Zyb20gJiYgIXRoaXMucmVzdW1pbmdGcm9tLmluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXN1bWluZ0Zyb20gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFByb2plY3Rpb25Ob2RlLnByb3RvdHlwZS5zZXRBbmltYXRpb25PcmlnaW4gPSBmdW5jdGlvbiAoZGVsdGEsIGhhc09ubHlSZWxhdGl2ZVRhcmdldENoYW5nZWQpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBpZiAoaGFzT25seVJlbGF0aXZlVGFyZ2V0Q2hhbmdlZCA9PT0gdm9pZCAwKSB7IGhhc09ubHlSZWxhdGl2ZVRhcmdldENoYW5nZWQgPSBmYWxzZTsgfVxuICAgICAgICAgICAgdmFyIHNuYXBzaG90ID0gdGhpcy5zbmFwc2hvdDtcbiAgICAgICAgICAgIHZhciBzbmFwc2hvdExhdGVzdFZhbHVlcyA9IChzbmFwc2hvdCA9PT0gbnVsbCB8fCBzbmFwc2hvdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc25hcHNob3QubGF0ZXN0VmFsdWVzKSB8fCB7fTtcbiAgICAgICAgICAgIHZhciBtaXhlZFZhbHVlcyA9IF9fYXNzaWduKHt9LCB0aGlzLmxhdGVzdFZhbHVlcyk7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0RGVsdGEgPSBjcmVhdGVEZWx0YSgpO1xuICAgICAgICAgICAgdGhpcy5yZWxhdGl2ZVRhcmdldCA9IHRoaXMucmVsYXRpdmVUYXJnZXRPcmlnaW4gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLmF0dGVtcHRUb1Jlc29sdmVSZWxhdGl2ZVRhcmdldCA9ICFoYXNPbmx5UmVsYXRpdmVUYXJnZXRDaGFuZ2VkO1xuICAgICAgICAgICAgdmFyIHJlbGF0aXZlTGF5b3V0ID0gY3JlYXRlQm94KCk7XG4gICAgICAgICAgICB2YXIgaXNTaGFyZWRMYXlvdXRBbmltYXRpb24gPSBzbmFwc2hvdCA9PT0gbnVsbCB8fCBzbmFwc2hvdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc25hcHNob3QuaXNTaGFyZWQ7XG4gICAgICAgICAgICB2YXIgaXNPbmx5TWVtYmVyID0gKCgoX2EgPSB0aGlzLmdldFN0YWNrKCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tZW1iZXJzLmxlbmd0aCkgfHwgMCkgPD0gMTtcbiAgICAgICAgICAgIHZhciBzaG91bGRDcm9zc2ZhZGVPcGFjaXR5ID0gQm9vbGVhbihpc1NoYXJlZExheW91dEFuaW1hdGlvbiAmJlxuICAgICAgICAgICAgICAgICFpc09ubHlNZW1iZXIgJiZcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuY3Jvc3NmYWRlID09PSB0cnVlICYmXG4gICAgICAgICAgICAgICAgIXRoaXMucGF0aC5zb21lKGhhc09wYWNpdHlDcm9zc2ZhZGUpKTtcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uUHJvZ3Jlc3MgPSAwO1xuICAgICAgICAgICAgdGhpcy5taXhUYXJnZXREZWx0YSA9IGZ1bmN0aW9uIChsYXRlc3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgdmFyIHByb2dyZXNzID0gbGF0ZXN0IC8gMTAwMDtcbiAgICAgICAgICAgICAgICBtaXhBeGlzRGVsdGEodGFyZ2V0RGVsdGEueCwgZGVsdGEueCwgcHJvZ3Jlc3MpO1xuICAgICAgICAgICAgICAgIG1peEF4aXNEZWx0YSh0YXJnZXREZWx0YS55LCBkZWx0YS55LCBwcm9ncmVzcyk7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2V0VGFyZ2V0RGVsdGEodGFyZ2V0RGVsdGEpO1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5yZWxhdGl2ZVRhcmdldCAmJlxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZWxhdGl2ZVRhcmdldE9yaWdpbiAmJlxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5sYXlvdXQgJiZcbiAgICAgICAgICAgICAgICAgICAgKChfYSA9IF90aGlzLnJlbGF0aXZlUGFyZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGF5b3V0KSkge1xuICAgICAgICAgICAgICAgICAgICBjYWxjUmVsYXRpdmVQb3NpdGlvbihyZWxhdGl2ZUxheW91dCwgX3RoaXMubGF5b3V0LmFjdHVhbCwgX3RoaXMucmVsYXRpdmVQYXJlbnQubGF5b3V0LmFjdHVhbCk7XG4gICAgICAgICAgICAgICAgICAgIG1peEJveChfdGhpcy5yZWxhdGl2ZVRhcmdldCwgX3RoaXMucmVsYXRpdmVUYXJnZXRPcmlnaW4sIHJlbGF0aXZlTGF5b3V0LCBwcm9ncmVzcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpc1NoYXJlZExheW91dEFuaW1hdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hbmltYXRpb25WYWx1ZXMgPSBtaXhlZFZhbHVlcztcbiAgICAgICAgICAgICAgICAgICAgbWl4VmFsdWVzKG1peGVkVmFsdWVzLCBzbmFwc2hvdExhdGVzdFZhbHVlcywgX3RoaXMubGF0ZXN0VmFsdWVzLCBwcm9ncmVzcywgc2hvdWxkQ3Jvc3NmYWRlT3BhY2l0eSwgaXNPbmx5TWVtYmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX3RoaXMucm9vdC5zY2hlZHVsZVVwZGF0ZVByb2plY3Rpb24oKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5zY2hlZHVsZVJlbmRlcigpO1xuICAgICAgICAgICAgICAgIF90aGlzLmFuaW1hdGlvblByb2dyZXNzID0gcHJvZ3Jlc3M7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5taXhUYXJnZXREZWx0YSgwKTtcbiAgICAgICAgfTtcbiAgICAgICAgUHJvamVjdGlvbk5vZGUucHJvdG90eXBlLnN0YXJ0QW5pbWF0aW9uID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgdGhpcy5ub3RpZnlMaXN0ZW5lcnMoXCJhbmltYXRpb25TdGFydFwiKTtcbiAgICAgICAgICAgIChfYSA9IHRoaXMuY3VycmVudEFuaW1hdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnN0b3AoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlc3VtaW5nRnJvbSkge1xuICAgICAgICAgICAgICAgIChfYiA9IHRoaXMucmVzdW1pbmdGcm9tLmN1cnJlbnRBbmltYXRpb24pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5wZW5kaW5nQW5pbWF0aW9uKSB7XG4gICAgICAgICAgICAgICAgY2FuY2VsU3luYy51cGRhdGUodGhpcy5wZW5kaW5nQW5pbWF0aW9uKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBlbmRpbmdBbmltYXRpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFN0YXJ0IHRoZSBhbmltYXRpb24gaW4gdGhlIG5leHQgZnJhbWUgdG8gaGF2ZSBhIGZyYW1lIHdpdGggcHJvZ3Jlc3MgMCxcbiAgICAgICAgICAgICAqIHdoZXJlIHRoZSB0YXJnZXQgaXMgdGhlIHNhbWUgYXMgd2hlbiB0aGUgYW5pbWF0aW9uIHN0YXJ0ZWQsIHNvIHdlIGNhblxuICAgICAgICAgICAgICogY2FsY3VsYXRlIHRoZSByZWxhdGl2ZSBwb3NpdGlvbnMgY29ycmVjdGx5IGZvciBpbnN0YW50IHRyYW5zaXRpb25zLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdBbmltYXRpb24gPSBzeW5jLnVwZGF0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgZ2xvYmFsUHJvamVjdGlvblN0YXRlLmhhc0FuaW1hdGVkU2luY2VSZXNpemUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIF90aGlzLmN1cnJlbnRBbmltYXRpb24gPSBhbmltYXRlKDAsIGFuaW1hdGlvblRhcmdldCwgX19hc3NpZ24oX19hc3NpZ24oe30sIG9wdGlvbnMpLCB7IG9uVXBkYXRlOiBmdW5jdGlvbiAobGF0ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5taXhUYXJnZXREZWx0YShsYXRlc3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgKF9hID0gb3B0aW9ucy5vblVwZGF0ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwob3B0aW9ucywgbGF0ZXN0KTtcbiAgICAgICAgICAgICAgICAgICAgfSwgb25Db21wbGV0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICAgICAgKF9hID0gb3B0aW9ucy5vbkNvbXBsZXRlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmNvbXBsZXRlQW5pbWF0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIH0gfSkpO1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5yZXN1bWluZ0Zyb20pIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVzdW1pbmdGcm9tLmN1cnJlbnRBbmltYXRpb24gPSBfdGhpcy5jdXJyZW50QW5pbWF0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy5wZW5kaW5nQW5pbWF0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIFByb2plY3Rpb25Ob2RlLnByb3RvdHlwZS5jb21wbGV0ZUFuaW1hdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlc3VtaW5nRnJvbSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzdW1pbmdGcm9tLmN1cnJlbnRBbmltYXRpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXN1bWluZ0Zyb20ucHJlc2VydmVPcGFjaXR5ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgKF9hID0gdGhpcy5nZXRTdGFjaygpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZXhpdEFuaW1hdGlvbkNvbXBsZXRlKCk7XG4gICAgICAgICAgICB0aGlzLnJlc3VtaW5nRnJvbSA9XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50QW5pbWF0aW9uID1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hbmltYXRpb25WYWx1ZXMgPVxuICAgICAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5ub3RpZnlMaXN0ZW5lcnMoXCJhbmltYXRpb25Db21wbGV0ZVwiKTtcbiAgICAgICAgfTtcbiAgICAgICAgUHJvamVjdGlvbk5vZGUucHJvdG90eXBlLmZpbmlzaEFuaW1hdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRBbmltYXRpb24pIHtcbiAgICAgICAgICAgICAgICAoX2EgPSB0aGlzLm1peFRhcmdldERlbHRhKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzLCBhbmltYXRpb25UYXJnZXQpO1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudEFuaW1hdGlvbi5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNvbXBsZXRlQW5pbWF0aW9uKCk7XG4gICAgICAgIH07XG4gICAgICAgIFByb2plY3Rpb25Ob2RlLnByb3RvdHlwZS5hcHBseVRyYW5zZm9ybXNUb1RhcmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBfYSA9IHRoaXMuZ2V0TGVhZCgpLCB0YXJnZXRXaXRoVHJhbnNmb3JtcyA9IF9hLnRhcmdldFdpdGhUcmFuc2Zvcm1zLCB0YXJnZXQgPSBfYS50YXJnZXQsIGxheW91dCA9IF9hLmxheW91dCwgbGF0ZXN0VmFsdWVzID0gX2EubGF0ZXN0VmFsdWVzO1xuICAgICAgICAgICAgaWYgKCF0YXJnZXRXaXRoVHJhbnNmb3JtcyB8fCAhdGFyZ2V0IHx8ICFsYXlvdXQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY29weUJveEludG8odGFyZ2V0V2l0aFRyYW5zZm9ybXMsIHRhcmdldCk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEFwcGx5IHRoZSBsYXRlc3QgdXNlci1zZXQgdHJhbnNmb3JtcyB0byB0aGUgdGFyZ2V0Qm94IHRvIHByb2R1Y2UgdGhlIHRhcmdldEJveEZpbmFsLlxuICAgICAgICAgICAgICogVGhpcyBpcyB0aGUgZmluYWwgYm94IHRoYXQgd2Ugd2lsbCB0aGVuIHByb2plY3QgaW50byBieSBjYWxjdWxhdGluZyBhIHRyYW5zZm9ybSBkZWx0YSBhbmRcbiAgICAgICAgICAgICAqIGFwcGx5aW5nIGl0IHRvIHRoZSBjb3JyZWN0ZWQgYm94LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0cmFuc2Zvcm1Cb3godGFyZ2V0V2l0aFRyYW5zZm9ybXMsIGxhdGVzdFZhbHVlcyk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFVwZGF0ZSB0aGUgZGVsdGEgYmV0d2VlbiB0aGUgY29ycmVjdGVkIGJveCBhbmQgdGhlIGZpbmFsIHRhcmdldCBib3gsIGFmdGVyXG4gICAgICAgICAgICAgKiB1c2VyLXNldCB0cmFuc2Zvcm1zIGFyZSBhcHBsaWVkIHRvIGl0LiBUaGlzIHdpbGwgYmUgdXNlZCBieSB0aGUgcmVuZGVyZXIgdG9cbiAgICAgICAgICAgICAqIGNyZWF0ZSBhIHRyYW5zZm9ybSBzdHlsZSB0aGF0IHdpbGwgcmVwcm9qZWN0IHRoZSBlbGVtZW50IGZyb20gaXRzIGFjdHVhbCBsYXlvdXRcbiAgICAgICAgICAgICAqIGludG8gdGhlIGRlc2lyZWQgYm91bmRpbmcgYm94LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjYWxjQm94RGVsdGEodGhpcy5wcm9qZWN0aW9uRGVsdGFXaXRoVHJhbnNmb3JtLCB0aGlzLmxheW91dENvcnJlY3RlZCwgdGFyZ2V0V2l0aFRyYW5zZm9ybXMsIGxhdGVzdFZhbHVlcyk7XG4gICAgICAgIH07XG4gICAgICAgIFByb2plY3Rpb25Ob2RlLnByb3RvdHlwZS5yZWdpc3RlclNoYXJlZE5vZGUgPSBmdW5jdGlvbiAobGF5b3V0SWQsIG5vZGUpIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnNoYXJlZE5vZGVzLmhhcyhsYXlvdXRJZCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNoYXJlZE5vZGVzLnNldChsYXlvdXRJZCwgbmV3IE5vZGVTdGFjaygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzdGFjayA9IHRoaXMuc2hhcmVkTm9kZXMuZ2V0KGxheW91dElkKTtcbiAgICAgICAgICAgIHN0YWNrLmFkZChub2RlKTtcbiAgICAgICAgICAgIG5vZGUucHJvbW90ZSh7XG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbjogKF9hID0gbm9kZS5vcHRpb25zLmluaXRpYWxQcm9tb3Rpb25Db25maWcpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50cmFuc2l0aW9uLFxuICAgICAgICAgICAgICAgIHByZXNlcnZlRm9sbG93T3BhY2l0eTogKF9jID0gKF9iID0gbm9kZS5vcHRpb25zLmluaXRpYWxQcm9tb3Rpb25Db25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zaG91bGRQcmVzZXJ2ZUZvbGxvd09wYWNpdHkpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5jYWxsKF9iLCBub2RlKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBQcm9qZWN0aW9uTm9kZS5wcm90b3R5cGUuaXNMZWFkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHN0YWNrID0gdGhpcy5nZXRTdGFjaygpO1xuICAgICAgICAgICAgcmV0dXJuIHN0YWNrID8gc3RhY2subGVhZCA9PT0gdGhpcyA6IHRydWU7XG4gICAgICAgIH07XG4gICAgICAgIFByb2plY3Rpb25Ob2RlLnByb3RvdHlwZS5nZXRMZWFkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgdmFyIGxheW91dElkID0gdGhpcy5vcHRpb25zLmxheW91dElkO1xuICAgICAgICAgICAgcmV0dXJuIGxheW91dElkID8gKChfYSA9IHRoaXMuZ2V0U3RhY2soKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxlYWQpIHx8IHRoaXMgOiB0aGlzO1xuICAgICAgICB9O1xuICAgICAgICBQcm9qZWN0aW9uTm9kZS5wcm90b3R5cGUuZ2V0UHJldkxlYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICB2YXIgbGF5b3V0SWQgPSB0aGlzLm9wdGlvbnMubGF5b3V0SWQ7XG4gICAgICAgICAgICByZXR1cm4gbGF5b3V0SWQgPyAoX2EgPSB0aGlzLmdldFN0YWNrKCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wcmV2TGVhZCA6IHVuZGVmaW5lZDtcbiAgICAgICAgfTtcbiAgICAgICAgUHJvamVjdGlvbk5vZGUucHJvdG90eXBlLmdldFN0YWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGxheW91dElkID0gdGhpcy5vcHRpb25zLmxheW91dElkO1xuICAgICAgICAgICAgaWYgKGxheW91dElkKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJvb3Quc2hhcmVkTm9kZXMuZ2V0KGxheW91dElkKTtcbiAgICAgICAgfTtcbiAgICAgICAgUHJvamVjdGlvbk5vZGUucHJvdG90eXBlLnByb21vdGUgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCBuZWVkc1Jlc2V0ID0gX2IubmVlZHNSZXNldCwgdHJhbnNpdGlvbiA9IF9iLnRyYW5zaXRpb24sIHByZXNlcnZlRm9sbG93T3BhY2l0eSA9IF9iLnByZXNlcnZlRm9sbG93T3BhY2l0eTtcbiAgICAgICAgICAgIHZhciBzdGFjayA9IHRoaXMuZ2V0U3RhY2soKTtcbiAgICAgICAgICAgIGlmIChzdGFjaylcbiAgICAgICAgICAgICAgICBzdGFjay5wcm9tb3RlKHRoaXMsIHByZXNlcnZlRm9sbG93T3BhY2l0eSk7XG4gICAgICAgICAgICBpZiAobmVlZHNSZXNldCkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvamVjdGlvbkRlbHRhID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHRoaXMubmVlZHNSZXNldCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHJhbnNpdGlvbilcbiAgICAgICAgICAgICAgICB0aGlzLnNldE9wdGlvbnMoeyB0cmFuc2l0aW9uOiB0cmFuc2l0aW9uIH0pO1xuICAgICAgICB9O1xuICAgICAgICBQcm9qZWN0aW9uTm9kZS5wcm90b3R5cGUucmVsZWdhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgc3RhY2sgPSB0aGlzLmdldFN0YWNrKCk7XG4gICAgICAgICAgICBpZiAoc3RhY2spIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhY2sucmVsZWdhdGUodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIFByb2plY3Rpb25Ob2RlLnByb3RvdHlwZS5yZXNldFJvdGF0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHZpc3VhbEVsZW1lbnQgPSB0aGlzLm9wdGlvbnMudmlzdWFsRWxlbWVudDtcbiAgICAgICAgICAgIGlmICghdmlzdWFsRWxlbWVudClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSdzIG5vIGRldGVjdGVkIHJvdGF0aW9uIHZhbHVlcywgd2UgY2FuIGVhcmx5IHJldHVybiB3aXRob3V0IGEgZm9yY2VkIHJlbmRlci5cbiAgICAgICAgICAgIHZhciBoYXNSb3RhdGUgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIEtlZXAgYSByZWNvcmQgb2YgYWxsIHRoZSB2YWx1ZXMgd2UndmUgcmVzZXRcbiAgICAgICAgICAgIHZhciByZXNldFZhbHVlcyA9IHt9O1xuICAgICAgICAgICAgLy8gQ2hlY2sgdGhlIHJvdGF0ZSB2YWx1ZSBvZiBhbGwgYXhlcyBhbmQgcmVzZXQgdG8gMFxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cmFuc2Zvcm1BeGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGF4aXMgPSB0cmFuc2Zvcm1BeGVzW2ldO1xuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBcInJvdGF0ZVwiICsgYXhpcztcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGlzIHJvdGF0aW9uIGRvZXNuJ3QgZXhpc3QgYXMgYSBtb3Rpb24gdmFsdWUsIHRoZW4gd2UgZG9uJ3RcbiAgICAgICAgICAgICAgICAvLyBuZWVkIHRvIHJlc2V0IGl0XG4gICAgICAgICAgICAgICAgaWYgKCF2aXN1YWxFbGVtZW50LmdldFN0YXRpY1ZhbHVlKGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGhhc1JvdGF0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgLy8gUmVjb3JkIHRoZSByb3RhdGlvbiBhbmQgdGhlbiB0ZW1wb3JhcmlseSBzZXQgaXQgdG8gMFxuICAgICAgICAgICAgICAgIHJlc2V0VmFsdWVzW2tleV0gPSB2aXN1YWxFbGVtZW50LmdldFN0YXRpY1ZhbHVlKGtleSk7XG4gICAgICAgICAgICAgICAgdmlzdWFsRWxlbWVudC5zZXRTdGF0aWNWYWx1ZShrZXksIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgdGhlcmUncyBubyByb3RhdGlvbiB2YWx1ZXMsIHdlIGRvbid0IG5lZWQgdG8gZG8gYW55IG1vcmUuXG4gICAgICAgICAgICBpZiAoIWhhc1JvdGF0ZSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAvLyBGb3JjZSBhIHJlbmRlciBvZiB0aGlzIGVsZW1lbnQgdG8gYXBwbHkgdGhlIHRyYW5zZm9ybSB3aXRoIGFsbCByb3RhdGlvbnNcbiAgICAgICAgICAgIC8vIHNldCB0byAwLlxuICAgICAgICAgICAgdmlzdWFsRWxlbWVudCA9PT0gbnVsbCB8fCB2aXN1YWxFbGVtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2aXN1YWxFbGVtZW50LnN5bmNSZW5kZXIoKTtcbiAgICAgICAgICAgIC8vIFB1dCBiYWNrIGFsbCB0aGUgdmFsdWVzIHdlIHJlc2V0XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gcmVzZXRWYWx1ZXMpIHtcbiAgICAgICAgICAgICAgICB2aXN1YWxFbGVtZW50LnNldFN0YXRpY1ZhbHVlKGtleSwgcmVzZXRWYWx1ZXNba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTY2hlZHVsZSBhIHJlbmRlciBmb3IgdGhlIG5leHQgZnJhbWUuIFRoaXMgZW5zdXJlcyB3ZSB3b24ndCB2aXN1YWxseVxuICAgICAgICAgICAgLy8gc2VlIHRoZSBlbGVtZW50IHdpdGggdGhlIHJlc2V0IHJvdGF0ZSB2YWx1ZSBhcHBsaWVkLlxuICAgICAgICAgICAgdmlzdWFsRWxlbWVudC5zY2hlZHVsZVJlbmRlcigpO1xuICAgICAgICB9O1xuICAgICAgICBQcm9qZWN0aW9uTm9kZS5wcm90b3R5cGUuZ2V0UHJvamVjdGlvblN0eWxlcyA9IGZ1bmN0aW9uIChzdHlsZVByb3ApIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xuICAgICAgICAgICAgaWYgKHN0eWxlUHJvcCA9PT0gdm9pZCAwKSB7IHN0eWxlUHJvcCA9IHt9OyB9XG4gICAgICAgICAgICAvLyBUT0RPOiBSZXR1cm4gbGlmZWN5Y2xlLXBlcnNpc3RlbnQgb2JqZWN0XG4gICAgICAgICAgICB2YXIgc3R5bGVzID0ge307XG4gICAgICAgICAgICBpZiAoIXRoaXMuaW5zdGFuY2UgfHwgdGhpcy5pc1NWRylcbiAgICAgICAgICAgICAgICByZXR1cm4gc3R5bGVzO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzVmlzaWJsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHZpc2liaWxpdHk6IFwiaGlkZGVuXCIgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0eWxlcy52aXNpYmlsaXR5ID0gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0cmFuc2Zvcm1UZW1wbGF0ZSA9IChfYSA9IHRoaXMub3B0aW9ucy52aXN1YWxFbGVtZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0UHJvcHMoKS50cmFuc2Zvcm1UZW1wbGF0ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLm5lZWRzUmVzZXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5lZWRzUmVzZXQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBzdHlsZXMub3BhY2l0eSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgc3R5bGVzLnBvaW50ZXJFdmVudHMgPVxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlTW90aW9uVmFsdWUoc3R5bGVQcm9wLnBvaW50ZXJFdmVudHMpIHx8IFwiXCI7XG4gICAgICAgICAgICAgICAgc3R5bGVzLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVRlbXBsYXRlXG4gICAgICAgICAgICAgICAgICAgID8gdHJhbnNmb3JtVGVtcGxhdGUodGhpcy5sYXRlc3RWYWx1ZXMsIFwiXCIpXG4gICAgICAgICAgICAgICAgICAgIDogXCJub25lXCI7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0eWxlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBsZWFkID0gdGhpcy5nZXRMZWFkKCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMucHJvamVjdGlvbkRlbHRhIHx8ICF0aGlzLmxheW91dCB8fCAhbGVhZC50YXJnZXQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZW1wdHlTdHlsZXMgPSB7fTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmxheW91dElkKSB7XG4gICAgICAgICAgICAgICAgICAgIGVtcHR5U3R5bGVzLm9wYWNpdHkgPSAoX2IgPSB0aGlzLmxhdGVzdFZhbHVlcy5vcGFjaXR5KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAxO1xuICAgICAgICAgICAgICAgICAgICBlbXB0eVN0eWxlcy5wb2ludGVyRXZlbnRzID1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVNb3Rpb25WYWx1ZShzdHlsZVByb3AucG9pbnRlckV2ZW50cykgfHwgXCJcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaGFzUHJvamVjdGVkICYmICFoYXNUcmFuc2Zvcm0odGhpcy5sYXRlc3RWYWx1ZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGVtcHR5U3R5bGVzLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVRlbXBsYXRlXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHRyYW5zZm9ybVRlbXBsYXRlKHt9LCBcIlwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBcIm5vbmVcIjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYXNQcm9qZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVtcHR5U3R5bGVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHZhbHVlc1RvUmVuZGVyID0gbGVhZC5hbmltYXRpb25WYWx1ZXMgfHwgbGVhZC5sYXRlc3RWYWx1ZXM7XG4gICAgICAgICAgICB0aGlzLmFwcGx5VHJhbnNmb3Jtc1RvVGFyZ2V0KCk7XG4gICAgICAgICAgICBzdHlsZXMudHJhbnNmb3JtID0gYnVpbGRQcm9qZWN0aW9uVHJhbnNmb3JtKHRoaXMucHJvamVjdGlvbkRlbHRhV2l0aFRyYW5zZm9ybSwgdGhpcy50cmVlU2NhbGUsIHZhbHVlc1RvUmVuZGVyKTtcbiAgICAgICAgICAgIGlmICh0cmFuc2Zvcm1UZW1wbGF0ZSkge1xuICAgICAgICAgICAgICAgIHN0eWxlcy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1UZW1wbGF0ZSh2YWx1ZXNUb1JlbmRlciwgc3R5bGVzLnRyYW5zZm9ybSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgX2cgPSB0aGlzLnByb2plY3Rpb25EZWx0YSwgeCA9IF9nLngsIHkgPSBfZy55O1xuICAgICAgICAgICAgc3R5bGVzLnRyYW5zZm9ybU9yaWdpbiA9IFwiXCIuY29uY2F0KHgub3JpZ2luICogMTAwLCBcIiUgXCIpLmNvbmNhdCh5Lm9yaWdpbiAqIDEwMCwgXCIlIDBcIik7XG4gICAgICAgICAgICBpZiAobGVhZC5hbmltYXRpb25WYWx1ZXMpIHtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBJZiB0aGUgbGVhZCBjb21wb25lbnQgaXMgYW5pbWF0aW5nLCBhc3NpZ24gdGhpcyBlaXRoZXIgdGhlIGVudGVyaW5nL2xlYXZpbmdcbiAgICAgICAgICAgICAgICAgKiBvcGFjaXR5XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgc3R5bGVzLm9wYWNpdHkgPVxuICAgICAgICAgICAgICAgICAgICBsZWFkID09PSB0aGlzXG4gICAgICAgICAgICAgICAgICAgICAgICA/IChfZCA9IChfYyA9IHZhbHVlc1RvUmVuZGVyLm9wYWNpdHkpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IHRoaXMubGF0ZXN0VmFsdWVzLm9wYWNpdHkpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IDFcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdGhpcy5wcmVzZXJ2ZU9wYWNpdHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHRoaXMubGF0ZXN0VmFsdWVzLm9wYWNpdHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHZhbHVlc1RvUmVuZGVyLm9wYWNpdHlFeGl0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogT3Igd2UncmUgbm90IGFuaW1hdGluZyBhdCBhbGwsIHNldCB0aGUgbGVhZCBjb21wb25lbnQgdG8gaXRzIGFjdHVhbFxuICAgICAgICAgICAgICAgICAqIG9wYWNpdHkgYW5kIG90aGVyIGNvbXBvbmVudHMgdG8gaGlkZGVuLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHN0eWxlcy5vcGFjaXR5ID1cbiAgICAgICAgICAgICAgICAgICAgbGVhZCA9PT0gdGhpc1xuICAgICAgICAgICAgICAgICAgICAgICAgPyAoX2UgPSB2YWx1ZXNUb1JlbmRlci5vcGFjaXR5KSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiBcIlwiXG4gICAgICAgICAgICAgICAgICAgICAgICA6IChfZiA9IHZhbHVlc1RvUmVuZGVyLm9wYWNpdHlFeGl0KSAhPT0gbnVsbCAmJiBfZiAhPT0gdm9pZCAwID8gX2YgOiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBcHBseSBzY2FsZSBjb3JyZWN0aW9uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBzY2FsZUNvcnJlY3RvcnMpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWVzVG9SZW5kZXJba2V5XSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB2YXIgX2ggPSBzY2FsZUNvcnJlY3RvcnNba2V5XSwgY29ycmVjdCA9IF9oLmNvcnJlY3QsIGFwcGx5VG8gPSBfaC5hcHBseVRvO1xuICAgICAgICAgICAgICAgIHZhciBjb3JyZWN0ZWQgPSBjb3JyZWN0KHZhbHVlc1RvUmVuZGVyW2tleV0sIGxlYWQpO1xuICAgICAgICAgICAgICAgIGlmIChhcHBseVRvKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBudW0gPSBhcHBseVRvLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW07IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3R5bGVzW2FwcGx5VG9baV1dID0gY29ycmVjdGVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZXNba2V5XSA9IGNvcnJlY3RlZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIERpc2FibGUgcG9pbnRlciBldmVudHMgb24gZm9sbG93IGNvbXBvbmVudHMuIFRoaXMgaXMgdG8gZW5zdXJlXG4gICAgICAgICAgICAgKiB0aGF0IGlmIGEgZm9sbG93IGNvbXBvbmVudCBjb3ZlcnMgYSBsZWFkIGNvbXBvbmVudCBpdCBkb2Vzbid0IGJsb2NrXG4gICAgICAgICAgICAgKiBwb2ludGVyIGV2ZW50cyBvbiB0aGUgbGVhZC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5sYXlvdXRJZCkge1xuICAgICAgICAgICAgICAgIHN0eWxlcy5wb2ludGVyRXZlbnRzID1cbiAgICAgICAgICAgICAgICAgICAgbGVhZCA9PT0gdGhpc1xuICAgICAgICAgICAgICAgICAgICAgICAgPyByZXNvbHZlTW90aW9uVmFsdWUoc3R5bGVQcm9wLnBvaW50ZXJFdmVudHMpIHx8IFwiXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIDogXCJub25lXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3R5bGVzO1xuICAgICAgICB9O1xuICAgICAgICBQcm9qZWN0aW9uTm9kZS5wcm90b3R5cGUuY2xlYXJTbmFwc2hvdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMucmVzdW1lRnJvbSA9IHRoaXMuc25hcHNob3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIH07XG4gICAgICAgIC8vIE9ubHkgcnVuIG9uIHJvb3RcbiAgICAgICAgUHJvamVjdGlvbk5vZGUucHJvdG90eXBlLnJlc2V0VHJlZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMucm9vdC5ub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7IHZhciBfYTsgcmV0dXJuIChfYSA9IG5vZGUuY3VycmVudEFuaW1hdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnN0b3AoKTsgfSk7XG4gICAgICAgICAgICB0aGlzLnJvb3Qubm9kZXMuZm9yRWFjaChjbGVhck1lYXN1cmVtZW50cyk7XG4gICAgICAgICAgICB0aGlzLnJvb3Quc2hhcmVkTm9kZXMuY2xlYXIoKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFByb2plY3Rpb25Ob2RlO1xuICAgIH0oKSk7XG59XG5mdW5jdGlvbiB1cGRhdGVMYXlvdXQobm9kZSkge1xuICAgIG5vZGUudXBkYXRlTGF5b3V0KCk7XG59XG5mdW5jdGlvbiBub3RpZnlMYXlvdXRVcGRhdGUobm9kZSkge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICB2YXIgc25hcHNob3QgPSAoX2IgPSAoX2EgPSBub2RlLnJlc3VtZUZyb20pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zbmFwc2hvdCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogbm9kZS5zbmFwc2hvdDtcbiAgICBpZiAobm9kZS5pc0xlYWQoKSAmJlxuICAgICAgICBub2RlLmxheW91dCAmJlxuICAgICAgICBzbmFwc2hvdCAmJlxuICAgICAgICBub2RlLmhhc0xpc3RlbmVycyhcImRpZFVwZGF0ZVwiKSkge1xuICAgICAgICB2YXIgX2UgPSBub2RlLmxheW91dCwgbGF5b3V0XzEgPSBfZS5hY3R1YWwsIG1lYXN1cmVkTGF5b3V0ID0gX2UubWVhc3VyZWQ7XG4gICAgICAgIC8vIFRPRE8gTWF5YmUgd2Ugd2FudCB0byBhbHNvIHJlc2l6ZSB0aGUgbGF5b3V0IHNuYXBzaG90IHNvIHdlIGRvbid0IHRyaWdnZXJcbiAgICAgICAgLy8gYW5pbWF0aW9ucyBmb3IgaW5zdGFuY2UgaWYgbGF5b3V0PVwic2l6ZVwiIGFuZCBhbiBlbGVtZW50IGhhcyBvbmx5IGNoYW5nZWQgcG9zaXRpb25cbiAgICAgICAgaWYgKG5vZGUub3B0aW9ucy5hbmltYXRpb25UeXBlID09PSBcInNpemVcIikge1xuICAgICAgICAgICAgZWFjaEF4aXMoZnVuY3Rpb24gKGF4aXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXhpc1NuYXBzaG90ID0gc25hcHNob3QuaXNTaGFyZWRcbiAgICAgICAgICAgICAgICAgICAgPyBzbmFwc2hvdC5tZWFzdXJlZFtheGlzXVxuICAgICAgICAgICAgICAgICAgICA6IHNuYXBzaG90LmxheW91dFtheGlzXTtcbiAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoID0gY2FsY0xlbmd0aChheGlzU25hcHNob3QpO1xuICAgICAgICAgICAgICAgIGF4aXNTbmFwc2hvdC5taW4gPSBsYXlvdXRfMVtheGlzXS5taW47XG4gICAgICAgICAgICAgICAgYXhpc1NuYXBzaG90Lm1heCA9IGF4aXNTbmFwc2hvdC5taW4gKyBsZW5ndGg7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlLm9wdGlvbnMuYW5pbWF0aW9uVHlwZSA9PT0gXCJwb3NpdGlvblwiKSB7XG4gICAgICAgICAgICBlYWNoQXhpcyhmdW5jdGlvbiAoYXhpcykge1xuICAgICAgICAgICAgICAgIHZhciBheGlzU25hcHNob3QgPSBzbmFwc2hvdC5pc1NoYXJlZFxuICAgICAgICAgICAgICAgICAgICA/IHNuYXBzaG90Lm1lYXN1cmVkW2F4aXNdXG4gICAgICAgICAgICAgICAgICAgIDogc25hcHNob3QubGF5b3V0W2F4aXNdO1xuICAgICAgICAgICAgICAgIHZhciBsZW5ndGggPSBjYWxjTGVuZ3RoKGxheW91dF8xW2F4aXNdKTtcbiAgICAgICAgICAgICAgICBheGlzU25hcHNob3QubWF4ID0gYXhpc1NuYXBzaG90Lm1pbiArIGxlbmd0aDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsYXlvdXREZWx0YSA9IGNyZWF0ZURlbHRhKCk7XG4gICAgICAgIGNhbGNCb3hEZWx0YShsYXlvdXREZWx0YSwgbGF5b3V0XzEsIHNuYXBzaG90LmxheW91dCk7XG4gICAgICAgIHZhciB2aXN1YWxEZWx0YSA9IGNyZWF0ZURlbHRhKCk7XG4gICAgICAgIGlmIChzbmFwc2hvdC5pc1NoYXJlZCkge1xuICAgICAgICAgICAgY2FsY0JveERlbHRhKHZpc3VhbERlbHRhLCBub2RlLmFwcGx5VHJhbnNmb3JtKG1lYXN1cmVkTGF5b3V0LCB0cnVlKSwgc25hcHNob3QubWVhc3VyZWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2FsY0JveERlbHRhKHZpc3VhbERlbHRhLCBsYXlvdXRfMSwgc25hcHNob3QubGF5b3V0KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaGFzTGF5b3V0Q2hhbmdlZCA9ICFpc0RlbHRhWmVybyhsYXlvdXREZWx0YSk7XG4gICAgICAgIHZhciBoYXNSZWxhdGl2ZVRhcmdldENoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgaWYgKCFub2RlLnJlc3VtZUZyb20pIHtcbiAgICAgICAgICAgIG5vZGUucmVsYXRpdmVQYXJlbnQgPSBub2RlLmdldENsb3Nlc3RQcm9qZWN0aW5nUGFyZW50KCk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElmIHRoZSByZWxhdGl2ZVBhcmVudCBpcyBpdHNlbGYgcmVzdW1pbmcgZnJvbSBhIGRpZmZlcmVudCBlbGVtZW50IHRoZW5cbiAgICAgICAgICAgICAqIHRoZSByZWxhdGl2ZSBzbmFwc2hvdCBpcyBub3QgcmVsYXZlbnRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKG5vZGUucmVsYXRpdmVQYXJlbnQgJiYgIW5vZGUucmVsYXRpdmVQYXJlbnQucmVzdW1lRnJvbSkge1xuICAgICAgICAgICAgICAgIHZhciBfZiA9IG5vZGUucmVsYXRpdmVQYXJlbnQsIHBhcmVudFNuYXBzaG90ID0gX2Yuc25hcHNob3QsIHBhcmVudExheW91dCA9IF9mLmxheW91dDtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50U25hcHNob3QgJiYgcGFyZW50TGF5b3V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZWxhdGl2ZVNuYXBzaG90ID0gY3JlYXRlQm94KCk7XG4gICAgICAgICAgICAgICAgICAgIGNhbGNSZWxhdGl2ZVBvc2l0aW9uKHJlbGF0aXZlU25hcHNob3QsIHNuYXBzaG90LmxheW91dCwgcGFyZW50U25hcHNob3QubGF5b3V0KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlbGF0aXZlTGF5b3V0ID0gY3JlYXRlQm94KCk7XG4gICAgICAgICAgICAgICAgICAgIGNhbGNSZWxhdGl2ZVBvc2l0aW9uKHJlbGF0aXZlTGF5b3V0LCBsYXlvdXRfMSwgcGFyZW50TGF5b3V0LmFjdHVhbCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghYm94RXF1YWxzKHJlbGF0aXZlU25hcHNob3QsIHJlbGF0aXZlTGF5b3V0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFzUmVsYXRpdmVUYXJnZXRDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBub2RlLm5vdGlmeUxpc3RlbmVycyhcImRpZFVwZGF0ZVwiLCB7XG4gICAgICAgICAgICBsYXlvdXQ6IGxheW91dF8xLFxuICAgICAgICAgICAgc25hcHNob3Q6IHNuYXBzaG90LFxuICAgICAgICAgICAgZGVsdGE6IHZpc3VhbERlbHRhLFxuICAgICAgICAgICAgbGF5b3V0RGVsdGE6IGxheW91dERlbHRhLFxuICAgICAgICAgICAgaGFzTGF5b3V0Q2hhbmdlZDogaGFzTGF5b3V0Q2hhbmdlZCxcbiAgICAgICAgICAgIGhhc1JlbGF0aXZlVGFyZ2V0Q2hhbmdlZDogaGFzUmVsYXRpdmVUYXJnZXRDaGFuZ2VkLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZS5pc0xlYWQoKSkge1xuICAgICAgICAoX2QgPSAoX2MgPSBub2RlLm9wdGlvbnMpLm9uRXhpdENvbXBsZXRlKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuY2FsbChfYyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsZWFyaW5nIHRyYW5zaXRpb25cbiAgICAgKiBUT0RPOiBJbnZlc3RpZ2F0ZSB3aHkgdGhpcyB0cmFuc2l0aW9uIGlzIGJlaW5nIHBhc3NlZCBpbiBhcyB7dHlwZTogZmFsc2UgfSBmcm9tIEZyYW1lclxuICAgICAqIGFuZCB3aHkgd2UgbmVlZCBpdCBhdCBhbGxcbiAgICAgKi9cbiAgICBub2RlLm9wdGlvbnMudHJhbnNpdGlvbiA9IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGNsZWFyU25hcHNob3Qobm9kZSkge1xuICAgIG5vZGUuY2xlYXJTbmFwc2hvdCgpO1xufVxuZnVuY3Rpb24gY2xlYXJNZWFzdXJlbWVudHMobm9kZSkge1xuICAgIG5vZGUuY2xlYXJNZWFzdXJlbWVudHMoKTtcbn1cbmZ1bmN0aW9uIHJlc2V0VHJhbnNmb3JtU3R5bGUobm9kZSkge1xuICAgIHZhciB2aXN1YWxFbGVtZW50ID0gbm9kZS5vcHRpb25zLnZpc3VhbEVsZW1lbnQ7XG4gICAgaWYgKHZpc3VhbEVsZW1lbnQgPT09IG51bGwgfHwgdmlzdWFsRWxlbWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmlzdWFsRWxlbWVudC5nZXRQcm9wcygpLm9uQmVmb3JlTGF5b3V0TWVhc3VyZSkge1xuICAgICAgICB2aXN1YWxFbGVtZW50Lm5vdGlmeUJlZm9yZUxheW91dE1lYXN1cmUoKTtcbiAgICB9XG4gICAgbm9kZS5yZXNldFRyYW5zZm9ybSgpO1xufVxuZnVuY3Rpb24gZmluaXNoQW5pbWF0aW9uKG5vZGUpIHtcbiAgICBub2RlLmZpbmlzaEFuaW1hdGlvbigpO1xuICAgIG5vZGUudGFyZ2V0RGVsdGEgPSBub2RlLnJlbGF0aXZlVGFyZ2V0ID0gbm9kZS50YXJnZXQgPSB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiByZXNvbHZlVGFyZ2V0RGVsdGEobm9kZSkge1xuICAgIG5vZGUucmVzb2x2ZVRhcmdldERlbHRhKCk7XG59XG5mdW5jdGlvbiBjYWxjUHJvamVjdGlvbihub2RlKSB7XG4gICAgbm9kZS5jYWxjUHJvamVjdGlvbigpO1xufVxuZnVuY3Rpb24gcmVzZXRSb3RhdGlvbihub2RlKSB7XG4gICAgbm9kZS5yZXNldFJvdGF0aW9uKCk7XG59XG5mdW5jdGlvbiByZW1vdmVMZWFkU25hcHNob3RzKHN0YWNrKSB7XG4gICAgc3RhY2sucmVtb3ZlTGVhZFNuYXBzaG90KCk7XG59XG5mdW5jdGlvbiBtaXhBeGlzRGVsdGEob3V0cHV0LCBkZWx0YSwgcCkge1xuICAgIG91dHB1dC50cmFuc2xhdGUgPSBtaXgoZGVsdGEudHJhbnNsYXRlLCAwLCBwKTtcbiAgICBvdXRwdXQuc2NhbGUgPSBtaXgoZGVsdGEuc2NhbGUsIDEsIHApO1xuICAgIG91dHB1dC5vcmlnaW4gPSBkZWx0YS5vcmlnaW47XG4gICAgb3V0cHV0Lm9yaWdpblBvaW50ID0gZGVsdGEub3JpZ2luUG9pbnQ7XG59XG5mdW5jdGlvbiBtaXhBeGlzKG91dHB1dCwgZnJvbSwgdG8sIHApIHtcbiAgICBvdXRwdXQubWluID0gbWl4KGZyb20ubWluLCB0by5taW4sIHApO1xuICAgIG91dHB1dC5tYXggPSBtaXgoZnJvbS5tYXgsIHRvLm1heCwgcCk7XG59XG5mdW5jdGlvbiBtaXhCb3gob3V0cHV0LCBmcm9tLCB0bywgcCkge1xuICAgIG1peEF4aXMob3V0cHV0LngsIGZyb20ueCwgdG8ueCwgcCk7XG4gICAgbWl4QXhpcyhvdXRwdXQueSwgZnJvbS55LCB0by55LCBwKTtcbn1cbmZ1bmN0aW9uIGhhc09wYWNpdHlDcm9zc2ZhZGUobm9kZSkge1xuICAgIHJldHVybiAobm9kZS5hbmltYXRpb25WYWx1ZXMgJiYgbm9kZS5hbmltYXRpb25WYWx1ZXMub3BhY2l0eUV4aXQgIT09IHVuZGVmaW5lZCk7XG59XG52YXIgZGVmYXVsdExheW91dFRyYW5zaXRpb24gPSB7XG4gICAgZHVyYXRpb246IDAuNDUsXG4gICAgZWFzZTogWzAuNCwgMCwgMC4xLCAxXSxcbn07XG5mdW5jdGlvbiBtb3VudE5vZGVFYXJseShub2RlLCBpZCkge1xuICAgIC8qKlxuICAgICAqIFJhdGhlciB0aGFuIHNlYXJjaGluZyB0aGUgRE9NIGZyb20gZG9jdW1lbnQgd2UgY2FuIHNlYXJjaCB0aGVcbiAgICAgKiBwYXRoIGZvciB0aGUgZGVlcGVzdCBtb3VudGVkIGFuY2VzdG9yIGFuZCBzZWFyY2ggZnJvbSB0aGVyZVxuICAgICAqL1xuICAgIHZhciBzZWFyY2hOb2RlID0gbm9kZS5yb290O1xuICAgIGZvciAodmFyIGkgPSBub2RlLnBhdGgubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgaWYgKEJvb2xlYW4obm9kZS5wYXRoW2ldLmluc3RhbmNlKSkge1xuICAgICAgICAgICAgc2VhcmNoTm9kZSA9IG5vZGUucGF0aFtpXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHZhciBzZWFyY2hFbGVtZW50ID0gc2VhcmNoTm9kZSAmJiBzZWFyY2hOb2RlICE9PSBub2RlLnJvb3QgPyBzZWFyY2hOb2RlLmluc3RhbmNlIDogZG9jdW1lbnQ7XG4gICAgdmFyIGVsZW1lbnQgPSBzZWFyY2hFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoXCJbZGF0YS1wcm9qZWN0aW9uLWlkPVxcXCJcIi5jb25jYXQoaWQsIFwiXFxcIl1cIikpO1xuICAgIGlmIChlbGVtZW50KVxuICAgICAgICBub2RlLm1vdW50KGVsZW1lbnQsIHRydWUpO1xufVxuZnVuY3Rpb24gcm91bmRBeGlzKGF4aXMpIHtcbiAgICBheGlzLm1pbiA9IE1hdGgucm91bmQoYXhpcy5taW4pO1xuICAgIGF4aXMubWF4ID0gTWF0aC5yb3VuZChheGlzLm1heCk7XG59XG5mdW5jdGlvbiByb3VuZEJveChib3gpIHtcbiAgICByb3VuZEF4aXMoYm94LngpO1xuICAgIHJvdW5kQXhpcyhib3gueSk7XG59XG5cbmV4cG9ydCB7IGNyZWF0ZVByb2plY3Rpb25Ob2RlLCBtaXhBeGlzLCBtaXhBeGlzRGVsdGEsIG1peEJveCB9O1xuIiwiaW1wb3J0IHsgY3JlYXRlUHJvamVjdGlvbk5vZGUgfSBmcm9tICcuL2NyZWF0ZS1wcm9qZWN0aW9uLW5vZGUubWpzJztcbmltcG9ydCB7IGFkZERvbUV2ZW50IH0gZnJvbSAnLi4vLi4vZXZlbnRzL3VzZS1kb20tZXZlbnQubWpzJztcblxudmFyIERvY3VtZW50UHJvamVjdGlvbk5vZGUgPSBjcmVhdGVQcm9qZWN0aW9uTm9kZSh7XG4gICAgYXR0YWNoUmVzaXplTGlzdGVuZXI6IGZ1bmN0aW9uIChyZWYsIG5vdGlmeSkgeyByZXR1cm4gYWRkRG9tRXZlbnQocmVmLCBcInJlc2l6ZVwiLCBub3RpZnkpOyB9LFxuICAgIG1lYXN1cmVTY3JvbGw6IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7XG4gICAgICAgIHg6IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0IHx8IGRvY3VtZW50LmJvZHkuc2Nyb2xsTGVmdCxcbiAgICAgICAgeTogZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCB8fCBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcCxcbiAgICB9KTsgfSxcbiAgICBjaGVja0lzU2Nyb2xsUm9vdDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJ1ZTsgfSxcbn0pO1xuXG5leHBvcnQgeyBEb2N1bWVudFByb2plY3Rpb25Ob2RlIH07XG4iLCJpbXBvcnQgeyBjcmVhdGVQcm9qZWN0aW9uTm9kZSB9IGZyb20gJy4vY3JlYXRlLXByb2plY3Rpb24tbm9kZS5tanMnO1xuaW1wb3J0IHsgRG9jdW1lbnRQcm9qZWN0aW9uTm9kZSB9IGZyb20gJy4vRG9jdW1lbnRQcm9qZWN0aW9uTm9kZS5tanMnO1xuXG52YXIgcm9vdFByb2plY3Rpb25Ob2RlID0ge1xuICAgIGN1cnJlbnQ6IHVuZGVmaW5lZCxcbn07XG52YXIgSFRNTFByb2plY3Rpb25Ob2RlID0gY3JlYXRlUHJvamVjdGlvbk5vZGUoe1xuICAgIG1lYXN1cmVTY3JvbGw6IGZ1bmN0aW9uIChpbnN0YW5jZSkgeyByZXR1cm4gKHtcbiAgICAgICAgeDogaW5zdGFuY2Uuc2Nyb2xsTGVmdCxcbiAgICAgICAgeTogaW5zdGFuY2Uuc2Nyb2xsVG9wLFxuICAgIH0pOyB9LFxuICAgIGRlZmF1bHRQYXJlbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFyb290UHJvamVjdGlvbk5vZGUuY3VycmVudCkge1xuICAgICAgICAgICAgdmFyIGRvY3VtZW50Tm9kZSA9IG5ldyBEb2N1bWVudFByb2plY3Rpb25Ob2RlKDAsIHt9KTtcbiAgICAgICAgICAgIGRvY3VtZW50Tm9kZS5tb3VudCh3aW5kb3cpO1xuICAgICAgICAgICAgZG9jdW1lbnROb2RlLnNldE9wdGlvbnMoeyBsYXlvdXRTY3JvbGw6IHRydWUgfSk7XG4gICAgICAgICAgICByb290UHJvamVjdGlvbk5vZGUuY3VycmVudCA9IGRvY3VtZW50Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcm9vdFByb2plY3Rpb25Ob2RlLmN1cnJlbnQ7XG4gICAgfSxcbiAgICByZXNldFRyYW5zZm9ybTogZnVuY3Rpb24gKGluc3RhbmNlLCB2YWx1ZSkge1xuICAgICAgICBpbnN0YW5jZS5zdHlsZS50cmFuc2Zvcm0gPSB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdm9pZCAwID8gdmFsdWUgOiBcIm5vbmVcIjtcbiAgICB9LFxuICAgIGNoZWNrSXNTY3JvbGxSb290OiBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4od2luZG93LmdldENvbXB1dGVkU3R5bGUoaW5zdGFuY2UpLnBvc2l0aW9uID09PSBcImZpeGVkXCIpO1xuICAgIH0sXG59KTtcblxuZXhwb3J0IHsgSFRNTFByb2plY3Rpb25Ob2RlLCByb290UHJvamVjdGlvbk5vZGUgfTtcbiIsImltcG9ydCB7IF9fYXNzaWduIH0gZnJvbSAndHNsaWInO1xuaW1wb3J0IHsgY3JlYXRlTW90aW9uQ29tcG9uZW50IH0gZnJvbSAnLi4vLi4vbW90aW9uL2luZGV4Lm1qcyc7XG5pbXBvcnQgeyBjcmVhdGVNb3Rpb25Qcm94eSB9IGZyb20gJy4vbW90aW9uLXByb3h5Lm1qcyc7XG5pbXBvcnQgeyBjcmVhdGVEb21Nb3Rpb25Db25maWcgfSBmcm9tICcuL3V0aWxzL2NyZWF0ZS1jb25maWcubWpzJztcbmltcG9ydCB7IGdlc3R1cmVBbmltYXRpb25zIH0gZnJvbSAnLi4vLi4vbW90aW9uL2ZlYXR1cmVzL2dlc3R1cmVzLm1qcyc7XG5pbXBvcnQgeyBhbmltYXRpb25zIH0gZnJvbSAnLi4vLi4vbW90aW9uL2ZlYXR1cmVzL2FuaW1hdGlvbnMubWpzJztcbmltcG9ydCB7IGRyYWcgfSBmcm9tICcuLi8uLi9tb3Rpb24vZmVhdHVyZXMvZHJhZy5tanMnO1xuaW1wb3J0IHsgY3JlYXRlRG9tVmlzdWFsRWxlbWVudCB9IGZyb20gJy4vY3JlYXRlLXZpc3VhbC1lbGVtZW50Lm1qcyc7XG5pbXBvcnQgeyBsYXlvdXRGZWF0dXJlcyB9IGZyb20gJy4uLy4uL21vdGlvbi9mZWF0dXJlcy9sYXlvdXQvaW5kZXgubWpzJztcbmltcG9ydCB7IEhUTUxQcm9qZWN0aW9uTm9kZSB9IGZyb20gJy4uLy4uL3Byb2plY3Rpb24vbm9kZS9IVE1MUHJvamVjdGlvbk5vZGUubWpzJztcblxudmFyIGZlYXR1cmVCdW5kbGUgPSBfX2Fzc2lnbihfX2Fzc2lnbihfX2Fzc2lnbihfX2Fzc2lnbih7fSwgYW5pbWF0aW9ucyksIGdlc3R1cmVBbmltYXRpb25zKSwgZHJhZyksIGxheW91dEZlYXR1cmVzKTtcbi8qKlxuICogSFRNTCAmIFNWRyBjb21wb25lbnRzLCBvcHRpbWlzZWQgZm9yIHVzZSB3aXRoIGdlc3R1cmVzIGFuZCBhbmltYXRpb24uIFRoZXNlIGNhbiBiZSB1c2VkIGFzXG4gKiBkcm9wLWluIHJlcGxhY2VtZW50cyBmb3IgYW55IEhUTUwgJiBTVkcgY29tcG9uZW50LCBhbGwgQ1NTICYgU1ZHIHByb3BlcnRpZXMgYXJlIHN1cHBvcnRlZC5cbiAqXG4gKiBAcHVibGljXG4gKi9cbnZhciBtb3Rpb24gPSAvKkBfX1BVUkVfXyovIGNyZWF0ZU1vdGlvblByb3h5KGZ1bmN0aW9uIChDb21wb25lbnQsIGNvbmZpZykge1xuICAgIHJldHVybiBjcmVhdGVEb21Nb3Rpb25Db25maWcoQ29tcG9uZW50LCBjb25maWcsIGZlYXR1cmVCdW5kbGUsIGNyZWF0ZURvbVZpc3VhbEVsZW1lbnQsIEhUTUxQcm9qZWN0aW9uTm9kZSk7XG59KTtcbi8qKlxuICogQ3JlYXRlIGEgRE9NIGBtb3Rpb25gIGNvbXBvbmVudCB3aXRoIHRoZSBwcm92aWRlZCBzdHJpbmcuIFRoaXMgaXMgcHJpbWFyaWx5IGludGVuZGVkXG4gKiBhcyBhIGZ1bGwgYWx0ZXJuYXRpdmUgdG8gYG1vdGlvbmAgZm9yIGNvbnN1bWVycyB3aG8gaGF2ZSB0byBzdXBwb3J0IGVudmlyb25tZW50cyB0aGF0IGRvbid0XG4gKiBzdXBwb3J0IGBQcm94eWAuXG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogaW1wb3J0IHsgY3JlYXRlRG9tTW90aW9uQ29tcG9uZW50IH0gZnJvbSBcImZyYW1lci1tb3Rpb25cIlxuICpcbiAqIGNvbnN0IG1vdGlvbiA9IHtcbiAqICAgZGl2OiBjcmVhdGVEb21Nb3Rpb25Db21wb25lbnQoJ2RpdicpXG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZURvbU1vdGlvbkNvbXBvbmVudChrZXkpIHtcbiAgICByZXR1cm4gY3JlYXRlTW90aW9uQ29tcG9uZW50KGNyZWF0ZURvbU1vdGlvbkNvbmZpZyhrZXksIHsgZm9yd2FyZE1vdGlvblByb3BzOiBmYWxzZSB9LCBmZWF0dXJlQnVuZGxlLCBjcmVhdGVEb21WaXN1YWxFbGVtZW50LCBIVE1MUHJvamVjdGlvbk5vZGUpKTtcbn1cblxuZXhwb3J0IHsgY3JlYXRlRG9tTW90aW9uQ29tcG9uZW50LCBtb3Rpb24gfTtcbiIsImltcG9ydCB7IGNyZWF0ZU1vdGlvblByb3h5IH0gZnJvbSAnLi9tb3Rpb24tcHJveHkubWpzJztcbmltcG9ydCB7IGNyZWF0ZURvbU1vdGlvbkNvbmZpZyB9IGZyb20gJy4vdXRpbHMvY3JlYXRlLWNvbmZpZy5tanMnO1xuXG4vKipcbiAqIEBwdWJsaWNcbiAqL1xudmFyIG0gPSBjcmVhdGVNb3Rpb25Qcm94eShjcmVhdGVEb21Nb3Rpb25Db25maWcpO1xuXG5leHBvcnQgeyBtIH07XG4iLCJpbXBvcnQgeyB1c2VSZWYgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0IH0gZnJvbSAnLi91c2UtaXNvbW9ycGhpYy1lZmZlY3QubWpzJztcblxuZnVuY3Rpb24gdXNlSXNNb3VudGVkKCkge1xuICAgIHZhciBpc01vdW50ZWQgPSB1c2VSZWYoZmFsc2UpO1xuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpc01vdW50ZWQuY3VycmVudCA9IHRydWU7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpc01vdW50ZWQuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICB9O1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gaXNNb3VudGVkO1xufVxuXG5leHBvcnQgeyB1c2VJc01vdW50ZWQgfTtcbiIsImltcG9ydCB7IF9fcmVhZCB9IGZyb20gJ3RzbGliJztcbmltcG9ydCBzeW5jIGZyb20gJ2ZyYW1lc3luYyc7XG5pbXBvcnQgeyB1c2VTdGF0ZSwgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VJc01vdW50ZWQgfSBmcm9tICcuL3VzZS1pcy1tb3VudGVkLm1qcyc7XG5cbmZ1bmN0aW9uIHVzZUZvcmNlVXBkYXRlKCkge1xuICAgIHZhciBpc01vdW50ZWQgPSB1c2VJc01vdW50ZWQoKTtcbiAgICB2YXIgX2EgPSBfX3JlYWQodXNlU3RhdGUoMCksIDIpLCBmb3JjZWRSZW5kZXJDb3VudCA9IF9hWzBdLCBzZXRGb3JjZWRSZW5kZXJDb3VudCA9IF9hWzFdO1xuICAgIHZhciBmb3JjZVJlbmRlciA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaXNNb3VudGVkLmN1cnJlbnQgJiYgc2V0Rm9yY2VkUmVuZGVyQ291bnQoZm9yY2VkUmVuZGVyQ291bnQgKyAxKTtcbiAgICB9LCBbZm9yY2VkUmVuZGVyQ291bnRdKTtcbiAgICAvKipcbiAgICAgKiBEZWZlciB0aGlzIHRvIHRoZSBlbmQgb2YgdGhlIG5leHQgYW5pbWF0aW9uIGZyYW1lIGluIGNhc2UgdGhlcmUgYXJlIG11bHRpcGxlXG4gICAgICogc3luY2hyb25vdXMgY2FsbHMuXG4gICAgICovXG4gICAgdmFyIGRlZmVycmVkRm9yY2VSZW5kZXIgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7IHJldHVybiBzeW5jLnBvc3RSZW5kZXIoZm9yY2VSZW5kZXIpOyB9LCBbZm9yY2VSZW5kZXJdKTtcbiAgICByZXR1cm4gW2RlZmVycmVkRm9yY2VSZW5kZXIsIGZvcmNlZFJlbmRlckNvdW50XTtcbn1cblxuZXhwb3J0IHsgdXNlRm9yY2VVcGRhdGUgfTtcbiIsImltcG9ydCB7IF9fdmFsdWVzIH0gZnJvbSAndHNsaWInO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlTWVtbyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IFByZXNlbmNlQ29udGV4dCB9IGZyb20gJy4uLy4uL2NvbnRleHQvUHJlc2VuY2VDb250ZXh0Lm1qcyc7XG5pbXBvcnQgeyB1c2VDb25zdGFudCB9IGZyb20gJy4uLy4uL3V0aWxzL3VzZS1jb25zdGFudC5tanMnO1xuaW1wb3J0IHsgdXNlSWQgfSBmcm9tICcuLi8uLi91dGlscy91c2UtaWQubWpzJztcblxudmFyIFByZXNlbmNlQ2hpbGQgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBfYS5jaGlsZHJlbiwgaW5pdGlhbCA9IF9hLmluaXRpYWwsIGlzUHJlc2VudCA9IF9hLmlzUHJlc2VudCwgb25FeGl0Q29tcGxldGUgPSBfYS5vbkV4aXRDb21wbGV0ZSwgY3VzdG9tID0gX2EuY3VzdG9tLCBwcmVzZW5jZUFmZmVjdHNMYXlvdXQgPSBfYS5wcmVzZW5jZUFmZmVjdHNMYXlvdXQ7XG4gICAgdmFyIHByZXNlbmNlQ2hpbGRyZW4gPSB1c2VDb25zdGFudChuZXdDaGlsZHJlbk1hcCk7XG4gICAgdmFyIGlkID0gdXNlSWQoKTtcbiAgICB2YXIgY29udGV4dCA9IHVzZU1lbW8oZnVuY3Rpb24gKCkgeyByZXR1cm4gKHtcbiAgICAgICAgaWQ6IGlkLFxuICAgICAgICBpbml0aWFsOiBpbml0aWFsLFxuICAgICAgICBpc1ByZXNlbnQ6IGlzUHJlc2VudCxcbiAgICAgICAgY3VzdG9tOiBjdXN0b20sXG4gICAgICAgIG9uRXhpdENvbXBsZXRlOiBmdW5jdGlvbiAoY2hpbGRJZCkge1xuICAgICAgICAgICAgdmFyIGVfMSwgX2E7XG4gICAgICAgICAgICBwcmVzZW5jZUNoaWxkcmVuLnNldChjaGlsZElkLCB0cnVlKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2IgPSBfX3ZhbHVlcyhwcmVzZW5jZUNoaWxkcmVuLnZhbHVlcygpKSwgX2MgPSBfYi5uZXh0KCk7ICFfYy5kb25lOyBfYyA9IF9iLm5leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaXNDb21wbGV0ZSA9IF9jLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzQ29tcGxldGUpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47IC8vIGNhbiBzdG9wIHNlYXJjaGluZyB3aGVuIGFueSBpcyBpbmNvbXBsZXRlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfYyAmJiAhX2MuZG9uZSAmJiAoX2EgPSBfYi5yZXR1cm4pKSBfYS5jYWxsKF9iKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb25FeGl0Q29tcGxldGUgPT09IG51bGwgfHwgb25FeGl0Q29tcGxldGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uRXhpdENvbXBsZXRlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlZ2lzdGVyOiBmdW5jdGlvbiAoY2hpbGRJZCkge1xuICAgICAgICAgICAgcHJlc2VuY2VDaGlsZHJlbi5zZXQoY2hpbGRJZCwgZmFsc2UpO1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHByZXNlbmNlQ2hpbGRyZW4uZGVsZXRlKGNoaWxkSWQpOyB9O1xuICAgICAgICB9LFxuICAgIH0pOyB9LCBcbiAgICAvKipcbiAgICAgKiBJZiB0aGUgcHJlc2VuY2Ugb2YgYSBjaGlsZCBhZmZlY3RzIHRoZSBsYXlvdXQgb2YgdGhlIGNvbXBvbmVudHMgYXJvdW5kIGl0LFxuICAgICAqIHdlIHdhbnQgdG8gbWFrZSBhIG5ldyBjb250ZXh0IHZhbHVlIHRvIGVuc3VyZSB0aGV5IGdldCByZS1yZW5kZXJlZFxuICAgICAqIHNvIHRoZXkgY2FuIGRldGVjdCB0aGF0IGxheW91dCBjaGFuZ2UuXG4gICAgICovXG4gICAgcHJlc2VuY2VBZmZlY3RzTGF5b3V0ID8gdW5kZWZpbmVkIDogW2lzUHJlc2VudF0pO1xuICAgIHVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgICAgICBwcmVzZW5jZUNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKF8sIGtleSkgeyByZXR1cm4gcHJlc2VuY2VDaGlsZHJlbi5zZXQoa2V5LCBmYWxzZSk7IH0pO1xuICAgIH0sIFtpc1ByZXNlbnRdKTtcbiAgICAvKipcbiAgICAgKiBJZiB0aGVyZSdzIG5vIGBtb3Rpb25gIGNvbXBvbmVudHMgdG8gZmlyZSBleGl0IGFuaW1hdGlvbnMsIHdlIHdhbnQgdG8gcmVtb3ZlIHRoaXNcbiAgICAgKiBjb21wb25lbnQgaW1tZWRpYXRlbHkuXG4gICAgICovXG4gICAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgIWlzUHJlc2VudCAmJiAhcHJlc2VuY2VDaGlsZHJlbi5zaXplICYmIChvbkV4aXRDb21wbGV0ZSA9PT0gbnVsbCB8fCBvbkV4aXRDb21wbGV0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25FeGl0Q29tcGxldGUoKSk7XG4gICAgfSwgW2lzUHJlc2VudF0pO1xuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChQcmVzZW5jZUNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IGNvbnRleHQgfSwgY2hpbGRyZW4pKTtcbn07XG5mdW5jdGlvbiBuZXdDaGlsZHJlbk1hcCgpIHtcbiAgICByZXR1cm4gbmV3IE1hcCgpO1xufVxuXG5leHBvcnQgeyBQcmVzZW5jZUNoaWxkIH07XG4iLCJpbXBvcnQgeyBfX3JlYWQsIF9fc3ByZWFkQXJyYXkgfSBmcm9tICd0c2xpYic7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VDb250ZXh0LCB1c2VSZWYsIGNsb25lRWxlbWVudCwgQ2hpbGRyZW4sIGlzVmFsaWRFbGVtZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgZW52IH0gZnJvbSAnLi4vLi4vdXRpbHMvcHJvY2Vzcy5tanMnO1xuaW1wb3J0IHsgdXNlRm9yY2VVcGRhdGUgfSBmcm9tICcuLi8uLi91dGlscy91c2UtZm9yY2UtdXBkYXRlLm1qcyc7XG5pbXBvcnQgeyB1c2VJc01vdW50ZWQgfSBmcm9tICcuLi8uLi91dGlscy91c2UtaXMtbW91bnRlZC5tanMnO1xuaW1wb3J0IHsgUHJlc2VuY2VDaGlsZCB9IGZyb20gJy4vUHJlc2VuY2VDaGlsZC5tanMnO1xuaW1wb3J0IHsgTGF5b3V0R3JvdXBDb250ZXh0IH0gZnJvbSAnLi4vLi4vY29udGV4dC9MYXlvdXRHcm91cENvbnRleHQubWpzJztcbmltcG9ydCB7IHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QgfSBmcm9tICcuLi8uLi91dGlscy91c2UtaXNvbW9ycGhpYy1lZmZlY3QubWpzJztcbmltcG9ydCB7IHVzZVVubW91bnRFZmZlY3QgfSBmcm9tICcuLi8uLi91dGlscy91c2UtdW5tb3VudC1lZmZlY3QubWpzJztcblxudmFyIGdldENoaWxkS2V5ID0gZnVuY3Rpb24gKGNoaWxkKSB7IHJldHVybiBjaGlsZC5rZXkgfHwgXCJcIjsgfTtcbmZ1bmN0aW9uIHVwZGF0ZUNoaWxkTG9va3VwKGNoaWxkcmVuLCBhbGxDaGlsZHJlbikge1xuICAgIGNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIHZhciBrZXkgPSBnZXRDaGlsZEtleShjaGlsZCk7XG4gICAgICAgIGFsbENoaWxkcmVuLnNldChrZXksIGNoaWxkKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIG9ubHlFbGVtZW50cyhjaGlsZHJlbikge1xuICAgIHZhciBmaWx0ZXJlZCA9IFtdO1xuICAgIC8vIFdlIHVzZSBmb3JFYWNoIGhlcmUgaW5zdGVhZCBvZiBtYXAgYXMgbWFwIG11dGF0ZXMgdGhlIGNvbXBvbmVudCBrZXkgYnkgcHJlcHJlbmRpbmcgYC4kYFxuICAgIENoaWxkcmVuLmZvckVhY2goY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICBpZiAoaXNWYWxpZEVsZW1lbnQoY2hpbGQpKVxuICAgICAgICAgICAgZmlsdGVyZWQucHVzaChjaGlsZCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGZpbHRlcmVkO1xufVxuLyoqXG4gKiBgQW5pbWF0ZVByZXNlbmNlYCBlbmFibGVzIHRoZSBhbmltYXRpb24gb2YgY29tcG9uZW50cyB0aGF0IGhhdmUgYmVlbiByZW1vdmVkIGZyb20gdGhlIHRyZWUuXG4gKlxuICogV2hlbiBhZGRpbmcvcmVtb3ZpbmcgbW9yZSB0aGFuIGEgc2luZ2xlIGNoaWxkLCBldmVyeSBjaGlsZCAqKm11c3QqKiBiZSBnaXZlbiBhIHVuaXF1ZSBga2V5YCBwcm9wLlxuICpcbiAqIEFueSBgbW90aW9uYCBjb21wb25lbnRzIHRoYXQgaGF2ZSBhbiBgZXhpdGAgcHJvcGVydHkgZGVmaW5lZCB3aWxsIGFuaW1hdGUgb3V0IHdoZW4gcmVtb3ZlZCBmcm9tXG4gKiB0aGUgdHJlZS5cbiAqXG4gKiBgYGBqc3hcbiAqIGltcG9ydCB7IG1vdGlvbiwgQW5pbWF0ZVByZXNlbmNlIH0gZnJvbSAnZnJhbWVyLW1vdGlvbidcbiAqXG4gKiBleHBvcnQgY29uc3QgSXRlbXMgPSAoeyBpdGVtcyB9KSA9PiAoXG4gKiAgIDxBbmltYXRlUHJlc2VuY2U+XG4gKiAgICAge2l0ZW1zLm1hcChpdGVtID0+IChcbiAqICAgICAgIDxtb3Rpb24uZGl2XG4gKiAgICAgICAgIGtleT17aXRlbS5pZH1cbiAqICAgICAgICAgaW5pdGlhbD17eyBvcGFjaXR5OiAwIH19XG4gKiAgICAgICAgIGFuaW1hdGU9e3sgb3BhY2l0eTogMSB9fVxuICogICAgICAgICBleGl0PXt7IG9wYWNpdHk6IDAgfX1cbiAqICAgICAgIC8+XG4gKiAgICAgKSl9XG4gKiAgIDwvQW5pbWF0ZVByZXNlbmNlPlxuICogKVxuICogYGBgXG4gKlxuICogWW91IGNhbiBzZXF1ZW5jZSBleGl0IGFuaW1hdGlvbnMgdGhyb3VnaG91dCBhIHRyZWUgdXNpbmcgdmFyaWFudHMuXG4gKlxuICogSWYgYSBjaGlsZCBjb250YWlucyBtdWx0aXBsZSBgbW90aW9uYCBjb21wb25lbnRzIHdpdGggYGV4aXRgIHByb3BzLCBpdCB3aWxsIG9ubHkgdW5tb3VudCB0aGUgY2hpbGRcbiAqIG9uY2UgYWxsIGBtb3Rpb25gIGNvbXBvbmVudHMgaGF2ZSBmaW5pc2hlZCBhbmltYXRpbmcgb3V0LiBMaWtld2lzZSwgYW55IGNvbXBvbmVudHMgdXNpbmdcbiAqIGB1c2VQcmVzZW5jZWAgYWxsIG5lZWQgdG8gY2FsbCBgc2FmZVRvUmVtb3ZlYC5cbiAqXG4gKiBAcHVibGljXG4gKi9cbnZhciBBbmltYXRlUHJlc2VuY2UgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBfYS5jaGlsZHJlbiwgY3VzdG9tID0gX2EuY3VzdG9tLCBfYiA9IF9hLmluaXRpYWwsIGluaXRpYWwgPSBfYiA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9iLCBvbkV4aXRDb21wbGV0ZSA9IF9hLm9uRXhpdENvbXBsZXRlLCBleGl0QmVmb3JlRW50ZXIgPSBfYS5leGl0QmVmb3JlRW50ZXIsIF9jID0gX2EucHJlc2VuY2VBZmZlY3RzTGF5b3V0LCBwcmVzZW5jZUFmZmVjdHNMYXlvdXQgPSBfYyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9jO1xuICAgIC8vIFdlIHdhbnQgdG8gZm9yY2UgYSByZS1yZW5kZXIgb25jZSBhbGwgZXhpdGluZyBhbmltYXRpb25zIGhhdmUgZmluaXNoZWQuIFdlXG4gICAgLy8gZWl0aGVyIHVzZSBhIGxvY2FsIGZvcmNlUmVuZGVyIGZ1bmN0aW9uLCBvciBvbmUgZnJvbSBhIHBhcmVudCBjb250ZXh0IGlmIGl0IGV4aXN0cy5cbiAgICB2YXIgX2QgPSBfX3JlYWQodXNlRm9yY2VVcGRhdGUoKSwgMSksIGZvcmNlUmVuZGVyID0gX2RbMF07XG4gICAgdmFyIGZvcmNlUmVuZGVyTGF5b3V0R3JvdXAgPSB1c2VDb250ZXh0KExheW91dEdyb3VwQ29udGV4dCkuZm9yY2VSZW5kZXI7XG4gICAgaWYgKGZvcmNlUmVuZGVyTGF5b3V0R3JvdXApXG4gICAgICAgIGZvcmNlUmVuZGVyID0gZm9yY2VSZW5kZXJMYXlvdXRHcm91cDtcbiAgICB2YXIgaXNNb3VudGVkID0gdXNlSXNNb3VudGVkKCk7XG4gICAgLy8gRmlsdGVyIG91dCBhbnkgY2hpbGRyZW4gdGhhdCBhcmVuJ3QgUmVhY3RFbGVtZW50cy4gV2UgY2FuIG9ubHkgdHJhY2sgUmVhY3RFbGVtZW50cyB3aXRoIGEgcHJvcHMua2V5XG4gICAgdmFyIGZpbHRlcmVkQ2hpbGRyZW4gPSBvbmx5RWxlbWVudHMoY2hpbGRyZW4pO1xuICAgIHZhciBjaGlsZHJlblRvUmVuZGVyID0gZmlsdGVyZWRDaGlsZHJlbjtcbiAgICB2YXIgZXhpdGluZyA9IG5ldyBTZXQoKTtcbiAgICAvLyBLZWVwIGEgbGl2aW5nIHJlY29yZCBvZiB0aGUgY2hpbGRyZW4gd2UncmUgYWN0dWFsbHkgcmVuZGVyaW5nIHNvIHdlXG4gICAgLy8gY2FuIGRpZmYgdG8gZmlndXJlIG91dCB3aGljaCBhcmUgZW50ZXJpbmcgYW5kIGV4aXRpbmdcbiAgICB2YXIgcHJlc2VudENoaWxkcmVuID0gdXNlUmVmKGNoaWxkcmVuVG9SZW5kZXIpO1xuICAgIC8vIEEgbG9va3VwIHRhYmxlIHRvIHF1aWNrbHkgcmVmZXJlbmNlIGNvbXBvbmVudHMgYnkga2V5XG4gICAgdmFyIGFsbENoaWxkcmVuID0gdXNlUmVmKG5ldyBNYXAoKSkuY3VycmVudDtcbiAgICAvLyBJZiB0aGlzIGlzIHRoZSBpbml0aWFsIGNvbXBvbmVudCByZW5kZXIsIGp1c3QgZGVhbCB3aXRoIGxvZ2ljIHN1cnJvdW5kaW5nIHdoZXRoZXJcbiAgICAvLyB3ZSBwbGF5IG9uTW91bnQgYW5pbWF0aW9ucyBvciBub3QuXG4gICAgdmFyIGlzSW5pdGlhbFJlbmRlciA9IHVzZVJlZih0cnVlKTtcbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaXNJbml0aWFsUmVuZGVyLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgdXBkYXRlQ2hpbGRMb29rdXAoZmlsdGVyZWRDaGlsZHJlbiwgYWxsQ2hpbGRyZW4pO1xuICAgICAgICBwcmVzZW50Q2hpbGRyZW4uY3VycmVudCA9IGNoaWxkcmVuVG9SZW5kZXI7XG4gICAgfSk7XG4gICAgdXNlVW5tb3VudEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlzSW5pdGlhbFJlbmRlci5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgYWxsQ2hpbGRyZW4uY2xlYXIoKTtcbiAgICAgICAgZXhpdGluZy5jbGVhcigpO1xuICAgIH0pO1xuICAgIGlmIChpc0luaXRpYWxSZW5kZXIuY3VycmVudCkge1xuICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIGNoaWxkcmVuVG9SZW5kZXIubWFwKGZ1bmN0aW9uIChjaGlsZCkgeyByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoUHJlc2VuY2VDaGlsZCwgeyBrZXk6IGdldENoaWxkS2V5KGNoaWxkKSwgaXNQcmVzZW50OiB0cnVlLCBpbml0aWFsOiBpbml0aWFsID8gdW5kZWZpbmVkIDogZmFsc2UsIHByZXNlbmNlQWZmZWN0c0xheW91dDogcHJlc2VuY2VBZmZlY3RzTGF5b3V0IH0sIGNoaWxkKSk7IH0pKSk7XG4gICAgfVxuICAgIC8vIElmIHRoaXMgaXMgYSBzdWJzZXF1ZW50IHJlbmRlciwgZGVhbCB3aXRoIGVudGVyaW5nIGFuZCBleGl0aW5nIGNoaWxkcmVuXG4gICAgY2hpbGRyZW5Ub1JlbmRlciA9IF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChjaGlsZHJlblRvUmVuZGVyKSwgZmFsc2UpO1xuICAgIC8vIERpZmYgdGhlIGtleXMgb2YgdGhlIGN1cnJlbnRseS1wcmVzZW50IGFuZCB0YXJnZXQgY2hpbGRyZW4gdG8gdXBkYXRlIG91clxuICAgIC8vIGV4aXRpbmcgbGlzdC5cbiAgICB2YXIgcHJlc2VudEtleXMgPSBwcmVzZW50Q2hpbGRyZW4uY3VycmVudC5tYXAoZ2V0Q2hpbGRLZXkpO1xuICAgIHZhciB0YXJnZXRLZXlzID0gZmlsdGVyZWRDaGlsZHJlbi5tYXAoZ2V0Q2hpbGRLZXkpO1xuICAgIC8vIERpZmYgdGhlIHByZXNlbnQgY2hpbGRyZW4gd2l0aCBvdXIgdGFyZ2V0IGNoaWxkcmVuIGFuZCBtYXJrIHRob3NlIHRoYXQgYXJlIGV4aXRpbmdcbiAgICB2YXIgbnVtUHJlc2VudCA9IHByZXNlbnRLZXlzLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVByZXNlbnQ7IGkrKykge1xuICAgICAgICB2YXIga2V5ID0gcHJlc2VudEtleXNbaV07XG4gICAgICAgIGlmICh0YXJnZXRLZXlzLmluZGV4T2Yoa2V5KSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGV4aXRpbmcuYWRkKGtleSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gSWYgd2UgY3VycmVudGx5IGhhdmUgZXhpdGluZyBjaGlsZHJlbiwgYW5kIHdlJ3JlIGRlZmVycmluZyByZW5kZXJpbmcgaW5jb21pbmcgY2hpbGRyZW5cbiAgICAvLyB1bnRpbCBhZnRlciBhbGwgY3VycmVudCBjaGlsZHJlbiBoYXZlIGV4aXRpbmcsIGVtcHR5IHRoZSBjaGlsZHJlblRvUmVuZGVyIGFycmF5XG4gICAgaWYgKGV4aXRCZWZvcmVFbnRlciAmJiBleGl0aW5nLnNpemUpIHtcbiAgICAgICAgY2hpbGRyZW5Ub1JlbmRlciA9IFtdO1xuICAgIH1cbiAgICAvLyBMb29wIHRocm91Z2ggYWxsIGN1cnJlbnRseSBleGl0aW5nIGNvbXBvbmVudHMgYW5kIGNsb25lIHRoZW0gdG8gb3ZlcndyaXRlIGBhbmltYXRlYFxuICAgIC8vIHdpdGggYW55IGBleGl0YCBwcm9wIHRoZXkgbWlnaHQgaGF2ZSBkZWZpbmVkLlxuICAgIGV4aXRpbmcuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIC8vIElmIHRoaXMgY29tcG9uZW50IGlzIGFjdHVhbGx5IGVudGVyaW5nIGFnYWluLCBlYXJseSByZXR1cm5cbiAgICAgICAgaWYgKHRhcmdldEtleXMuaW5kZXhPZihrZXkpICE9PSAtMSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIGNoaWxkID0gYWxsQ2hpbGRyZW4uZ2V0KGtleSk7XG4gICAgICAgIGlmICghY2hpbGQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciBpbnNlcnRpb25JbmRleCA9IHByZXNlbnRLZXlzLmluZGV4T2Yoa2V5KTtcbiAgICAgICAgdmFyIG9uRXhpdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGFsbENoaWxkcmVuLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgZXhpdGluZy5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGlzIGNoaWxkIGZyb20gdGhlIHByZXNlbnQgY2hpbGRyZW5cbiAgICAgICAgICAgIHZhciByZW1vdmVJbmRleCA9IHByZXNlbnRDaGlsZHJlbi5jdXJyZW50LmZpbmRJbmRleChmdW5jdGlvbiAocHJlc2VudENoaWxkKSB7IHJldHVybiBwcmVzZW50Q2hpbGQua2V5ID09PSBrZXk7IH0pO1xuICAgICAgICAgICAgcHJlc2VudENoaWxkcmVuLmN1cnJlbnQuc3BsaWNlKHJlbW92ZUluZGV4LCAxKTtcbiAgICAgICAgICAgIC8vIERlZmVyIHJlLXJlbmRlcmluZyB1bnRpbCBhbGwgZXhpdGluZyBjaGlsZHJlbiBoYXZlIGluZGVlZCBsZWZ0XG4gICAgICAgICAgICBpZiAoIWV4aXRpbmcuc2l6ZSkge1xuICAgICAgICAgICAgICAgIHByZXNlbnRDaGlsZHJlbi5jdXJyZW50ID0gZmlsdGVyZWRDaGlsZHJlbjtcbiAgICAgICAgICAgICAgICBpZiAoaXNNb3VudGVkLmN1cnJlbnQgPT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgZm9yY2VSZW5kZXIoKTtcbiAgICAgICAgICAgICAgICBvbkV4aXRDb21wbGV0ZSAmJiBvbkV4aXRDb21wbGV0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjaGlsZHJlblRvUmVuZGVyLnNwbGljZShpbnNlcnRpb25JbmRleCwgMCwgUmVhY3QuY3JlYXRlRWxlbWVudChQcmVzZW5jZUNoaWxkLCB7IGtleTogZ2V0Q2hpbGRLZXkoY2hpbGQpLCBpc1ByZXNlbnQ6IGZhbHNlLCBvbkV4aXRDb21wbGV0ZTogb25FeGl0LCBjdXN0b206IGN1c3RvbSwgcHJlc2VuY2VBZmZlY3RzTGF5b3V0OiBwcmVzZW5jZUFmZmVjdHNMYXlvdXQgfSwgY2hpbGQpKTtcbiAgICB9KTtcbiAgICAvLyBBZGQgYE1vdGlvbkNvbnRleHRgIGV2ZW4gdG8gY2hpbGRyZW4gdGhhdCBkb24ndCBuZWVkIGl0IHRvIGVuc3VyZSB3ZSdyZSByZW5kZXJpbmdcbiAgICAvLyB0aGUgc2FtZSB0cmVlIGJldHdlZW4gcmVuZGVyc1xuICAgIGNoaWxkcmVuVG9SZW5kZXIgPSBjaGlsZHJlblRvUmVuZGVyLm1hcChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgdmFyIGtleSA9IGNoaWxkLmtleTtcbiAgICAgICAgcmV0dXJuIGV4aXRpbmcuaGFzKGtleSkgPyAoY2hpbGQpIDogKFJlYWN0LmNyZWF0ZUVsZW1lbnQoUHJlc2VuY2VDaGlsZCwgeyBrZXk6IGdldENoaWxkS2V5KGNoaWxkKSwgaXNQcmVzZW50OiB0cnVlLCBwcmVzZW5jZUFmZmVjdHNMYXlvdXQ6IHByZXNlbmNlQWZmZWN0c0xheW91dCB9LCBjaGlsZCkpO1xuICAgIH0pO1xuICAgIGlmIChlbnYgIT09IFwicHJvZHVjdGlvblwiICYmXG4gICAgICAgIGV4aXRCZWZvcmVFbnRlciAmJlxuICAgICAgICBjaGlsZHJlblRvUmVuZGVyLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiWW91J3JlIGF0dGVtcHRpbmcgdG8gYW5pbWF0ZSBtdWx0aXBsZSBjaGlsZHJlbiB3aXRoaW4gQW5pbWF0ZVByZXNlbmNlLCBidXQgaXRzIGV4aXRCZWZvcmVFbnRlciBwcm9wIGlzIHNldCB0byB0cnVlLiBUaGlzIHdpbGwgbGVhZCB0byBvZGQgdmlzdWFsIGJlaGF2aW91ci5cIik7XG4gICAgfVxuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgZXhpdGluZy5zaXplXG4gICAgICAgID8gY2hpbGRyZW5Ub1JlbmRlclxuICAgICAgICA6IGNoaWxkcmVuVG9SZW5kZXIubWFwKGZ1bmN0aW9uIChjaGlsZCkgeyByZXR1cm4gY2xvbmVFbGVtZW50KGNoaWxkKTsgfSkpKTtcbn07XG5cbmV4cG9ydCB7IEFuaW1hdGVQcmVzZW5jZSB9O1xuIiwiaW1wb3J0IHsgY3JlYXRlQ29udGV4dCB9IGZyb20gJ3JlYWN0JztcblxuLyoqXG4gKiBAZGVwcmVjYXRlZFxuICovXG52YXIgRGVwcmVjYXRlZExheW91dEdyb3VwQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQobnVsbCk7XG5cbmV4cG9ydCB7IERlcHJlY2F0ZWRMYXlvdXRHcm91cENvbnRleHQgfTtcbiIsInZhciBub3RpZnkgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIHJldHVybiAhbm9kZS5pc0xheW91dERpcnR5ICYmIG5vZGUud2lsbFVwZGF0ZShmYWxzZSk7XG59O1xuZnVuY3Rpb24gbm9kZUdyb3VwKCkge1xuICAgIHZhciBub2RlcyA9IG5ldyBTZXQoKTtcbiAgICB2YXIgc3Vic2NyaXB0aW9ucyA9IG5ldyBXZWFrTWFwKCk7XG4gICAgdmFyIGRpcnR5QWxsID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbm9kZXMuZm9yRWFjaChub3RpZnkpOyB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIGFkZDogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIG5vZGVzLmFkZChub2RlKTtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbnMuc2V0KG5vZGUsIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcIndpbGxVcGRhdGVcIiwgZGlydHlBbGwpKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgbm9kZXMuZGVsZXRlKG5vZGUpO1xuICAgICAgICAgICAgKF9hID0gc3Vic2NyaXB0aW9ucy5nZXQobm9kZSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYSgpO1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9ucy5kZWxldGUobm9kZSk7XG4gICAgICAgICAgICBkaXJ0eUFsbCgpO1xuICAgICAgICB9LFxuICAgICAgICBkaXJ0eTogZGlydHlBbGwsXG4gICAgfTtcbn1cblxuZXhwb3J0IHsgbm9kZUdyb3VwIH07XG4iLCJpbXBvcnQgeyBfX3JlYWQsIF9fYXNzaWduIH0gZnJvbSAndHNsaWInO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlQ29udGV4dCwgdXNlUmVmLCB1c2VNZW1vIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgTGF5b3V0R3JvdXBDb250ZXh0IH0gZnJvbSAnLi4vLi4vY29udGV4dC9MYXlvdXRHcm91cENvbnRleHQubWpzJztcbmltcG9ydCB7IERlcHJlY2F0ZWRMYXlvdXRHcm91cENvbnRleHQgfSBmcm9tICcuLi8uLi9jb250ZXh0L0RlcHJlY2F0ZWRMYXlvdXRHcm91cENvbnRleHQubWpzJztcbmltcG9ydCB7IHVzZUZvcmNlVXBkYXRlIH0gZnJvbSAnLi4vLi4vdXRpbHMvdXNlLWZvcmNlLXVwZGF0ZS5tanMnO1xuaW1wb3J0IHsgbm9kZUdyb3VwIH0gZnJvbSAnLi4vLi4vcHJvamVjdGlvbi9ub2RlL2dyb3VwLm1qcyc7XG5cbnZhciBzaG91bGRJbmhlcml0R3JvdXAgPSBmdW5jdGlvbiAoaW5oZXJpdCkgeyByZXR1cm4gaW5oZXJpdCA9PT0gdHJ1ZTsgfTtcbnZhciBzaG91bGRJbmhlcml0SWQgPSBmdW5jdGlvbiAoaW5oZXJpdCkge1xuICAgIHJldHVybiBzaG91bGRJbmhlcml0R3JvdXAoaW5oZXJpdCA9PT0gdHJ1ZSkgfHwgaW5oZXJpdCA9PT0gXCJpZFwiO1xufTtcbnZhciBMYXlvdXRHcm91cCA9IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBfYiwgX2M7XG4gICAgdmFyIGNoaWxkcmVuID0gX2EuY2hpbGRyZW4sIGlkID0gX2EuaWQsIGluaGVyaXRJZCA9IF9hLmluaGVyaXRJZCwgX2QgPSBfYS5pbmhlcml0LCBpbmhlcml0ID0gX2QgPT09IHZvaWQgMCA/IHRydWUgOiBfZDtcbiAgICAvLyBNYWludGFpbiBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSB3aXRoIGluaGVyaXRJZCB1bnRpbCA3LjBcbiAgICBpZiAoaW5oZXJpdElkICE9PSB1bmRlZmluZWQpXG4gICAgICAgIGluaGVyaXQgPSBpbmhlcml0SWQ7XG4gICAgdmFyIGxheW91dEdyb3VwQ29udGV4dCA9IHVzZUNvbnRleHQoTGF5b3V0R3JvdXBDb250ZXh0KTtcbiAgICB2YXIgZGVwcmVjYXRlZExheW91dEdyb3VwQ29udGV4dCA9IHVzZUNvbnRleHQoRGVwcmVjYXRlZExheW91dEdyb3VwQ29udGV4dCk7XG4gICAgdmFyIF9lID0gX19yZWFkKHVzZUZvcmNlVXBkYXRlKCksIDIpLCBmb3JjZVJlbmRlciA9IF9lWzBdLCBrZXkgPSBfZVsxXTtcbiAgICB2YXIgY29udGV4dCA9IHVzZVJlZihudWxsKTtcbiAgICB2YXIgdXBzdHJlYW1JZCA9IChfYiA9IGxheW91dEdyb3VwQ29udGV4dC5pZCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZGVwcmVjYXRlZExheW91dEdyb3VwQ29udGV4dDtcbiAgICBpZiAoY29udGV4dC5jdXJyZW50ID09PSBudWxsKSB7XG4gICAgICAgIGlmIChzaG91bGRJbmhlcml0SWQoaW5oZXJpdCkgJiYgdXBzdHJlYW1JZCkge1xuICAgICAgICAgICAgaWQgPSBpZCA/IHVwc3RyZWFtSWQgKyBcIi1cIiArIGlkIDogdXBzdHJlYW1JZDtcbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0LmN1cnJlbnQgPSB7XG4gICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICBncm91cDogc2hvdWxkSW5oZXJpdEdyb3VwKGluaGVyaXQpXG4gICAgICAgICAgICAgICAgPyAoX2MgPSBsYXlvdXRHcm91cENvbnRleHQgPT09IG51bGwgfHwgbGF5b3V0R3JvdXBDb250ZXh0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsYXlvdXRHcm91cENvbnRleHQuZ3JvdXApICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IG5vZGVHcm91cCgpXG4gICAgICAgICAgICAgICAgOiBub2RlR3JvdXAoKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgdmFyIG1lbW9pemVkQ29udGV4dCA9IHVzZU1lbW8oZnVuY3Rpb24gKCkgeyByZXR1cm4gKF9fYXNzaWduKF9fYXNzaWduKHt9LCBjb250ZXh0LmN1cnJlbnQpLCB7IGZvcmNlUmVuZGVyOiBmb3JjZVJlbmRlciB9KSk7IH0sIFtrZXldKTtcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoTGF5b3V0R3JvdXBDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBtZW1vaXplZENvbnRleHQgfSwgY2hpbGRyZW4pKTtcbn07XG5cbmV4cG9ydCB7IExheW91dEdyb3VwIH07XG4iLCJpbXBvcnQgeyB3YXJuaW5nIH0gZnJvbSAnaGV5LWxpc3Rlbic7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VDb25zdGFudCB9IGZyb20gJy4uL3V0aWxzL3VzZS1jb25zdGFudC5tanMnO1xuaW1wb3J0IHsgTGF5b3V0R3JvdXAgfSBmcm9tICcuL0xheW91dEdyb3VwL2luZGV4Lm1qcyc7XG5cbnZhciBpZCA9IDA7XG52YXIgQW5pbWF0ZVNoYXJlZExheW91dCA9IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBjaGlsZHJlbiA9IF9hLmNoaWxkcmVuO1xuICAgIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsIFwiQW5pbWF0ZVNoYXJlZExheW91dCBpcyBkZXByZWNhdGVkOiBodHRwczovL3d3dy5mcmFtZXIuY29tL2RvY3MvZ3VpZGUtdXBncmFkZS8jI3NoYXJlZC1sYXlvdXQtYW5pbWF0aW9uc1wiKTtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KExheW91dEdyb3VwLCB7IGlkOiB1c2VDb25zdGFudChmdW5jdGlvbiAoKSB7IHJldHVybiBcImFzbC1cIi5jb25jYXQoaWQrKyk7IH0pIH0sIGNoaWxkcmVuKSk7XG59O1xuXG5leHBvcnQgeyBBbmltYXRlU2hhcmVkTGF5b3V0IH07XG4iLCJpbXBvcnQgeyBfX3Jlc3QsIF9fYXNzaWduIH0gZnJvbSAndHNsaWInO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlQ29udGV4dCwgdXNlTWVtbyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IE1vdGlvbkNvbmZpZ0NvbnRleHQgfSBmcm9tICcuLi8uLi9jb250ZXh0L01vdGlvbkNvbmZpZ0NvbnRleHQubWpzJztcbmltcG9ydCB7IGxvYWRFeHRlcm5hbElzVmFsaWRQcm9wIH0gZnJvbSAnLi4vLi4vcmVuZGVyL2RvbS91dGlscy9maWx0ZXItcHJvcHMubWpzJztcbmltcG9ydCB7IHVzZUNvbnN0YW50IH0gZnJvbSAnLi4vLi4vdXRpbHMvdXNlLWNvbnN0YW50Lm1qcyc7XG5cbi8qKlxuICogYE1vdGlvbkNvbmZpZ2AgaXMgdXNlZCB0byBzZXQgY29uZmlndXJhdGlvbiBvcHRpb25zIGZvciBhbGwgY2hpbGRyZW4gYG1vdGlvbmAgY29tcG9uZW50cy5cbiAqXG4gKiBgYGBqc3hcbiAqIGltcG9ydCB7IG1vdGlvbiwgTW90aW9uQ29uZmlnIH0gZnJvbSBcImZyYW1lci1tb3Rpb25cIlxuICpcbiAqIGV4cG9ydCBmdW5jdGlvbiBBcHAoKSB7XG4gKiAgIHJldHVybiAoXG4gKiAgICAgPE1vdGlvbkNvbmZpZyB0cmFuc2l0aW9uPXt7IHR5cGU6IFwic3ByaW5nXCIgfX0+XG4gKiAgICAgICA8bW90aW9uLmRpdiBhbmltYXRlPXt7IHg6IDEwMCB9fSAvPlxuICogICAgIDwvTW90aW9uQ29uZmlnPlxuICogICApXG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIE1vdGlvbkNvbmZpZyhfYSkge1xuICAgIHZhciBjaGlsZHJlbiA9IF9hLmNoaWxkcmVuLCBpc1ZhbGlkUHJvcCA9IF9hLmlzVmFsaWRQcm9wLCBjb25maWcgPSBfX3Jlc3QoX2EsIFtcImNoaWxkcmVuXCIsIFwiaXNWYWxpZFByb3BcIl0pO1xuICAgIGlzVmFsaWRQcm9wICYmIGxvYWRFeHRlcm5hbElzVmFsaWRQcm9wKGlzVmFsaWRQcm9wKTtcbiAgICAvKipcbiAgICAgKiBJbmhlcml0IHByb3BzIGZyb20gYW55IHBhcmVudCBNb3Rpb25Db25maWcgY29tcG9uZW50c1xuICAgICAqL1xuICAgIGNvbmZpZyA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCB1c2VDb250ZXh0KE1vdGlvbkNvbmZpZ0NvbnRleHQpKSwgY29uZmlnKTtcbiAgICAvKipcbiAgICAgKiBEb24ndCBhbGxvdyBpc1N0YXRpYyB0byBjaGFuZ2UgYmV0d2VlbiByZW5kZXJzIGFzIGl0IGFmZmVjdHMgaG93IG1hbnkgaG9va3NcbiAgICAgKiBtb3Rpb24gY29tcG9uZW50cyBmaXJlLlxuICAgICAqL1xuICAgIGNvbmZpZy5pc1N0YXRpYyA9IHVzZUNvbnN0YW50KGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbmZpZy5pc1N0YXRpYzsgfSk7XG4gICAgLyoqXG4gICAgICogQ3JlYXRpbmcgYSBuZXcgY29uZmlnIGNvbnRleHQgb2JqZWN0IHdpbGwgcmUtcmVuZGVyIGV2ZXJ5IGBtb3Rpb25gIGNvbXBvbmVudFxuICAgICAqIGV2ZXJ5IHRpbWUgaXQgcmVuZGVycy4gU28gd2Ugb25seSB3YW50IHRvIGNyZWF0ZSBhIG5ldyBvbmUgc3BhcmluZ2x5LlxuICAgICAqL1xuICAgIHZhciBjb250ZXh0ID0gdXNlTWVtbyhmdW5jdGlvbiAoKSB7IHJldHVybiBjb25maWc7IH0sIFtKU09OLnN0cmluZ2lmeShjb25maWcudHJhbnNpdGlvbiksIGNvbmZpZy50cmFuc2Zvcm1QYWdlUG9pbnQsIGNvbmZpZy5yZWR1Y2VkTW90aW9uXSk7XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KE1vdGlvbkNvbmZpZ0NvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IGNvbnRleHQgfSwgY2hpbGRyZW4pKTtcbn1cblxuZXhwb3J0IHsgTW90aW9uQ29uZmlnIH07XG4iLCJpbXBvcnQgeyBfX3JlYWQsIF9fcmVzdCB9IGZyb20gJ3RzbGliJztcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZVN0YXRlLCB1c2VSZWYsIHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IExhenlDb250ZXh0IH0gZnJvbSAnLi4vLi4vY29udGV4dC9MYXp5Q29udGV4dC5tanMnO1xuaW1wb3J0IHsgbG9hZEZlYXR1cmVzIH0gZnJvbSAnLi4vLi4vbW90aW9uL2ZlYXR1cmVzL2RlZmluaXRpb25zLm1qcyc7XG5cbi8qKlxuICogVXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIHRoZSBgbWAgY29tcG9uZW50IHRvIHJlZHVjZSBidW5kbGUgc2l6ZS5cbiAqXG4gKiBgbWAgaXMgYSB2ZXJzaW9uIG9mIHRoZSBgbW90aW9uYCBjb21wb25lbnQgdGhhdCBvbmx5IGxvYWRzIGZ1bmN0aW9uYWxpdHlcbiAqIGNyaXRpY2FsIGZvciB0aGUgaW5pdGlhbCByZW5kZXIuXG4gKlxuICogYExhenlNb3Rpb25gIGNhbiB0aGVuIGJlIHVzZWQgdG8gZWl0aGVyIHN5bmNocm9ub3VzbHkgb3IgYXN5bmNocm9ub3VzbHlcbiAqIGxvYWQgYW5pbWF0aW9uIGFuZCBnZXN0dXJlIHN1cHBvcnQuXG4gKlxuICogYGBganN4XG4gKiAvLyBTeW5jaHJvbm91cyBsb2FkaW5nXG4gKiBpbXBvcnQgeyBMYXp5TW90aW9uLCBtLCBkb21BbmltYXRpb25zIH0gZnJvbSBcImZyYW1lci1tb3Rpb25cIlxuICpcbiAqIGZ1bmN0aW9uIEFwcCgpIHtcbiAqICAgcmV0dXJuIChcbiAqICAgICA8TGF6eU1vdGlvbiBmZWF0dXJlcz17ZG9tQW5pbWF0aW9uc30+XG4gKiAgICAgICA8bS5kaXYgYW5pbWF0ZT17eyBzY2FsZTogMiB9fSAvPlxuICogICAgIDwvTGF6eU1vdGlvbj5cbiAqICAgKVxuICogfVxuICpcbiAqIC8vIEFzeW5jaHJvbm91cyBsb2FkaW5nXG4gKiBpbXBvcnQgeyBMYXp5TW90aW9uLCBtIH0gZnJvbSBcImZyYW1lci1tb3Rpb25cIlxuICpcbiAqIGZ1bmN0aW9uIEFwcCgpIHtcbiAqICAgcmV0dXJuIChcbiAqICAgICA8TGF6eU1vdGlvbiBmZWF0dXJlcz17KCkgPT4gaW1wb3J0KCcuL3BhdGgvdG8vZG9tQW5pbWF0aW9ucycpfT5cbiAqICAgICAgIDxtLmRpdiBhbmltYXRlPXt7IHNjYWxlOiAyIH19IC8+XG4gKiAgICAgPC9MYXp5TW90aW9uPlxuICogICApXG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIExhenlNb3Rpb24oX2EpIHtcbiAgICB2YXIgY2hpbGRyZW4gPSBfYS5jaGlsZHJlbiwgZmVhdHVyZXMgPSBfYS5mZWF0dXJlcywgX2IgPSBfYS5zdHJpY3QsIHN0cmljdCA9IF9iID09PSB2b2lkIDAgPyBmYWxzZSA6IF9iO1xuICAgIHZhciBfYyA9IF9fcmVhZCh1c2VTdGF0ZSghaXNMYXp5QnVuZGxlKGZlYXR1cmVzKSksIDIpLCBzZXRJc0xvYWRlZCA9IF9jWzFdO1xuICAgIHZhciBsb2FkZWRSZW5kZXJlciA9IHVzZVJlZih1bmRlZmluZWQpO1xuICAgIC8qKlxuICAgICAqIElmIHRoaXMgaXMgYSBzeW5jaHJvbm91cyBsb2FkLCBsb2FkIGZlYXR1cmVzIGltbWVkaWF0ZWx5XG4gICAgICovXG4gICAgaWYgKCFpc0xhenlCdW5kbGUoZmVhdHVyZXMpKSB7XG4gICAgICAgIHZhciByZW5kZXJlciA9IGZlYXR1cmVzLnJlbmRlcmVyLCBsb2FkZWRGZWF0dXJlcyA9IF9fcmVzdChmZWF0dXJlcywgW1wicmVuZGVyZXJcIl0pO1xuICAgICAgICBsb2FkZWRSZW5kZXJlci5jdXJyZW50ID0gcmVuZGVyZXI7XG4gICAgICAgIGxvYWRGZWF0dXJlcyhsb2FkZWRGZWF0dXJlcyk7XG4gICAgfVxuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChpc0xhenlCdW5kbGUoZmVhdHVyZXMpKSB7XG4gICAgICAgICAgICBmZWF0dXJlcygpLnRoZW4oZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlbmRlcmVyID0gX2EucmVuZGVyZXIsIGxvYWRlZEZlYXR1cmVzID0gX19yZXN0KF9hLCBbXCJyZW5kZXJlclwiXSk7XG4gICAgICAgICAgICAgICAgbG9hZEZlYXR1cmVzKGxvYWRlZEZlYXR1cmVzKTtcbiAgICAgICAgICAgICAgICBsb2FkZWRSZW5kZXJlci5jdXJyZW50ID0gcmVuZGVyZXI7XG4gICAgICAgICAgICAgICAgc2V0SXNMb2FkZWQodHJ1ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoTGF6eUNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IHsgcmVuZGVyZXI6IGxvYWRlZFJlbmRlcmVyLmN1cnJlbnQsIHN0cmljdDogc3RyaWN0IH0gfSwgY2hpbGRyZW4pKTtcbn1cbmZ1bmN0aW9uIGlzTGF6eUJ1bmRsZShmZWF0dXJlcykge1xuICAgIHJldHVybiB0eXBlb2YgZmVhdHVyZXMgPT09IFwiZnVuY3Rpb25cIjtcbn1cblxuZXhwb3J0IHsgTGF6eU1vdGlvbiB9O1xuIiwiaW1wb3J0IHsgY3JlYXRlQ29udGV4dCB9IGZyb20gJ3JlYWN0JztcblxudmFyIFJlb3JkZXJDb250ZXh0ID0gY3JlYXRlQ29udGV4dChudWxsKTtcblxuZXhwb3J0IHsgUmVvcmRlckNvbnRleHQgfTtcbiIsImltcG9ydCB7IG1peCB9IGZyb20gJ3BvcG1vdGlvbic7XG5pbXBvcnQgeyBtb3ZlSXRlbSB9IGZyb20gJy4uLy4uLy4uL3V0aWxzL2FycmF5Lm1qcyc7XG5cbmZ1bmN0aW9uIGNoZWNrUmVvcmRlcihvcmRlciwgdmFsdWUsIG9mZnNldCwgdmVsb2NpdHkpIHtcbiAgICBpZiAoIXZlbG9jaXR5KVxuICAgICAgICByZXR1cm4gb3JkZXI7XG4gICAgdmFyIGluZGV4ID0gb3JkZXIuZmluZEluZGV4KGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBpdGVtLnZhbHVlID09PSB2YWx1ZTsgfSk7XG4gICAgaWYgKGluZGV4ID09PSAtMSlcbiAgICAgICAgcmV0dXJuIG9yZGVyO1xuICAgIHZhciBuZXh0T2Zmc2V0ID0gdmVsb2NpdHkgPiAwID8gMSA6IC0xO1xuICAgIHZhciBuZXh0SXRlbSA9IG9yZGVyW2luZGV4ICsgbmV4dE9mZnNldF07XG4gICAgaWYgKCFuZXh0SXRlbSlcbiAgICAgICAgcmV0dXJuIG9yZGVyO1xuICAgIHZhciBpdGVtID0gb3JkZXJbaW5kZXhdO1xuICAgIHZhciBuZXh0TGF5b3V0ID0gbmV4dEl0ZW0ubGF5b3V0O1xuICAgIHZhciBuZXh0SXRlbUNlbnRlciA9IG1peChuZXh0TGF5b3V0Lm1pbiwgbmV4dExheW91dC5tYXgsIDAuNSk7XG4gICAgaWYgKChuZXh0T2Zmc2V0ID09PSAxICYmIGl0ZW0ubGF5b3V0Lm1heCArIG9mZnNldCA+IG5leHRJdGVtQ2VudGVyKSB8fFxuICAgICAgICAobmV4dE9mZnNldCA9PT0gLTEgJiYgaXRlbS5sYXlvdXQubWluICsgb2Zmc2V0IDwgbmV4dEl0ZW1DZW50ZXIpKSB7XG4gICAgICAgIHJldHVybiBtb3ZlSXRlbShvcmRlciwgaW5kZXgsIGluZGV4ICsgbmV4dE9mZnNldCk7XG4gICAgfVxuICAgIHJldHVybiBvcmRlcjtcbn1cblxuZXhwb3J0IHsgY2hlY2tSZW9yZGVyIH07XG4iLCJpbXBvcnQgeyBfX3Jlc3QsIF9fYXNzaWduIH0gZnJvbSAndHNsaWInO1xuaW1wb3J0IHsgaW52YXJpYW50IH0gZnJvbSAnaGV5LWxpc3Rlbic7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBmb3J3YXJkUmVmLCB1c2VSZWYsIHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IFJlb3JkZXJDb250ZXh0IH0gZnJvbSAnLi4vLi4vY29udGV4dC9SZW9yZGVyQ29udGV4dC5tanMnO1xuaW1wb3J0IHsgbW90aW9uIH0gZnJvbSAnLi4vLi4vcmVuZGVyL2RvbS9tb3Rpb24ubWpzJztcbmltcG9ydCB7IHVzZUNvbnN0YW50IH0gZnJvbSAnLi4vLi4vdXRpbHMvdXNlLWNvbnN0YW50Lm1qcyc7XG5pbXBvcnQgeyBjaGVja1Jlb3JkZXIgfSBmcm9tICcuL3V0aWxzL2NoZWNrLXJlb3JkZXIubWpzJztcblxuZnVuY3Rpb24gUmVvcmRlckdyb3VwKF9hLCBleHRlcm5hbFJlZikge1xuICAgIHZhciBjaGlsZHJlbiA9IF9hLmNoaWxkcmVuLCBfYiA9IF9hLmFzLCBhcyA9IF9iID09PSB2b2lkIDAgPyBcInVsXCIgOiBfYiwgX2MgPSBfYS5heGlzLCBheGlzID0gX2MgPT09IHZvaWQgMCA/IFwieVwiIDogX2MsIG9uUmVvcmRlciA9IF9hLm9uUmVvcmRlciwgdmFsdWVzID0gX2EudmFsdWVzLCBwcm9wcyA9IF9fcmVzdChfYSwgW1wiY2hpbGRyZW5cIiwgXCJhc1wiLCBcImF4aXNcIiwgXCJvblJlb3JkZXJcIiwgXCJ2YWx1ZXNcIl0pO1xuICAgIHZhciBDb21wb25lbnQgPSB1c2VDb25zdGFudChmdW5jdGlvbiAoKSB7IHJldHVybiBtb3Rpb24oYXMpOyB9KTtcbiAgICB2YXIgb3JkZXIgPSBbXTtcbiAgICB2YXIgaXNSZW9yZGVyaW5nID0gdXNlUmVmKGZhbHNlKTtcbiAgICBpbnZhcmlhbnQoQm9vbGVhbih2YWx1ZXMpLCBcIlJlb3JkZXIuR3JvdXAgbXVzdCBiZSBwcm92aWRlZCBhIHZhbHVlcyBwcm9wXCIpO1xuICAgIHZhciBjb250ZXh0ID0ge1xuICAgICAgICBheGlzOiBheGlzLFxuICAgICAgICByZWdpc3Rlckl0ZW06IGZ1bmN0aW9uICh2YWx1ZSwgbGF5b3V0KSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEVuc3VyZSBlbnRyaWVzIGNhbid0IGFkZCB0aGVtc2VsdmVzIG1vcmUgdGhhbiBvbmNlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmIChsYXlvdXQgJiZcbiAgICAgICAgICAgICAgICBvcmRlci5maW5kSW5kZXgoZnVuY3Rpb24gKGVudHJ5KSB7IHJldHVybiB2YWx1ZSA9PT0gZW50cnkudmFsdWU7IH0pID09PSAtMSkge1xuICAgICAgICAgICAgICAgIG9yZGVyLnB1c2goeyB2YWx1ZTogdmFsdWUsIGxheW91dDogbGF5b3V0W2F4aXNdIH0pO1xuICAgICAgICAgICAgICAgIG9yZGVyLnNvcnQoY29tcGFyZU1pbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZU9yZGVyOiBmdW5jdGlvbiAoaWQsIG9mZnNldCwgdmVsb2NpdHkpIHtcbiAgICAgICAgICAgIGlmIChpc1Jlb3JkZXJpbmcuY3VycmVudClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB2YXIgbmV3T3JkZXIgPSBjaGVja1Jlb3JkZXIob3JkZXIsIGlkLCBvZmZzZXQsIHZlbG9jaXR5KTtcbiAgICAgICAgICAgIGlmIChvcmRlciAhPT0gbmV3T3JkZXIpIHtcbiAgICAgICAgICAgICAgICBpc1Jlb3JkZXJpbmcuY3VycmVudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgb25SZW9yZGVyKG5ld09yZGVyXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoZ2V0VmFsdWUpXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiB2YWx1ZXMuaW5kZXhPZih2YWx1ZSkgIT09IC0xOyB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpc1Jlb3JkZXJpbmcuY3VycmVudCA9IGZhbHNlO1xuICAgIH0pO1xuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChDb21wb25lbnQsIF9fYXNzaWduKHt9LCBwcm9wcywgeyByZWY6IGV4dGVybmFsUmVmIH0pLFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFJlb3JkZXJDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBjb250ZXh0IH0sIGNoaWxkcmVuKSkpO1xufVxudmFyIEdyb3VwID0gZm9yd2FyZFJlZihSZW9yZGVyR3JvdXApO1xuZnVuY3Rpb24gZ2V0VmFsdWUoaXRlbSkge1xuICAgIHJldHVybiBpdGVtLnZhbHVlO1xufVxuZnVuY3Rpb24gY29tcGFyZU1pbihhLCBiKSB7XG4gICAgcmV0dXJuIGEubGF5b3V0Lm1pbiAtIGIubGF5b3V0Lm1pbjtcbn1cblxuZXhwb3J0IHsgR3JvdXAsIFJlb3JkZXJHcm91cCB9O1xuIiwiaW1wb3J0IHsgX19yZWFkIH0gZnJvbSAndHNsaWInO1xuaW1wb3J0IHsgdXNlQ29udGV4dCwgdXNlU3RhdGUsIHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IG1vdGlvblZhbHVlIH0gZnJvbSAnLi9pbmRleC5tanMnO1xuaW1wb3J0IHsgTW90aW9uQ29uZmlnQ29udGV4dCB9IGZyb20gJy4uL2NvbnRleHQvTW90aW9uQ29uZmlnQ29udGV4dC5tanMnO1xuaW1wb3J0IHsgdXNlQ29uc3RhbnQgfSBmcm9tICcuLi91dGlscy91c2UtY29uc3RhbnQubWpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgYE1vdGlvblZhbHVlYCB0byB0cmFjayB0aGUgc3RhdGUgYW5kIHZlbG9jaXR5IG9mIGEgdmFsdWUuXG4gKlxuICogVXN1YWxseSwgdGhlc2UgYXJlIGNyZWF0ZWQgYXV0b21hdGljYWxseS4gRm9yIGFkdmFuY2VkIHVzZS1jYXNlcywgbGlrZSB1c2Ugd2l0aCBgdXNlVHJhbnNmb3JtYCwgeW91IGNhbiBjcmVhdGUgYE1vdGlvblZhbHVlYHMgZXh0ZXJuYWxseSBhbmQgcGFzcyB0aGVtIGludG8gdGhlIGFuaW1hdGVkIGNvbXBvbmVudCB2aWEgdGhlIGBzdHlsZWAgcHJvcC5cbiAqXG4gKiBgYGBqc3hcbiAqIGV4cG9ydCBjb25zdCBNeUNvbXBvbmVudCA9ICgpID0+IHtcbiAqICAgY29uc3Qgc2NhbGUgPSB1c2VNb3Rpb25WYWx1ZSgxKVxuICpcbiAqICAgcmV0dXJuIDxtb3Rpb24uZGl2IHN0eWxlPXt7IHNjYWxlIH19IC8+XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gaW5pdGlhbCAtIFRoZSBpbml0aWFsIHN0YXRlLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gdXNlTW90aW9uVmFsdWUoaW5pdGlhbCkge1xuICAgIHZhciB2YWx1ZSA9IHVzZUNvbnN0YW50KGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1vdGlvblZhbHVlKGluaXRpYWwpOyB9KTtcbiAgICAvKipcbiAgICAgKiBJZiB0aGlzIG1vdGlvbiB2YWx1ZSBpcyBiZWluZyB1c2VkIGluIHN0YXRpYyBtb2RlLCBsaWtlIG9uXG4gICAgICogdGhlIEZyYW1lciBjYW52YXMsIGZvcmNlIGNvbXBvbmVudHMgdG8gcmVyZW5kZXIgd2hlbiB0aGUgbW90aW9uXG4gICAgICogdmFsdWUgaXMgdXBkYXRlZC5cbiAgICAgKi9cbiAgICB2YXIgaXNTdGF0aWMgPSB1c2VDb250ZXh0KE1vdGlvbkNvbmZpZ0NvbnRleHQpLmlzU3RhdGljO1xuICAgIGlmIChpc1N0YXRpYykge1xuICAgICAgICB2YXIgX2EgPSBfX3JlYWQodXNlU3RhdGUoaW5pdGlhbCksIDIpLCBzZXRMYXRlc3RfMSA9IF9hWzFdO1xuICAgICAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkgeyByZXR1cm4gdmFsdWUub25DaGFuZ2Uoc2V0TGF0ZXN0XzEpOyB9LCBbXSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cblxuZXhwb3J0IHsgdXNlTW90aW9uVmFsdWUgfTtcbiIsImltcG9ydCB7IF9fYXNzaWduIH0gZnJvbSAndHNsaWInO1xuaW1wb3J0IHsgaW50ZXJwb2xhdGUgfSBmcm9tICdwb3Btb3Rpb24nO1xuXG52YXIgaXNDdXN0b21WYWx1ZVR5cGUgPSBmdW5jdGlvbiAodikge1xuICAgIHJldHVybiB0eXBlb2YgdiA9PT0gXCJvYmplY3RcIiAmJiB2Lm1peDtcbn07XG52YXIgZ2V0TWl4ZXIgPSBmdW5jdGlvbiAodikgeyByZXR1cm4gKGlzQ3VzdG9tVmFsdWVUeXBlKHYpID8gdi5taXggOiB1bmRlZmluZWQpOyB9O1xuZnVuY3Rpb24gdHJhbnNmb3JtKCkge1xuICAgIHZhciBhcmdzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICB2YXIgdXNlSW1tZWRpYXRlID0gIUFycmF5LmlzQXJyYXkoYXJnc1swXSk7XG4gICAgdmFyIGFyZ09mZnNldCA9IHVzZUltbWVkaWF0ZSA/IDAgOiAtMTtcbiAgICB2YXIgaW5wdXRWYWx1ZSA9IGFyZ3NbMCArIGFyZ09mZnNldF07XG4gICAgdmFyIGlucHV0UmFuZ2UgPSBhcmdzWzEgKyBhcmdPZmZzZXRdO1xuICAgIHZhciBvdXRwdXRSYW5nZSA9IGFyZ3NbMiArIGFyZ09mZnNldF07XG4gICAgdmFyIG9wdGlvbnMgPSBhcmdzWzMgKyBhcmdPZmZzZXRdO1xuICAgIHZhciBpbnRlcnBvbGF0b3IgPSBpbnRlcnBvbGF0ZShpbnB1dFJhbmdlLCBvdXRwdXRSYW5nZSwgX19hc3NpZ24oeyBtaXhlcjogZ2V0TWl4ZXIob3V0cHV0UmFuZ2VbMF0pIH0sIG9wdGlvbnMpKTtcbiAgICByZXR1cm4gdXNlSW1tZWRpYXRlID8gaW50ZXJwb2xhdG9yKGlucHV0VmFsdWUpIDogaW50ZXJwb2xhdG9yO1xufVxuXG5leHBvcnQgeyB0cmFuc2Zvcm0gfTtcbiIsImltcG9ydCB7IGlzTW90aW9uVmFsdWUgfSBmcm9tICcuL3V0aWxzL2lzLW1vdGlvbi12YWx1ZS5tanMnO1xuaW1wb3J0IHsgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCB9IGZyb20gJy4uL3V0aWxzL3VzZS1pc29tb3JwaGljLWVmZmVjdC5tanMnO1xuXG5mdW5jdGlvbiB1c2VPbkNoYW5nZSh2YWx1ZSwgY2FsbGJhY2spIHtcbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGlzTW90aW9uVmFsdWUodmFsdWUpKVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLm9uQ2hhbmdlKGNhbGxiYWNrKTtcbiAgICB9LCBbY2FsbGJhY2tdKTtcbn1cbmZ1bmN0aW9uIHVzZU11bHRpT25DaGFuZ2UodmFsdWVzLCBoYW5kbGVyKSB7XG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzdWJzY3JpcHRpb25zID0gdmFsdWVzLm1hcChmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIHZhbHVlLm9uQ2hhbmdlKGhhbmRsZXIpOyB9KTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHN1YnNjcmlwdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAodW5zdWJzY3JpYmUpIHsgcmV0dXJuIHVuc3Vic2NyaWJlKCk7IH0pOyB9O1xuICAgIH0pO1xufVxuXG5leHBvcnQgeyB1c2VNdWx0aU9uQ2hhbmdlLCB1c2VPbkNoYW5nZSB9O1xuIiwiaW1wb3J0IHsgdXNlTW90aW9uVmFsdWUgfSBmcm9tICcuL3VzZS1tb3Rpb24tdmFsdWUubWpzJztcbmltcG9ydCB7IHVzZU11bHRpT25DaGFuZ2UgfSBmcm9tICcuL3VzZS1vbi1jaGFuZ2UubWpzJztcbmltcG9ydCBzeW5jIGZyb20gJ2ZyYW1lc3luYyc7XG5cbmZ1bmN0aW9uIHVzZUNvbWJpbmVNb3Rpb25WYWx1ZXModmFsdWVzLCBjb21iaW5lVmFsdWVzKSB7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGlzZSB0aGUgcmV0dXJuZWQgbW90aW9uIHZhbHVlLiBUaGlzIHJlbWFpbnMgdGhlIHNhbWUgYmV0d2VlbiByZW5kZXJzLlxuICAgICAqL1xuICAgIHZhciB2YWx1ZSA9IHVzZU1vdGlvblZhbHVlKGNvbWJpbmVWYWx1ZXMoKSk7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgZnVuY3Rpb24gdGhhdCB3aWxsIHVwZGF0ZSB0aGUgdGVtcGxhdGUgbW90aW9uIHZhbHVlIHdpdGggdGhlIGxhdGVzdCB2YWx1ZXMuXG4gICAgICogVGhpcyBpcyBwcmUtYm91bmQgc28gd2hlbmV2ZXIgYSBtb3Rpb24gdmFsdWUgdXBkYXRlcyBpdCBjYW4gc2NoZWR1bGUgaXRzXG4gICAgICogZXhlY3V0aW9uIGluIEZyYW1lc3luYy4gSWYgaXQncyBhbHJlYWR5IGJlZW4gc2NoZWR1bGVkIGl0IHdvbid0IGJlIGZpcmVkIHR3aWNlXG4gICAgICogaW4gYSBzaW5nbGUgZnJhbWUuXG4gICAgICovXG4gICAgdmFyIHVwZGF0ZVZhbHVlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdmFsdWUuc2V0KGNvbWJpbmVWYWx1ZXMoKSk7IH07XG4gICAgLyoqXG4gICAgICogU3luY2hyb25vdXNseSB1cGRhdGUgdGhlIG1vdGlvbiB2YWx1ZSB3aXRoIHRoZSBsYXRlc3QgdmFsdWVzIGR1cmluZyB0aGUgcmVuZGVyLlxuICAgICAqIFRoaXMgZW5zdXJlcyB0aGF0IHdpdGhpbiBhIFJlYWN0IHJlbmRlciwgdGhlIHN0eWxlcyBhcHBsaWVkIHRvIHRoZSBET00gYXJlIHVwLXRvLWRhdGUuXG4gICAgICovXG4gICAgdXBkYXRlVmFsdWUoKTtcbiAgICAvKipcbiAgICAgKiBTdWJzY3JpYmUgdG8gYWxsIG1vdGlvbiB2YWx1ZXMgZm91bmQgd2l0aGluIHRoZSB0ZW1wbGF0ZS4gV2hlbmV2ZXIgYW55IG9mIHRoZW0gY2hhbmdlLFxuICAgICAqIHNjaGVkdWxlIGFuIHVwZGF0ZS5cbiAgICAgKi9cbiAgICB1c2VNdWx0aU9uQ2hhbmdlKHZhbHVlcywgZnVuY3Rpb24gKCkgeyByZXR1cm4gc3luYy51cGRhdGUodXBkYXRlVmFsdWUsIGZhbHNlLCB0cnVlKTsgfSk7XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuXG5leHBvcnQgeyB1c2VDb21iaW5lTW90aW9uVmFsdWVzIH07XG4iLCJpbXBvcnQgeyBfX3JlYWQgfSBmcm9tICd0c2xpYic7XG5pbXBvcnQgeyB0cmFuc2Zvcm0gfSBmcm9tICcuLi91dGlscy90cmFuc2Zvcm0ubWpzJztcbmltcG9ydCB7IHVzZUNvbWJpbmVNb3Rpb25WYWx1ZXMgfSBmcm9tICcuL3VzZS1jb21iaW5lLXZhbHVlcy5tanMnO1xuaW1wb3J0IHsgdXNlQ29uc3RhbnQgfSBmcm9tICcuLi91dGlscy91c2UtY29uc3RhbnQubWpzJztcblxuZnVuY3Rpb24gdXNlVHJhbnNmb3JtKGlucHV0LCBpbnB1dFJhbmdlT3JUcmFuc2Zvcm1lciwgb3V0cHV0UmFuZ2UsIG9wdGlvbnMpIHtcbiAgICB2YXIgdHJhbnNmb3JtZXIgPSB0eXBlb2YgaW5wdXRSYW5nZU9yVHJhbnNmb3JtZXIgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICA/IGlucHV0UmFuZ2VPclRyYW5zZm9ybWVyXG4gICAgICAgIDogdHJhbnNmb3JtKGlucHV0UmFuZ2VPclRyYW5zZm9ybWVyLCBvdXRwdXRSYW5nZSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoaW5wdXQpXG4gICAgICAgID8gdXNlTGlzdFRyYW5zZm9ybShpbnB1dCwgdHJhbnNmb3JtZXIpXG4gICAgICAgIDogdXNlTGlzdFRyYW5zZm9ybShbaW5wdXRdLCBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciBfYiA9IF9fcmVhZChfYSwgMSksIGxhdGVzdCA9IF9iWzBdO1xuICAgICAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVyKGxhdGVzdCk7XG4gICAgICAgIH0pO1xufVxuZnVuY3Rpb24gdXNlTGlzdFRyYW5zZm9ybSh2YWx1ZXMsIHRyYW5zZm9ybWVyKSB7XG4gICAgdmFyIGxhdGVzdCA9IHVzZUNvbnN0YW50KGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdOyB9KTtcbiAgICByZXR1cm4gdXNlQ29tYmluZU1vdGlvblZhbHVlcyh2YWx1ZXMsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbGF0ZXN0Lmxlbmd0aCA9IDA7XG4gICAgICAgIHZhciBudW1WYWx1ZXMgPSB2YWx1ZXMubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bVZhbHVlczsgaSsrKSB7XG4gICAgICAgICAgICBsYXRlc3RbaV0gPSB2YWx1ZXNbaV0uZ2V0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVyKGxhdGVzdCk7XG4gICAgfSk7XG59XG5cbmV4cG9ydCB7IHVzZVRyYW5zZm9ybSB9O1xuIiwiaW1wb3J0IHsgX19yZXN0LCBfX3JlYWQsIF9fYXNzaWduIH0gZnJvbSAndHNsaWInO1xuaW1wb3J0IHsgaW52YXJpYW50IH0gZnJvbSAnaGV5LWxpc3Rlbic7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBmb3J3YXJkUmVmLCB1c2VDb250ZXh0LCB1c2VSZWYsIHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IFJlb3JkZXJDb250ZXh0IH0gZnJvbSAnLi4vLi4vY29udGV4dC9SZW9yZGVyQ29udGV4dC5tanMnO1xuaW1wb3J0IHsgbW90aW9uIH0gZnJvbSAnLi4vLi4vcmVuZGVyL2RvbS9tb3Rpb24ubWpzJztcbmltcG9ydCB7IHVzZUNvbnN0YW50IH0gZnJvbSAnLi4vLi4vdXRpbHMvdXNlLWNvbnN0YW50Lm1qcyc7XG5pbXBvcnQgeyB1c2VNb3Rpb25WYWx1ZSB9IGZyb20gJy4uLy4uL3ZhbHVlL3VzZS1tb3Rpb24tdmFsdWUubWpzJztcbmltcG9ydCB7IHVzZVRyYW5zZm9ybSB9IGZyb20gJy4uLy4uL3ZhbHVlL3VzZS10cmFuc2Zvcm0ubWpzJztcbmltcG9ydCB7IGlzTW90aW9uVmFsdWUgfSBmcm9tICcuLi8uLi92YWx1ZS91dGlscy9pcy1tb3Rpb24tdmFsdWUubWpzJztcblxuZnVuY3Rpb24gdXNlRGVmYXVsdE1vdGlvblZhbHVlKHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcbiAgICBpZiAoZGVmYXVsdFZhbHVlID09PSB2b2lkIDApIHsgZGVmYXVsdFZhbHVlID0gMDsgfVxuICAgIHJldHVybiBpc01vdGlvblZhbHVlKHZhbHVlKSA/IHZhbHVlIDogdXNlTW90aW9uVmFsdWUoZGVmYXVsdFZhbHVlKTtcbn1cbmZ1bmN0aW9uIFJlb3JkZXJJdGVtKF9hLCBleHRlcm5hbFJlZikge1xuICAgIHZhciBjaGlsZHJlbiA9IF9hLmNoaWxkcmVuLCBzdHlsZSA9IF9hLnN0eWxlLCB2YWx1ZSA9IF9hLnZhbHVlLCBfYiA9IF9hLmFzLCBhcyA9IF9iID09PSB2b2lkIDAgPyBcImxpXCIgOiBfYiwgb25EcmFnID0gX2Eub25EcmFnLCBfYyA9IF9hLmxheW91dCwgbGF5b3V0ID0gX2MgPT09IHZvaWQgMCA/IHRydWUgOiBfYywgcHJvcHMgPSBfX3Jlc3QoX2EsIFtcImNoaWxkcmVuXCIsIFwic3R5bGVcIiwgXCJ2YWx1ZVwiLCBcImFzXCIsIFwib25EcmFnXCIsIFwibGF5b3V0XCJdKTtcbiAgICB2YXIgQ29tcG9uZW50ID0gdXNlQ29uc3RhbnQoZnVuY3Rpb24gKCkgeyByZXR1cm4gbW90aW9uKGFzKTsgfSk7XG4gICAgdmFyIGNvbnRleHQgPSB1c2VDb250ZXh0KFJlb3JkZXJDb250ZXh0KTtcbiAgICB2YXIgcG9pbnQgPSB7XG4gICAgICAgIHg6IHVzZURlZmF1bHRNb3Rpb25WYWx1ZShzdHlsZSA9PT0gbnVsbCB8fCBzdHlsZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3R5bGUueCksXG4gICAgICAgIHk6IHVzZURlZmF1bHRNb3Rpb25WYWx1ZShzdHlsZSA9PT0gbnVsbCB8fCBzdHlsZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3R5bGUueSksXG4gICAgfTtcbiAgICB2YXIgekluZGV4ID0gdXNlVHJhbnNmb3JtKFtwb2ludC54LCBwb2ludC55XSwgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBfYiA9IF9fcmVhZChfYSwgMiksIGxhdGVzdFggPSBfYlswXSwgbGF0ZXN0WSA9IF9iWzFdO1xuICAgICAgICByZXR1cm4gbGF0ZXN0WCB8fCBsYXRlc3RZID8gMSA6IFwidW5zZXRcIjtcbiAgICB9KTtcbiAgICB2YXIgbWVhc3VyZWRMYXlvdXQgPSB1c2VSZWYobnVsbCk7XG4gICAgaW52YXJpYW50KEJvb2xlYW4oY29udGV4dCksIFwiUmVvcmRlci5JdGVtIG11c3QgYmUgYSBjaGlsZCBvZiBSZW9yZGVyLkdyb3VwXCIpO1xuICAgIHZhciBfZCA9IGNvbnRleHQsIGF4aXMgPSBfZC5heGlzLCByZWdpc3Rlckl0ZW0gPSBfZC5yZWdpc3Rlckl0ZW0sIHVwZGF0ZU9yZGVyID0gX2QudXBkYXRlT3JkZXI7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmVnaXN0ZXJJdGVtKHZhbHVlLCBtZWFzdXJlZExheW91dC5jdXJyZW50KTtcbiAgICB9LCBbY29udGV4dF0pO1xuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChDb21wb25lbnQsIF9fYXNzaWduKHsgZHJhZzogYXhpcyB9LCBwcm9wcywgeyBkcmFnU25hcFRvT3JpZ2luOiB0cnVlLCBzdHlsZTogX19hc3NpZ24oX19hc3NpZ24oe30sIHN0eWxlKSwgeyB4OiBwb2ludC54LCB5OiBwb2ludC55LCB6SW5kZXg6IHpJbmRleCB9KSwgbGF5b3V0OiBsYXlvdXQsIG9uRHJhZzogZnVuY3Rpb24gKGV2ZW50LCBnZXN0dXJlUG9pbnQpIHtcbiAgICAgICAgICAgIHZhciB2ZWxvY2l0eSA9IGdlc3R1cmVQb2ludC52ZWxvY2l0eTtcbiAgICAgICAgICAgIHZlbG9jaXR5W2F4aXNdICYmXG4gICAgICAgICAgICAgICAgdXBkYXRlT3JkZXIodmFsdWUsIHBvaW50W2F4aXNdLmdldCgpLCB2ZWxvY2l0eVtheGlzXSk7XG4gICAgICAgICAgICBvbkRyYWcgPT09IG51bGwgfHwgb25EcmFnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvbkRyYWcoZXZlbnQsIGdlc3R1cmVQb2ludCk7XG4gICAgICAgIH0sIG9uTGF5b3V0TWVhc3VyZTogZnVuY3Rpb24gKG1lYXN1cmVkKSB7XG4gICAgICAgICAgICBtZWFzdXJlZExheW91dC5jdXJyZW50ID0gbWVhc3VyZWQ7XG4gICAgICAgIH0sIHJlZjogZXh0ZXJuYWxSZWYgfSksIGNoaWxkcmVuKSk7XG59XG52YXIgSXRlbSA9IGZvcndhcmRSZWYoUmVvcmRlckl0ZW0pO1xuXG5leHBvcnQgeyBJdGVtLCBSZW9yZGVySXRlbSB9O1xuIiwiaW1wb3J0IHsgR3JvdXAgfSBmcm9tICcuL0dyb3VwLm1qcyc7XG5pbXBvcnQgeyBJdGVtIH0gZnJvbSAnLi9JdGVtLm1qcyc7XG5cbnZhciBSZW9yZGVyID0ge1xuICAgIEdyb3VwOiBHcm91cCxcbiAgICBJdGVtOiBJdGVtLFxufTtcblxuZXhwb3J0IHsgUmVvcmRlciB9O1xuIiwiaW1wb3J0IHsgX19hc3NpZ24gfSBmcm9tICd0c2xpYic7XG5pbXBvcnQgeyBhbmltYXRpb25zIH0gZnJvbSAnLi4vLi4vbW90aW9uL2ZlYXR1cmVzL2FuaW1hdGlvbnMubWpzJztcbmltcG9ydCB7IGdlc3R1cmVBbmltYXRpb25zIH0gZnJvbSAnLi4vLi4vbW90aW9uL2ZlYXR1cmVzL2dlc3R1cmVzLm1qcyc7XG5pbXBvcnQgeyBjcmVhdGVEb21WaXN1YWxFbGVtZW50IH0gZnJvbSAnLi9jcmVhdGUtdmlzdWFsLWVsZW1lbnQubWpzJztcblxuLyoqXG4gKiBAcHVibGljXG4gKi9cbnZhciBkb21BbmltYXRpb24gPSBfX2Fzc2lnbihfX2Fzc2lnbih7IHJlbmRlcmVyOiBjcmVhdGVEb21WaXN1YWxFbGVtZW50IH0sIGFuaW1hdGlvbnMpLCBnZXN0dXJlQW5pbWF0aW9ucyk7XG5cbmV4cG9ydCB7IGRvbUFuaW1hdGlvbiB9O1xuIiwiaW1wb3J0IHsgX19hc3NpZ24gfSBmcm9tICd0c2xpYic7XG5pbXBvcnQgeyBkcmFnIH0gZnJvbSAnLi4vLi4vbW90aW9uL2ZlYXR1cmVzL2RyYWcubWpzJztcbmltcG9ydCB7IGxheW91dEZlYXR1cmVzIH0gZnJvbSAnLi4vLi4vbW90aW9uL2ZlYXR1cmVzL2xheW91dC9pbmRleC5tanMnO1xuaW1wb3J0IHsgZG9tQW5pbWF0aW9uIH0gZnJvbSAnLi9mZWF0dXJlcy1hbmltYXRpb24ubWpzJztcbmltcG9ydCB7IEhUTUxQcm9qZWN0aW9uTm9kZSB9IGZyb20gJy4uLy4uL3Byb2plY3Rpb24vbm9kZS9IVE1MUHJvamVjdGlvbk5vZGUubWpzJztcblxuLyoqXG4gKiBAcHVibGljXG4gKi9cbnZhciBkb21NYXggPSBfX2Fzc2lnbihfX2Fzc2lnbihfX2Fzc2lnbihfX2Fzc2lnbih7fSwgZG9tQW5pbWF0aW9uKSwgZHJhZyksIGxheW91dEZlYXR1cmVzKSwgeyBwcm9qZWN0aW9uTm9kZUNvbnN0cnVjdG9yOiBIVE1MUHJvamVjdGlvbk5vZGUgfSk7XG5cbmV4cG9ydCB7IGRvbU1heCB9O1xuIiwiaW1wb3J0IHsgdXNlQ29tYmluZU1vdGlvblZhbHVlcyB9IGZyb20gJy4vdXNlLWNvbWJpbmUtdmFsdWVzLm1qcyc7XG5cbi8qKlxuICogQ29tYmluZSBtdWx0aXBsZSBtb3Rpb24gdmFsdWVzIGludG8gYSBuZXcgb25lIHVzaW5nIGEgc3RyaW5nIHRlbXBsYXRlIGxpdGVyYWwuXG4gKlxuICogYGBganN4XG4gKiBpbXBvcnQge1xuICogICBtb3Rpb24sXG4gKiAgIHVzZVNwcmluZyxcbiAqICAgdXNlTW90aW9uVmFsdWUsXG4gKiAgIHVzZU1vdGlvblRlbXBsYXRlXG4gKiB9IGZyb20gXCJmcmFtZXItbW90aW9uXCJcbiAqXG4gKiBmdW5jdGlvbiBDb21wb25lbnQoKSB7XG4gKiAgIGNvbnN0IHNoYWRvd1ggPSB1c2VTcHJpbmcoMClcbiAqICAgY29uc3Qgc2hhZG93WSA9IHVzZU1vdGlvblZhbHVlKDApXG4gKiAgIGNvbnN0IHNoYWRvdyA9IHVzZU1vdGlvblRlbXBsYXRlYGRyb3Atc2hhZG93KCR7c2hhZG93WH1weCAke3NoYWRvd1l9cHggMjBweCByZ2JhKDAsMCwwLDAuMykpYFxuICpcbiAqICAgcmV0dXJuIDxtb3Rpb24uZGl2IHN0eWxlPXt7IGZpbHRlcjogc2hhZG93IH19IC8+XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHVzZU1vdGlvblRlbXBsYXRlKGZyYWdtZW50cykge1xuICAgIHZhciB2YWx1ZXMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YWx1ZXNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBidWlsZCBhIHN0cmluZyBmcm9tIHRoZSBsYXRlc3QgbW90aW9uIHZhbHVlcy5cbiAgICAgKi9cbiAgICB2YXIgbnVtRnJhZ21lbnRzID0gZnJhZ21lbnRzLmxlbmd0aDtcbiAgICBmdW5jdGlvbiBidWlsZFZhbHVlKCkge1xuICAgICAgICB2YXIgb3V0cHV0ID0gXCJcIjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1GcmFnbWVudHM7IGkrKykge1xuICAgICAgICAgICAgb3V0cHV0ICs9IGZyYWdtZW50c1tpXTtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHZhbHVlc1tpXTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSlcbiAgICAgICAgICAgICAgICBvdXRwdXQgKz0gdmFsdWVzW2ldLmdldCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuICAgIHJldHVybiB1c2VDb21iaW5lTW90aW9uVmFsdWVzKHZhbHVlcywgYnVpbGRWYWx1ZSk7XG59XG5cbmV4cG9ydCB7IHVzZU1vdGlvblRlbXBsYXRlIH07XG4iLCJpbXBvcnQgeyBfX2Fzc2lnbiB9IGZyb20gJ3RzbGliJztcbmltcG9ydCB7IHVzZUNvbnRleHQsIHVzZVJlZiwgdXNlTWVtbyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGFuaW1hdGUgfSBmcm9tICdwb3Btb3Rpb24nO1xuaW1wb3J0IHsgaXNNb3Rpb25WYWx1ZSB9IGZyb20gJy4vdXRpbHMvaXMtbW90aW9uLXZhbHVlLm1qcyc7XG5pbXBvcnQgeyB1c2VNb3Rpb25WYWx1ZSB9IGZyb20gJy4vdXNlLW1vdGlvbi12YWx1ZS5tanMnO1xuaW1wb3J0IHsgdXNlT25DaGFuZ2UgfSBmcm9tICcuL3VzZS1vbi1jaGFuZ2UubWpzJztcbmltcG9ydCB7IE1vdGlvbkNvbmZpZ0NvbnRleHQgfSBmcm9tICcuLi9jb250ZXh0L01vdGlvbkNvbmZpZ0NvbnRleHQubWpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgYE1vdGlvblZhbHVlYCB0aGF0LCB3aGVuIGBzZXRgLCB3aWxsIHVzZSBhIHNwcmluZyBhbmltYXRpb24gdG8gYW5pbWF0ZSB0byBpdHMgbmV3IHN0YXRlLlxuICpcbiAqIEl0IGNhbiBlaXRoZXIgd29yayBhcyBhIHN0YW5kLWFsb25lIGBNb3Rpb25WYWx1ZWAgYnkgaW5pdGlhbGlzaW5nIGl0IHdpdGggYSB2YWx1ZSwgb3IgYXMgYSBzdWJzY3JpYmVyXG4gKiB0byBhbm90aGVyIGBNb3Rpb25WYWx1ZWAuXG4gKlxuICogQHJlbWFya3NcbiAqXG4gKiBgYGBqc3hcbiAqIGNvbnN0IHggPSB1c2VTcHJpbmcoMCwgeyBzdGlmZm5lc3M6IDMwMCB9KVxuICogY29uc3QgeSA9IHVzZVNwcmluZyh4LCB7IGRhbXBpbmc6IDEwIH0pXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gaW5wdXRWYWx1ZSAtIGBNb3Rpb25WYWx1ZWAgb3IgbnVtYmVyLiBJZiBwcm92aWRlZCBhIGBNb3Rpb25WYWx1ZWAsIHdoZW4gdGhlIGlucHV0IGBNb3Rpb25WYWx1ZWAgY2hhbmdlcywgdGhlIGNyZWF0ZWQgYE1vdGlvblZhbHVlYCB3aWxsIHNwcmluZyB0b3dhcmRzIHRoYXQgdmFsdWUuXG4gKiBAcGFyYW0gc3ByaW5nQ29uZmlnIC0gQ29uZmlndXJhdGlvbiBvcHRpb25zIGZvciB0aGUgc3ByaW5nLlxuICogQHJldHVybnMgYE1vdGlvblZhbHVlYFxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gdXNlU3ByaW5nKHNvdXJjZSwgY29uZmlnKSB7XG4gICAgaWYgKGNvbmZpZyA9PT0gdm9pZCAwKSB7IGNvbmZpZyA9IHt9OyB9XG4gICAgdmFyIGlzU3RhdGljID0gdXNlQ29udGV4dChNb3Rpb25Db25maWdDb250ZXh0KS5pc1N0YXRpYztcbiAgICB2YXIgYWN0aXZlU3ByaW5nQW5pbWF0aW9uID0gdXNlUmVmKG51bGwpO1xuICAgIHZhciB2YWx1ZSA9IHVzZU1vdGlvblZhbHVlKGlzTW90aW9uVmFsdWUoc291cmNlKSA/IHNvdXJjZS5nZXQoKSA6IHNvdXJjZSk7XG4gICAgdXNlTWVtbyhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5hdHRhY2goZnVuY3Rpb24gKHYsIHNldCkge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBIG1vcmUgaG9sbGlzdGljIGFwcHJvYWNoIHRvIHRoaXMgbWlnaHQgYmUgdG8gdXNlIGlzU3RhdGljIHRvIGZpeCBWaXN1YWxFbGVtZW50IGFuaW1hdGlvbnNcbiAgICAgICAgICAgICAqIGF0IHRoYXQgbGV2ZWwsIGJ1dCB0aGlzIHdpbGwgd29yayBmb3Igbm93XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmIChpc1N0YXRpYylcbiAgICAgICAgICAgICAgICByZXR1cm4gc2V0KHYpO1xuICAgICAgICAgICAgaWYgKGFjdGl2ZVNwcmluZ0FuaW1hdGlvbi5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgYWN0aXZlU3ByaW5nQW5pbWF0aW9uLmN1cnJlbnQuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWN0aXZlU3ByaW5nQW5pbWF0aW9uLmN1cnJlbnQgPSBhbmltYXRlKF9fYXNzaWduKF9fYXNzaWduKHsgZnJvbTogdmFsdWUuZ2V0KCksIHRvOiB2LCB2ZWxvY2l0eTogdmFsdWUuZ2V0VmVsb2NpdHkoKSB9LCBjb25maWcpLCB7IG9uVXBkYXRlOiBzZXQgfSkpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLmdldCgpO1xuICAgICAgICB9KTtcbiAgICB9LCBbSlNPTi5zdHJpbmdpZnkoY29uZmlnKV0pO1xuICAgIHVzZU9uQ2hhbmdlKHNvdXJjZSwgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHZhbHVlLnNldChwYXJzZUZsb2F0KHYpKTsgfSk7XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuXG5leHBvcnQgeyB1c2VTcHJpbmcgfTtcbiIsImltcG9ydCB7IHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZU1vdGlvblZhbHVlIH0gZnJvbSAnLi91c2UtbW90aW9uLXZhbHVlLm1qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGBNb3Rpb25WYWx1ZWAgdGhhdCB1cGRhdGVzIHdoZW4gdGhlIHZlbG9jaXR5IG9mIHRoZSBwcm92aWRlZCBgTW90aW9uVmFsdWVgIGNoYW5nZXMuXG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogY29uc3QgeCA9IHVzZU1vdGlvblZhbHVlKDApXG4gKiBjb25zdCB4VmVsb2NpdHkgPSB1c2VWZWxvY2l0eSh4KVxuICogY29uc3QgeEFjY2VsZXJhdGlvbiA9IHVzZVZlbG9jaXR5KHhWZWxvY2l0eSlcbiAqIGBgYFxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gdXNlVmVsb2NpdHkodmFsdWUpIHtcbiAgICB2YXIgdmVsb2NpdHkgPSB1c2VNb3Rpb25WYWx1ZSh2YWx1ZS5nZXRWZWxvY2l0eSgpKTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdmFsdWUudmVsb2NpdHlVcGRhdGVTdWJzY3JpYmVycy5hZGQoZnVuY3Rpb24gKG5ld1ZlbG9jaXR5KSB7XG4gICAgICAgICAgICB2ZWxvY2l0eS5zZXQobmV3VmVsb2NpdHkpO1xuICAgICAgICB9KTtcbiAgICB9LCBbdmFsdWVdKTtcbiAgICByZXR1cm4gdmVsb2NpdHk7XG59XG5cbmV4cG9ydCB7IHVzZVZlbG9jaXR5IH07XG4iLCJmdW5jdGlvbiByZXNvbHZlRWxlbWVudHMoZWxlbWVudHMsIHNlbGVjdG9yQ2FjaGUpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKHR5cGVvZiBlbGVtZW50cyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAoc2VsZWN0b3JDYWNoZSkge1xuICAgICAgICAgICAgKF9hID0gc2VsZWN0b3JDYWNoZVtlbGVtZW50c10pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IChzZWxlY3RvckNhY2hlW2VsZW1lbnRzXSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoZWxlbWVudHMpKTtcbiAgICAgICAgICAgIGVsZW1lbnRzID0gc2VsZWN0b3JDYWNoZVtlbGVtZW50c107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlbGVtZW50cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoZWxlbWVudHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGVsZW1lbnRzIGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgICAgICBlbGVtZW50cyA9IFtlbGVtZW50c107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBhbiBlbXB0eSBhcnJheVxuICAgICAqL1xuICAgIHJldHVybiBBcnJheS5mcm9tKGVsZW1lbnRzIHx8IFtdKTtcbn1cblxuZXhwb3J0IHsgcmVzb2x2ZUVsZW1lbnRzIH07XG4iLCJpbXBvcnQgeyByZXNvbHZlRWxlbWVudHMgfSBmcm9tICcuLi8uLi91dGlscy9yZXNvbHZlLWVsZW1lbnRzLmVzLmpzJztcblxuY29uc3QgcmVzaXplSGFuZGxlcnMgPSBuZXcgV2Vha01hcCgpO1xubGV0IG9ic2VydmVyO1xuZnVuY3Rpb24gZ2V0RWxlbWVudFNpemUodGFyZ2V0LCBib3JkZXJCb3hTaXplKSB7XG4gICAgaWYgKGJvcmRlckJveFNpemUpIHtcbiAgICAgICAgY29uc3QgeyBpbmxpbmVTaXplLCBibG9ja1NpemUgfSA9IGJvcmRlckJveFNpemVbMF07XG4gICAgICAgIHJldHVybiB7IHdpZHRoOiBpbmxpbmVTaXplLCBoZWlnaHQ6IGJsb2NrU2l6ZSB9O1xuICAgIH1cbiAgICBlbHNlIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBTVkdFbGVtZW50ICYmIFwiZ2V0QkJveFwiIGluIHRhcmdldCkge1xuICAgICAgICByZXR1cm4gdGFyZ2V0LmdldEJCb3goKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3aWR0aDogdGFyZ2V0Lm9mZnNldFdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiB0YXJnZXQub2Zmc2V0SGVpZ2h0LFxuICAgICAgICB9O1xuICAgIH1cbn1cbmZ1bmN0aW9uIG5vdGlmeVRhcmdldCh7IHRhcmdldCwgY29udGVudFJlY3QsIGJvcmRlckJveFNpemUsIH0pIHtcbiAgICB2YXIgX2E7XG4gICAgKF9hID0gcmVzaXplSGFuZGxlcnMuZ2V0KHRhcmdldCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5mb3JFYWNoKChoYW5kbGVyKSA9PiB7XG4gICAgICAgIGhhbmRsZXIoe1xuICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgY29udGVudFNpemU6IGNvbnRlbnRSZWN0LFxuICAgICAgICAgICAgZ2V0IHNpemUoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldEVsZW1lbnRTaXplKHRhcmdldCwgYm9yZGVyQm94U2l6ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIG5vdGlmeUFsbChlbnRyaWVzKSB7XG4gICAgZW50cmllcy5mb3JFYWNoKG5vdGlmeVRhcmdldCk7XG59XG5mdW5jdGlvbiBjcmVhdGVSZXNpemVPYnNlcnZlcigpIHtcbiAgICBpZiAodHlwZW9mIFJlc2l6ZU9ic2VydmVyID09PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICByZXR1cm47XG4gICAgb2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIobm90aWZ5QWxsKTtcbn1cbmZ1bmN0aW9uIHJlc2l6ZUVsZW1lbnQodGFyZ2V0LCBoYW5kbGVyKSB7XG4gICAgaWYgKCFvYnNlcnZlcilcbiAgICAgICAgY3JlYXRlUmVzaXplT2JzZXJ2ZXIoKTtcbiAgICBjb25zdCBlbGVtZW50cyA9IHJlc29sdmVFbGVtZW50cyh0YXJnZXQpO1xuICAgIGVsZW1lbnRzLmZvckVhY2goKGVsZW1lbnQpID0+IHtcbiAgICAgICAgbGV0IGVsZW1lbnRIYW5kbGVycyA9IHJlc2l6ZUhhbmRsZXJzLmdldChlbGVtZW50KTtcbiAgICAgICAgaWYgKCFlbGVtZW50SGFuZGxlcnMpIHtcbiAgICAgICAgICAgIGVsZW1lbnRIYW5kbGVycyA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgIHJlc2l6ZUhhbmRsZXJzLnNldChlbGVtZW50LCBlbGVtZW50SGFuZGxlcnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsZW1lbnRIYW5kbGVycy5hZGQoaGFuZGxlcik7XG4gICAgICAgIG9ic2VydmVyID09PSBudWxsIHx8IG9ic2VydmVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvYnNlcnZlci5vYnNlcnZlKGVsZW1lbnQpO1xuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGVsZW1lbnRzLmZvckVhY2goKGVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnRIYW5kbGVycyA9IHJlc2l6ZUhhbmRsZXJzLmdldChlbGVtZW50KTtcbiAgICAgICAgICAgIGVsZW1lbnRIYW5kbGVycyA9PT0gbnVsbCB8fCBlbGVtZW50SGFuZGxlcnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVsZW1lbnRIYW5kbGVycy5kZWxldGUoaGFuZGxlcik7XG4gICAgICAgICAgICBpZiAoIShlbGVtZW50SGFuZGxlcnMgPT09IG51bGwgfHwgZWxlbWVudEhhbmRsZXJzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlbGVtZW50SGFuZGxlcnMuc2l6ZSkpIHtcbiAgICAgICAgICAgICAgICBvYnNlcnZlciA9PT0gbnVsbCB8fCBvYnNlcnZlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2JzZXJ2ZXIudW5vYnNlcnZlKGVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xufVxuXG5leHBvcnQgeyByZXNpemVFbGVtZW50IH07XG4iLCJjb25zdCB3aW5kb3dDYWxsYmFja3MgPSBuZXcgU2V0KCk7XG5sZXQgd2luZG93UmVzaXplSGFuZGxlcjtcbmZ1bmN0aW9uIGNyZWF0ZVdpbmRvd1Jlc2l6ZUhhbmRsZXIoKSB7XG4gICAgd2luZG93UmVzaXplSGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IHtcbiAgICAgICAgICAgIHdpZHRoOiB3aW5kb3cuaW5uZXJXaWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogd2luZG93LmlubmVySGVpZ2h0LFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBpbmZvID0ge1xuICAgICAgICAgICAgdGFyZ2V0OiB3aW5kb3csXG4gICAgICAgICAgICBzaXplLFxuICAgICAgICAgICAgY29udGVudFNpemU6IHNpemUsXG4gICAgICAgIH07XG4gICAgICAgIHdpbmRvd0NhbGxiYWNrcy5mb3JFYWNoKChjYWxsYmFjaykgPT4gY2FsbGJhY2soaW5mbykpO1xuICAgIH07XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgd2luZG93UmVzaXplSGFuZGxlcik7XG59XG5mdW5jdGlvbiByZXNpemVXaW5kb3coY2FsbGJhY2spIHtcbiAgICB3aW5kb3dDYWxsYmFja3MuYWRkKGNhbGxiYWNrKTtcbiAgICBpZiAoIXdpbmRvd1Jlc2l6ZUhhbmRsZXIpXG4gICAgICAgIGNyZWF0ZVdpbmRvd1Jlc2l6ZUhhbmRsZXIoKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICB3aW5kb3dDYWxsYmFja3MuZGVsZXRlKGNhbGxiYWNrKTtcbiAgICAgICAgaWYgKCF3aW5kb3dDYWxsYmFja3Muc2l6ZSAmJiB3aW5kb3dSZXNpemVIYW5kbGVyKSB7XG4gICAgICAgICAgICB3aW5kb3dSZXNpemVIYW5kbGVyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuZXhwb3J0IHsgcmVzaXplV2luZG93IH07XG4iLCJpbXBvcnQgeyByZXNpemVFbGVtZW50IH0gZnJvbSAnLi9oYW5kbGUtZWxlbWVudC5lcy5qcyc7XG5pbXBvcnQgeyByZXNpemVXaW5kb3cgfSBmcm9tICcuL2hhbmRsZS13aW5kb3cuZXMuanMnO1xuXG5mdW5jdGlvbiByZXNpemUoYSwgYikge1xuICAgIHJldHVybiB0eXBlb2YgYSA9PT0gXCJmdW5jdGlvblwiID8gcmVzaXplV2luZG93KGEpIDogcmVzaXplRWxlbWVudChhLCBiKTtcbn1cblxuZXhwb3J0IHsgcmVzaXplIH07XG4iLCJjb25zdCBwcm9ncmVzcyA9IChtaW4sIG1heCwgdmFsdWUpID0+IG1heCAtIG1pbiA9PT0gMCA/IDEgOiAodmFsdWUgLSBtaW4pIC8gKG1heCAtIG1pbik7XG5cbmV4cG9ydCB7IHByb2dyZXNzIH07XG4iLCIvKlxuICBDb252ZXJ0IHZlbG9jaXR5IGludG8gdmVsb2NpdHkgcGVyIHNlY29uZFxuXG4gIEBwYXJhbSBbbnVtYmVyXTogVW5pdCBwZXIgZnJhbWVcbiAgQHBhcmFtIFtudW1iZXJdOiBGcmFtZSBkdXJhdGlvbiBpbiBtc1xuKi9cbmZ1bmN0aW9uIHZlbG9jaXR5UGVyU2Vjb25kKHZlbG9jaXR5LCBmcmFtZUR1cmF0aW9uKSB7XG4gICAgcmV0dXJuIGZyYW1lRHVyYXRpb24gPyB2ZWxvY2l0eSAqICgxMDAwIC8gZnJhbWVEdXJhdGlvbikgOiAwO1xufVxuXG5leHBvcnQgeyB2ZWxvY2l0eVBlclNlY29uZCB9O1xuIiwiaW1wb3J0IHsgcHJvZ3Jlc3MsIHZlbG9jaXR5UGVyU2Vjb25kIH0gZnJvbSAnQG1vdGlvbm9uZS91dGlscyc7XG5cbi8qKlxuICogQSB0aW1lIGluIG1pbGxpc2Vjb25kcywgYmV5b25kIHdoaWNoIHdlIGNvbnNpZGVyIHRoZSBzY3JvbGwgdmVsb2NpdHkgdG8gYmUgMC5cbiAqL1xuY29uc3QgbWF4RWxhcHNlZCA9IDUwO1xuY29uc3QgY3JlYXRlQXhpc0luZm8gPSAoKSA9PiAoe1xuICAgIGN1cnJlbnQ6IDAsXG4gICAgb2Zmc2V0OiBbXSxcbiAgICBwcm9ncmVzczogMCxcbiAgICBzY3JvbGxMZW5ndGg6IDAsXG4gICAgdGFyZ2V0T2Zmc2V0OiAwLFxuICAgIHRhcmdldExlbmd0aDogMCxcbiAgICBjb250YWluZXJMZW5ndGg6IDAsXG4gICAgdmVsb2NpdHk6IDAsXG59KTtcbmNvbnN0IGNyZWF0ZVNjcm9sbEluZm8gPSAoKSA9PiAoe1xuICAgIHRpbWU6IDAsXG4gICAgeDogY3JlYXRlQXhpc0luZm8oKSxcbiAgICB5OiBjcmVhdGVBeGlzSW5mbygpLFxufSk7XG5jb25zdCBrZXlzID0ge1xuICAgIHg6IHtcbiAgICAgICAgbGVuZ3RoOiBcIldpZHRoXCIsXG4gICAgICAgIHBvc2l0aW9uOiBcIkxlZnRcIixcbiAgICB9LFxuICAgIHk6IHtcbiAgICAgICAgbGVuZ3RoOiBcIkhlaWdodFwiLFxuICAgICAgICBwb3NpdGlvbjogXCJUb3BcIixcbiAgICB9LFxufTtcbmZ1bmN0aW9uIHVwZGF0ZUF4aXNJbmZvKGVsZW1lbnQsIGF4aXNOYW1lLCBpbmZvLCB0aW1lKSB7XG4gICAgY29uc3QgYXhpcyA9IGluZm9bYXhpc05hbWVdO1xuICAgIGNvbnN0IHsgbGVuZ3RoLCBwb3NpdGlvbiB9ID0ga2V5c1theGlzTmFtZV07XG4gICAgY29uc3QgcHJldiA9IGF4aXMuY3VycmVudDtcbiAgICBjb25zdCBwcmV2VGltZSA9IGluZm8udGltZTtcbiAgICBheGlzLmN1cnJlbnQgPSBlbGVtZW50W1wic2Nyb2xsXCIgKyBwb3NpdGlvbl07XG4gICAgYXhpcy5zY3JvbGxMZW5ndGggPSBlbGVtZW50W1wic2Nyb2xsXCIgKyBsZW5ndGhdIC0gZWxlbWVudFtcImNsaWVudFwiICsgbGVuZ3RoXTtcbiAgICBheGlzLm9mZnNldC5sZW5ndGggPSAwO1xuICAgIGF4aXMub2Zmc2V0WzBdID0gMDtcbiAgICBheGlzLm9mZnNldFsxXSA9IGF4aXMuc2Nyb2xsTGVuZ3RoO1xuICAgIGF4aXMucHJvZ3Jlc3MgPSBwcm9ncmVzcygwLCBheGlzLnNjcm9sbExlbmd0aCwgYXhpcy5jdXJyZW50KTtcbiAgICBjb25zdCBlbGFwc2VkID0gdGltZSAtIHByZXZUaW1lO1xuICAgIGF4aXMudmVsb2NpdHkgPVxuICAgICAgICBlbGFwc2VkID4gbWF4RWxhcHNlZCA/IDAgOiB2ZWxvY2l0eVBlclNlY29uZChheGlzLmN1cnJlbnQgLSBwcmV2LCBlbGFwc2VkKTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZVNjcm9sbEluZm8oZWxlbWVudCwgaW5mbywgdGltZSkge1xuICAgIHVwZGF0ZUF4aXNJbmZvKGVsZW1lbnQsIFwieFwiLCBpbmZvLCB0aW1lKTtcbiAgICB1cGRhdGVBeGlzSW5mbyhlbGVtZW50LCBcInlcIiwgaW5mbywgdGltZSk7XG4gICAgaW5mby50aW1lID0gdGltZTtcbn1cblxuZXhwb3J0IHsgY3JlYXRlU2Nyb2xsSW5mbywgdXBkYXRlU2Nyb2xsSW5mbyB9O1xuIiwiY29uc3Qgbm9vcCA9ICgpID0+IHsgfTtcbmNvbnN0IG5vb3BSZXR1cm4gPSAodikgPT4gdjtcblxuZXhwb3J0IHsgbm9vcCwgbm9vcFJldHVybiB9O1xuIiwiY29uc3QgbWl4ID0gKG1pbiwgbWF4LCBwcm9ncmVzcykgPT4gLXByb2dyZXNzICogbWluICsgcHJvZ3Jlc3MgKiBtYXggKyBtaW47XG5cbmV4cG9ydCB7IG1peCB9O1xuIiwiaW1wb3J0IHsgbWl4IH0gZnJvbSAnLi9taXguZXMuanMnO1xuaW1wb3J0IHsgcHJvZ3Jlc3MgfSBmcm9tICcuL3Byb2dyZXNzLmVzLmpzJztcblxuZnVuY3Rpb24gZmlsbE9mZnNldChvZmZzZXQsIHJlbWFpbmluZykge1xuICAgIGNvbnN0IG1pbiA9IG9mZnNldFtvZmZzZXQubGVuZ3RoIC0gMV07XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gcmVtYWluaW5nOyBpKyspIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0UHJvZ3Jlc3MgPSBwcm9ncmVzcygwLCByZW1haW5pbmcsIGkpO1xuICAgICAgICBvZmZzZXQucHVzaChtaXgobWluLCAxLCBvZmZzZXRQcm9ncmVzcykpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGRlZmF1bHRPZmZzZXQobGVuZ3RoKSB7XG4gICAgY29uc3Qgb2Zmc2V0ID0gWzBdO1xuICAgIGZpbGxPZmZzZXQob2Zmc2V0LCBsZW5ndGggLSAxKTtcbiAgICByZXR1cm4gb2Zmc2V0O1xufVxuXG5leHBvcnQgeyBkZWZhdWx0T2Zmc2V0LCBmaWxsT2Zmc2V0IH07XG4iLCJjb25zdCBpc051bWJlciA9ICh2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiO1xuXG5leHBvcnQgeyBpc051bWJlciB9O1xuIiwiaW1wb3J0IHsgaXNOdW1iZXIgfSBmcm9tICcuL2lzLW51bWJlci5lcy5qcyc7XG5cbmNvbnN0IGlzRWFzaW5nTGlzdCA9IChlYXNpbmcpID0+IEFycmF5LmlzQXJyYXkoZWFzaW5nKSAmJiAhaXNOdW1iZXIoZWFzaW5nWzBdKTtcblxuZXhwb3J0IHsgaXNFYXNpbmdMaXN0IH07XG4iLCJjb25zdCB3cmFwID0gKG1pbiwgbWF4LCB2KSA9PiB7XG4gICAgY29uc3QgcmFuZ2VTaXplID0gbWF4IC0gbWluO1xuICAgIHJldHVybiAoKCgodiAtIG1pbikgJSByYW5nZVNpemUpICsgcmFuZ2VTaXplKSAlIHJhbmdlU2l6ZSkgKyBtaW47XG59O1xuXG5leHBvcnQgeyB3cmFwIH07XG4iLCJpbXBvcnQgeyBpc0Vhc2luZ0xpc3QgfSBmcm9tICcuL2lzLWVhc2luZy1saXN0LmVzLmpzJztcbmltcG9ydCB7IHdyYXAgfSBmcm9tICcuL3dyYXAuZXMuanMnO1xuXG5mdW5jdGlvbiBnZXRFYXNpbmdGb3JTZWdtZW50KGVhc2luZywgaSkge1xuICAgIHJldHVybiBpc0Vhc2luZ0xpc3QoZWFzaW5nKVxuICAgICAgICA/IGVhc2luZ1t3cmFwKDAsIGVhc2luZy5sZW5ndGgsIGkpXVxuICAgICAgICA6IGVhc2luZztcbn1cblxuZXhwb3J0IHsgZ2V0RWFzaW5nRm9yU2VnbWVudCB9O1xuIiwiY29uc3QgY2xhbXAgPSAobWluLCBtYXgsIHYpID0+IE1hdGgubWluKE1hdGgubWF4KHYsIG1pbiksIG1heCk7XG5cbmV4cG9ydCB7IGNsYW1wIH07XG4iLCJpbXBvcnQgeyBtaXggfSBmcm9tICcuL21peC5lcy5qcyc7XG5pbXBvcnQgeyBub29wUmV0dXJuIH0gZnJvbSAnLi9ub29wLmVzLmpzJztcbmltcG9ydCB7IGZpbGxPZmZzZXQsIGRlZmF1bHRPZmZzZXQgfSBmcm9tICcuL29mZnNldC5lcy5qcyc7XG5pbXBvcnQgeyBwcm9ncmVzcyB9IGZyb20gJy4vcHJvZ3Jlc3MuZXMuanMnO1xuaW1wb3J0IHsgZ2V0RWFzaW5nRm9yU2VnbWVudCB9IGZyb20gJy4vZWFzaW5nLmVzLmpzJztcbmltcG9ydCB7IGNsYW1wIH0gZnJvbSAnLi9jbGFtcC5lcy5qcyc7XG5cbmZ1bmN0aW9uIGludGVycG9sYXRlKG91dHB1dCwgaW5wdXQgPSBkZWZhdWx0T2Zmc2V0KG91dHB1dC5sZW5ndGgpLCBlYXNpbmcgPSBub29wUmV0dXJuKSB7XG4gICAgY29uc3QgbGVuZ3RoID0gb3V0cHV0Lmxlbmd0aDtcbiAgICAvKipcbiAgICAgKiBJZiB0aGUgaW5wdXQgbGVuZ3RoIGlzIGxvd2VyIHRoYW4gdGhlIG91dHB1dCB3ZVxuICAgICAqIGZpbGwgdGhlIGlucHV0IHRvIG1hdGNoLiBUaGlzIGN1cnJlbnRseSBhc3N1bWVzIHRoZSBpbnB1dFxuICAgICAqIGlzIGFuIGFuaW1hdGlvbiBwcm9ncmVzcyB2YWx1ZSBzbyBpcyBhIGdvb2QgY2FuZGlkYXRlIGZvclxuICAgICAqIG1vdmluZyBvdXRzaWRlIHRoZSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBjb25zdCByZW1haW5kZXIgPSBsZW5ndGggLSBpbnB1dC5sZW5ndGg7XG4gICAgcmVtYWluZGVyID4gMCAmJiBmaWxsT2Zmc2V0KGlucHV0LCByZW1haW5kZXIpO1xuICAgIHJldHVybiAodCkgPT4ge1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIGZvciAoOyBpIDwgbGVuZ3RoIC0gMjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodCA8IGlucHV0W2kgKyAxXSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBsZXQgcHJvZ3Jlc3NJblJhbmdlID0gY2xhbXAoMCwgMSwgcHJvZ3Jlc3MoaW5wdXRbaV0sIGlucHV0W2kgKyAxXSwgdCkpO1xuICAgICAgICBjb25zdCBzZWdtZW50RWFzaW5nID0gZ2V0RWFzaW5nRm9yU2VnbWVudChlYXNpbmcsIGkpO1xuICAgICAgICBwcm9ncmVzc0luUmFuZ2UgPSBzZWdtZW50RWFzaW5nKHByb2dyZXNzSW5SYW5nZSk7XG4gICAgICAgIHJldHVybiBtaXgob3V0cHV0W2ldLCBvdXRwdXRbaSArIDFdLCBwcm9ncmVzc0luUmFuZ2UpO1xuICAgIH07XG59XG5cbmV4cG9ydCB7IGludGVycG9sYXRlIH07XG4iLCJmdW5jdGlvbiBjYWxjSW5zZXQoZWxlbWVudCwgY29udGFpbmVyKSB7XG4gICAgbGV0IGluc2V0ID0geyB4OiAwLCB5OiAwIH07XG4gICAgbGV0IGN1cnJlbnQgPSBlbGVtZW50O1xuICAgIHdoaWxlIChjdXJyZW50ICYmIGN1cnJlbnQgIT09IGNvbnRhaW5lcikge1xuICAgICAgICBpZiAoY3VycmVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICAgICAgICBpbnNldC54ICs9IGN1cnJlbnQub2Zmc2V0TGVmdDtcbiAgICAgICAgICAgIGluc2V0LnkgKz0gY3VycmVudC5vZmZzZXRUb3A7XG4gICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5vZmZzZXRQYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY3VycmVudCBpbnN0YW5jZW9mIFNWR0dyYXBoaWNzRWxlbWVudCAmJiBcImdldEJCb3hcIiBpbiBjdXJyZW50KSB7XG4gICAgICAgICAgICBjb25zdCB7IHRvcCwgbGVmdCB9ID0gY3VycmVudC5nZXRCQm94KCk7XG4gICAgICAgICAgICBpbnNldC54ICs9IGxlZnQ7XG4gICAgICAgICAgICBpbnNldC55ICs9IHRvcDtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQXNzaWduIHRoZSBuZXh0IHBhcmVudCBlbGVtZW50IGFzIHRoZSA8c3ZnIC8+IHRhZy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgd2hpbGUgKGN1cnJlbnQgJiYgY3VycmVudC50YWdOYW1lICE9PSBcInN2Z1wiKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50Tm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaW5zZXQ7XG59XG5cbmV4cG9ydCB7IGNhbGNJbnNldCB9O1xuIiwiY29uc3QgU2Nyb2xsT2Zmc2V0ID0ge1xuICAgIEVudGVyOiBbXG4gICAgICAgIFswLCAxXSxcbiAgICAgICAgWzEsIDFdLFxuICAgIF0sXG4gICAgRXhpdDogW1xuICAgICAgICBbMCwgMF0sXG4gICAgICAgIFsxLCAwXSxcbiAgICBdLFxuICAgIEFueTogW1xuICAgICAgICBbMSwgMF0sXG4gICAgICAgIFswLCAxXSxcbiAgICBdLFxuICAgIEFsbDogW1xuICAgICAgICBbMCwgMF0sXG4gICAgICAgIFsxLCAxXSxcbiAgICBdLFxufTtcblxuZXhwb3J0IHsgU2Nyb2xsT2Zmc2V0IH07XG4iLCJjb25zdCBpc1N0cmluZyA9ICh2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiO1xuXG5leHBvcnQgeyBpc1N0cmluZyB9O1xuIiwiaW1wb3J0IHsgaXNTdHJpbmcsIGlzTnVtYmVyIH0gZnJvbSAnQG1vdGlvbm9uZS91dGlscyc7XG5cbmNvbnN0IG5hbWVkRWRnZXMgPSB7XG4gICAgc3RhcnQ6IDAsXG4gICAgY2VudGVyOiAwLjUsXG4gICAgZW5kOiAxLFxufTtcbmZ1bmN0aW9uIHJlc29sdmVFZGdlKGVkZ2UsIGxlbmd0aCwgaW5zZXQgPSAwKSB7XG4gICAgbGV0IGRlbHRhID0gMDtcbiAgICAvKipcbiAgICAgKiBJZiB3ZSBoYXZlIHRoaXMgZWRnZSBkZWZpbmVkIGFzIGEgcHJlc2V0LCByZXBsYWNlIHRoZSBkZWZpbml0aW9uXG4gICAgICogd2l0aCB0aGUgbnVtZXJpY2FsIHZhbHVlLlxuICAgICAqL1xuICAgIGlmIChuYW1lZEVkZ2VzW2VkZ2VdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZWRnZSA9IG5hbWVkRWRnZXNbZWRnZV07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZSB1bml0IHZhbHVlc1xuICAgICAqL1xuICAgIGlmIChpc1N0cmluZyhlZGdlKSkge1xuICAgICAgICBjb25zdCBhc051bWJlciA9IHBhcnNlRmxvYXQoZWRnZSk7XG4gICAgICAgIGlmIChlZGdlLmVuZHNXaXRoKFwicHhcIikpIHtcbiAgICAgICAgICAgIGRlbHRhID0gYXNOdW1iZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZWRnZS5lbmRzV2l0aChcIiVcIikpIHtcbiAgICAgICAgICAgIGVkZ2UgPSBhc051bWJlciAvIDEwMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlZGdlLmVuZHNXaXRoKFwidndcIikpIHtcbiAgICAgICAgICAgIGRlbHRhID0gKGFzTnVtYmVyIC8gMTAwKSAqIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlZGdlLmVuZHNXaXRoKFwidmhcIikpIHtcbiAgICAgICAgICAgIGRlbHRhID0gKGFzTnVtYmVyIC8gMTAwKSAqIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlZGdlID0gYXNOdW1iZXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSWYgdGhlIGVkZ2UgaXMgZGVmaW5lZCBhcyBhIG51bWJlciwgaGFuZGxlIGFzIGEgcHJvZ3Jlc3MgdmFsdWUuXG4gICAgICovXG4gICAgaWYgKGlzTnVtYmVyKGVkZ2UpKSB7XG4gICAgICAgIGRlbHRhID0gbGVuZ3RoICogZWRnZTtcbiAgICB9XG4gICAgcmV0dXJuIGluc2V0ICsgZGVsdGE7XG59XG5cbmV4cG9ydCB7IG5hbWVkRWRnZXMsIHJlc29sdmVFZGdlIH07XG4iLCJpbXBvcnQgeyBpc051bWJlciwgaXNTdHJpbmcgfSBmcm9tICdAbW90aW9ub25lL3V0aWxzJztcbmltcG9ydCB7IHJlc29sdmVFZGdlLCBuYW1lZEVkZ2VzIH0gZnJvbSAnLi9lZGdlLmVzLmpzJztcblxuY29uc3QgZGVmYXVsdE9mZnNldCA9IFswLCAwXTtcbmZ1bmN0aW9uIHJlc29sdmVPZmZzZXQob2Zmc2V0LCBjb250YWluZXJMZW5ndGgsIHRhcmdldExlbmd0aCwgdGFyZ2V0SW5zZXQpIHtcbiAgICBsZXQgb2Zmc2V0RGVmaW5pdGlvbiA9IEFycmF5LmlzQXJyYXkob2Zmc2V0KSA/IG9mZnNldCA6IGRlZmF1bHRPZmZzZXQ7XG4gICAgbGV0IHRhcmdldFBvaW50ID0gMDtcbiAgICBsZXQgY29udGFpbmVyUG9pbnQgPSAwO1xuICAgIGlmIChpc051bWJlcihvZmZzZXQpKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB3ZSdyZSBwcm92aWRlZCBvZmZzZXQ6IFswLCAwLjUsIDFdIHRoZW4gZWFjaCBudW1iZXIgeCBzaG91bGQgYmVjb21lXG4gICAgICAgICAqIFt4LCB4XSwgc28gd2UgZGVmYXVsdCB0byB0aGUgYmVoYXZpb3VyIG9mIG1hcHBpbmcgMCA9PiAwIG9mIGJvdGggdGFyZ2V0XG4gICAgICAgICAqIGFuZCBjb250YWluZXIgZXRjLlxuICAgICAgICAgKi9cbiAgICAgICAgb2Zmc2V0RGVmaW5pdGlvbiA9IFtvZmZzZXQsIG9mZnNldF07XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzU3RyaW5nKG9mZnNldCkpIHtcbiAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0LnRyaW0oKTtcbiAgICAgICAgaWYgKG9mZnNldC5pbmNsdWRlcyhcIiBcIikpIHtcbiAgICAgICAgICAgIG9mZnNldERlZmluaXRpb24gPSBvZmZzZXQuc3BsaXQoXCIgXCIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJZiB3ZSdyZSBwcm92aWRlZCBhIGRlZmluaXRpb24gbGlrZSBcIjEwMHB4XCIgdGhlbiB3ZSB3YW50IHRvIGFwcGx5XG4gICAgICAgICAgICAgKiB0aGF0IG9ubHkgdG8gdGhlIHRvcCBvZiB0aGUgdGFyZ2V0IHBvaW50LCBsZWF2aW5nIHRoZSBjb250YWluZXIgYXQgMC5cbiAgICAgICAgICAgICAqIFdoZXJlYXMgYSBuYW1lZCBvZmZzZXQgbGlrZSBcImVuZFwiIHNob3VsZCBiZSBhcHBsaWVkIHRvIGJvdGguXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIG9mZnNldERlZmluaXRpb24gPSBbb2Zmc2V0LCBuYW1lZEVkZ2VzW29mZnNldF0gPyBvZmZzZXQgOiBgMGBdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRhcmdldFBvaW50ID0gcmVzb2x2ZUVkZ2Uob2Zmc2V0RGVmaW5pdGlvblswXSwgdGFyZ2V0TGVuZ3RoLCB0YXJnZXRJbnNldCk7XG4gICAgY29udGFpbmVyUG9pbnQgPSByZXNvbHZlRWRnZShvZmZzZXREZWZpbml0aW9uWzFdLCBjb250YWluZXJMZW5ndGgpO1xuICAgIHJldHVybiB0YXJnZXRQb2ludCAtIGNvbnRhaW5lclBvaW50O1xufVxuXG5leHBvcnQgeyByZXNvbHZlT2Zmc2V0IH07XG4iLCJpbXBvcnQgeyBpbnRlcnBvbGF0ZSwgZGVmYXVsdE9mZnNldCB9IGZyb20gJ0Btb3Rpb25vbmUvdXRpbHMnO1xuaW1wb3J0IHsgY2FsY0luc2V0IH0gZnJvbSAnLi9pbnNldC5lcy5qcyc7XG5pbXBvcnQgeyBTY3JvbGxPZmZzZXQgfSBmcm9tICcuL3ByZXNldHMuZXMuanMnO1xuaW1wb3J0IHsgcmVzb2x2ZU9mZnNldCB9IGZyb20gJy4vb2Zmc2V0LmVzLmpzJztcblxuY29uc3QgcG9pbnQgPSB7IHg6IDAsIHk6IDAgfTtcbmZ1bmN0aW9uIHJlc29sdmVPZmZzZXRzKGNvbnRhaW5lciwgaW5mbywgb3B0aW9ucykge1xuICAgIGxldCB7IG9mZnNldDogb2Zmc2V0RGVmaW5pdGlvbiA9IFNjcm9sbE9mZnNldC5BbGwgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgeyB0YXJnZXQgPSBjb250YWluZXIsIGF4aXMgPSBcInlcIiB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBsZW5ndGhMYWJlbCA9IGF4aXMgPT09IFwieVwiID8gXCJoZWlnaHRcIiA6IFwid2lkdGhcIjtcbiAgICBjb25zdCBpbnNldCA9IHRhcmdldCAhPT0gY29udGFpbmVyID8gY2FsY0luc2V0KHRhcmdldCwgY29udGFpbmVyKSA6IHBvaW50O1xuICAgIC8qKlxuICAgICAqIE1lYXN1cmUgdGhlIHRhcmdldCBhbmQgY29udGFpbmVyLiBJZiB0aGV5J3JlIHRoZSBzYW1lIHRoaW5nIHRoZW4gd2VcbiAgICAgKiB1c2UgdGhlIGNvbnRhaW5lcidzIHNjcm9sbFdpZHRoL0hlaWdodCBhcyB0aGUgdGFyZ2V0LCBmcm9tIHRoZXJlXG4gICAgICogYWxsIG90aGVyIGNhbGN1bGF0aW9ucyBjYW4gcmVtYWluIHRoZSBzYW1lLlxuICAgICAqL1xuICAgIGNvbnN0IHRhcmdldFNpemUgPSB0YXJnZXQgPT09IGNvbnRhaW5lclxuICAgICAgICA/IHsgd2lkdGg6IGNvbnRhaW5lci5zY3JvbGxXaWR0aCwgaGVpZ2h0OiBjb250YWluZXIuc2Nyb2xsSGVpZ2h0IH1cbiAgICAgICAgOiB7IHdpZHRoOiB0YXJnZXQuY2xpZW50V2lkdGgsIGhlaWdodDogdGFyZ2V0LmNsaWVudEhlaWdodCB9O1xuICAgIGNvbnN0IGNvbnRhaW5lclNpemUgPSB7XG4gICAgICAgIHdpZHRoOiBjb250YWluZXIuY2xpZW50V2lkdGgsXG4gICAgICAgIGhlaWdodDogY29udGFpbmVyLmNsaWVudEhlaWdodCxcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJlc2V0IHRoZSBsZW5ndGggb2YgdGhlIHJlc29sdmVkIG9mZnNldCBhcnJheSByYXRoZXIgdGhhbiBjcmVhdGluZyBhIG5ldyBvbmUuXG4gICAgICogVE9ETzogTW9yZSByZXVzYWJsZSBkYXRhIHN0cnVjdHVyZXMgZm9yIHRhcmdldFNpemUvY29udGFpbmVyU2l6ZSB3b3VsZCBhbHNvIGJlIGdvb2QuXG4gICAgICovXG4gICAgaW5mb1theGlzXS5vZmZzZXQubGVuZ3RoID0gMDtcbiAgICAvKipcbiAgICAgKiBQb3B1bGF0ZSB0aGUgb2Zmc2V0IGFycmF5IGJ5IHJlc29sdmluZyB0aGUgdXNlcidzIG9mZnNldCBkZWZpbml0aW9uIGludG9cbiAgICAgKiBhIGxpc3Qgb2YgcGl4ZWwgc2Nyb2xsIG9mZmV0cy5cbiAgICAgKi9cbiAgICBsZXQgaGFzQ2hhbmdlZCA9ICFpbmZvW2F4aXNdLmludGVycG9sYXRlO1xuICAgIGNvbnN0IG51bU9mZnNldHMgPSBvZmZzZXREZWZpbml0aW9uLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bU9mZnNldHM7IGkrKykge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSByZXNvbHZlT2Zmc2V0KG9mZnNldERlZmluaXRpb25baV0sIGNvbnRhaW5lclNpemVbbGVuZ3RoTGFiZWxdLCB0YXJnZXRTaXplW2xlbmd0aExhYmVsXSwgaW5zZXRbYXhpc10pO1xuICAgICAgICBpZiAoIWhhc0NoYW5nZWQgJiYgb2Zmc2V0ICE9PSBpbmZvW2F4aXNdLmludGVycG9sYXRvck9mZnNldHNbaV0pIHtcbiAgICAgICAgICAgIGhhc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGluZm9bYXhpc10ub2Zmc2V0W2ldID0gb2Zmc2V0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJZiB0aGUgcGl4ZWwgc2Nyb2xsIG9mZnNldHMgaGF2ZSBjaGFuZ2VkLCBjcmVhdGUgYSBuZXcgaW50ZXJwb2xhdG9yIGZ1bmN0aW9uXG4gICAgICogdG8gbWFwIHNjcm9sbCB2YWx1ZSBpbnRvIGEgcHJvZ3Jlc3MuXG4gICAgICovXG4gICAgaWYgKGhhc0NoYW5nZWQpIHtcbiAgICAgICAgaW5mb1theGlzXS5pbnRlcnBvbGF0ZSA9IGludGVycG9sYXRlKGRlZmF1bHRPZmZzZXQobnVtT2Zmc2V0cyksIGluZm9bYXhpc10ub2Zmc2V0KTtcbiAgICAgICAgaW5mb1theGlzXS5pbnRlcnBvbGF0b3JPZmZzZXRzID0gWy4uLmluZm9bYXhpc10ub2Zmc2V0XTtcbiAgICB9XG4gICAgaW5mb1theGlzXS5wcm9ncmVzcyA9IGluZm9bYXhpc10uaW50ZXJwb2xhdGUoaW5mb1theGlzXS5jdXJyZW50KTtcbn1cblxuZXhwb3J0IHsgcmVzb2x2ZU9mZnNldHMgfTtcbiIsImltcG9ydCB7IG5vb3BSZXR1cm4gfSBmcm9tICdAbW90aW9ub25lL3V0aWxzJztcbmltcG9ydCB7IHVwZGF0ZVNjcm9sbEluZm8gfSBmcm9tICcuL2luZm8uZXMuanMnO1xuaW1wb3J0IHsgcmVzb2x2ZU9mZnNldHMgfSBmcm9tICcuL29mZnNldHMvaW5kZXguZXMuanMnO1xuXG5mdW5jdGlvbiBtZWFzdXJlKGNvbnRhaW5lciwgdGFyZ2V0ID0gY29udGFpbmVyLCBpbmZvKSB7XG4gICAgLyoqXG4gICAgICogRmluZCBpbnNldCBvZiB0YXJnZXQgd2l0aGluIHNjcm9sbGFibGUgY29udGFpbmVyXG4gICAgICovXG4gICAgaW5mby54LnRhcmdldE9mZnNldCA9IDA7XG4gICAgaW5mby55LnRhcmdldE9mZnNldCA9IDA7XG4gICAgaWYgKHRhcmdldCAhPT0gY29udGFpbmVyKSB7XG4gICAgICAgIGxldCBub2RlID0gdGFyZ2V0O1xuICAgICAgICB3aGlsZSAobm9kZSAmJiBub2RlICE9IGNvbnRhaW5lcikge1xuICAgICAgICAgICAgaW5mby54LnRhcmdldE9mZnNldCArPSBub2RlLm9mZnNldExlZnQ7XG4gICAgICAgICAgICBpbmZvLnkudGFyZ2V0T2Zmc2V0ICs9IG5vZGUub2Zmc2V0VG9wO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUub2Zmc2V0UGFyZW50O1xuICAgICAgICB9XG4gICAgfVxuICAgIGluZm8ueC50YXJnZXRMZW5ndGggPVxuICAgICAgICB0YXJnZXQgPT09IGNvbnRhaW5lciA/IHRhcmdldC5zY3JvbGxXaWR0aCA6IHRhcmdldC5jbGllbnRXaWR0aDtcbiAgICBpbmZvLnkudGFyZ2V0TGVuZ3RoID1cbiAgICAgICAgdGFyZ2V0ID09PSBjb250YWluZXIgPyB0YXJnZXQuc2Nyb2xsSGVpZ2h0IDogdGFyZ2V0LmNsaWVudEhlaWdodDtcbiAgICBpbmZvLnguY29udGFpbmVyTGVuZ3RoID0gY29udGFpbmVyLmNsaWVudFdpZHRoO1xuICAgIGluZm8ueS5jb250YWluZXJMZW5ndGggPSBjb250YWluZXIuY2xpZW50SGVpZ2h0O1xufVxuZnVuY3Rpb24gY3JlYXRlT25TY3JvbGxIYW5kbGVyKGVsZW1lbnQsIG9uU2Nyb2xsLCBpbmZvLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBheGlzID0gb3B0aW9ucy5heGlzIHx8IFwieVwiO1xuICAgIHJldHVybiB7XG4gICAgICAgIG1lYXN1cmU6ICgpID0+IG1lYXN1cmUoZWxlbWVudCwgb3B0aW9ucy50YXJnZXQsIGluZm8pLFxuICAgICAgICB1cGRhdGU6ICh0aW1lKSA9PiB7XG4gICAgICAgICAgICB1cGRhdGVTY3JvbGxJbmZvKGVsZW1lbnQsIGluZm8sIHRpbWUpO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMub2Zmc2V0IHx8IG9wdGlvbnMudGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZU9mZnNldHMoZWxlbWVudCwgaW5mbywgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG5vdGlmeTogdHlwZW9mIG9uU2Nyb2xsID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICAgID8gKCkgPT4gb25TY3JvbGwoaW5mbylcbiAgICAgICAgICAgIDogc2NydWJBbmltYXRpb24ob25TY3JvbGwsIGluZm9bYXhpc10pLFxuICAgIH07XG59XG5mdW5jdGlvbiBzY3J1YkFuaW1hdGlvbihjb250cm9scywgYXhpc0luZm8pIHtcbiAgICBjb250cm9scy5wYXVzZSgpO1xuICAgIGNvbnRyb2xzLmZvckVhY2hOYXRpdmUoKGFuaW1hdGlvbiwgeyBlYXNpbmcgfSkgPT4ge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBpZiAoYW5pbWF0aW9uLnVwZGF0ZUR1cmF0aW9uKSB7XG4gICAgICAgICAgICBpZiAoIWVhc2luZylcbiAgICAgICAgICAgICAgICBhbmltYXRpb24uZWFzaW5nID0gbm9vcFJldHVybjtcbiAgICAgICAgICAgIGFuaW1hdGlvbi51cGRhdGVEdXJhdGlvbigxKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHRpbWluZ09wdGlvbnMgPSB7IGR1cmF0aW9uOiAxMDAwIH07XG4gICAgICAgICAgICBpZiAoIWVhc2luZylcbiAgICAgICAgICAgICAgICB0aW1pbmdPcHRpb25zLmVhc2luZyA9IFwibGluZWFyXCI7XG4gICAgICAgICAgICAoX2IgPSAoX2EgPSBhbmltYXRpb24uZWZmZWN0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudXBkYXRlVGltaW5nKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgdGltaW5nT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBjb250cm9scy5jdXJyZW50VGltZSA9IGF4aXNJbmZvLnByb2dyZXNzO1xuICAgIH07XG59XG5cbmV4cG9ydCB7IGNyZWF0ZU9uU2Nyb2xsSGFuZGxlciB9O1xuIiwiaW1wb3J0IHsgX19yZXN0IH0gZnJvbSAndHNsaWInO1xuaW1wb3J0IHsgcmVzaXplIH0gZnJvbSAnLi4vcmVzaXplL2luZGV4LmVzLmpzJztcbmltcG9ydCB7IGNyZWF0ZVNjcm9sbEluZm8gfSBmcm9tICcuL2luZm8uZXMuanMnO1xuaW1wb3J0IHsgY3JlYXRlT25TY3JvbGxIYW5kbGVyIH0gZnJvbSAnLi9vbi1zY3JvbGwtaGFuZGxlci5lcy5qcyc7XG5cbmNvbnN0IHNjcm9sbExpc3RlbmVycyA9IG5ldyBXZWFrTWFwKCk7XG5jb25zdCByZXNpemVMaXN0ZW5lcnMgPSBuZXcgV2Vha01hcCgpO1xuY29uc3Qgb25TY3JvbGxIYW5kbGVycyA9IG5ldyBXZWFrTWFwKCk7XG5jb25zdCBnZXRFdmVudFRhcmdldCA9IChlbGVtZW50KSA9PiBlbGVtZW50ID09PSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgPyB3aW5kb3cgOiBlbGVtZW50O1xuZnVuY3Rpb24gc2Nyb2xsKG9uU2Nyb2xsLCBfYSA9IHt9KSB7XG4gICAgdmFyIHsgY29udGFpbmVyID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50IH0gPSBfYSwgb3B0aW9ucyA9IF9fcmVzdChfYSwgW1wiY29udGFpbmVyXCJdKTtcbiAgICBsZXQgY29udGFpbmVySGFuZGxlcnMgPSBvblNjcm9sbEhhbmRsZXJzLmdldChjb250YWluZXIpO1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgb25TY3JvbGwgaGFuZGxlcnMgZm9yIHRoaXMgY29udGFpbmVyLlxuICAgICAqIElmIG9uZSBpc24ndCBmb3VuZCwgY3JlYXRlIGEgbmV3IG9uZS5cbiAgICAgKi9cbiAgICBpZiAoIWNvbnRhaW5lckhhbmRsZXJzKSB7XG4gICAgICAgIGNvbnRhaW5lckhhbmRsZXJzID0gbmV3IFNldCgpO1xuICAgICAgICBvblNjcm9sbEhhbmRsZXJzLnNldChjb250YWluZXIsIGNvbnRhaW5lckhhbmRsZXJzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IG9uU2Nyb2xsIGhhbmRsZXIgZm9yIHRoZSBwcm92aWRlZCBjYWxsYmFjay5cbiAgICAgKi9cbiAgICBjb25zdCBpbmZvID0gY3JlYXRlU2Nyb2xsSW5mbygpO1xuICAgIGNvbnN0IGNvbnRhaW5lckhhbmRsZXIgPSBjcmVhdGVPblNjcm9sbEhhbmRsZXIoY29udGFpbmVyLCBvblNjcm9sbCwgaW5mbywgb3B0aW9ucyk7XG4gICAgY29udGFpbmVySGFuZGxlcnMuYWRkKGNvbnRhaW5lckhhbmRsZXIpO1xuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZXJlJ3MgYSBzY3JvbGwgZXZlbnQgbGlzdGVuZXIgZm9yIHRoaXMgY29udGFpbmVyLlxuICAgICAqIElmIG5vdCwgY3JlYXRlIG9uZS5cbiAgICAgKi9cbiAgICBpZiAoIXNjcm9sbExpc3RlbmVycy5oYXMoY29udGFpbmVyKSkge1xuICAgICAgICBjb25zdCBsaXN0ZW5lciA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaGFuZGxlciBvZiBjb250YWluZXJIYW5kbGVycylcbiAgICAgICAgICAgICAgICBoYW5kbGVyLm1lYXN1cmUoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaGFuZGxlciBvZiBjb250YWluZXJIYW5kbGVycylcbiAgICAgICAgICAgICAgICBoYW5kbGVyLnVwZGF0ZSh0aW1lKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaGFuZGxlciBvZiBjb250YWluZXJIYW5kbGVycylcbiAgICAgICAgICAgICAgICBoYW5kbGVyLm5vdGlmeSgpO1xuICAgICAgICB9O1xuICAgICAgICBzY3JvbGxMaXN0ZW5lcnMuc2V0KGNvbnRhaW5lciwgbGlzdGVuZXIpO1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBnZXRFdmVudFRhcmdldChjb250YWluZXIpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCBsaXN0ZW5lciwgeyBwYXNzaXZlOiB0cnVlIH0pO1xuICAgICAgICBpZiAoY29udGFpbmVyICE9PSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJlc2l6ZUxpc3RlbmVycy5zZXQoY29udGFpbmVyLCByZXNpemUoY29udGFpbmVyLCBsaXN0ZW5lcikpO1xuICAgICAgICB9XG4gICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIGxpc3RlbmVyLCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgfVxuICAgIGNvbnN0IGxpc3RlbmVyID0gc2Nyb2xsTGlzdGVuZXJzLmdldChjb250YWluZXIpO1xuICAgIGNvbnN0IG9uTG9hZFByb2Nlc3NzID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGxpc3RlbmVyKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICh0eXBlb2Ygb25TY3JvbGwgIT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgIG9uU2Nyb2xsLnN0b3AoKTtcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUob25Mb2FkUHJvY2Vzc3MpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2hlY2sgaWYgd2UgZXZlbiBoYXZlIGFueSBoYW5kbGVycyBmb3IgdGhpcyBjb250YWluZXIuXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBjb250YWluZXJIYW5kbGVycyA9IG9uU2Nyb2xsSGFuZGxlcnMuZ2V0KGNvbnRhaW5lcik7XG4gICAgICAgIGlmICghY29udGFpbmVySGFuZGxlcnMpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnRhaW5lckhhbmRsZXJzLmRlbGV0ZShjb250YWluZXJIYW5kbGVyKTtcbiAgICAgICAgaWYgKGNvbnRhaW5lckhhbmRsZXJzLnNpemUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBubyBtb3JlIGhhbmRsZXJzLCByZW1vdmUgdGhlIHNjcm9sbCBsaXN0ZW5lciB0b28uXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBsaXN0ZW5lciA9IHNjcm9sbExpc3RlbmVycy5nZXQoY29udGFpbmVyKTtcbiAgICAgICAgc2Nyb2xsTGlzdGVuZXJzLmRlbGV0ZShjb250YWluZXIpO1xuICAgICAgICBpZiAobGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGdldEV2ZW50VGFyZ2V0KGNvbnRhaW5lcikucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCBsaXN0ZW5lcik7XG4gICAgICAgICAgICAoX2EgPSByZXNpemVMaXN0ZW5lcnMuZ2V0KGNvbnRhaW5lcikpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYSgpO1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgbGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuZXhwb3J0IHsgc2Nyb2xsIH07XG4iLCJpbXBvcnQgeyBfX3Jlc3QsIF9fYXNzaWduIH0gZnJvbSAndHNsaWInO1xuaW1wb3J0IHsgc2Nyb2xsIH0gZnJvbSAnQG1vdGlvbm9uZS9kb20nO1xuaW1wb3J0IHsgbW90aW9uVmFsdWUgfSBmcm9tICcuL2luZGV4Lm1qcyc7XG5pbXBvcnQgeyB1c2VDb25zdGFudCB9IGZyb20gJy4uL3V0aWxzL3VzZS1jb25zdGFudC5tanMnO1xuaW1wb3J0IHsgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCB9IGZyb20gJy4uL3V0aWxzL3VzZS1pc29tb3JwaGljLWVmZmVjdC5tanMnO1xuXG52YXIgY3JlYXRlU2Nyb2xsTW90aW9uVmFsdWVzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKHtcbiAgICBzY3JvbGxYOiBtb3Rpb25WYWx1ZSgwKSxcbiAgICBzY3JvbGxZOiBtb3Rpb25WYWx1ZSgwKSxcbiAgICBzY3JvbGxYUHJvZ3Jlc3M6IG1vdGlvblZhbHVlKDApLFxuICAgIHNjcm9sbFlQcm9ncmVzczogbW90aW9uVmFsdWUoMCksXG59KTsgfTtcbmZ1bmN0aW9uIHVzZVNjcm9sbChfYSkge1xuICAgIGlmIChfYSA9PT0gdm9pZCAwKSB7IF9hID0ge307IH1cbiAgICB2YXIgY29udGFpbmVyID0gX2EuY29udGFpbmVyLCB0YXJnZXQgPSBfYS50YXJnZXQsIG9wdGlvbnMgPSBfX3Jlc3QoX2EsIFtcImNvbnRhaW5lclwiLCBcInRhcmdldFwiXSk7XG4gICAgdmFyIHZhbHVlcyA9IHVzZUNvbnN0YW50KGNyZWF0ZVNjcm9sbE1vdGlvblZhbHVlcyk7XG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBzY3JvbGwoZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgeCA9IF9hLngsIHkgPSBfYS55O1xuICAgICAgICAgICAgdmFsdWVzLnNjcm9sbFguc2V0KHguY3VycmVudCk7XG4gICAgICAgICAgICB2YWx1ZXMuc2Nyb2xsWFByb2dyZXNzLnNldCh4LnByb2dyZXNzKTtcbiAgICAgICAgICAgIHZhbHVlcy5zY3JvbGxZLnNldCh5LmN1cnJlbnQpO1xuICAgICAgICAgICAgdmFsdWVzLnNjcm9sbFlQcm9ncmVzcy5zZXQoeS5wcm9ncmVzcyk7XG4gICAgICAgIH0sIF9fYXNzaWduKF9fYXNzaWduKHt9LCBvcHRpb25zKSwgeyBjb250YWluZXI6IChjb250YWluZXIgPT09IG51bGwgfHwgY29udGFpbmVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb250YWluZXIuY3VycmVudCkgfHwgdW5kZWZpbmVkLCB0YXJnZXQ6ICh0YXJnZXQgPT09IG51bGwgfHwgdGFyZ2V0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0YXJnZXQuY3VycmVudCkgfHwgdW5kZWZpbmVkIH0pKTtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIHZhbHVlcztcbn1cblxuZXhwb3J0IHsgdXNlU2Nyb2xsIH07XG4iLCJpbXBvcnQgeyB3YXJuT25jZSB9IGZyb20gJy4uLy4uL3V0aWxzL3dhcm4tb25jZS5tanMnO1xuaW1wb3J0IHsgdXNlU2Nyb2xsIH0gZnJvbSAnLi4vdXNlLXNjcm9sbC5tanMnO1xuXG5mdW5jdGlvbiB1c2VFbGVtZW50U2Nyb2xsKHJlZikge1xuICAgIHdhcm5PbmNlKGZhbHNlLCBcInVzZUVsZW1lbnRTY3JvbGwgaXMgZGVwcmVjYXRlZC4gQ29udmVydCB0byB1c2VTY3JvbGwoeyBjb250YWluZXI6IHJlZiB9KS5cIik7XG4gICAgcmV0dXJuIHVzZVNjcm9sbCh7IGNvbnRhaW5lcjogcmVmIH0pO1xufVxuXG5leHBvcnQgeyB1c2VFbGVtZW50U2Nyb2xsIH07XG4iLCJpbXBvcnQgeyB3YXJuT25jZSB9IGZyb20gJy4uLy4uL3V0aWxzL3dhcm4tb25jZS5tanMnO1xuaW1wb3J0IHsgdXNlU2Nyb2xsIH0gZnJvbSAnLi4vdXNlLXNjcm9sbC5tanMnO1xuXG5mdW5jdGlvbiB1c2VWaWV3cG9ydFNjcm9sbCgpIHtcbiAgICB3YXJuT25jZShmYWxzZSwgXCJ1c2VWaWV3cG9ydFNjcm9sbCBpcyBkZXByZWNhdGVkLiBDb252ZXJ0IHRvIHVzZVNjcm9sbCgpLlwiKTtcbiAgICByZXR1cm4gdXNlU2Nyb2xsKCk7XG59XG5cbmV4cG9ydCB7IHVzZVZpZXdwb3J0U2Nyb2xsIH07XG4iLCJpbXBvcnQgc3luYywgeyBjYW5jZWxTeW5jIH0gZnJvbSAnZnJhbWVzeW5jJztcbmltcG9ydCB7IHVzZUNvbnRleHQsIHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZUNvbnN0YW50IH0gZnJvbSAnLi91c2UtY29uc3RhbnQubWpzJztcbmltcG9ydCB7IE1vdGlvbkNvbmZpZ0NvbnRleHQgfSBmcm9tICcuLi9jb250ZXh0L01vdGlvbkNvbmZpZ0NvbnRleHQubWpzJztcblxudmFyIGdldEN1cnJlbnRUaW1lID0gdHlwZW9mIHBlcmZvcm1hbmNlICE9PSBcInVuZGVmaW5lZFwiXG4gICAgPyBmdW5jdGlvbiAoKSB7IHJldHVybiBwZXJmb3JtYW5jZS5ub3coKTsgfVxuICAgIDogZnVuY3Rpb24gKCkgeyByZXR1cm4gRGF0ZS5ub3coKTsgfTtcbmZ1bmN0aW9uIHVzZUFuaW1hdGlvbkZyYW1lKGNhbGxiYWNrKSB7XG4gICAgdmFyIGluaXRpYWxUaW1lc3RhbXAgPSB1c2VDb25zdGFudChnZXRDdXJyZW50VGltZSk7XG4gICAgdmFyIGlzU3RhdGljID0gdXNlQ29udGV4dChNb3Rpb25Db25maWdDb250ZXh0KS5pc1N0YXRpYztcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaXNTdGF0aWMpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHZhciBwcm92aWRlVGltZVNpbmNlU3RhcnQgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgIHZhciB0aW1lc3RhbXAgPSBfYS50aW1lc3RhbXA7XG4gICAgICAgICAgICBjYWxsYmFjayh0aW1lc3RhbXAgLSBpbml0aWFsVGltZXN0YW1wKTtcbiAgICAgICAgfTtcbiAgICAgICAgc3luYy51cGRhdGUocHJvdmlkZVRpbWVTaW5jZVN0YXJ0LCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNhbmNlbFN5bmMudXBkYXRlKHByb3ZpZGVUaW1lU2luY2VTdGFydCk7IH07XG4gICAgfSwgW2NhbGxiYWNrXSk7XG59XG5cbmV4cG9ydCB7IHVzZUFuaW1hdGlvbkZyYW1lIH07XG4iLCJpbXBvcnQgeyB1c2VBbmltYXRpb25GcmFtZSB9IGZyb20gJy4uL3V0aWxzL3VzZS1hbmltYXRpb24tZnJhbWUubWpzJztcbmltcG9ydCB7IHVzZU1vdGlvblZhbHVlIH0gZnJvbSAnLi91c2UtbW90aW9uLXZhbHVlLm1qcyc7XG5cbmZ1bmN0aW9uIHVzZVRpbWUoKSB7XG4gICAgdmFyIHRpbWUgPSB1c2VNb3Rpb25WYWx1ZSgwKTtcbiAgICB1c2VBbmltYXRpb25GcmFtZShmdW5jdGlvbiAodCkgeyByZXR1cm4gdGltZS5zZXQodCk7IH0pO1xuICAgIHJldHVybiB0aW1lO1xufVxuXG5leHBvcnQgeyB1c2VUaW1lIH07XG4iLCJpbXBvcnQgeyBfX3NwcmVhZEFycmF5LCBfX3JlYWQgfSBmcm9tICd0c2xpYic7XG5pbXBvcnQgeyBpbnZhcmlhbnQgfSBmcm9tICdoZXktbGlzdGVuJztcbmltcG9ydCB7IHN0b3BBbmltYXRpb24sIGFuaW1hdGVWaXN1YWxFbGVtZW50IH0gZnJvbSAnLi4vcmVuZGVyL3V0aWxzL2FuaW1hdGlvbi5tanMnO1xuaW1wb3J0IHsgc2V0VmFsdWVzIH0gZnJvbSAnLi4vcmVuZGVyL3V0aWxzL3NldHRlcnMubWpzJztcblxuLyoqXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGFuaW1hdGlvbkNvbnRyb2xzKCkge1xuICAgIC8qKlxuICAgICAqIFRyYWNrIHdoZXRoZXIgdGhlIGhvc3QgY29tcG9uZW50IGhhcyBtb3VudGVkLlxuICAgICAqL1xuICAgIHZhciBoYXNNb3VudGVkID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogUGVuZGluZyBhbmltYXRpb25zIHRoYXQgYXJlIHN0YXJ0ZWQgYmVmb3JlIGEgY29tcG9uZW50IGlzIG1vdW50ZWQuXG4gICAgICogVE9ETzogUmVtb3ZlIHRoaXMgYXMgYW5pbWF0aW9ucyBzaG91bGQgb25seSBydW4gaW4gZWZmZWN0c1xuICAgICAqL1xuICAgIHZhciBwZW5kaW5nQW5pbWF0aW9ucyA9IFtdO1xuICAgIC8qKlxuICAgICAqIEEgY29sbGVjdGlvbiBvZiBsaW5rZWQgY29tcG9uZW50IGFuaW1hdGlvbiBjb250cm9scy5cbiAgICAgKi9cbiAgICB2YXIgc3Vic2NyaWJlcnMgPSBuZXcgU2V0KCk7XG4gICAgdmFyIGNvbnRyb2xzID0ge1xuICAgICAgICBzdWJzY3JpYmU6IGZ1bmN0aW9uICh2aXN1YWxFbGVtZW50KSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVycy5hZGQodmlzdWFsRWxlbWVudCk7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gdm9pZCBzdWJzY3JpYmVycy5kZWxldGUodmlzdWFsRWxlbWVudCk7IH07XG4gICAgICAgIH0sXG4gICAgICAgIHN0YXJ0OiBmdW5jdGlvbiAoZGVmaW5pdGlvbiwgdHJhbnNpdGlvbk92ZXJyaWRlKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRPRE86IFdlIG9ubHkgcGVyZm9ybSB0aGlzIGhhc01vdW50ZWQgY2hlY2sgYmVjYXVzZSBpbiBGcmFtZXIgd2UgdXNlZCB0b1xuICAgICAgICAgICAgICogZW5jb3VyYWdlIHRoZSBhYmlsaXR5IHRvIHN0YXJ0IGFuIGFuaW1hdGlvbiB3aXRoaW4gdGhlIHJlbmRlciBwaGFzZS4gVGhpc1xuICAgICAgICAgICAgICogaXNuJ3QgYmVoYXZpb3VyIGNvbmN1cnJlbnQtc2FmZSBzbyB3aGVuIHdlIG1ha2UgRnJhbWVyIGNvbmN1cnJlbnQtc2FmZVxuICAgICAgICAgICAgICogd2UgY2FuIGRpdGNoIHRoaXMuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmIChoYXNNb3VudGVkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFuaW1hdGlvbnNfMSA9IFtdO1xuICAgICAgICAgICAgICAgIHN1YnNjcmliZXJzLmZvckVhY2goZnVuY3Rpb24gKHZpc3VhbEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uc18xLnB1c2goYW5pbWF0ZVZpc3VhbEVsZW1lbnQodmlzdWFsRWxlbWVudCwgZGVmaW5pdGlvbiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbk92ZXJyaWRlOiB0cmFuc2l0aW9uT3ZlcnJpZGUsXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoYW5pbWF0aW9uc18xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgICAgICAgICBwZW5kaW5nQW5pbWF0aW9ucy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbjogW2RlZmluaXRpb24sIHRyYW5zaXRpb25PdmVycmlkZV0sXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlOiByZXNvbHZlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoZGVmaW5pdGlvbikge1xuICAgICAgICAgICAgaW52YXJpYW50KGhhc01vdW50ZWQsIFwiY29udHJvbHMuc2V0KCkgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIGFmdGVyIGEgY29tcG9uZW50IGhhcyBtb3VudGVkLiBDb25zaWRlciBjYWxsaW5nIHdpdGhpbiBhIHVzZUVmZmVjdCBob29rLlwiKTtcbiAgICAgICAgICAgIHJldHVybiBzdWJzY3JpYmVycy5mb3JFYWNoKGZ1bmN0aW9uICh2aXN1YWxFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgc2V0VmFsdWVzKHZpc3VhbEVsZW1lbnQsIGRlZmluaXRpb24pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHN0b3A6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHN1YnNjcmliZXJzLmZvckVhY2goZnVuY3Rpb24gKHZpc3VhbEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBzdG9wQW5pbWF0aW9uKHZpc3VhbEVsZW1lbnQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIG1vdW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBoYXNNb3VudGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHBlbmRpbmdBbmltYXRpb25zLmZvckVhY2goZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFuaW1hdGlvbiA9IF9hLmFuaW1hdGlvbiwgcmVzb2x2ZSA9IF9hLnJlc29sdmU7XG4gICAgICAgICAgICAgICAgY29udHJvbHMuc3RhcnQuYXBwbHkoY29udHJvbHMsIF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChhbmltYXRpb24pLCBmYWxzZSkpLnRoZW4ocmVzb2x2ZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaGFzTW91bnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGNvbnRyb2xzLnN0b3AoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgfTtcbiAgICByZXR1cm4gY29udHJvbHM7XG59XG5cbmV4cG9ydCB7IGFuaW1hdGlvbkNvbnRyb2xzIH07XG4iLCJpbXBvcnQgeyBhbmltYXRpb25Db250cm9scyB9IGZyb20gJy4vYW5pbWF0aW9uLWNvbnRyb2xzLm1qcyc7XG5pbXBvcnQgeyB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VDb25zdGFudCB9IGZyb20gJy4uL3V0aWxzL3VzZS1jb25zdGFudC5tanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYEFuaW1hdGlvbkNvbnRyb2xzYCwgd2hpY2ggY2FuIGJlIHVzZWQgdG8gbWFudWFsbHkgc3RhcnQsIHN0b3BcbiAqIGFuZCBzZXF1ZW5jZSBhbmltYXRpb25zIG9uIG9uZSBvciBtb3JlIGNvbXBvbmVudHMuXG4gKlxuICogVGhlIHJldHVybmVkIGBBbmltYXRpb25Db250cm9sc2Agc2hvdWxkIGJlIHBhc3NlZCB0byB0aGUgYGFuaW1hdGVgIHByb3BlcnR5XG4gKiBvZiB0aGUgY29tcG9uZW50cyB5b3Ugd2FudCB0byBhbmltYXRlLlxuICpcbiAqIFRoZXNlIGNvbXBvbmVudHMgY2FuIHRoZW4gYmUgYW5pbWF0ZWQgd2l0aCB0aGUgYHN0YXJ0YCBtZXRob2QuXG4gKlxuICogYGBganN4XG4gKiBpbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCdcbiAqIGltcG9ydCB7IG1vdGlvbiwgdXNlQW5pbWF0aW9uIH0gZnJvbSAnZnJhbWVyLW1vdGlvbidcbiAqXG4gKiBleHBvcnQgZnVuY3Rpb24gTXlDb21wb25lbnQocHJvcHMpIHtcbiAqICAgIGNvbnN0IGNvbnRyb2xzID0gdXNlQW5pbWF0aW9uKClcbiAqXG4gKiAgICBjb250cm9scy5zdGFydCh7XG4gKiAgICAgICAgeDogMTAwLFxuICogICAgICAgIHRyYW5zaXRpb246IHsgZHVyYXRpb246IDAuNSB9LFxuICogICAgfSlcbiAqXG4gKiAgICByZXR1cm4gPG1vdGlvbi5kaXYgYW5pbWF0ZT17Y29udHJvbHN9IC8+XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBAcmV0dXJucyBBbmltYXRpb24gY29udHJvbGxlciB3aXRoIGBzdGFydGAgYW5kIGBzdG9wYCBtZXRob2RzXG4gKlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiB1c2VBbmltYXRpb25Db250cm9scygpIHtcbiAgICB2YXIgY29udHJvbHMgPSB1c2VDb25zdGFudChhbmltYXRpb25Db250cm9scyk7XG4gICAgdXNlRWZmZWN0KGNvbnRyb2xzLm1vdW50LCBbXSk7XG4gICAgcmV0dXJuIGNvbnRyb2xzO1xufVxudmFyIHVzZUFuaW1hdGlvbiA9IHVzZUFuaW1hdGlvbkNvbnRyb2xzO1xuXG5leHBvcnQgeyB1c2VBbmltYXRpb24sIHVzZUFuaW1hdGlvbkNvbnRyb2xzIH07XG4iLCJjb25zdCB3cmFwID0gKG1pbiwgbWF4LCB2KSA9PiB7XG4gICAgY29uc3QgcmFuZ2VTaXplID0gbWF4IC0gbWluO1xuICAgIHJldHVybiAoKCgodiAtIG1pbikgJSByYW5nZVNpemUpICsgcmFuZ2VTaXplKSAlIHJhbmdlU2l6ZSkgKyBtaW47XG59O1xuXG5leHBvcnQgeyB3cmFwIH07XG4iLCJpbXBvcnQgeyBfX3JlYWQsIF9fc3ByZWFkQXJyYXkgfSBmcm9tICd0c2xpYic7XG5pbXBvcnQgeyB3cmFwIH0gZnJvbSAncG9wbW90aW9uJztcbmltcG9ydCB7IHVzZVJlZiwgdXNlU3RhdGUsIHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnO1xuXG4vKipcbiAqIEN5Y2xlcyB0aHJvdWdoIGEgc2VyaWVzIG9mIHZpc3VhbCBwcm9wZXJ0aWVzLiBDYW4gYmUgdXNlZCB0byB0b2dnbGUgYmV0d2VlbiBvciBjeWNsZSB0aHJvdWdoIGFuaW1hdGlvbnMuIEl0IHdvcmtzIHNpbWlsYXIgdG8gYHVzZVN0YXRlYCBpbiBSZWFjdC4gSXQgaXMgcHJvdmlkZWQgYW4gaW5pdGlhbCBhcnJheSBvZiBwb3NzaWJsZSBzdGF0ZXMsIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mIHR3byBhcmd1bWVudHMuXG4gKlxuICogQW4gaW5kZXggdmFsdWUgY2FuIGJlIHBhc3NlZCB0byB0aGUgcmV0dXJuZWQgYGN5Y2xlYCBmdW5jdGlvbiB0byBjeWNsZSB0byBhIHNwZWNpZmljIGluZGV4LlxuICpcbiAqIGBgYGpzeFxuICogaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCJcbiAqIGltcG9ydCB7IG1vdGlvbiwgdXNlQ3ljbGUgfSBmcm9tIFwiZnJhbWVyLW1vdGlvblwiXG4gKlxuICogZXhwb3J0IGNvbnN0IE15Q29tcG9uZW50ID0gKCkgPT4ge1xuICogICBjb25zdCBbeCwgY3ljbGVYXSA9IHVzZUN5Y2xlKDAsIDUwLCAxMDApXG4gKlxuICogICByZXR1cm4gKFxuICogICAgIDxtb3Rpb24uZGl2XG4gKiAgICAgICBhbmltYXRlPXt7IHg6IHggfX1cbiAqICAgICAgIG9uVGFwPXsoKSA9PiBjeWNsZVgoKX1cbiAqICAgICAgLz5cbiAqICAgIClcbiAqIH1cbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBpdGVtcyAtIGl0ZW1zIHRvIGN5Y2xlIHRocm91Z2hcbiAqIEByZXR1cm5zIFtjdXJyZW50U3RhdGUsIGN5Y2xlU3RhdGVdXG4gKlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiB1c2VDeWNsZSgpIHtcbiAgICB2YXIgaXRlbXMgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBpdGVtc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICB2YXIgaW5kZXggPSB1c2VSZWYoMCk7XG4gICAgdmFyIF9hID0gX19yZWFkKHVzZVN0YXRlKGl0ZW1zW2luZGV4LmN1cnJlbnRdKSwgMiksIGl0ZW0gPSBfYVswXSwgc2V0SXRlbSA9IF9hWzFdO1xuICAgIHZhciBydW5DeWNsZSA9IHVzZUNhbGxiYWNrKGZ1bmN0aW9uIChuZXh0KSB7XG4gICAgICAgIGluZGV4LmN1cnJlbnQgPVxuICAgICAgICAgICAgdHlwZW9mIG5leHQgIT09IFwibnVtYmVyXCJcbiAgICAgICAgICAgICAgICA/IHdyYXAoMCwgaXRlbXMubGVuZ3RoLCBpbmRleC5jdXJyZW50ICsgMSlcbiAgICAgICAgICAgICAgICA6IG5leHQ7XG4gICAgICAgIHNldEl0ZW0oaXRlbXNbaW5kZXguY3VycmVudF0pO1xuICAgIH0sIF9fc3ByZWFkQXJyYXkoW2l0ZW1zLmxlbmd0aF0sIF9fcmVhZChpdGVtcyksIGZhbHNlKSk7XG4gICAgcmV0dXJuIFtpdGVtLCBydW5DeWNsZV07XG59XG5cbmV4cG9ydCB7IHVzZUN5Y2xlIH07XG4iLCJpbXBvcnQgeyByZXNvbHZlRWxlbWVudHMgfSBmcm9tICcuLi91dGlscy9yZXNvbHZlLWVsZW1lbnRzLmVzLmpzJztcblxuY29uc3QgdGhyZXNob2xkcyA9IHtcbiAgICBhbnk6IDAsXG4gICAgYWxsOiAxLFxufTtcbmZ1bmN0aW9uIGluVmlldyhlbGVtZW50T3JTZWxlY3Rvciwgb25TdGFydCwgeyByb290LCBtYXJnaW46IHJvb3RNYXJnaW4sIGFtb3VudCA9IFwiYW55XCIgfSA9IHt9KSB7XG4gICAgLyoqXG4gICAgICogSWYgdGhpcyBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCBJbnRlcnNlY3Rpb25PYnNlcnZlciwgcmV0dXJuIGEgZHVtbXkgc3RvcCBmdW5jdGlvbi5cbiAgICAgKiBEZWZhdWx0IHRyaWdnZXJpbmcgb2Ygb25TdGFydCBpcyB0cmlja3kgLSBpdCBjb3VsZCBiZSB1c2VkIGZvciBzdGFydGluZy9zdG9wcGluZ1xuICAgICAqIHZpZGVvcywgbGF6eSBsb2FkaW5nIGNvbnRlbnQgZXRjLiBXZSBjb3VsZCBwcm92aWRlIGFuIG9wdGlvbiB0byBlbmFibGUgYSBmYWxsYmFjaywgb3JcbiAgICAgKiBwcm92aWRlIGEgZmFsbGJhY2sgY2FsbGJhY2sgb3B0aW9uLlxuICAgICAqL1xuICAgIGlmICh0eXBlb2YgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgcmV0dXJuICgpID0+IHsgfTtcbiAgICB9XG4gICAgY29uc3QgZWxlbWVudHMgPSByZXNvbHZlRWxlbWVudHMoZWxlbWVudE9yU2VsZWN0b3IpO1xuICAgIGNvbnN0IGFjdGl2ZUludGVyc2VjdGlvbnMgPSBuZXcgV2Vha01hcCgpO1xuICAgIGNvbnN0IG9uSW50ZXJzZWN0aW9uQ2hhbmdlID0gKGVudHJpZXMpID0+IHtcbiAgICAgICAgZW50cmllcy5mb3JFYWNoKChlbnRyeSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgb25FbmQgPSBhY3RpdmVJbnRlcnNlY3Rpb25zLmdldChlbnRyeS50YXJnZXQpO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJZiB0aGVyZSdzIG5vIGNoYW5nZSB0byB0aGUgaW50ZXJzZWN0aW9uLCB3ZSBkb24ndCBuZWVkIHRvXG4gICAgICAgICAgICAgKiBkbyBhbnl0aGluZyBoZXJlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoZW50cnkuaXNJbnRlcnNlY3RpbmcgPT09IEJvb2xlYW4ob25FbmQpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmIChlbnRyeS5pc0ludGVyc2VjdGluZykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld09uRW5kID0gb25TdGFydChlbnRyeSk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBuZXdPbkVuZCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZUludGVyc2VjdGlvbnMuc2V0KGVudHJ5LnRhcmdldCwgbmV3T25FbmQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIudW5vYnNlcnZlKGVudHJ5LnRhcmdldCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAob25FbmQpIHtcbiAgICAgICAgICAgICAgICBvbkVuZChlbnRyeSk7XG4gICAgICAgICAgICAgICAgYWN0aXZlSW50ZXJzZWN0aW9ucy5kZWxldGUoZW50cnkudGFyZ2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBvYnNlcnZlciA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcihvbkludGVyc2VjdGlvbkNoYW5nZSwge1xuICAgICAgICByb290LFxuICAgICAgICByb290TWFyZ2luLFxuICAgICAgICB0aHJlc2hvbGQ6IHR5cGVvZiBhbW91bnQgPT09IFwibnVtYmVyXCIgPyBhbW91bnQgOiB0aHJlc2hvbGRzW2Ftb3VudF0sXG4gICAgfSk7XG4gICAgZWxlbWVudHMuZm9yRWFjaCgoZWxlbWVudCkgPT4gb2JzZXJ2ZXIub2JzZXJ2ZShlbGVtZW50KSk7XG4gICAgcmV0dXJuICgpID0+IG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbn1cblxuZXhwb3J0IHsgaW5WaWV3IH07XG4iLCJpbXBvcnQgeyBfX3JlYWQgfSBmcm9tICd0c2xpYic7XG5pbXBvcnQgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgaW5WaWV3IH0gZnJvbSAnQG1vdGlvbm9uZS9kb20nO1xuXG5mdW5jdGlvbiB1c2VJblZpZXcocmVmLCBfYSkge1xuICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCByb290ID0gX2Iucm9vdCwgbWFyZ2luID0gX2IubWFyZ2luLCBhbW91bnQgPSBfYi5hbW91bnQsIF9jID0gX2Iub25jZSwgb25jZSA9IF9jID09PSB2b2lkIDAgPyBmYWxzZSA6IF9jO1xuICAgIHZhciBfZCA9IF9fcmVhZCh1c2VTdGF0ZShmYWxzZSksIDIpLCBpc0luVmlldyA9IF9kWzBdLCBzZXRJblZpZXcgPSBfZFsxXTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICghcmVmLmN1cnJlbnQgfHwgKG9uY2UgJiYgaXNJblZpZXcpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgb25FbnRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHNldEluVmlldyh0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiBvbmNlID8gdW5kZWZpbmVkIDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2V0SW5WaWV3KGZhbHNlKTsgfTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICByb290OiAoX2EgPSByb290ID09PSBudWxsIHx8IHJvb3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJvb3QuY3VycmVudCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgbWFyZ2luOiBtYXJnaW4sXG4gICAgICAgICAgICBhbW91bnQ6IGFtb3VudCA9PT0gXCJzb21lXCIgPyBcImFueVwiIDogYW1vdW50LFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gaW5WaWV3KHJlZi5jdXJyZW50LCBvbkVudGVyLCBvcHRpb25zKTtcbiAgICB9LCBbcm9vdCwgcmVmLCBtYXJnaW4sIG9uY2VdKTtcbiAgICByZXR1cm4gaXNJblZpZXc7XG59XG5cbmV4cG9ydCB7IHVzZUluVmlldyB9O1xuIiwiaW1wb3J0IHsgdXNlQ29uc3RhbnQgfSBmcm9tICcuLi8uLi91dGlscy91c2UtY29uc3RhbnQubWpzJztcblxuLyoqXG4gKiBDYW4gbWFudWFsbHkgdHJpZ2dlciBhIGRyYWcgZ2VzdHVyZSBvbiBvbmUgb3IgbW9yZSBgZHJhZ2AtZW5hYmxlZCBgbW90aW9uYCBjb21wb25lbnRzLlxuICpcbiAqIGBgYGpzeFxuICogY29uc3QgZHJhZ0NvbnRyb2xzID0gdXNlRHJhZ0NvbnRyb2xzKClcbiAqXG4gKiBmdW5jdGlvbiBzdGFydERyYWcoZXZlbnQpIHtcbiAqICAgZHJhZ0NvbnRyb2xzLnN0YXJ0KGV2ZW50LCB7IHNuYXBUb0N1cnNvcjogdHJ1ZSB9KVxuICogfVxuICpcbiAqIHJldHVybiAoXG4gKiAgIDw+XG4gKiAgICAgPGRpdiBvblBvaW50ZXJEb3duPXtzdGFydERyYWd9IC8+XG4gKiAgICAgPG1vdGlvbi5kaXYgZHJhZz1cInhcIiBkcmFnQ29udHJvbHM9e2RyYWdDb250cm9sc30gLz5cbiAqICAgPC8+XG4gKiApXG4gKiBgYGBcbiAqXG4gKiBAcHVibGljXG4gKi9cbnZhciBEcmFnQ29udHJvbHMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRHJhZ0NvbnRyb2xzKCkge1xuICAgICAgICB0aGlzLmNvbXBvbmVudENvbnRyb2xzID0gbmV3IFNldCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdWJzY3JpYmUgYSBjb21wb25lbnQncyBpbnRlcm5hbCBgVmlzdWFsRWxlbWVudERyYWdDb250cm9sc2AgdG8gdGhlIHVzZXItZmFjaW5nIEFQSS5cbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIERyYWdDb250cm9scy5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24gKGNvbnRyb2xzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMuY29tcG9uZW50Q29udHJvbHMuYWRkKGNvbnRyb2xzKTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLmNvbXBvbmVudENvbnRyb2xzLmRlbGV0ZShjb250cm9scyk7IH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTdGFydCBhIGRyYWcgZ2VzdHVyZSBvbiBldmVyeSBgbW90aW9uYCBjb21wb25lbnQgdGhhdCBoYXMgdGhpcyBzZXQgb2YgZHJhZyBjb250cm9sc1xuICAgICAqIHBhc3NlZCBpbnRvIGl0IHZpYSB0aGUgYGRyYWdDb250cm9sc2AgcHJvcC5cbiAgICAgKlxuICAgICAqIGBgYGpzeFxuICAgICAqIGRyYWdDb250cm9scy5zdGFydChlLCB7XG4gICAgICogICBzbmFwVG9DdXJzb3I6IHRydWVcbiAgICAgKiB9KVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIGV2ZW50IC0gUG9pbnRlckV2ZW50XG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgRHJhZ0NvbnRyb2xzLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uIChldmVudCwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLmNvbXBvbmVudENvbnRyb2xzLmZvckVhY2goZnVuY3Rpb24gKGNvbnRyb2xzKSB7XG4gICAgICAgICAgICBjb250cm9scy5zdGFydChldmVudC5uYXRpdmVFdmVudCB8fCBldmVudCwgb3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIERyYWdDb250cm9scztcbn0oKSk7XG52YXIgY3JlYXRlRHJhZ0NvbnRyb2xzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IERyYWdDb250cm9scygpOyB9O1xuLyoqXG4gKiBVc3VhbGx5LCBkcmFnZ2luZyBpcyBpbml0aWF0ZWQgYnkgcHJlc3NpbmcgZG93biBvbiBhIGBtb3Rpb25gIGNvbXBvbmVudCB3aXRoIGEgYGRyYWdgIHByb3BcbiAqIGFuZCBtb3ZpbmcgaXQuIEZvciBzb21lIHVzZS1jYXNlcywgZm9yIGluc3RhbmNlIGNsaWNraW5nIGF0IGFuIGFyYml0cmFyeSBwb2ludCBvbiBhIHZpZGVvIHNjcnViYmVyLCB3ZVxuICogbWlnaHQgd2FudCB0byBpbml0aWF0ZSB0aGF0IGRyYWdnaW5nIGZyb20gYSBkaWZmZXJlbnQgY29tcG9uZW50IHRoYW4gdGhlIGRyYWdnYWJsZSBvbmUuXG4gKlxuICogQnkgY3JlYXRpbmcgYSBgZHJhZ0NvbnRyb2xzYCB1c2luZyB0aGUgYHVzZURyYWdDb250cm9sc2AgaG9vaywgd2UgY2FuIHBhc3MgdGhpcyBpbnRvXG4gKiB0aGUgZHJhZ2dhYmxlIGNvbXBvbmVudCdzIGBkcmFnQ29udHJvbHNgIHByb3AuIEl0IGV4cG9zZXMgYSBgc3RhcnRgIG1ldGhvZFxuICogdGhhdCBjYW4gc3RhcnQgZHJhZ2dpbmcgZnJvbSBwb2ludGVyIGV2ZW50cyBvbiBvdGhlciBjb21wb25lbnRzLlxuICpcbiAqIGBgYGpzeFxuICogY29uc3QgZHJhZ0NvbnRyb2xzID0gdXNlRHJhZ0NvbnRyb2xzKClcbiAqXG4gKiBmdW5jdGlvbiBzdGFydERyYWcoZXZlbnQpIHtcbiAqICAgZHJhZ0NvbnRyb2xzLnN0YXJ0KGV2ZW50LCB7IHNuYXBUb0N1cnNvcjogdHJ1ZSB9KVxuICogfVxuICpcbiAqIHJldHVybiAoXG4gKiAgIDw+XG4gKiAgICAgPGRpdiBvblBvaW50ZXJEb3duPXtzdGFydERyYWd9IC8+XG4gKiAgICAgPG1vdGlvbi5kaXYgZHJhZz1cInhcIiBkcmFnQ29udHJvbHM9e2RyYWdDb250cm9sc30gLz5cbiAqICAgPC8+XG4gKiApXG4gKiBgYGBcbiAqXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHVzZURyYWdDb250cm9scygpIHtcbiAgICByZXR1cm4gdXNlQ29uc3RhbnQoY3JlYXRlRHJhZ0NvbnRyb2xzKTtcbn1cblxuZXhwb3J0IHsgRHJhZ0NvbnRyb2xzLCB1c2VEcmFnQ29udHJvbHMgfTtcbiIsImltcG9ydCB7IHJvb3RQcm9qZWN0aW9uTm9kZSB9IGZyb20gJy4vbm9kZS9IVE1MUHJvamVjdGlvbk5vZGUubWpzJztcblxuZnVuY3Rpb24gdXNlSW5zdGFudExheW91dFRyYW5zaXRpb24oKSB7XG4gICAgcmV0dXJuIHN0YXJ0VHJhbnNpdGlvbjtcbn1cbmZ1bmN0aW9uIHN0YXJ0VHJhbnNpdGlvbihjYikge1xuICAgIGlmICghcm9vdFByb2plY3Rpb25Ob2RlLmN1cnJlbnQpXG4gICAgICAgIHJldHVybjtcbiAgICByb290UHJvamVjdGlvbk5vZGUuY3VycmVudC5pc1VwZGF0aW5nID0gZmFsc2U7XG4gICAgcm9vdFByb2plY3Rpb25Ob2RlLmN1cnJlbnQuYmxvY2tVcGRhdGUoKTtcbiAgICBjYiA9PT0gbnVsbCB8fCBjYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2IoKTtcbn1cblxuZXhwb3J0IHsgdXNlSW5zdGFudExheW91dFRyYW5zaXRpb24gfTtcbiIsImltcG9ydCB7IF9fcmVhZCB9IGZyb20gJ3RzbGliJztcbmltcG9ydCBzeW5jIGZyb20gJ2ZyYW1lc3luYyc7XG5pbXBvcnQgeyB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VJbnN0YW50TGF5b3V0VHJhbnNpdGlvbiB9IGZyb20gJy4uL3Byb2plY3Rpb24vdXNlLWluc3RhbnQtbGF5b3V0LXRyYW5zaXRpb24ubWpzJztcbmltcG9ydCB7IHVzZUZvcmNlVXBkYXRlIH0gZnJvbSAnLi91c2UtZm9yY2UtdXBkYXRlLm1qcyc7XG5pbXBvcnQgeyBpbnN0YW50QW5pbWF0aW9uU3RhdGUgfSBmcm9tICcuL3VzZS1pbnN0YW50LXRyYW5zaXRpb24tc3RhdGUubWpzJztcblxuZnVuY3Rpb24gdXNlSW5zdGFudFRyYW5zaXRpb24oKSB7XG4gICAgdmFyIF9hID0gX19yZWFkKHVzZUZvcmNlVXBkYXRlKCksIDIpLCBmb3JjZVVwZGF0ZSA9IF9hWzBdLCBmb3JjZWRSZW5kZXJDb3VudCA9IF9hWzFdO1xuICAgIHZhciBzdGFydEluc3RhbnRMYXlvdXRUcmFuc2l0aW9uID0gdXNlSW5zdGFudExheW91dFRyYW5zaXRpb24oKTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogVW5ibG9jayBhZnRlciB0d28gYW5pbWF0aW9uIGZyYW1lcywgb3RoZXJ3aXNlIHRoaXMgd2lsbCB1bmJsb2NrIHRvbyBzb29uLlxuICAgICAgICAgKi9cbiAgICAgICAgc3luYy5wb3N0UmVuZGVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBzeW5jLnBvc3RSZW5kZXIoZnVuY3Rpb24gKCkgeyByZXR1cm4gKGluc3RhbnRBbmltYXRpb25TdGF0ZS5jdXJyZW50ID0gZmFsc2UpOyB9KTtcbiAgICAgICAgfSk7XG4gICAgfSwgW2ZvcmNlZFJlbmRlckNvdW50XSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICBzdGFydEluc3RhbnRMYXlvdXRUcmFuc2l0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGluc3RhbnRBbmltYXRpb25TdGF0ZS5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvcmNlVXBkYXRlKCk7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9KTtcbiAgICB9O1xufVxuXG5leHBvcnQgeyB1c2VJbnN0YW50VHJhbnNpdGlvbiB9O1xuIiwiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgcm9vdFByb2plY3Rpb25Ob2RlIH0gZnJvbSAnLi9ub2RlL0hUTUxQcm9qZWN0aW9uTm9kZS5tanMnO1xuXG5mdW5jdGlvbiB1c2VSZXNldFByb2plY3Rpb24oKSB7XG4gICAgdmFyIHJlc2V0ID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcm9vdCA9IHJvb3RQcm9qZWN0aW9uTm9kZS5jdXJyZW50O1xuICAgICAgICBpZiAoIXJvb3QpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHJvb3QucmVzZXRUcmVlKCk7XG4gICAgfSwgW10pO1xuICAgIHJldHVybiByZXNldDtcbn1cblxuZXhwb3J0IHsgdXNlUmVzZXRQcm9qZWN0aW9uIH07XG4iLCJpbXBvcnQgeyBfX3Jlc3QsIF9fYXNzaWduLCBfX3JlYWQgfSBmcm9tICd0c2xpYic7XG5pbXBvcnQgeyB1c2VTdGF0ZSwgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgdXNlQ29uc3RhbnQgfSBmcm9tICcuLi91dGlscy91c2UtY29uc3RhbnQubWpzJztcbmltcG9ydCB7IGdldE9yaWdpbiwgY2hlY2tUYXJnZXRGb3JOZXdWYWx1ZXMgfSBmcm9tICcuLi9yZW5kZXIvdXRpbHMvc2V0dGVycy5tanMnO1xuaW1wb3J0IHsgdmlzdWFsRWxlbWVudCB9IGZyb20gJy4uL3JlbmRlci9pbmRleC5tanMnO1xuaW1wb3J0IHsgYW5pbWF0ZVZpc3VhbEVsZW1lbnQgfSBmcm9tICcuLi9yZW5kZXIvdXRpbHMvYW5pbWF0aW9uLm1qcyc7XG5pbXBvcnQgeyBtYWtlVXNlVmlzdWFsU3RhdGUgfSBmcm9tICcuLi9tb3Rpb24vdXRpbHMvdXNlLXZpc3VhbC1zdGF0ZS5tanMnO1xuaW1wb3J0IHsgY3JlYXRlQm94IH0gZnJvbSAnLi4vcHJvamVjdGlvbi9nZW9tZXRyeS9tb2RlbHMubWpzJztcblxudmFyIGNyZWF0ZU9iamVjdCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICh7fSk7IH07XG52YXIgc3RhdGVWaXN1YWxFbGVtZW50ID0gdmlzdWFsRWxlbWVudCh7XG4gICAgYnVpbGQ6IGZ1bmN0aW9uICgpIHsgfSxcbiAgICBtZWFzdXJlVmlld3BvcnRCb3g6IGNyZWF0ZUJveCxcbiAgICByZXNldFRyYW5zZm9ybTogZnVuY3Rpb24gKCkgeyB9LFxuICAgIHJlc3RvcmVUcmFuc2Zvcm06IGZ1bmN0aW9uICgpIHsgfSxcbiAgICByZW1vdmVWYWx1ZUZyb21SZW5kZXJTdGF0ZTogZnVuY3Rpb24gKCkgeyB9LFxuICAgIHJlbmRlcjogZnVuY3Rpb24gKCkgeyB9LFxuICAgIHNjcmFwZU1vdGlvblZhbHVlc0Zyb21Qcm9wczogY3JlYXRlT2JqZWN0LFxuICAgIHJlYWRWYWx1ZUZyb21JbnN0YW5jZTogZnVuY3Rpb24gKF9zdGF0ZSwga2V5LCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zLmluaXRpYWxTdGF0ZVtrZXldIHx8IDA7XG4gICAgfSxcbiAgICBtYWtlVGFyZ2V0QW5pbWF0YWJsZTogZnVuY3Rpb24gKGVsZW1lbnQsIF9hKSB7XG4gICAgICAgIHZhciB0cmFuc2l0aW9uID0gX2EudHJhbnNpdGlvbiwgdHJhbnNpdGlvbkVuZCA9IF9hLnRyYW5zaXRpb25FbmQsIHRhcmdldCA9IF9fcmVzdChfYSwgW1widHJhbnNpdGlvblwiLCBcInRyYW5zaXRpb25FbmRcIl0pO1xuICAgICAgICB2YXIgb3JpZ2luID0gZ2V0T3JpZ2luKHRhcmdldCwgdHJhbnNpdGlvbiB8fCB7fSwgZWxlbWVudCk7XG4gICAgICAgIGNoZWNrVGFyZ2V0Rm9yTmV3VmFsdWVzKGVsZW1lbnQsIHRhcmdldCwgb3JpZ2luKTtcbiAgICAgICAgcmV0dXJuIF9fYXNzaWduKHsgdHJhbnNpdGlvbjogdHJhbnNpdGlvbiwgdHJhbnNpdGlvbkVuZDogdHJhbnNpdGlvbkVuZCB9LCB0YXJnZXQpO1xuICAgIH0sXG59KTtcbnZhciB1c2VWaXN1YWxTdGF0ZSA9IG1ha2VVc2VWaXN1YWxTdGF0ZSh7XG4gICAgc2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzOiBjcmVhdGVPYmplY3QsXG4gICAgY3JlYXRlUmVuZGVyU3RhdGU6IGNyZWF0ZU9iamVjdCxcbn0pO1xuLyoqXG4gKiBUaGlzIGlzIG5vdCBhbiBvZmZpY2lhbGx5IHN1cHBvcnRlZCBBUEkgYW5kIG1heSBiZSByZW1vdmVkXG4gKiBvbiBhbnkgdmVyc2lvbi5cbiAqL1xuZnVuY3Rpb24gdXNlQW5pbWF0ZWRTdGF0ZShpbml0aWFsU3RhdGUpIHtcbiAgICB2YXIgX2EgPSBfX3JlYWQodXNlU3RhdGUoaW5pdGlhbFN0YXRlKSwgMiksIGFuaW1hdGlvblN0YXRlID0gX2FbMF0sIHNldEFuaW1hdGlvblN0YXRlID0gX2FbMV07XG4gICAgdmFyIHZpc3VhbFN0YXRlID0gdXNlVmlzdWFsU3RhdGUoe30sIGZhbHNlKTtcbiAgICB2YXIgZWxlbWVudCA9IHVzZUNvbnN0YW50KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlVmlzdWFsRWxlbWVudCh7IHByb3BzOiB7fSwgdmlzdWFsU3RhdGU6IHZpc3VhbFN0YXRlIH0sIHsgaW5pdGlhbFN0YXRlOiBpbml0aWFsU3RhdGUgfSk7XG4gICAgfSk7XG4gICAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZWxlbWVudC5tb3VudCh7fSk7XG4gICAgICAgIHJldHVybiBlbGVtZW50LnVubW91bnQ7XG4gICAgfSwgW2VsZW1lbnRdKTtcbiAgICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBlbGVtZW50LnNldFByb3BzKHtcbiAgICAgICAgICAgIG9uVXBkYXRlOiBmdW5jdGlvbiAodikge1xuICAgICAgICAgICAgICAgIHNldEFuaW1hdGlvblN0YXRlKF9fYXNzaWduKHt9LCB2KSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9LCBbc2V0QW5pbWF0aW9uU3RhdGUsIGVsZW1lbnRdKTtcbiAgICB2YXIgc3RhcnRBbmltYXRpb24gPSB1c2VDb25zdGFudChmdW5jdGlvbiAoKSB7IHJldHVybiBmdW5jdGlvbiAoYW5pbWF0aW9uRGVmaW5pdGlvbikge1xuICAgICAgICByZXR1cm4gYW5pbWF0ZVZpc3VhbEVsZW1lbnQoZWxlbWVudCwgYW5pbWF0aW9uRGVmaW5pdGlvbik7XG4gICAgfTsgfSk7XG4gICAgcmV0dXJuIFthbmltYXRpb25TdGF0ZSwgc3RhcnRBbmltYXRpb25dO1xufVxuXG5leHBvcnQgeyB1c2VBbmltYXRlZFN0YXRlIH07XG4iLCJpbXBvcnQgeyB1c2VUcmFuc2Zvcm0gfSBmcm9tICcuL3VzZS10cmFuc2Zvcm0ubWpzJztcbmltcG9ydCB7IGludmFyaWFudCwgd2FybmluZyB9IGZyb20gJ2hleS1saXN0ZW4nO1xuaW1wb3J0IHsgdXNlTW90aW9uVmFsdWUgfSBmcm9tICcuL3VzZS1tb3Rpb24tdmFsdWUubWpzJztcbmltcG9ydCB7IHVzZVZpc3VhbEVsZW1lbnRDb250ZXh0IH0gZnJvbSAnLi4vY29udGV4dC9Nb3Rpb25Db250ZXh0L2luZGV4Lm1qcyc7XG5cbi8vIEtlZXAgdGhpbmdzIHJlYXNvbmFibGUgYW5kIGF2b2lkIHNjYWxlOiBJbmZpbml0eS4gSW4gcHJhY3Rpc2Ugd2UgbWlnaHQgbmVlZFxuLy8gdG8gYWRkIGFub3RoZXIgdmFsdWUsIG9wYWNpdHksIHRoYXQgY291bGQgaW50ZXJwb2xhdGUgc2NhbGVYL1kgWzAsMC4wMV0gPT4gWzAsMV1cbi8vIHRvIHNpbXBseSBoaWRlIGNvbnRlbnQgYXQgdW5yZWFzb25hYmxlIHNjYWxlcy5cbnZhciBtYXhTY2FsZSA9IDEwMDAwMDtcbnZhciBpbnZlcnRTY2FsZSA9IGZ1bmN0aW9uIChzY2FsZSkge1xuICAgIHJldHVybiBzY2FsZSA+IDAuMDAxID8gMSAvIHNjYWxlIDogbWF4U2NhbGU7XG59O1xudmFyIGhhc1dhcm5lZCA9IGZhbHNlO1xuLyoqXG4gKiBSZXR1cm5zIGEgYE1vdGlvblZhbHVlYCBlYWNoIGZvciBgc2NhbGVYYCBhbmQgYHNjYWxlWWAgdGhhdCB1cGRhdGUgd2l0aCB0aGUgaW52ZXJzZVxuICogb2YgdGhlaXIgcmVzcGVjdGl2ZSBwYXJlbnQgc2NhbGVzLlxuICpcbiAqIFRoaXMgaXMgdXNlZnVsIGZvciB1bmRvaW5nIHRoZSBkaXN0b3J0aW9uIG9mIGNvbnRlbnQgd2hlbiBzY2FsaW5nIGEgcGFyZW50IGNvbXBvbmVudC5cbiAqXG4gKiBCeSBkZWZhdWx0LCBgdXNlSW52ZXJ0ZWRTY2FsZWAgd2lsbCBhdXRvbWF0aWNhbGx5IGZldGNoIGBzY2FsZVhgIGFuZCBgc2NhbGVZYCBmcm9tIHRoZSBuZWFyZXN0IHBhcmVudC5cbiAqIEJ5IHBhc3Npbmcgb3RoZXIgYE1vdGlvblZhbHVlYHMgaW4gYXMgYHVzZUludmVydGVkU2NhbGUoeyBzY2FsZVgsIHNjYWxlWSB9KWAsIGl0IHdpbGwgaW52ZXJ0IHRoZSBvdXRwdXRcbiAqIG9mIHRob3NlIGluc3RlYWQuXG4gKlxuICogYGBganN4XG4gKiBjb25zdCBNeUNvbXBvbmVudCA9ICgpID0+IHtcbiAqICAgY29uc3QgeyBzY2FsZVgsIHNjYWxlWSB9ID0gdXNlSW52ZXJ0ZWRTY2FsZSgpXG4gKiAgIHJldHVybiA8bW90aW9uLmRpdiBzdHlsZT17eyBzY2FsZVgsIHNjYWxlWSB9fSAvPlxuICogfVxuICogYGBgXG4gKlxuICogQGRlcHJlY2F0ZWRcbiAqL1xuZnVuY3Rpb24gdXNlSW52ZXJ0ZWRTY2FsZShzY2FsZSkge1xuICAgIHZhciBwYXJlbnRTY2FsZVggPSB1c2VNb3Rpb25WYWx1ZSgxKTtcbiAgICB2YXIgcGFyZW50U2NhbGVZID0gdXNlTW90aW9uVmFsdWUoMSk7XG4gICAgdmFyIHZpc3VhbEVsZW1lbnQgPSB1c2VWaXN1YWxFbGVtZW50Q29udGV4dCgpO1xuICAgIGludmFyaWFudCghIShzY2FsZSB8fCB2aXN1YWxFbGVtZW50KSwgXCJJZiBubyBzY2FsZSB2YWx1ZXMgYXJlIHByb3ZpZGVkLCB1c2VJbnZlcnRlZFNjYWxlIG11c3QgYmUgdXNlZCB3aXRoaW4gYSBjaGlsZCBvZiBhbm90aGVyIG1vdGlvbiBjb21wb25lbnQuXCIpO1xuICAgIHdhcm5pbmcoaGFzV2FybmVkLCBcInVzZUludmVydGVkU2NhbGUgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIDMuMC4gVXNlIHRoZSBsYXlvdXQgcHJvcCBpbnN0ZWFkLlwiKTtcbiAgICBoYXNXYXJuZWQgPSB0cnVlO1xuICAgIGlmIChzY2FsZSkge1xuICAgICAgICBwYXJlbnRTY2FsZVggPSBzY2FsZS5zY2FsZVggfHwgcGFyZW50U2NhbGVYO1xuICAgICAgICBwYXJlbnRTY2FsZVkgPSBzY2FsZS5zY2FsZVkgfHwgcGFyZW50U2NhbGVZO1xuICAgIH1cbiAgICBlbHNlIGlmICh2aXN1YWxFbGVtZW50KSB7XG4gICAgICAgIHBhcmVudFNjYWxlWCA9IHZpc3VhbEVsZW1lbnQuZ2V0VmFsdWUoXCJzY2FsZVhcIiwgMSk7XG4gICAgICAgIHBhcmVudFNjYWxlWSA9IHZpc3VhbEVsZW1lbnQuZ2V0VmFsdWUoXCJzY2FsZVlcIiwgMSk7XG4gICAgfVxuICAgIHZhciBzY2FsZVggPSB1c2VUcmFuc2Zvcm0ocGFyZW50U2NhbGVYLCBpbnZlcnRTY2FsZSk7XG4gICAgdmFyIHNjYWxlWSA9IHVzZVRyYW5zZm9ybShwYXJlbnRTY2FsZVksIGludmVydFNjYWxlKTtcbiAgICByZXR1cm4geyBzY2FsZVg6IHNjYWxlWCwgc2NhbGVZOiBzY2FsZVkgfTtcbn1cblxuZXhwb3J0IHsgaW52ZXJ0U2NhbGUsIHVzZUludmVydGVkU2NhbGUgfTtcbiIsImV4cG9ydCB7IGNyZWF0ZURvbU1vdGlvbkNvbXBvbmVudCwgbW90aW9uIH0gZnJvbSAnLi9yZW5kZXIvZG9tL21vdGlvbi5tanMnO1xuZXhwb3J0IHsgbSB9IGZyb20gJy4vcmVuZGVyL2RvbS9tb3Rpb24tbWluaW1hbC5tanMnO1xuZXhwb3J0IHsgQW5pbWF0ZVByZXNlbmNlIH0gZnJvbSAnLi9jb21wb25lbnRzL0FuaW1hdGVQcmVzZW5jZS9pbmRleC5tanMnO1xuZXhwb3J0IHsgQW5pbWF0ZVNoYXJlZExheW91dCB9IGZyb20gJy4vY29tcG9uZW50cy9BbmltYXRlU2hhcmVkTGF5b3V0Lm1qcyc7XG5leHBvcnQgeyBNb3Rpb25Db25maWcgfSBmcm9tICcuL2NvbXBvbmVudHMvTW90aW9uQ29uZmlnL2luZGV4Lm1qcyc7XG5leHBvcnQgeyBMYXp5TW90aW9uIH0gZnJvbSAnLi9jb21wb25lbnRzL0xhenlNb3Rpb24vaW5kZXgubWpzJztcbmV4cG9ydCB7IExheW91dEdyb3VwIH0gZnJvbSAnLi9jb21wb25lbnRzL0xheW91dEdyb3VwL2luZGV4Lm1qcyc7XG5leHBvcnQgeyBSZW9yZGVyIH0gZnJvbSAnLi9jb21wb25lbnRzL1Jlb3JkZXIvaW5kZXgubWpzJztcbmV4cG9ydCB7IGRvbUFuaW1hdGlvbiB9IGZyb20gJy4vcmVuZGVyL2RvbS9mZWF0dXJlcy1hbmltYXRpb24ubWpzJztcbmV4cG9ydCB7IGRvbU1heCB9IGZyb20gJy4vcmVuZGVyL2RvbS9mZWF0dXJlcy1tYXgubWpzJztcbmV4cG9ydCB7IHVzZU1vdGlvblZhbHVlIH0gZnJvbSAnLi92YWx1ZS91c2UtbW90aW9uLXZhbHVlLm1qcyc7XG5leHBvcnQgeyB1c2VNb3Rpb25UZW1wbGF0ZSB9IGZyb20gJy4vdmFsdWUvdXNlLW1vdGlvbi10ZW1wbGF0ZS5tanMnO1xuZXhwb3J0IHsgTW90aW9uVmFsdWUsIG1vdGlvblZhbHVlIH0gZnJvbSAnLi92YWx1ZS9pbmRleC5tanMnO1xuZXhwb3J0IHsgcmVzb2x2ZU1vdGlvblZhbHVlIH0gZnJvbSAnLi92YWx1ZS91dGlscy9yZXNvbHZlLW1vdGlvbi12YWx1ZS5tanMnO1xuZXhwb3J0IHsgdXNlVHJhbnNmb3JtIH0gZnJvbSAnLi92YWx1ZS91c2UtdHJhbnNmb3JtLm1qcyc7XG5leHBvcnQgeyB1c2VTcHJpbmcgfSBmcm9tICcuL3ZhbHVlL3VzZS1zcHJpbmcubWpzJztcbmV4cG9ydCB7IHVzZVZlbG9jaXR5IH0gZnJvbSAnLi92YWx1ZS91c2UtdmVsb2NpdHkubWpzJztcbmV4cG9ydCB7IHVzZVNjcm9sbCB9IGZyb20gJy4vdmFsdWUvdXNlLXNjcm9sbC5tanMnO1xuZXhwb3J0IHsgdXNlRWxlbWVudFNjcm9sbCB9IGZyb20gJy4vdmFsdWUvc2Nyb2xsL3VzZS1lbGVtZW50LXNjcm9sbC5tanMnO1xuZXhwb3J0IHsgdXNlVmlld3BvcnRTY3JvbGwgfSBmcm9tICcuL3ZhbHVlL3Njcm9sbC91c2Utdmlld3BvcnQtc2Nyb2xsLm1qcyc7XG5leHBvcnQgeyB1c2VUaW1lIH0gZnJvbSAnLi92YWx1ZS91c2UtdGltZS5tanMnO1xuZXhwb3J0IHsgdXNlUmVkdWNlZE1vdGlvbiwgdXNlUmVkdWNlZE1vdGlvbkNvbmZpZyB9IGZyb20gJy4vdXRpbHMvdXNlLXJlZHVjZWQtbW90aW9uLm1qcyc7XG5leHBvcnQgeyBhbmltYXRpb25Db250cm9scyB9IGZyb20gJy4vYW5pbWF0aW9uL2FuaW1hdGlvbi1jb250cm9scy5tanMnO1xuZXhwb3J0IHsgdXNlQW5pbWF0aW9uLCB1c2VBbmltYXRpb25Db250cm9scyB9IGZyb20gJy4vYW5pbWF0aW9uL3VzZS1hbmltYXRpb24ubWpzJztcbmV4cG9ydCB7IHVzZUFuaW1hdGlvbkZyYW1lIH0gZnJvbSAnLi91dGlscy91c2UtYW5pbWF0aW9uLWZyYW1lLm1qcyc7XG5leHBvcnQgeyBhbmltYXRlIH0gZnJvbSAnLi9hbmltYXRpb24vYW5pbWF0ZS5tanMnO1xuZXhwb3J0IHsgYW5pbWF0ZVZpc3VhbEVsZW1lbnQgfSBmcm9tICcuL3JlbmRlci91dGlscy9hbmltYXRpb24ubWpzJztcbmV4cG9ydCB7IHVzZUN5Y2xlIH0gZnJvbSAnLi91dGlscy91c2UtY3ljbGUubWpzJztcbmV4cG9ydCB7IHRyYW5zZm9ybSB9IGZyb20gJy4vdXRpbHMvdHJhbnNmb3JtLm1qcyc7XG5leHBvcnQgeyBpc1ZhbGlkTW90aW9uUHJvcCB9IGZyb20gJy4vbW90aW9uL3V0aWxzL3ZhbGlkLXByb3AubWpzJztcbmV4cG9ydCB7IHVzZUlzUHJlc2VudCwgdXNlUHJlc2VuY2UgfSBmcm9tICcuL2NvbXBvbmVudHMvQW5pbWF0ZVByZXNlbmNlL3VzZS1wcmVzZW5jZS5tanMnO1xuZXhwb3J0IHsgdXNlSW5WaWV3IH0gZnJvbSAnLi91dGlscy91c2UtaW4tdmlldy5tanMnO1xuZXhwb3J0IHsgRHJhZ0NvbnRyb2xzLCB1c2VEcmFnQ29udHJvbHMgfSBmcm9tICcuL2dlc3R1cmVzL2RyYWcvdXNlLWRyYWctY29udHJvbHMubWpzJztcbmV4cG9ydCB7IHVzZURvbUV2ZW50IH0gZnJvbSAnLi9ldmVudHMvdXNlLWRvbS1ldmVudC5tanMnO1xuZXhwb3J0IHsgY3JlYXRlTW90aW9uQ29tcG9uZW50IH0gZnJvbSAnLi9tb3Rpb24vaW5kZXgubWpzJztcbmV4cG9ydCB7IHZpc3VhbEVsZW1lbnQgfSBmcm9tICcuL3JlbmRlci9pbmRleC5tanMnO1xuZXhwb3J0IHsgYWRkU2NhbGVDb3JyZWN0b3IgfSBmcm9tICcuL3Byb2plY3Rpb24vc3R5bGVzL3NjYWxlLWNvcnJlY3Rpb24ubWpzJztcbmV4cG9ydCB7IHVzZUluc3RhbnRUcmFuc2l0aW9uIH0gZnJvbSAnLi91dGlscy91c2UtaW5zdGFudC10cmFuc2l0aW9uLm1qcyc7XG5leHBvcnQgeyB1c2VJbnN0YW50TGF5b3V0VHJhbnNpdGlvbiB9IGZyb20gJy4vcHJvamVjdGlvbi91c2UtaW5zdGFudC1sYXlvdXQtdHJhbnNpdGlvbi5tanMnO1xuZXhwb3J0IHsgdXNlUmVzZXRQcm9qZWN0aW9uIH0gZnJvbSAnLi9wcm9qZWN0aW9uL3VzZS1yZXNldC1wcm9qZWN0aW9uLm1qcyc7XG5leHBvcnQgeyBNb3Rpb25Db250ZXh0LCB1c2VWaXN1YWxFbGVtZW50Q29udGV4dCB9IGZyb20gJy4vY29udGV4dC9Nb3Rpb25Db250ZXh0L2luZGV4Lm1qcyc7XG5leHBvcnQgeyBNb3Rpb25Db25maWdDb250ZXh0IH0gZnJvbSAnLi9jb250ZXh0L01vdGlvbkNvbmZpZ0NvbnRleHQubWpzJztcbmV4cG9ydCB7IFByZXNlbmNlQ29udGV4dCB9IGZyb20gJy4vY29udGV4dC9QcmVzZW5jZUNvbnRleHQubWpzJztcbmV4cG9ydCB7IExheW91dEdyb3VwQ29udGV4dCB9IGZyb20gJy4vY29udGV4dC9MYXlvdXRHcm91cENvbnRleHQubWpzJztcbmV4cG9ydCB7IERlcHJlY2F0ZWRMYXlvdXRHcm91cENvbnRleHQgfSBmcm9tICcuL2NvbnRleHQvRGVwcmVjYXRlZExheW91dEdyb3VwQ29udGV4dC5tanMnO1xuZXhwb3J0IHsgU3dpdGNoTGF5b3V0R3JvdXBDb250ZXh0IH0gZnJvbSAnLi9jb250ZXh0L1N3aXRjaExheW91dEdyb3VwQ29udGV4dC5tanMnO1xuZXhwb3J0IHsgRmxhdFRyZWUgfSBmcm9tICcuL3JlbmRlci91dGlscy9mbGF0LXRyZWUubWpzJztcbmV4cG9ydCB7IHVzZUFuaW1hdGVkU3RhdGUgYXMgdXNlRGVwcmVjYXRlZEFuaW1hdGVkU3RhdGUgfSBmcm9tICcuL2FuaW1hdGlvbi91c2UtYW5pbWF0ZWQtc3RhdGUubWpzJztcbmV4cG9ydCB7IHVzZUludmVydGVkU2NhbGUgYXMgdXNlRGVwcmVjYXRlZEludmVydGVkU2NhbGUgfSBmcm9tICcuL3ZhbHVlL3VzZS1pbnZlcnRlZC1zY2FsZS5tanMnO1xuZXhwb3J0IHsgQW5pbWF0aW9uVHlwZSB9IGZyb20gJy4vcmVuZGVyL3V0aWxzL3R5cGVzLm1qcyc7XG5leHBvcnQgeyBhbmltYXRpb25zIH0gZnJvbSAnLi9tb3Rpb24vZmVhdHVyZXMvYW5pbWF0aW9ucy5tanMnO1xuZXhwb3J0IHsgY2hlY2tUYXJnZXRGb3JOZXdWYWx1ZXMgfSBmcm9tICcuL3JlbmRlci91dGlscy9zZXR0ZXJzLm1qcyc7XG5leHBvcnQgeyBjcmVhdGVCb3ggfSBmcm9tICcuL3Byb2plY3Rpb24vZ2VvbWV0cnkvbW9kZWxzLm1qcyc7XG5leHBvcnQgeyBjYWxjTGVuZ3RoIH0gZnJvbSAnLi9wcm9qZWN0aW9uL2dlb21ldHJ5L2RlbHRhLWNhbGMubWpzJztcbmV4cG9ydCB7IGZpbHRlclByb3BzIH0gZnJvbSAnLi9yZW5kZXIvZG9tL3V0aWxzL2ZpbHRlci1wcm9wcy5tanMnO1xuZXhwb3J0IHsgbWFrZVVzZVZpc3VhbFN0YXRlIH0gZnJvbSAnLi9tb3Rpb24vdXRpbHMvdXNlLXZpc3VhbC1zdGF0ZS5tanMnO1xuZXhwb3J0IHsgaXNEcmFnQWN0aXZlIH0gZnJvbSAnLi9nZXN0dXJlcy9kcmFnL3V0aWxzL2xvY2subWpzJztcbmV4cG9ydCB7IGFkZFBvaW50ZXJFdmVudCB9IGZyb20gJy4vZXZlbnRzL3VzZS1wb2ludGVyLWV2ZW50Lm1qcyc7XG5leHBvcnQgeyB3cmFwSGFuZGxlciB9IGZyb20gJy4vZXZlbnRzL2V2ZW50LWluZm8ubWpzJztcbmV4cG9ydCB7IGlzTW90aW9uVmFsdWUgfSBmcm9tICcuL3ZhbHVlL3V0aWxzL2lzLW1vdGlvbi12YWx1ZS5tanMnO1xuZXhwb3J0IHsgaXNCcm93c2VyIH0gZnJvbSAnLi91dGlscy9pcy1icm93c2VyLm1qcyc7XG5leHBvcnQgeyB1c2VVbm1vdW50RWZmZWN0IH0gZnJvbSAnLi91dGlscy91c2UtdW5tb3VudC1lZmZlY3QubWpzJztcbmV4cG9ydCB7IHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QgfSBmcm9tICcuL3V0aWxzL3VzZS1pc29tb3JwaGljLWVmZmVjdC5tanMnO1xuZXhwb3J0IHsgdXNlRm9yY2VVcGRhdGUgfSBmcm9tICcuL3V0aWxzL3VzZS1mb3JjZS11cGRhdGUubWpzJztcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///7704\n')}}]);